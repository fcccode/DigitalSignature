; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\Signature.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0CD@HFEEKIIE@mbstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JADEDFCN@wcstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DFFCODPF@m_pData?9?$DOnRefs?5?$DN?$DN?5?91?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFNMPDFA@m_pData?9?$DOnDataLength?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JINHKJCC@pData?9?$DOnRefs?5?$DM?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNGMIMJM@pData?9?$DOnRefs?5?$DM?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@EIPLHBJE@CFixedStringMgr?3?3Allocate?$CI?$CJ?5spil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@PINPFILO@CFixedStringMgr?3?3Reallocate?$CI?$CJ?5sp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDHCGOCC@m_pMemMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@ENACCIMA@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KICONMKH@pData?9?$DOpStringMgr?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPMMCKHL@?$CI?$CIWORD?$CJ?$CI?$CIDWORD_PTR?$CJ?$CIpsz?$CJ?5?$DO?$DO?516?$CJ?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BDLMIBLB@pFormat?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGFACAOB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KCADNOJC@?$CF02ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@FKADHJGH@strFormat?4LoadStringA?$CInFormatID?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@BJCBICOJ@c?3?2activex?2xmlsign?2ShowSelectCer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIDNGAPJ@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5char?$CK?$CJ?5?$CKthis?5?$CB?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@NCNHACCB@s?5?$DN?$DN?50?5?$HM?$HM?5m_Data?5?$DN?$DN?50?5?$HM?$HM?5m_Data?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@LJMJHPFK@m_Data?5?$CB?$DN?50?5?$CG?$CG?5m_Data?9?$DORefCount?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@GKIPNLEE@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5?$CIBSTR@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDNDDDBI@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5pSrc?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EL@EEEMIENH@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5?$CIVT_I1?5?$HM?5VT_BYRE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@IHHPLLAD@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_DISPATCH?5?$HM?$HM?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@LJOMBHMP@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_UNKNOWN?5?$HM?$HM?5pS@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BJHHJGLF@c?3?2activex?2xmlsign?2Signature?4h?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KEHCEMNB@CSignature?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LIEICNMC@m_bModal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJEKGMMD@Warning?3?5implicit?5LoadString?$CI?$CFu?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@EMNMEGHE@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@PNDBCBIA@CAxDialogImpl?3?3AdviseSinkMap?5cal@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@HHPDHHJB@AtlAxWinLic71?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BNFEDJPE@?$CBm_bModal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@G@ATL@@CGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@G@ATL@@KGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@G@ATL@@KGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@G@ATL@@KGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@G@ATL@@SAPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTimeSpan@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatGmt@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setConfigFile@CConfig@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CConfig@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCConfig@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCRLTimeOut@CRLCache@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferVariant@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferVariant@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferVariant@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferVariant@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPBXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPBEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CBufferVariant@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssignData@CBufferVariant@@QAEXPBXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@CBufferVariant@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CBufferVariant@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_DebugHeapString@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@GDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@GDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@G@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dowiden@?$ctype@G@std@@IBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Donarrow@?$ctype@G@std@@IBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setLicenseFile@CLicense@@QAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getSignAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getVerifyAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getEncryptAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getDecryptAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getSecureSignAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getSecureSignServerAllowed@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?checkLicense@CLicense@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getLicensedUserCount@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getMaintExpiryYear@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getMaintExpiryMonth@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getMaintExpiryDay@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isClientLinux@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isClientWindows@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isClientSolaris@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isClientMac@CLicense@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessWindowMessage@CShowSelectCert@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnInitDialog@CShowSelectCert@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnOK@CShowSelectCert@@QAEJGGPAUHWND__@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCancel@CShowSelectCert@@QAEJGGPAUHWND__@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateHeader@CShowSelectCert@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCell@CShowSelectCert@@QAEXPAGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClickList@CShowSelectCert@@QAEJHPAUtagNMHDR@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?selectCertificate@CShowSelectCert@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setSelection@CShowSelectCert@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCShowSelectCert@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckError@_com_util@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_bstr_t@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y_bstr_t@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7_bstr_t@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@_bstr_t@@QAEXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Compare@_bstr_t@@ABEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RefCount@Data_t@_bstr_t@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@Data_t@_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@Data_t@_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Data_t@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@Data_t@_bstr_t@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_variant_t@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8_variant_t@@QBE_NPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@_variant_t@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeType@_variant_t@@QAEXGPBV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@ABV_variant_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_com_error@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetRawUnknown@CSignature@@QAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ANSIToUnicode@CSignature@@QAEPAGPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SigException@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@SigException@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSigException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SigException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E4
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E5
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E7
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E8
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E10
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E11
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E13
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E14
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E16
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E17
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E19
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E20
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E22
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E23
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E25
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E26
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E28
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E29
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _$E31
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E32
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleCommandTarget@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CConfig@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0SigException@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ISignature@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCAMClient@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSignature@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0NtpServerResponse@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRLCache@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Preallocate@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormat@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDialogProc@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEP6GHPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndDialog@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessWindowMessage@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateActiveXControls@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MapDialogRect@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAEHPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnInitDialog@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDestroy@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLic@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEJPBGPAUIStream@@PAPAUIUnknown@@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendChar@?$CSimpleStringT@D$0A@@ATL@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExecuteDlgInit@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdviseSinkMap@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@?$CAxWindow2T@VCWindow@ATL@@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLicEx@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEJPBGPAUIStream@@PAPAUIUnknown@@2ABU_GUID@@PAU4@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxWindowT@VCWindow@ATL@@@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@?$CComPtrBase@UIUnknown@@@ATL@@QAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QAEPAPAUIAxWinHostWindowLic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIAxWinHostWindowLic@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@G@std@@@std@@YAABV?$ctype@G@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DialogProc@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryHost@UIAxWinHostWindowLic@@@?$CAxWindowT@VCWindow@ATL@@@ATL@@QAEJPAPAUIAxWinHostWindowLic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryInterface@UIUnknown@@@?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QBEJPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_DebugHeapString@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_DebugHeapString@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDD@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryHost@?$CAxWindowT@VCWindow@ATL@@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ?QueryInterface@CSignature@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CSignature@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CSignature@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?id@?$codecvt@DDH@std@@2V0locale@2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ??C?$CComPtrBase@UIUnknown@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIUnknown@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@PGEBGEDK@ppUnk?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MEKCDCMA@pp?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_3935bda8_4ed9_495c_8650_e01fc1e38a4b
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?DialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BF@CCFFBNDL@?$CI?$CIHRESULT?$CJ?$CIhr?$CJ?5?$DO?$DN?50?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?A2T@@YAPADPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDlgItemMessageA@CWindow@ATL@@QAEJHIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@CWindow@ATL@@QAEPAUHWND__@@PBDPAU3@V_U_RECT@2@0KKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InlineIsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00020401_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??ICComBSTR@ATL@@QAEPAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CComBSTR@ATL@@QAEXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CComBSTR@ATL@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocslen@@YAHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FindNextDlgItem@_DialogSplitHelper@ATL@@SAPAUDLGITEMTEMPLATE@@PAU3@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowPos@CWindow@ATL@@QAEHPAUHWND__@@HHHHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowContextHelpId@CWindow@ATL@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIStream@@@ATL@@QBEPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseInitData@_DialogSplitHelper@ATL@@SAJPAUIStream@@PAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIStream@@@ATL@@QAEPAPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIStream@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindCreateData@_DialogSplitHelper@ATL@@SAKKPAEPAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@KAJDHFFC@dwLen?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsActiveXControl@_DialogSplitHelper@ATL@@SA_NPAUDLGITEMTEMPLATE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CWindow@ATL@@QBE?AV12@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFirstDlgItem@_DialogSplitHelper@ATL@@SAPAUDLGITEMTEMPLATE@@PBUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DlgTemplateItemCount@_DialogSplitHelper@ATL@@SAAAGPAUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDialogEx@_DialogSplitHelper@ATL@@SAHPBUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlIsValidString@ATL@@YAHPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b15c7688_86e5_48bd_9c71_1e131cd191a9
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_d8f3211f_302f_45db_8187_cdf6b7677d90
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0a06154b_8ff9_48b2_a819_b68c327fc773
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Empty@CComBSTR@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDispatch@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA2?AVSigException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVSigException@@@8??0SigException@@QAE@ABV0@@Z16
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVSigException@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVSigException@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IObjectWithSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7SigException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CComVariant@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceDHelper@CAtlModule@ATL@@QAGJPBGHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIRegistrar@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIRegistrar@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIRegistrar@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIRegistrar@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIRegistrar@@@ATL@@QAEPAPAUIRegistrar@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UIRegistrar@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIRegistrar@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIRegistrar@@@ATL@@QBEPAUIRegistrar@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b722bccb_4e68_101b_a2bc_00aa00404770
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HNJMKNAP@_GetEntries?$CI?$CJ?$FL0?$FN?4pFunc?5?$DN?$DN?5?$CI?$CIATL?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Unlock@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Cache@CComObjectRootBase@ATL@@SGJPAXABU_GUID@@PAPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_c8be4864_227a_4a1b_84ee_473681bd4872
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCWindow@ATL@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendMessageA@CWindow@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDlgItem@CWindow@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterWindow@CWindow@ATL@@QAEHPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStyle@CWindow@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BH@ENLIMLGL@?3?3IsWindow?$CIhWndParent?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LBNLFONB@?3?3IsWindow?$CIhWndCenter?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@CComBSTR@ATL@@QAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@BNLFFEBD@Invalid?5message?5map?5ID?5?$CI?$CFi?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EnableWindow@CWindow@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CShowSelectCert@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBufferVariant@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CConfig@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBJEMDLA@nRet?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@MLJMCNFJ@pStringMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWThunk
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?CharLowerWThunk@ATL@@YGPAGPAG@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPAGPAG@Z		; ATL::CharUpperWThunk
PUBLIC	?Base64Chars@@3PAEA				; Base64Chars
PUBLIC	_LogEnabled
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?licenseTimeout@CLicense@@0HB			; CLicense::licenseTimeout
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	_DebugLogEnabled
PUBLIC	_MemoryLogEnabled
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?RegEntries@CSignature@@2PAU_ATL_REGMAP_ENTRY@ATL@@A ; CSignature::RegEntries
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	_IID_IePad
PUBLIC	_LIBID_SECUREPADLib
PUBLIC	_CLSID_ePad
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWThunk
EXTRN	?szModulePath@@3PAGA:BYTE			; szModulePath
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPBG0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
CONST	SEGMENT
$SG166454 DB	'Invalid DateTime', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:$SG166454		; ATL::szInvalidDateTime
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG166456 DB	'Invalid DateTimeSpan', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:$SG166456	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT
?licenseTimeout@CLicense@@0HB DD 01eH			; CLicense::licenseTimeout
CONST	ENDS
CONST	SEGMENT
	ORG $+3
_IID_IePad DD	0f5734f4fH
	DW	08013H
	DW	0496bH
	DB	0a7H
	DB	0f6H
	DB	010H
	DB	0d2H
	DB	0f1H
	DB	0c0H
	DB	048H
	DB	0fdH
_LIBID_SECUREPADLib DD 043176c29H
	DW	0bea3H
	DW	0401bH
	DB	0a3H
	DB	0e2H
	DB	06aH
	DB	01cH
	DB	03fH
	DB	0ccH
	DB	0d6H
	DB	012H
_CLSID_ePad DD	0acc8c50cH
	DW	031c8H
	DW	04453H
	DB	0a5H
	DB	035H
	DB	084H
	DB	0c5H
	DB	0f8H
	DB	0c9H
	DB	0f9H
	DB	09aH
$SG204876 DB	'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H
	DB	'P', 00H, 'a', 00H, 't', 00H, 'h', 00H, 00H, 00H
CONST	ENDS
_DATA	SEGMENT
?RegEntries@CSignature@@2PAU_ATL_REGMAP_ENTRY@ATL@@A DD FLAT:$SG204876 ; CSignature::RegEntries
	DD	FLAT:?szModulePath@@3PAGA
	DD	00H
	DD	00H
?Base64Chars@@3PAEA DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvw'
	DB	'xyz0123456789+/=', 00H			; Base64Chars
	ORG $+2
_DebugLogEnabled DD 01H
_MemoryLogEnabled DD 01H
_LogEnabled DD	01H
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG204892 DB	'netscp', 00H
	ORG $+1
$SG204893 DB	'iexplore', 00H
	ORG $+3
$SG204894 DB	'mozilla', 00H
$SG204895 DB	'firefox', 00H
CONST	ENDS
_DATA	SEGMENT
_RestrictedProgramList DD FLAT:$SG204892
	DD	FLAT:$SG204893
	DD	FLAT:$SG204894
	DD	FLAT:$SG204895
_DATA	ENDS
CONST	SEGMENT
$SG204898 DB	'CqD09vDlKUxOwqxJTcGQSrtVoOZzOATyJZYxggEYMBMGCSqGSIb3DQEJ'
	DB	'FTEGBAQBAAAAMGMGCSsGAQQBgjcRATFWHlQATQBpAGMAcgBvAHMAbwBmAHQAI'
	DB	'ABCAGEAcwBlACAAQwByAHkAcAB0AG8AZwByAGEAcABoAGkAYwAgAFAAcgBvAH'
	DB	'YAaQBkAGUAcgAgAHYAMQAuADAwgZsGCSqGSIb3DQEJFDGBjR6BigAzADkAZgB'
	DB	'mAGQAMgAwAGQAZAA1AGIANAAzADUAOQBhADcAOQA1ADQAZgAyAGEAZQA5AGMA'
	DB	'YQAzAGYAMQBhADUAXwBjADYANABjAGYAYwBiADIALQA0AGUAOQBkAC0ANAAxA'
	DB	'GIAYQAtAGIAZAAyADYALQAyADYAMQBjADkAOABkAGQAMgAwADYAODCCDI8GCS'
	DB	'qGSIb3DQEHBqCCDIAwggx8AgEAMIIMdQYJKoZIhvcNAQcBMBwGCiqGSIb3DQE'
	DB	'MAQYwDgQIZmD5BywuWgYCAgfQgIIMSCBOXKF4xx6o+dvu45pFLvWjUB44S/1w'
	DB	'504WVp4KKUgKFZOvfGIfJbIOlHp/ZbkXjqc5NdJ4KoVLq21ZmSS6ROrMIdKJl'
	DB	'cB7AvCmJN0fuZxqe5+azq6va9Kuo7XyGZSd1AMpYwGWA54d4LXCBlnO3iH6tH'
	DB	'De+uTQTuAQizcWATiv59Nby7iFrilGhyO7YqN8v+Z7bVJBIR5L4cudepQeOcW'
	DB	'hHDu2ULI14HqPY/pW7biy18OcONcMvojt7MN1A5v5M7xjNI8SOizJlBaTKQ+a'
	DB	'FivPXuDLyab5XKEUv4dSfgaine66XLNP+jk1WSTLZHxY7GWUj5PANVLB+is7W'
	DB	'Otdm+ALjoVIYpHcnBfArrQPh3qq8a9vKNmI8q5nqCNMlRJ6hiST5D5efZAYF2'
	DB	'/qi6CBNPaHaJk17Z0TWgsHK0oQOsFZFERyGUo0oB8fRZHDpuXvFv1Np8/cS78'
	DB	'67atVxkxaUIGLX94uBlfsqFXDIrSX', 00H
	ORG $+7
$SG204904 DB	'UHmvkICg2lRPGAMG2AIqs16Hqjnp+j6FGg8VzqioenSNN6HH1VgAZmQq'
	DB	'0LN7I9YVseMCx6KK1CkzHeqmyZr3DgNVGofUkzDSNe6KIdc9YVHGaTEoFNT7V'
	DB	'2IJQv2L6HytuAMuMDswHzAHBgUrDgMCGgQUa6XzwBso6MhKYmYoywZj78RFce'
	DB	'UEFA/6/K0CTxwzEPFw7/6jgBvpSsQJAgIH0A==', 00H
	ORG $+7
$SG204910 DB	'Y8TEQMJMCxXAxf8bPmgzWQLguurAzn6bqxJ+KkLKFGMJx7/oX2DU0wfm'
	DB	'qV7YknpsPp9zS8ENH2aJ+9Xe7qPwaaFOW9BcIGOXWNO4uERDLzuir2hO91ex+'
	DB	'wKwGb8kommigD+whv6gjqseN9oaKcd8jv+et/UqVBNqKRKrXkTQuXuK0wmF41'
	DB	'PfJ4CM9RHn/1Pl3ctyRFS4OMkstDfrtaFx3Op6rmyRORhTjguonQ4+C3kHnjI'
	DB	'Po7s3129/0/PhHhuaxTTzWiV1L48Nve6wKMC2nBHEqTuttDxQ3tIhF2O8zpkG'
	DB	'Fx8g4VPGZRya31Y8iPhH55kqaVUYopAVGbCmnquVgaiydb7wcnKis+BSoaE7k'
	DB	'YLT2Ey9JjYlNxIbKNfUxReM4wIwojHQxDTy/xvhbqsMv0yWdBfrz8yFFSkiNj'
	DB	'ubV+mfhil0eTZ+xshOYydKtoiCLavKqiiShNrbbOaUEgtmG6WeZpVkk6h2pth'
	DB	'UUdkuhY7/QCb2TFYyzh9PeqU///IGCIFjjCJ9JLofLGpwWQaNftb7eZ1dNIu/'
	DB	'NwG0DsFICT9jEU2Ji7qE5BZ8bSGhY4RCmFMe6oaQodmkfCKMpBjo8sn01/wXv'
	DB	'QDuYVSj9Ai8+KfI9nClf+d1Le+1tmLfqf/tJOT+qIpb4lTwpAbhI21KSz2yxL'
	DB	'NRYG1FX1Gpi2kGel06feDwH0BbsfwhiSGuBxjXqKCC61mBBbVyqIARbdcLR6G'
	DB	'Zt1/RqJ3x61Z4lReFhbafKOwKUKmgWvV1xEsSy+HWRJOowAMJRSM1SFycT7m/'
	DB	'm6mjBzl0tYCeMslOdgfV+2AOS2N0gnQa+1XTxvfC3h6S6aH1rTckTru7XLS/z'
	DB	'Q6uz5Ottf4VWgOOr9lqQViYzFnrWbnopua4uaxX+tjjgOgsav3IaphYgSrmhy'
	DB	'GNoia5d5igPwr/S+jw4yPuoeaIqKr6fEFL95X3flGhjNNa/hsg3PmLOJMLh6b'
	DB	'MkJSBp3Dhb91qHVnczaUvCRt2BT4c', 00H
	ORG $+3
$SG204916 DB	'pXfQ/mdS7IRdWlYYMCA+WRLHMPh0yJG/1xAtWj7s5tZBR8vjN9u', 00H
$SG204922 DB	'C7mkE79KQdPrdI+u0/hc04UTtjvmixSrFrMsyQTj8Qa9/VgNhnAQdVDl'
	DB	'pmseg/UN+nRl4aSU1XxNRLJW6mwULWIy2oMkdlUM5EPWZtdkgju06VF8elbmq'
	DB	'V83jczP1u9ZmWt1tb4fNnZFXacvDICjsf4v9lywXdMkAdL3R3QC2irH85U/+T'
	DB	'5UcXy0GKaHu267dsQ6CvW9KVpQVhmpwG+VKe8GMfa6iVrELK6OzuCZTUPA2Ny'
	DB	'gU4t5WcKzif0k2PphELICpUICyk0lljOl+K6WsbLm9uiP6sDLhZDuAduyUsD1'
	DB	'cbk9Ld4aUtICcevJV8HQPdaf6kv1/rwfy5rrMjfQm0R7qOW7nq5NMzIuC2bRT'
	DB	'lamu8i/WJ4B2fPNUTyNGip6QzznhrZHLgraw6X+PI73tuuscoXKE0jsLAmAGO'
	DB	'6x8LxSNKP9JOCnfqogRoSWWusAqpSbVgrb1a4T5kjSUpTarhPxnTZr0pFOr4g'
	DB	'IMh7EAWzP5MrgL00xVkB+YSZO+zh8ERJyk7/eILFWROaGetTO7hw6MqTZJWea'
	DB	'qwt+AUfaR8+s/L7hBRW8f5c3AgMkLYuZ7LT8vTXfx+ZbbWQHqXGA07EvHbcKd'
	DB	'cdWuCZPP6tZghstI/TZZko8PD77C6YmKOXAcyaCarxGpxOpB+npXmuUoYq2rv'
	DB	'GER6Kp7Oqw9asvDflyxztD7zpEG+xH9PrQutGWrzA7MB8wBwYFKw4DAhoEFAW'
	DB	'YQYNKeznyhd4r/ccgvkZC/oQABBQX0hGT3zvy+g96yp80pdWqIjjJ7QICB9A='
	DB	00H
	ORG $+3
$SG204928 DB	'+OvbSsu8av2p9rQBT90eK8ML5zTxR1gdt7at5Xkom+9RI1GKaRlh2gfc'
	DB	'N/i38rwjtwotOr7i6', 00H
	ORG $+6
$SG204934 DB	'MIIQ8AIBAzCCEKwGCSqGSIb3DQEHAaCCEJ0EghCZMIIQlTCCA/4GCSqG'
	DB	'SIb3DQEHAaCCA+8EggPrMIID5zCCA+MGCyqGSIb3DQEMCgECoIICtjCCArIwH'
	DB	'AYKKoZIhvcNAQwBAzAOBAj3HeWAAnVoZAICB9AEggKQZKqxNZ4EGsxyM7X4lF'
	DB	'wnjun8KfDj6WESEwbH3bGFdOCGtqS+oy42+ws9En774h9b7i3G3b87zMa+mfB'
	DB	'NTH6I/3NqUg+MdF0Kh6kcjGPXjVgD6ojBVwV2JHfj7kWtrV8pGOLNPjLChSh2'
	DB	'4QJ5ffhiezFUB0Ak4G5wbWCR1OW3MqOMVItLHdKdJzQG3Uj4K8VWbZmz8Flxt'
	DB	'Jzcog2vTZpkGdBxP5a6+ONyBd95T6UnkPnXqc47YYIMjeCuXb1q2BRVSAG4XZ'
	DB	'j+I0WY62uCl5dTYnB9UpvJjFlI4F0Heb3BAfUmcEZOB0GytzsWyW2OpnpZJ4c'
	DB	'hrmZ/XTZ/qqRoHYMdR6QB2eYXeWakdSoIz1feJcBpLI5vb97qU/D+o5yXJsrS'
	DB	'wBGRf4Wlby5U82+qSC9qSh0wsEgE5RvV9+anXLaDxXUZz+pq5HF6aQ4vXI3pH'
	DB	'iYMpOwBzeoaNMtP0AhRDsBR5ZQ1luTJXRiGnLQBQt9Qh89mD86+zgxY0jqQ70'
	DB	'5WIqrSMpG4+rlmHWI6qLnqFOttIrN5pn9wT9XVTvC7GJVlUz6+MUCn40/20vh'
	DB	'dqYrNzGmTRCMh4Ur59LDXH7cogsME+scbdRTG+SaAFrtdagi/2pxGRS+oun9y'
	DB	'auRktgQA3y+R+kBu8y+mj1A80ef2KrBoovsVgSDJBwloujhXoeB1an91A+XRd'
	DB	'EfQt98zpkXxEZ4WfYogruySOHrsSeX77bO1TB4fiBQLEc0hJHqLRcPePVT/Oc'
	DB	'F6ELUt085VPmu7Jsstp3S7uqfxfdmpGDy38BQ70uO/utcP6EBkkOFKXGCrRdG'
	DB	'Gfc4insahwSvmGhP20UtByso85EK4', 00H
	ORG $+7
$SG204940 DB	'0OQbFpRmbUSxGFsM2IfRPcmTuj6GQIL7HOaBdFDnvFda2G9JBbo6jdYj'
	DB	'B1v2Yd/DKCjaTkgeYv23dhOifdTxw8lTwPY4XBAekqYugtJA6HMibY/sLPvlT'
	DB	'+TkSONJK2hHYQ/9pU/UqhBQDBfNFLw/mBke9dZatVE2P/3mu7nRb1GvSx1wsh'
	DB	'JmAiP9iDVp6888+P7GBoJe0aGUhYXbCkO6XaPrGZ6iahVB5641sSHqUAxOE3I'
	DB	'jHOqCxaWLMREduSbSRYcCWwqPQfK/NFRYZiE7kZmQ1CMItYp0AFfXDaoLf7TY'
	DB	'QQYgltQkrGA2G/BlSveEaXPaaFJBEWq3yR+0GJRRMBUSywVPjAfQB52KJ+AlK'
	DB	'jXv4Ljgt5kWCEa4C5Juzj77gu95MlkHZ3zneBpTpylNVN42/LT2Chn5v4s0K+'
	DB	'XSPUhmUkSZ/Tgi8g8NZf5Cb8AuVQLXa32ec2g8/almzZf4T4f27BYg3XQNNby'
	DB	'mAjxdDM+6Y3X2wgLWUnpJKfztXDgiImZYpB2rcDYhIJcSSPjkX992Frs7nrfW'
	DB	'oAMdLIqCXEYtNHC6T4oRxYQV+Kf5SujGNQTaLzbWK2CveoqJEL7JuPHkr8vox'
	DB	'TPj4E/MdiMlufzD0pdTx7+DPl82ViudyTFx8vElHmc2XMlgat4pB67IufXvuj'
	DB	'U2BC5FRqoUhX79gGNK0jhKqr/ZvL7zI46uqwQrsuizNiWRBrVuVdJ/lc6rx1i'
	DB	'qqTQvD9IA17/PUwH9d6jcot9xMNHMcCtV4l1Lv0In83IEECp4jPVf7xaiJZ96'
	DB	'FiNw9b12UpmYS3ntPKpl/wUzSrRijNwzKxHdzom+h7RiMWClqM+cpAxf2GmFr'
	DB	'oe823UB1IkUD0NPBNVys+ytl75U8o/i4eOF5EjJOko3IQDzjmPUTtOWZEVo1z'
	DB	'14jF2UNR26TaOr037CFY+LmPgkZj7wW53MxEAxx0N0FQikVuLDjNKPdAJjlQy'
	DB	'hwg1MPWeDG+pi2yx7AbvgzOQvSFpx', 00H
	ORG $+7
$SG204946 DB	'zCCEewGCSqGSIb3DQEHAaCCEd0EghHZMIIR1TCCA/4GCSqGSIb3DQEHA'
	DB	'aCCA+8EggPrMIID5zCCA+MGCyqGSIb3DQEMCgECoIICtjCCArIwHAYKKoZIhv'
	DB	'cNAQwBAzAOBAjRCuvybYFG2QICB9AEggKQikDH4PsWWvIs2DLre2xYmcJFvSg'
	DB	'R32l', 00H
	ORG $+1
$SG204952 DB	'77kdP1ceKQe/kBTCR6qS9u262fN7H5xIvY3WJxUtJl/33sepuCBwRMAp'
	DB	'WpR9T45qkFsHUfWJalzWluV+pSauk104QVV43UATFVgLxd2OeEwqSNU7UGqHC'
	DB	'e4TnMt6IcMSFHPZhnRdvaZ3hFIURhAuNep357YAa40urJ4kxIAdB2Bezs1OHn'
	DB	'4vWbz3NLoxaHE5Jbf2jdyBRKI5RzIOew9vX8Rs6EVBE/aRrOyMcOWTXB+AODK'
	DB	'laCMbMEvDYATFALYfpqOec/62Uqwuz3CaBk/0+kljuEnjWoDzmHa+2ukjOvlf'
	DB	'Dopdc1f2aed9/RkURfGz5hMlV6zPoKJTi2HtbwZrCB/9jqqM4dvAxmF1057OP'
	DB	'DGGM9+I/BGU/Dvh7JMUegFgQ+1oOcZqX9X7tT07qh0qFsMbLkIsZi6ZlW1eNu'
	DB	'qpCm3CB9mHy0BGxhE5/ypFMz8R2/qp3iFWEhDrJoJ/tbwB7CAmnrpkMSJliaC'
	DB	'auNH/nY91Pil6ATEyOpxDM5+mloM4SomBIBL+5DOFsNlBjnXK/GpIDDmcA+HO'
	DB	'WNbP96ymQwt+ZM3eLu2c5pbLIosEMVRfTbL3+42jkrLrJEf2XqptG/7e2dPwK'
	DB	'WlENdDBCezl1kvlmUx5uXjTmyiVG614y9YNz4+S3fbJAk1tYdiQfVBu+98qDO'
	DB	'9XtnegeoKFnsWdbGVEFkmlLRp6dCuVZYqPnECzM8uRTLxzu0uehdfYufD8BD1'
	DB	'eDyCgu79WtmLIR252bgUZ28HaGOKFUUkGPDRefioj+Zh4DJb93r5N4E7/MLLc'
	DB	'jsdNIFsGh/7ke+IftJuXreH9P/k6aloptITCOnv/cLfGYDDNmrQ+oguhAC0Ht'
	DB	'ysCO/iP0AxZ8IMExE6RPJ+mKHwZLwCK+CTSLFrp9siVRdCGKK9+HlWKDWsUh7'
	DB	'Hqgl14krKRlU7HsEYvoCgkVfTRVWW6DVx1OYSt7egpS6OCP9ADcZrr79Uz6+0'
	DB	'xnqMdXeq7ZyW2U1+FpCgPQTT0Nnl+', 00H
	ORG $+3
$SG204964 DB	'EN', 00H
	ORG $+1
$SG204968 DB	'Infomosaic SecureXML', 00H
	ORG $+3
$SG204969 DB	'P', 00H, 'r', 00H, 'o', 00H, 'v', 00H, 'i', 00H, 'd', 00H
	DB	'e', 00H, 'r', 00H, '=', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, '.', 00H
	DB	'J', 00H, 'e', 00H, 't', 00H, '.', 00H, 'O', 00H, 'L', 00H, 'E'
	DB	00H, 'D', 00H, 'B', 00H, '.', 00H, '4', 00H, '.', 00H, '0', 00H
	DB	';', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, ' ', 00H, 'S'
	DB	00H, 'o', 00H, 'u', 00H, 'r', 00H, 'c', 00H, 'e', 00H, '=', 00H
	DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g'
	DB	00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'I', 00H, 'n', 00H, 'f'
	DB	00H, 'o', 00H, 'm', 00H, 'o', 00H, 's', 00H, 'a', 00H, 'i', 00H
	DB	'c', 00H, '\', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r'
	DB	00H, 'e', 00H, 'X', 00H, 'M', 00H, 'L', 00H, '\', 00H, 'S', 00H
	DB	'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'e', 00H, 'X', 00H, 'M'
	DB	00H, 'L', 00H, '.', 00H, 'm', 00H, 'd', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG204970 DB	00H, 00H
	ORG $+2
$SG205438 DB	'Library initialization failed', 00H
	ORG $+2
$SG205441 DB	'MY', 00H
	ORG $+1
$SG205458 DB	'CLSID\{D300C133-A6F6-4FB4-A734-4865FBF5A3B1}\InprocServe'
	DB	'r32', 00H
$SG205461 DB	'\', 00H
	ORG $+2
$SG205463 DB	'C:\Program Files\Infomosaic\SecureXML\SecureXMLLicense.x'
	DB	'ml', 00H
	ORG $+1
$SG205465 DB	'C:\Program Files\Infomosaic\SecureXML\SecureXML.config', 00H
	ORG $+1
$SG205486 DB	'SecureXMLLicense.xml', 00H
	ORG $+3
$SG205490 DB	'SecureXML.config', 00H
	ORG $+3
$SG205495 DB	'EnglishDiag.dll', 00H
$SG205501 DB	'EnglishDiag.dll', 00H
$SG205507 DB	'No version information found in DLL: %s', 00H
$SG205514 DB	'\', 00H
	ORG $+2
$SG205516 DB	'%d.%d', 00H
	ORG $+2
$SG205517 DB	'.%d.%d', 00H
	ORG $+1
$SG205521 DB	'\VarFileInfo\Translation', 00H
	ORG $+3
$SG205525 DB	'\StringFileInfo\%04x%04x\PrivateBuild', 00H
	ORG $+2
$SG205535 DB	'r', 00H
	ORG $+2
$SG205539 DB	'r', 00H
	ORG $+2
$SG205869 DB	'addressbook', 00H
$SG206059 DB	'\', 00H
	ORG $+2
$SG206075 DB	'FR', 00H
	ORG $+1
$SG206078 DB	'FrenchDiag.dll', 00H
	ORG $+1
$SG206084 DB	'FrenchDiag.dll', 00H
	ORG $+1
$SG206097 DB	'JP', 00H
	ORG $+1
$SG206100 DB	'JapaneseDiag.dll', 00H
	ORG $+3
$SG206106 DB	'JapaneseDiag.dll', 00H
	ORG $+3
$SG206119 DB	'HU', 00H
	ORG $+1
$SG206122 DB	'HungarianDiag.dll', 00H
	ORG $+2
$SG206128 DB	'HungarianDiag.dll', 00H
	ORG $+2
$SG206141 DB	'ES', 00H
	ORG $+1
$SG206144 DB	'SpanishDiag.dll', 00H
$SG206150 DB	'SpanishDiag.dll', 00H
$SG206163 DB	'DE', 00H
	ORG $+1
$SG206166 DB	'GermanDiag.dll', 00H
	ORG $+1
$SG206172 DB	'GermanDiag.dll', 00H
	ORG $+1
$SG206296 DB	'http://', 00H
$SG206297 DB	'ldap://', 00H
$SG206351 DB	'1.0', 00H
$SG206353 DB	'Signature', 00H
	ORG $+2
$SG206356 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG206359 DB	'Id', 00H
	ORG $+1
$SG206361 DB	'SignedInfo', 00H
	ORG $+1
$SG206363 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG206371 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG206372 DB	'Algorithm', 00H
	ORG $+2
$SG206376 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG206377 DB	'Algorithm', 00H
	ORG $+2
$SG206381 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG206382 DB	'Algorithm', 00H
	ORG $+2
$SG206386 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG206387 DB	'Algorithm', 00H
	ORG $+2
$SG206391 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG206392 DB	'Algorithm', 00H
	ORG $+2
$SG206395 DB	'Reference', 00H
	ORG $+2
$SG206396 DB	'REF_Enveloping_%s', 00H
	ORG $+2
$SG206397 DB	'#OBJECT_%s', 00H
	ORG $+1
$SG206400 DB	'Id', 00H
	ORG $+1
$SG206403 DB	'URI', 00H
$SG206407 DB	'Transforms', 00H
	ORG $+1
$SG206409 DB	'Transform', 00H
	ORG $+2
$SG206413 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG206414 DB	'Algorithm', 00H
	ORG $+2
$SG206419 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG206420 DB	'Algorithm', 00H
	ORG $+2
$SG206423 DB	'InclusiveNamespaces', 00H
$SG206426 DB	'ec', 00H
	ORG $+1
$SG206427 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG206430 DB	'PrefixList', 00H
	ORG $+1
$SG206434 DB	'InclusiveNamespaces', 00H
$SG206437 DB	'ec', 00H
	ORG $+1
$SG206438 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG206441 DB	'PrefixList', 00H
	ORG $+1
$SG206446 DB	'Object', 00H
	ORG $+1
$SG206447 DB	'OBJECT_%s', 00H
	ORG $+2
$SG206450 DB	'Id', 00H
	ORG $+1
$SG206464 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG206465 DB	'Encoding', 00H
	ORG $+3
$SG206471 DB	'SignatureProperties', 00H
$SG206473 DB	'SignatureProperty', 00H
	ORG $+2
$SG206476 DB	'URI', 00H
$SG206477 DB	'Id', 00H
	ORG $+1
$SG206480 DB	'Target', 00H
	ORG $+1
$SG206878 DB	'INFM', 00H
	ORG $+3
$SG206932 DB	'INFM', 00H
	ORG $+3
$SG207088 DB	'r', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG207254 DB	'SignedInfo', 00H
	ORG $+1
$SG207257 DB	'Signature', 00H
	ORG $+2
$SG207261 DB	'Id', 00H
	ORG $+1
$SG207264 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG207266 DB	'SignedInfo', 00H
	ORG $+1
$SG207268 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG207276 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG207277 DB	'Algorithm', 00H
	ORG $+2
$SG207281 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG207282 DB	'Algorithm', 00H
	ORG $+2
$SG207286 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG207287 DB	'Algorithm', 00H
	ORG $+2
$SG207291 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG207292 DB	'Algorithm', 00H
	ORG $+2
$SG207296 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG207297 DB	'Algorithm', 00H
	ORG $+2
$SG207299 DB	'Reference', 00H
$SG207302 DB	00H
	ORG $+1
$SG207303 DB	'URI', 00H
$SG207305 DB	'Transforms', 00H
	ORG $+1
$SG207309 DB	'Transform', 00H
	ORG $+2
$SG207313 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG207314 DB	'Algorithm', 00H
	ORG $+2
$SG207319 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG207320 DB	'Algorithm', 00H
	ORG $+2
$SG207323 DB	'InclusiveNamespaces', 00H
$SG207326 DB	'ec', 00H
	ORG $+1
$SG207327 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG207330 DB	'PrefixList', 00H
	ORG $+1
$SG207334 DB	'InclusiveNamespaces', 00H
$SG207337 DB	'ec', 00H
	ORG $+1
$SG207338 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG207341 DB	'PrefixList', 00H
	ORG $+1
$SG207343 DB	'Transform', 00H
	ORG $+2
$SG207346 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG207347 DB	'Algorithm', 00H
	ORG $+2
$SG207401 DB	'http://', 00H
$SG207404 DB	'Cannot fetch content: %s', 0aH, 00H
	ORG $+2
$SG207406 DB	'ldap:', 00H
	ORG $+2
$SG207416 DB	'file://', 00H
$SG207418 DB	'r', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG207488 DB	'INF', 00H
$SG207496 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG207563 DB	'1.0', 00H
$SG207565 DB	'InfomosaicSecureXML', 00H
$SG207568 DB	'infomosaic', 00H
	ORG $+1
$SG207569 DB	'http://www.infomosaic.net/SignHTML/DTD.htm', 00H
	ORG $+1
$SG207571 DB	'SignedHTML', 00H
	ORG $+1
$SG207574 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG207575 DB	'Encoding', 00H
	ORG $+3
$SG207578 DB	'HTMLData', 00H
	ORG $+3
$SG207579 DB	'Id', 00H
	ORG $+1
$SG207594 DB	'Signature', 00H
	ORG $+2
$SG207597 DB	'Id', 00H
	ORG $+1
$SG207600 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG207602 DB	'SignedInfo', 00H
	ORG $+1
$SG207604 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG207612 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG207613 DB	'Algorithm', 00H
	ORG $+2
$SG207617 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG207618 DB	'Algorithm', 00H
	ORG $+2
$SG207622 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG207623 DB	'Algorithm', 00H
	ORG $+2
$SG207627 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG207628 DB	'Algorithm', 00H
	ORG $+2
$SG207632 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG207633 DB	'Algorithm', 00H
	ORG $+2
$SG207635 DB	'Reference', 00H
	ORG $+2
$SG207638 DB	'#HTMLData', 00H
	ORG $+2
$SG207639 DB	'URI', 00H
$SG207641 DB	'Transforms', 00H
	ORG $+1
$SG207643 DB	'Transform', 00H
	ORG $+2
$SG207646 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG207647 DB	'Algorithm', 00H
	ORG $+6
$SG207699 DB	'<?xml version="1.0" ?>', 0aH, '<Error>Invalid SecureXML '
	DB	'License</Error>', 00H
$SG207703 DB	'<?xml version="1.0" ?>', 0aH, '<Error>No SecureXML Verif'
	DB	'ication License</Error>', 00H
$SG207708 DB	'<?xml version="1.0" ?>', 0aH, '<Error>XML Parser Error</'
	DB	'Error>', 00H
	ORG $+1
$SG207715 DB	'<?xml version="1.0" ?>', 0aH, '<Error>Out of memory</Err'
	DB	'or>', 00H
$SG207719 DB	'<?xml version="1.0" ?>', 0aH, '<Error>Base64 Decode Erro'
	DB	'r</Error>', 00H
	ORG $+2
$SG207735 DB	'Microsoft Enhanced Cryptographic Provider v1.0', 00H
	ORG $+1
$SG207740 DB	'1.0', 00H
$SG207742 DB	'XMLSignatureVerificationResponse', 00H
	ORG $+3
$SG207744 DB	'http://www.infomosaic.net/XMLSign/VerifyResponse/DTD.htm'
	DB	00H
	ORG $+3
$SG207746 DB	'1.2 Verified by Infomosaic SecureXML http://www.infomosa'
	DB	'ic.net', 00H
	ORG $+1
$SG207748 DB	'SignatureCount', 00H
	ORG $+1
$SG207753 DB	'SignatureStatus', 00H
$SG207755 DB	'SignatureId', 00H
$SG207757 DB	'SignatureAlgorithm', 00H
	ORG $+1
$SG207759 DB	'Status', 00H
	ORG $+1
$SG207763 DB	'LastError', 00H
	ORG $+2
$SG207769 DB	'ReferenceCount', 00H
	ORG $+1
$SG207771 DB	'0', 00H
	ORG $+2
$SG207773 DB	'Reference', 00H
	ORG $+2
$SG207779 DB	'SignatureStatus', 00H
$SG207781 DB	'SignatureId', 00H
$SG207785 DB	'SignatureAlgorithm', 00H
	ORG $+1
$SG207789 DB	'Status', 00H
	ORG $+1
$SG207800 DB	'LastError', 00H
	ORG $+2
$SG207813 DB	'ReferenceCount', 00H
	ORG $+1
$SG207822 DB	'CertificateInfo', 00H
$SG207824 DB	'Subject', 00H
$SG207831 DB	'ShortSubject', 00H
	ORG $+3
$SG207838 DB	'CertificateIssuer', 00H
	ORG $+2
$SG207845 DB	'CertificateSerialNumber', 00H
$SG207853 DB	'CertificateExpiration', 00H
	ORG $+2
$SG207861 DB	'Reference', 00H
	ORG $+2
$SG207863 DB	'URI', 00H
$SG207867 DB	'DigestMethod', 00H
	ORG $+3
$SG207871 DB	'DigestStatus', 00H
	ORG $+3
$SG207875 DB	'SignedObject', 00H
	ORG $+3
$SG207880 DB	'Encoding', 00H
	ORG $+3
$SG207884 DB	'PropertyCount', 00H
	ORG $+2
$SG207888 DB	'SignatureProperties', 00H
$SG207895 DB	'Property', 00H
	ORG $+3
$SG207898 DB	'Name', 00H
	ORG $+3
$SG207901 DB	'Value', 00H
	ORG $+2
$SG207903 DB	'UTF-16', 00H
	ORG $+1
$SG207951 DB	'SignedHTML', 00H
	ORG $+1
$SG208004 DB	'1.0', 00H
$SG208006 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG208009 DB	'Id', 00H
	ORG $+1
$SG208010 DB	'infomosaic:SignedObject', 00H
$SG208014 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG208017 DB	'infomosaic', 00H
	ORG $+1
$SG208018 DB	'http://www.infomosaic.net/SignData/DTD.htm', 00H
	ORG $+1
$SG208020 DB	'SignedObject', 00H
	ORG $+3
$SG208023 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG208024 DB	'Encoding', 00H
	ORG $+3
$SG208027 DB	'Id', 00H
	ORG $+1
$SG208030 DB	'FileName', 00H
	ORG $+3
$SG208044 DB	'Signature', 00H
	ORG $+2
$SG208047 DB	'Id', 00H
	ORG $+1
$SG208050 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG208052 DB	'SignedInfo', 00H
	ORG $+1
$SG208054 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG208062 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG208063 DB	'Algorithm', 00H
	ORG $+2
$SG208067 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG208068 DB	'Algorithm', 00H
	ORG $+2
$SG208072 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG208073 DB	'Algorithm', 00H
	ORG $+2
$SG208077 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG208078 DB	'Algorithm', 00H
	ORG $+2
$SG208082 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG208083 DB	'Algorithm', 00H
	ORG $+2
$SG208085 DB	'Reference', 00H
	ORG $+2
$SG208088 DB	'URI', 00H
$SG208090 DB	'Transforms', 00H
	ORG $+1
$SG208092 DB	'Transform', 00H
	ORG $+2
$SG208095 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG208096 DB	'Algorithm', 00H
	ORG $+2
$SG208106 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG208176 DB	'SignedObject', 00H
	ORG $+3
$SG208179 DB	'FileName', 00H
	ORG $+3
$SG208200 DB	'\', 00H, 00H, 00H
$SG208203 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG208258 DB	'Library initialization failed', 00H
	ORG $+2
$SG208262 DB	'Netscape', 00H
	ORG $+3
$SG208395 DB	'Signature', 00H
	ORG $+2
$SG208398 DB	'Id', 00H
	ORG $+1
$SG208401 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG208403 DB	'SignedInfo', 00H
	ORG $+1
$SG208405 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG208413 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG208414 DB	'Algorithm', 00H
	ORG $+2
$SG208418 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG208419 DB	'Algorithm', 00H
	ORG $+2
$SG208423 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG208424 DB	'Algorithm', 00H
	ORG $+2
$SG208428 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG208429 DB	'Algorithm', 00H
	ORG $+2
$SG208433 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG208434 DB	'Algorithm', 00H
	ORG $+2
$SG208436 DB	'Reference', 00H
$SG208439 DB	00H
	ORG $+1
$SG208440 DB	'URI', 00H
$SG208442 DB	'Transforms', 00H
	ORG $+1
$SG208446 DB	'Transform', 00H
	ORG $+2
$SG208450 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG208451 DB	'Algorithm', 00H
	ORG $+2
$SG208456 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG208457 DB	'Algorithm', 00H
	ORG $+2
$SG208460 DB	'InclusiveNamespaces', 00H
$SG208463 DB	'ec', 00H
	ORG $+1
$SG208464 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG208467 DB	'PrefixList', 00H
	ORG $+1
$SG208471 DB	'InclusiveNamespaces', 00H
$SG208474 DB	'ec', 00H
	ORG $+1
$SG208475 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG208478 DB	'PrefixList', 00H
	ORG $+1
$SG208480 DB	'Transform', 00H
	ORG $+2
$SG208483 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG208484 DB	'Algorithm', 00H
	ORG $+2
$SG208592 DB	'IEFrame', 00H
$SG208595 DB	'Shell DocObject View', 00H
	ORG $+3
$SG208598 DB	'Internet Explorer_Server', 00H
	ORG $+3
$SG208602 DB	'OLEACC.DLL', 00H
	ORG $+1
$SG208680 DB	'WM_HTML_GETOBJECT', 00H
	ORG $+2
$SG208684 DB	'ObjectFromLresult', 00H
	ORG $+2
$SG208821 DB	'C:\Tmp\SecureXMLsignedHTML.xml', 00H
	ORG $+1
$SG208871 DB	'C:\Tmp\SecureXMLorigHTML.html', 00H
	ORG $+2
$SG208889 DB	'C:\Tmp\setsiteinv.txt', 00H
	ORG $+2
$SG208901 DB	'We are in Setsite', 00H
	ORG $+2
$SG209004 DB	'Microsoft Enhanced Cryptographic Provider v1.0', 00H
	ORG $+1
$SG209105 DB	'INFM', 00H
	ORG $+3
$SG209254 DB	'REF_Detached_%s', 00H
$SG209280 DB	'REF_Detached_%s_%d', 00H
	ORG $+1
$SG209317 DB	'OBJECT_%s_%d', 00H
	ORG $+3
$SG209319 DB	'URI_%s', 00H
	ORG $+1
$SG209332 DB	'REF_Attached_%s_%d', 00H
	ORG $+1
$SG209333 DB	'#OBJECT_%s_%d', 00H
	ORG $+2
$SG209380 DB	'Timestamp_', 00H
	ORG $+1
$SG209383 DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 'm', 00H, 'p', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 't', 00H, 00H, 00H
$SG209389 DB	'0', 00H, 00H, 00H
$SG209391 DB	'1', 00H, 00H, 00H
$SG209393 DB	'2', 00H, 00H, 00H
$SG209395 DB	'0', 00H, 00H, 00H
$SG209397 DB	'TimeStampURL', 00H
	ORG $+3
$SG209399 DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 'm', 00H, 'p', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 't'
	DB	00H, 'o', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 00H, 00H
$SG209401 DB	'S', 00H, 'N', 00H, 'T', 00H, 'P', 00H, '-', 00H, 'R', 00H
	DB	'F', 00H, 'C', 00H, '-', 00H, '1', 00H, '3', 00H, '0', 00H, '5'
	DB	00H, 00H, 00H
$SG209418 DB	'http://time-b.timefreq.bldrdoc.gov:13', 00H
	ORG $+2
$SG209427 DB	'SystemTime', 00H
	ORG $+1
$SG209450 DB	'Timestamp_', 00H
	ORG $+1
$SG209453 DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 'm', 00H, 'p', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 't', 00H, 00H, 00H
$SG209459 DB	'0', 00H, 00H, 00H
$SG209461 DB	'1', 00H, 00H, 00H
$SG209463 DB	'2', 00H, 00H, 00H
$SG209465 DB	'0', 00H, 00H, 00H
$SG209467 DB	'TimeStampURL', 00H
	ORG $+3
$SG209469 DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 'm', 00H, 'p', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 't'
	DB	00H, 'o', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 00H, 00H
$SG209471 DB	'D', 00H, 'A', 00H, 'Y', 00H, 'T', 00H, 'I', 00H, 'M', 00H
	DB	'E', 00H, '-', 00H, 'R', 00H, 'F', 00H, 'C', 00H, '-', 00H, '8'
	DB	00H, '6', 00H, '7', 00H, 00H, 00H
$SG209482 DB	'CertificateValidationMethod', 00H
$SG209485 DB	'CAM', 00H
$SG209487 DB	'CamServerHost', 00H
	ORG $+2
$SG209491 DB	'CamTransactionId', 00H
	ORG $+3
$SG209495 DB	'CamValidationResponse', 00H
	ORG $+2
$SG209500 DB	'OCSP', 00H
	ORG $+3
$SG209502 DB	'OcspResponderURL', 00H
	ORG $+3
$SG209505 DB	'OcspNonce', 00H
	ORG $+2
$SG209508 DB	'OcspTextResponse', 00H
	ORG $+3
$SG209511 DB	'OcspBinaryResponse', 00H
	ORG $+1
$SG209514 DB	'CRL', 00H
$SG209517 DB	00H
	ORG $+3
$SG209519 DB	'CertificateVerificationOptions', 00H
	ORG $+1
$SG209522 DB	'VERIFY_CRL', 00H
	ORG $+1
$SG209525 DB	', ', 00H
	ORG $+1
$SG209526 DB	'VERIFY_CHAIN', 00H
	ORG $+3
$SG209529 DB	', ', 00H
	ORG $+1
$SG209530 DB	'VERIFY_PATH_LENGTH', 00H
	ORG $+1
$SG209533 DB	', ', 00H
	ORG $+1
$SG209534 DB	'VERIFY_POLICY', 00H
	ORG $+2
$SG209537 DB	', ', 00H
	ORG $+1
$SG209538 DB	'POLICY_EXPLICIT', 00H
$SG209541 DB	', ', 00H
	ORG $+1
$SG209542 DB	'EXPLICIT_TRUST', 00H
	ORG $+1
$SG209548 DB	'SignatureImageId', 00H
$SG209562 DB	00H
	ORG $+2
$SG209574 DB	'REF_Properties_%s', 00H
	ORG $+2
$SG209575 DB	'#PROPERTIES_%s', 00H
	ORG $+1
$SG209592 DB	'PROPERTIES_%s', 00H
	ORG $+2
$SG209635 DB	'http://www.w3.org/2000/09/xmldsig#hmac-sha1', 00H
$SG209637 DB	'Microsoft Enhanced Cryptographic Provider v1.0', 00H
	ORG $+1
$SG209713 DB	'http://time-b.timefreq.bldrdoc.gov:13', 00H
	ORG $+2
$SG209774 DB	'Timestamp_', 00H
	ORG $+1
$SG209779 DB	'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 'S', 00H, 't', 00H
	DB	'a', 00H, 'm', 00H, 'p', 00H, 'F', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 't', 00H, 00H, 00H
$SG209784 DB	'1', 00H, 00H, 00H
$SG209788 DB	'2', 00H, 00H, 00H
$SG209965 DB	'%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x', 00H
	ORG $+3
$SG209989 DB	'SignatureImage_', 00H
$SG209992 DB	'SignatureImage_', 00H
$SG209995 DB	'#', 00H
	ORG $+2
$SG210008 DB	'r', 00H
$SG210014 DB	00H
$SG210024 DB	00H
$SG210027 DB	00H
$SG210031 DB	00H
	ORG $+2
$SG210033 DB	'Object', 00H
	ORG $+1
$SG210036 DB	'Id', 00H
	ORG $+1
$SG210039 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210040 DB	'Encoding', 00H
	ORG $+3
$SG210043 DB	'Reference', 00H
	ORG $+2
$SG210046 DB	'URI', 00H
$SG210048 DB	'Transforms', 00H
	ORG $+1
$SG210050 DB	'Transform', 00H
	ORG $+2
$SG210053 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210054 DB	'Algorithm', 00H
$SG210063 DB	00H
$SG210073 DB	00H
$SG210076 DB	00H
$SG210080 DB	00H
	ORG $+2
$SG210082 DB	'Object', 00H
	ORG $+1
$SG210085 DB	'Id', 00H
	ORG $+1
$SG210088 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210089 DB	'Encoding', 00H
	ORG $+3
$SG210092 DB	'Reference', 00H
	ORG $+2
$SG210095 DB	'URI', 00H
$SG210097 DB	'Transforms', 00H
	ORG $+1
$SG210099 DB	'Transform', 00H
	ORG $+2
$SG210102 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210103 DB	'Algorithm', 00H
	ORG $+2
$SG210107 DB	'Object', 00H
	ORG $+1
$SG210110 DB	'Id', 00H
	ORG $+1
$SG210113 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210114 DB	'Encoding', 00H
	ORG $+3
$SG210117 DB	'Reference', 00H
	ORG $+2
$SG210120 DB	'URI', 00H
$SG210122 DB	'Transforms', 00H
	ORG $+1
$SG210124 DB	'Transform', 00H
	ORG $+2
$SG210127 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210128 DB	'Algorithm', 00H
	ORG $+2
$SG210205 DB	'WindowImage_', 00H
	ORG $+3
$SG210208 DB	'WindowImage_', 00H
	ORG $+3
$SG210211 DB	'#', 00H
	ORG $+2
$SG210226 DB	'Object', 00H
	ORG $+1
$SG210229 DB	'Id', 00H
	ORG $+1
$SG210232 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210233 DB	'Encoding', 00H
	ORG $+3
$SG210236 DB	'Reference', 00H
	ORG $+2
$SG210239 DB	'URI', 00H
$SG210241 DB	'Transforms', 00H
	ORG $+1
$SG210243 DB	'Transform', 00H
	ORG $+2
$SG210246 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210247 DB	'Algorithm', 00H
	ORG $+2
$SG210348 DB	'SignedInfo', 00H
	ORG $+1
$SG210351 DB	'Signature', 00H
	ORG $+2
$SG210354 DB	'Id', 00H
	ORG $+1
$SG210357 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG210359 DB	'SignedInfo', 00H
	ORG $+1
$SG210361 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG210369 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210370 DB	'Algorithm', 00H
	ORG $+2
$SG210374 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG210375 DB	'Algorithm', 00H
	ORG $+2
$SG210379 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210380 DB	'Algorithm', 00H
	ORG $+2
$SG210384 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210385 DB	'Algorithm', 00H
	ORG $+2
$SG210389 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210390 DB	'Algorithm', 00H
	ORG $+2
$SG210392 DB	'Reference', 00H
$SG210395 DB	00H
	ORG $+1
$SG210396 DB	'URI', 00H
$SG210398 DB	'Transforms', 00H
	ORG $+1
$SG210402 DB	'Transform', 00H
	ORG $+2
$SG210406 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210407 DB	'Algorithm', 00H
	ORG $+2
$SG210412 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210413 DB	'Algorithm', 00H
	ORG $+2
$SG210416 DB	'InclusiveNamespaces', 00H
$SG210419 DB	'ec', 00H
	ORG $+1
$SG210420 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210423 DB	'PrefixList', 00H
	ORG $+1
$SG210427 DB	'InclusiveNamespaces', 00H
$SG210430 DB	'ec', 00H
	ORG $+1
$SG210431 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210434 DB	'PrefixList', 00H
	ORG $+1
$SG210436 DB	'Transform', 00H
	ORG $+2
$SG210439 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG210440 DB	'Algorithm', 00H
	ORG $+2
$SG210442 DB	'Transform', 00H
	ORG $+2
$SG210445 DB	'http://www.w3.org/TR/1999/REC-xpath-19991116', 00H
	ORG $+3
$SG210446 DB	'Algorithm', 00H
	ORG $+2
$SG210448 DB	'XPath', 00H
	ORG $+2
$SG210467 DB	'Reference', 00H
$SG210470 DB	00H
	ORG $+1
$SG210471 DB	'URI', 00H
$SG210473 DB	'Transforms', 00H
	ORG $+1
$SG210477 DB	'Transform', 00H
	ORG $+2
$SG210481 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210482 DB	'Algorithm', 00H
	ORG $+2
$SG210487 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210488 DB	'Algorithm', 00H
	ORG $+2
$SG210491 DB	'InclusiveNamespaces', 00H
$SG210494 DB	'ec', 00H
	ORG $+1
$SG210495 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210498 DB	'PrefixList', 00H
	ORG $+1
$SG210502 DB	'InclusiveNamespaces', 00H
$SG210505 DB	'ec', 00H
	ORG $+1
$SG210506 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210509 DB	'PrefixList', 00H
	ORG $+1
$SG210511 DB	'Transform', 00H
	ORG $+2
$SG210514 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG210515 DB	'Algorithm', 00H
	ORG $+2
$SG210517 DB	'Transform', 00H
	ORG $+2
$SG210520 DB	'http://www.w3.org/TR/1999/REC-xpath-19991116', 00H
	ORG $+3
$SG210521 DB	'Algorithm', 00H
	ORG $+2
$SG210523 DB	'XPath', 00H
	ORG $+2
$SG210620 DB	'=', 00H, 00H, 00H
$SG210663 DB	'r', 00H
$SG210670 DB	00H
$SG210683 DB	00H
$SG210726 DB	'1.0', 00H
$SG210728 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG210731 DB	'Id', 00H
	ORG $+1
$SG210732 DB	'infomosaic:SignedObject', 00H
$SG210736 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG210739 DB	'infomosaic', 00H
	ORG $+1
$SG210740 DB	'http://www.infomosaic.net/SignData/DTD.htm', 00H
	ORG $+1
$SG210742 DB	'SignedObject', 00H
	ORG $+3
$SG210745 DB	'Id', 00H
	ORG $+1
$SG210748 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210749 DB	'Encoding', 00H
	ORG $+3
$SG210771 DB	'Signature', 00H
	ORG $+2
$SG210774 DB	'Id', 00H
	ORG $+1
$SG210777 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG210779 DB	'SignedInfo', 00H
	ORG $+1
$SG210781 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG210789 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210790 DB	'Algorithm', 00H
	ORG $+2
$SG210794 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG210795 DB	'Algorithm', 00H
	ORG $+2
$SG210799 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210800 DB	'Algorithm', 00H
	ORG $+2
$SG210804 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210805 DB	'Algorithm', 00H
	ORG $+2
$SG210809 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210810 DB	'Algorithm', 00H
	ORG $+2
$SG210812 DB	'Reference', 00H
	ORG $+2
$SG210815 DB	'URI', 00H
$SG210817 DB	'Transforms', 00H
	ORG $+1
$SG210819 DB	'Transform', 00H
	ORG $+2
$SG210822 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG210823 DB	'Algorithm', 00H
	ORG $+2
$SG210939 DB	'SignedObject', 00H
	ORG $+3
$SG210940 DB	'(//. | //@* | //namespace::*)[self::infomosaic:%s]', 00H
	ORG $+1
$SG210944 DB	'http://www.infomosaic.net/SignData/DTD.htm', 00H
	ORG $+1
$SG210945 DB	'infomosaic', 00H
	ORG $+1
$SG210953 DB	'Signature', 00H
	ORG $+2
$SG210956 DB	'Id', 00H
	ORG $+1
$SG210959 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG210961 DB	'SignedInfo', 00H
	ORG $+1
$SG210963 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG210971 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210972 DB	'Algorithm', 00H
	ORG $+2
$SG210976 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG210977 DB	'Algorithm', 00H
	ORG $+2
$SG210981 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG210982 DB	'Algorithm', 00H
	ORG $+2
$SG210986 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG210987 DB	'Algorithm', 00H
	ORG $+2
$SG210991 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG210992 DB	'Algorithm', 00H
	ORG $+2
$SG211002 DB	'SignatureImage_', 00H
$SG211003 DB	'WindowImage_', 00H
	ORG $+3
$SG211004 DB	'Timestamp_', 00H
	ORG $+1
$SG211005 DB	'PROPERTIES_', 00H
$SG211006 DB	'Comments_', 00H
	ORG $+2
$SG211008 DB	'Reference', 00H
	ORG $+2
$SG211011 DB	'URI', 00H
$SG211012 DB	'SignedObject', 00H
	ORG $+3
$SG211013 DB	'(//. | //@* | //namespace::*)[self::infomosaic:%s[@Id='''
	DB	'%s'']]', 00H
	ORG $+3
$SG211021 DB	'Encoding', 00H
	ORG $+3
$SG211024 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG211028 DB	'Transforms', 00H
	ORG $+1
$SG211031 DB	'Transform', 00H
	ORG $+2
$SG211034 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG211035 DB	'Algorithm', 00H
	ORG $+2
$SG211040 DB	'Transform', 00H
	ORG $+2
$SG211044 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG211045 DB	'Algorithm', 00H
	ORG $+2
$SG211050 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG211051 DB	'Algorithm', 00H
	ORG $+2
$SG211054 DB	'InclusiveNamespaces', 00H
$SG211057 DB	'ec', 00H
	ORG $+1
$SG211058 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG211061 DB	'PrefixList', 00H
	ORG $+1
$SG211065 DB	'InclusiveNamespaces', 00H
$SG211068 DB	'ec', 00H
	ORG $+1
$SG211069 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG211072 DB	'PrefixList', 00H
	ORG $+1
$SG211074 DB	'Transform', 00H
	ORG $+2
$SG211077 DB	'http://www.w3.org/TR/1999/REC-xpath-19991116', 00H
	ORG $+3
$SG211078 DB	'Algorithm', 00H
	ORG $+2
$SG211080 DB	'XPath', 00H
	ORG $+2
$SG211082 DB	'self::text()', 00H
	ORG $+3
$SG211173 DB	'1.0', 00H
$SG211175 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG211178 DB	'Id', 00H
	ORG $+1
$SG211179 DB	'infomosaic:SignedObject', 00H
$SG211183 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG211186 DB	'infomosaic', 00H
	ORG $+1
$SG211187 DB	'http://www.infomosaic.net/SignData/DTD.htm', 00H
	ORG $+1
$SG211204 DB	'SignedObject', 00H
	ORG $+3
$SG211207 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG211208 DB	'Encoding', 00H
	ORG $+3
$SG211211 DB	'Id', 00H
	ORG $+1
$SG211214 DB	'FileName', 00H
	ORG $+3
$SG211233 DB	'Signature', 00H
	ORG $+2
$SG211236 DB	'Id', 00H
	ORG $+1
$SG211239 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG211241 DB	'SignedInfo', 00H
	ORG $+1
$SG211243 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG211251 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG211252 DB	'Algorithm', 00H
	ORG $+2
$SG211256 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG211257 DB	'Algorithm', 00H
	ORG $+2
$SG211261 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG211262 DB	'Algorithm', 00H
	ORG $+2
$SG211266 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG211267 DB	'Algorithm', 00H
	ORG $+2
$SG211271 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG211272 DB	'Algorithm', 00H
	ORG $+2
$SG211277 DB	'Reference', 00H
	ORG $+2
$SG211280 DB	'URI', 00H
$SG211282 DB	'Transforms', 00H
	ORG $+1
$SG211284 DB	'Transform', 00H
	ORG $+2
$SG211287 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG211288 DB	'Algorithm', 00H
	ORG $+2
$SG211393 DB	'length', 00H
	ORG $+1
$SG211406 DB	'%d', 00H
	ORG $+1
$SG211801 DB	'INFM', 00H
	ORG $+3
$SG211921 DB	'wb', 00H
	ORG $+1
$SG211922 DB	'c:\temp\pkcs7.tmp', 00H
	ORG $+2
$SG211930 DB	'c:\temp\pkcs7.tmp', 00H
	ORG $+2
$SG212370 DB	'TransID: ', 00H
	ORG $+2
$SG212504 DB	'\', 00H
	ORG $+2
$SG212521 DB	'SecureXMLLicense.xml', 00H
	ORG $+3
$SG212534 DB	'INF', 00H
$SG212543 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG212598 DB	'rb', 00H
	ORG $+1
$SG212604 DB	'INF', 00H
$SG212615 DB	'wb', 00H
	ORG $+1
$SG212668 DB	'%02x', 00H
	ORG $+3
$SG212671 DB	' ', 00H
	ORG $+2
$SG212866 DB	'Netscape', 00H
	ORG $+3
$SG213116 DB	'SignedInfo', 00H
	ORG $+1
$SG213119 DB	'Signature', 00H
	ORG $+2
$SG213123 DB	'Id', 00H
	ORG $+1
$SG213126 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG213128 DB	'SignedInfo', 00H
	ORG $+1
$SG213130 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG213138 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213139 DB	'Algorithm', 00H
	ORG $+2
$SG213143 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG213144 DB	'Algorithm', 00H
	ORG $+2
$SG213148 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213149 DB	'Algorithm', 00H
	ORG $+2
$SG213153 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213154 DB	'Algorithm', 00H
	ORG $+2
$SG213158 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213159 DB	'Algorithm', 00H
	ORG $+2
$SG213161 DB	'Reference', 00H
$SG213164 DB	00H
	ORG $+1
$SG213165 DB	'URI', 00H
$SG213167 DB	'Transforms', 00H
	ORG $+1
$SG213171 DB	'Transform', 00H
	ORG $+2
$SG213175 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213176 DB	'Algorithm', 00H
	ORG $+2
$SG213181 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213182 DB	'Algorithm', 00H
	ORG $+2
$SG213185 DB	'InclusiveNamespaces', 00H
$SG213188 DB	'ec', 00H
	ORG $+1
$SG213189 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213192 DB	'PrefixList', 00H
	ORG $+1
$SG213196 DB	'InclusiveNamespaces', 00H
$SG213199 DB	'ec', 00H
	ORG $+1
$SG213200 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213203 DB	'PrefixList', 00H
	ORG $+1
$SG213205 DB	'Transform', 00H
	ORG $+2
$SG213208 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG213209 DB	'Algorithm', 00H
	ORG $+2
$SG213258 DB	'INF', 00H
$SG213266 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG213322 DB	'Microsoft Enhanced Cryptographic Provider v1.0', 00H
	ORG $+5
$SG213370 DB	'<?xml version="1.0" ?>', 0aH, '<Error>Invalid SecureXML '
	DB	'License</Error>', 00H
$SG213375 DB	'<?xml version="1.0" ?>', 0aH, '<Error>No SecureXML Verif'
	DB	'ication License</Error>', 00H
$SG213390 DB	'Microsoft Enhanced Cryptographic Provider v1.0', 00H
	ORG $+1
$SG213394 DB	'1.0', 00H
$SG213396 DB	'XMLSignatureVerificationResponse', 00H
	ORG $+3
$SG213398 DB	'http://www.infomosaic.net/XMLSign/VerifyResponse/DTD.htm'
	DB	00H
	ORG $+3
$SG213400 DB	'1.2 Verified by Infomosaic SecureXML http://www.infomosa'
	DB	'ic.net', 00H
	ORG $+1
$SG213402 DB	'SignatureCount', 00H
	ORG $+1
$SG213407 DB	'SignatureStatus', 00H
$SG213409 DB	'SignatureId', 00H
$SG213411 DB	'SignatureAlgorithm', 00H
	ORG $+1
$SG213413 DB	'Status', 00H
	ORG $+1
$SG213417 DB	'LastError', 00H
	ORG $+2
$SG213424 DB	'ReferenceCount', 00H
	ORG $+1
$SG213426 DB	'0', 00H
	ORG $+2
$SG213428 DB	'Reference', 00H
	ORG $+2
$SG213434 DB	'SignatureStatus', 00H
$SG213436 DB	'SignatureId', 00H
$SG213440 DB	'SignatureAlgorithm', 00H
	ORG $+1
$SG213444 DB	'Status', 00H
	ORG $+1
$SG213455 DB	'LastError', 00H
	ORG $+2
$SG213468 DB	'ReferenceCount', 00H
	ORG $+1
$SG213477 DB	'CertificateInfo', 00H
$SG213479 DB	'Subject', 00H
$SG213486 DB	'ShortSubject', 00H
	ORG $+3
$SG213493 DB	'CertificateIssuer', 00H
	ORG $+2
$SG213500 DB	'CertificateSerialNumber', 00H
$SG213508 DB	'CertificateExpiration', 00H
	ORG $+2
$SG213516 DB	'Reference', 00H
	ORG $+2
$SG213518 DB	'URI', 00H
$SG213522 DB	'DigestMethod', 00H
	ORG $+3
$SG213526 DB	'DigestStatus', 00H
	ORG $+3
$SG213530 DB	'SignedObject', 00H
	ORG $+3
$SG213535 DB	'Encoding', 00H
	ORG $+3
$SG213539 DB	'PropertyCount', 00H
	ORG $+2
$SG213543 DB	'SignatureProperties', 00H
$SG213550 DB	'Property', 00H
	ORG $+3
$SG213553 DB	'Name', 00H
	ORG $+3
$SG213556 DB	'Value', 00H
	ORG $+2
$SG213558 DB	'UTF-16', 00H
	ORG $+1
$SG213636 DB	'SignedInfo', 00H
	ORG $+1
$SG213639 DB	'Signature', 00H
	ORG $+2
$SG213642 DB	'Id', 00H
	ORG $+1
$SG213645 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG213647 DB	'SignedInfo', 00H
	ORG $+1
$SG213649 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG213657 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213658 DB	'Algorithm', 00H
	ORG $+2
$SG213662 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG213663 DB	'Algorithm', 00H
	ORG $+2
$SG213667 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213668 DB	'Algorithm', 00H
	ORG $+2
$SG213672 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213673 DB	'Algorithm', 00H
	ORG $+2
$SG213677 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213678 DB	'Algorithm', 00H
	ORG $+2
$SG213680 DB	'Reference', 00H
$SG213683 DB	00H
	ORG $+1
$SG213684 DB	'URI', 00H
$SG213686 DB	'Transforms', 00H
	ORG $+1
$SG213688 DB	'Transform', 00H
	ORG $+2
$SG213691 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG213692 DB	'Algorithm', 00H
	ORG $+2
$SG213694 DB	'Transform', 00H
	ORG $+2
$SG213697 DB	'http://www.w3.org/TR/1999/REC-xpath-19991116', 00H
	ORG $+3
$SG213698 DB	'Algorithm', 00H
	ORG $+2
$SG213700 DB	'XPath', 00H
	ORG $+2
$SG213720 DB	'Reference', 00H
$SG213723 DB	00H
	ORG $+1
$SG213724 DB	'URI', 00H
$SG213726 DB	'Transforms', 00H
	ORG $+1
$SG213730 DB	'Transform', 00H
	ORG $+2
$SG213734 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213735 DB	'Algorithm', 00H
	ORG $+2
$SG213740 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213741 DB	'Algorithm', 00H
	ORG $+2
$SG213744 DB	'InclusiveNamespaces', 00H
$SG213747 DB	'ec', 00H
	ORG $+1
$SG213748 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213751 DB	'PrefixList', 00H
	ORG $+1
$SG213755 DB	'InclusiveNamespaces', 00H
$SG213758 DB	'ec', 00H
	ORG $+1
$SG213759 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213762 DB	'PrefixList', 00H
	ORG $+1
$SG213764 DB	'Transform', 00H
	ORG $+2
$SG213767 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG213768 DB	'Algorithm', 00H
	ORG $+2
$SG213770 DB	'Transform', 00H
	ORG $+2
$SG213773 DB	'http://www.w3.org/TR/1999/REC-xpath-19991116', 00H
	ORG $+3
$SG213774 DB	'Algorithm', 00H
	ORG $+2
$SG213776 DB	'XPath', 00H
	ORG $+2
$SG213873 DB	'Signature', 00H
	ORG $+2
$SG213876 DB	'Id', 00H
	ORG $+1
$SG213879 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG213881 DB	'SignedInfo', 00H
	ORG $+1
$SG213883 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG213891 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213892 DB	'Algorithm', 00H
	ORG $+2
$SG213896 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG213897 DB	'Algorithm', 00H
	ORG $+2
$SG213901 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213902 DB	'Algorithm', 00H
	ORG $+2
$SG213906 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213907 DB	'Algorithm', 00H
	ORG $+2
$SG213911 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG213912 DB	'Algorithm', 00H
	ORG $+2
$SG213914 DB	'Reference', 00H
$SG213917 DB	00H
	ORG $+1
$SG213918 DB	'URI', 00H
$SG213920 DB	'Transforms', 00H
	ORG $+1
$SG213924 DB	'Transform', 00H
	ORG $+2
$SG213928 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213929 DB	'Algorithm', 00H
	ORG $+2
$SG213934 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213935 DB	'Algorithm', 00H
	ORG $+2
$SG213938 DB	'InclusiveNamespaces', 00H
$SG213941 DB	'ec', 00H
	ORG $+1
$SG213942 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG213945 DB	'PrefixList', 00H
	ORG $+1
$SG213949 DB	'InclusiveNamespaces', 00H
$SG213952 DB	'ec', 00H
	ORG $+1
$SG213953 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG213956 DB	'PrefixList', 00H
	ORG $+1
$SG213958 DB	'Transform', 00H
	ORG $+2
$SG213961 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG213962 DB	'Algorithm', 00H
	ORG $+2
$SG214018 DB	'INF', 00H
$SG214027 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG214135 DB	'INF', 00H
$SG214144 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG214211 DB	'INF', 00H
$SG214220 DB	'w', 00H, 'b', 00H, 00H, 00H
	ORG $+2
$SG214535 DB	'SignedInfo', 00H
	ORG $+1
$SG214538 DB	'Signature', 00H
	ORG $+2
$SG214542 DB	'Id', 00H
	ORG $+1
$SG214545 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG214547 DB	'SignedInfo', 00H
	ORG $+1
$SG214549 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG214557 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG214558 DB	'Algorithm', 00H
	ORG $+2
$SG214562 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG214563 DB	'Algorithm', 00H
	ORG $+2
$SG214567 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG214568 DB	'Algorithm', 00H
	ORG $+2
$SG214572 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG214573 DB	'Algorithm', 00H
	ORG $+2
$SG214577 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG214578 DB	'Algorithm', 00H
	ORG $+2
$SG214581 DB	'SignatureMethod', 00H
$SG214584 DB	'http://www.w3.org/2000/09/xmldsig#rsa-sha1', 00H
	ORG $+1
$SG214585 DB	'Algorithm', 00H
	ORG $+2
$SG214587 DB	'Reference', 00H
$SG214590 DB	00H
	ORG $+1
$SG214591 DB	'URI', 00H
$SG214593 DB	'Transforms', 00H
	ORG $+1
$SG214597 DB	'Transform', 00H
	ORG $+2
$SG214601 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG214602 DB	'Algorithm', 00H
	ORG $+2
$SG214607 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG214608 DB	'Algorithm', 00H
	ORG $+2
$SG214611 DB	'InclusiveNamespaces', 00H
$SG214614 DB	'ec', 00H
	ORG $+1
$SG214615 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG214618 DB	'PrefixList', 00H
	ORG $+1
$SG214622 DB	'InclusiveNamespaces', 00H
$SG214625 DB	'ec', 00H
	ORG $+1
$SG214626 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG214629 DB	'PrefixList', 00H
	ORG $+1
$SG214631 DB	'Transform', 00H
	ORG $+2
$SG214634 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG214635 DB	'Algorithm', 00H
	ORG $+2
$SG214716 DB	'1.0', 00H
$SG214718 DB	'CertificateChain', 00H
	ORG $+3
$SG214720 DB	'%d', 00H
	ORG $+1
$SG214723 DB	'CertificateCount', 00H
	ORG $+3
$SG214729 DB	'X509Certificate', 00H
$SG214760 DB	'CertificateCount', 00H
	ORG $+3
$SG214774 DB	'X509Certificate', 00H
$SG214909 DB	'1.0', 00H
$SG214911 DB	'SignedInfoSignature', 00H
$SG214913 DB	'SignatureValue', 00H
	ORG $+1
$SG214916 DB	'PublicKeyValue', 00H
	ORG $+1
$SG214919 DB	'AlgorithmType', 00H
	ORG $+2
$SG214921 DB	'%d', 00H
	ORG $+1
$SG214924 DB	'CertificateChainLength', 00H
	ORG $+1
$SG214926 DB	'%d', 00H
	ORG $+1
$SG214934 DB	'X509Certificate', 00H
$SG214990 DB	'SignatureValue', 00H
	ORG $+1
$SG214997 DB	'PublicKeyValue', 00H
	ORG $+1
$SG215004 DB	'AlgorithmType', 00H
	ORG $+2
$SG215009 DB	'CertificateChainLength', 00H
	ORG $+1
$SG215017 DB	'X509Certificate', 00H
$SG215216 DB	'SignedInfo', 00H
	ORG $+1
$SG215219 DB	'Signature', 00H
	ORG $+2
$SG215223 DB	'Id', 00H
	ORG $+1
$SG215226 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG215228 DB	'SignedInfo', 00H
	ORG $+1
$SG215230 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG215238 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG215239 DB	'Algorithm', 00H
	ORG $+2
$SG215243 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG215244 DB	'Algorithm', 00H
	ORG $+2
$SG215248 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215249 DB	'Algorithm', 00H
	ORG $+2
$SG215253 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG215254 DB	'Algorithm', 00H
	ORG $+2
$SG215258 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG215259 DB	'Algorithm', 00H
	ORG $+2
$SG215262 DB	'SignatureMethod', 00H
$SG215265 DB	'http://www.w3.org/2000/09/xmldsig#rsa-sha1', 00H
	ORG $+1
$SG215266 DB	'Algorithm', 00H
	ORG $+2
$SG215268 DB	'Reference', 00H
$SG215271 DB	00H
	ORG $+1
$SG215272 DB	'URI', 00H
$SG215274 DB	'Transforms', 00H
	ORG $+1
$SG215278 DB	'Transform', 00H
	ORG $+2
$SG215282 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215283 DB	'Algorithm', 00H
	ORG $+2
$SG215288 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG215289 DB	'Algorithm', 00H
	ORG $+2
$SG215292 DB	'InclusiveNamespaces', 00H
$SG215295 DB	'ec', 00H
	ORG $+1
$SG215296 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215299 DB	'PrefixList', 00H
	ORG $+1
$SG215303 DB	'InclusiveNamespaces', 00H
$SG215306 DB	'ec', 00H
	ORG $+1
$SG215307 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG215310 DB	'PrefixList', 00H
	ORG $+1
$SG215312 DB	'Transform', 00H
	ORG $+2
$SG215315 DB	'http://www.w3.org/2000/09/xmldsig#enveloped-signature', 00H
	ORG $+2
$SG215316 DB	'Algorithm', 00H
	ORG $+2
$SG215391 DB	'SignatureValue', 00H
	ORG $+1
$SG215399 DB	'PublicKeyValue', 00H
	ORG $+1
$SG215407 DB	'AlgorithmType', 00H
	ORG $+2
$SG215412 DB	'CertificateChainLength', 00H
	ORG $+1
$SG215420 DB	'X509Certificate', 00H
$SG215842 DB	' ', 00H
	ORG $+2
$SG215872 DB	'1.0', 00H
$SG215874 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG215877 DB	'Id', 00H
	ORG $+1
$SG215878 DB	'ifmc:SignedObject', 00H
	ORG $+2
$SG215882 DB	'SignatureEnvelope', 00H
	ORG $+2
$SG215885 DB	'ifmc', 00H
	ORG $+3
$SG215886 DB	'http://www.infomosaic.net/', 00H
	ORG $+1
$SG215888 DB	'Signature', 00H
	ORG $+2
$SG215892 DB	'Id', 00H
	ORG $+1
$SG215895 DB	'ds', 00H
	ORG $+1
$SG215896 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG215898 DB	'SignedInfo', 00H
	ORG $+1
$SG215900 DB	'CanonicalizationMethod', 00H
	ORG $+1
$SG215908 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG215909 DB	'Algorithm', 00H
	ORG $+2
$SG215913 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315', 00H
$SG215914 DB	'Algorithm', 00H
	ORG $+2
$SG215918 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215919 DB	'Algorithm', 00H
	ORG $+2
$SG215923 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG215924 DB	'Algorithm', 00H
	ORG $+2
$SG215928 DB	'http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComm'
	DB	'ents', 00H
	ORG $+3
$SG215929 DB	'Algorithm', 00H
	ORG $+2
$SG215932 DB	'SignatureMethod', 00H
$SG215935 DB	'http://www.w3.org/2000/09/xmldsig#rsa-sha1', 00H
	ORG $+1
$SG215936 DB	'Algorithm', 00H
	ORG $+2
$SG215948 DB	'URI_%s', 00H
	ORG $+1
$SG215954 DB	'SignedObject', 00H
	ORG $+3
$SG215957 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG215958 DB	'Encoding', 00H
	ORG $+3
$SG215961 DB	'Id', 00H
	ORG $+1
$SG215964 DB	'FileName', 00H
	ORG $+3
$SG215967 DB	'Reference', 00H
	ORG $+2
$SG215970 DB	'URI', 00H
$SG215972 DB	'Transforms', 00H
	ORG $+1
$SG215976 DB	'Transform', 00H
	ORG $+2
$SG215980 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215981 DB	'Algorithm', 00H
	ORG $+2
$SG215986 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG215987 DB	'Algorithm', 00H
	ORG $+2
$SG215990 DB	'InclusiveNamespaces', 00H
$SG215993 DB	'ec', 00H
	ORG $+1
$SG215994 DB	'http://www.w3.org/2001/10/xml-exc-c14n#WithComments', 00H
$SG215997 DB	'PrefixList', 00H
	ORG $+1
$SG216001 DB	'InclusiveNamespaces', 00H
$SG216004 DB	'ec', 00H
	ORG $+1
$SG216005 DB	'http://www.w3.org/2001/10/xml-exc-c14n#', 00H
$SG216008 DB	'PrefixList', 00H
	ORG $+1
$SG216010 DB	'Transform', 00H
	ORG $+2
$SG216013 DB	'http://www.w3.org/2000/09/xmldsig#base64', 00H
	ORG $+3
$SG216014 DB	'Algorithm', 00H
	ORG $+2
$SG216033 DB	'pm', 00H
	ORG $+1
$SG216035 DB	'am', 00H
	ORG $+1
$SG216037 DB	'%02d/%02d/%04d %02d:%02d:%02d %s', 00H
	ORG $+3
$SG216058 DB	'SW5mb21vc2FpY1NlY3VyZVdlYnNpZ25QYXNzd29yZA==', 00H
	ORG $+3
$SG216075 DB	'%d', 00H
	ORG $+1
$SG216077 DB	'MaintExpiryYear', 00H
$SG216080 DB	'%d', 00H
	ORG $+1
$SG216082 DB	'MaintExpiryMonth', 00H
	ORG $+3
$SG216085 DB	'%d', 00H
	ORG $+1
$SG216087 DB	'MaintExpiryDay', 00H
	ORG $+1
$SG216090 DB	'%d', 00H
	ORG $+1
$SG216092 DB	'LinuxClient', 00H
$SG216095 DB	'%d', 00H
	ORG $+1
$SG216097 DB	'WindowsClient', 00H
	ORG $+2
$SG216100 DB	'%d', 00H
	ORG $+1
$SG216102 DB	'SolarisClient', 00H
	ORG $+2
$SG216105 DB	'%d', 00H
	ORG $+1
$SG216107 DB	'MacClient', 00H
	ORG $+2
$SG218324 DB	'pThis != 0', 00H
	ORG $+1
$SG218325 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG218335 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG218336 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG218342 DB	'pp != 0', 00H
$SG218343 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160708 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160709 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWFake
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
;	COMDAT rtc$IMZ
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	mov	eax, DWORD PTR __imp__GetEnvironmentVariableW@12
	push	eax
	push	OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ; ATL::GetEnvironmentVariableWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

	mov	esi, esp
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 188  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	mov	eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	and	eax, 1
	jne	SHORT $L163734
	mov	ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
	mov	esi, esp
	call	DWORD PTR __imp__GetVersion@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483648			; 80000000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L163734:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

	movzx	edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	test	edx, edx
	je	SHORT $L163736

; 125  : 		pfn = pfnWin9x;

	mov	eax, DWORD PTR _pfnWin9x$[ebp]
	mov	DWORD PTR _pfn$[ebp], eax

; 126  : 	else

	jmp	SHORT $L163737
$L163736:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

	mov	ecx, DWORD PTR _pfnNT$[ebp]
	mov	DWORD PTR _pfn$[ebp], ecx
$L163737:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

	mov	edx, DWORD PTR _pfn$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppThunk$[ebp]
	push	eax
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
PUBLIC	??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@	; `string'
EXTRN	__except_list:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
EXTRN	__CrtDbgReport:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T220254 DD	0ffffffffH
	DD	FLAT:$L220238
	DD	00H
	DD	FLAT:$L220239
$T220243 DD	019930520H
	DD	02H
	DD	FLAT:$T220254
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT
??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@ DB 'nSize >= nSizeW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\cs'
	DB	'tringt.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
$T220237 = -316						; size = 4
$T220235 = -312						; size = 4
$T220234 = -308						; size = 4
_pszNameA$ = -300					; size = 132
_pszBufferA$ = -160					; size = 132
_nSizeW$ = -24						; size = 4
_nSizeA$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z	; ATL::CW2AEX<128>::CW2AEX<128>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

	cmp	DWORD PTR _nSizeA$[ebp], 0
	jne	SHORT $L163808

; 167  : 		return 0;

	mov	DWORD PTR $T220234[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220234[ebp]
	jmp	$L163780
$L163808:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

	mov	ecx, DWORD PTR _nSizeA$[ebp]
	shl	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

	mov	esi, esp
	mov	edx, DWORD PTR _nSizeA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

	cmp	DWORD PTR _nSize$[ebp], 0
	jne	SHORT $L163810

; 174  : 		return nSizeW;

	mov	eax, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T220235[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220235[ebp]
	jmp	$L163780
$L163810:

; 175  : 	ATLASSERT(nSize >= nSizeW);

	mov	ecx, DWORD PTR _nSize$[ebp]
	cmp	ecx, DWORD PTR _nSizeW$[ebp]
	jae	SHORT $L220236
	push	OFFSET FLAT:??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
	push	0
	push	175					; 000000afH
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220236
	int	3
$L220236:

; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

	mov	esi, esp
	mov	eax, DWORD PTR _nSizeW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$[ebp]
	push	ecx
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  : 
; 178  : 	return nSizeW;

	mov	edx, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T220237[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220237[ebp]
$L163780:

; 179  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220251
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L220251:
	DD	2
	DD	$L220250
$L220250:
	DD	-160					; ffffff60H
	DD	132					; 00000084H
	DD	$L220244
	DD	-300					; fffffed4H
	DD	132					; 00000084H
	DD	$L220245
$L220245:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	0
$L220244:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220238:
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L220239:
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	jmp	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z:
	mov	eax, OFFSET FLAT:$T220243
	jmp	___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWFake
PUBLIC	?CompareStringWFake@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	mov	eax, DWORD PTR __imp__CompareStringW@24
	push	eax
	push	OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ; ATL::CompareStringWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

	mov	esi, esp
	mov	ecx, DWORD PTR _nLength2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszString2$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLength1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszString1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	24					; 00000018H
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPBGHI@Z			; AtlW2AHelper
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__alloca_probe:NEAR
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T220279 DD	0ffffffffH
	DD	FLAT:$L220271
$T220273 DD	019930520H
	DD	01H
	DD	FLAT:$T220279
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
tv147 = -76						; size = 4
tv142 = -72						; size = 4
tv149 = -68						; size = 4
tv89 = -64						; size = 4
tv84 = -60						; size = 4
tv91 = -56						; size = 4
$T220270 = -52						; size = 4
_pszAString2$ = -48					; size = 4
_pszAString1$ = -44					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 193  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

	mov	DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

	cmp	DWORD PTR _pszString1$[ebp], 0
	je	$L163835

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString1$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L220264
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L220265
$L220264:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L220262
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L220262
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv84[ebp], esp
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $L220263
$L220262:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv89[ebp], eax
$L220263:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv91[ebp], eax
$L220265:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

	cmp	DWORD PTR _pszAString1$[ebp], 0
	jne	SHORT $L163835

; 200  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L163835:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

	mov	DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

	cmp	DWORD PTR _pszString2$[ebp], 0
	je	$L163841

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString2$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L220268
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $L220269
$L220268:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L220266
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L220266
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv142[ebp], esp
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv147[ebp], edx
	jmp	SHORT $L220267
$L220266:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv147[ebp], eax
$L220267:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv147[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv149[ebp], eax
$L220269:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

	cmp	DWORD PTR _pszAString2$[ebp], 0
	jne	SHORT $L163841

; 208  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L163841:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

	mov	esi, esp
	mov	eax, DWORD PTR _nLength2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszAString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszAString1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR __imp__CompareStringA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T220270[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220270[ebp]
$L220261:

; 212  : }

	lea	esp, DWORD PTR [ebp-84]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220278
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L220278:
	DD	1
	DD	$L220277
$L220277:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L220275
$L220275:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220271:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z:
	mov	eax, OFFSET FLAT:$T220273
	jmp	___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWFake
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	mov	eax, DWORD PTR __imp__GetStringTypeExW@20
	push	eax
	push	OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ; ATL::GetStringTypeExWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

	mov	esi, esp
	mov	ecx, DWORD PTR _pwCharType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwInfoType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 244  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__WideCharToMultiByte@32:NEAR
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T220296 DD	0ffffffffH
	DD	FLAT:$L220288
$T220290 DD	019930520H
	DD	01H
	DD	FLAT:$T220296
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
$T220287 = -164						; size = 4
_pszA$ = -156						; size = 132
_nLengthA$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

	mov	edx, DWORD PTR _nLengthA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszSrc$[ebp]
	push	edx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : 
; 232  : 	if (nLength == -1)

	cmp	DWORD PTR _nLength$[ebp], -1
	jne	SHORT $L163867

; 233  : 		nLengthA = -1;

	mov	DWORD PTR _nLengthA$[ebp], -1
$L163867:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

	mov	esi, esp
	mov	eax, DWORD PTR _pwCharType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLengthA$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	edx, DWORD PTR _dwInfoType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR __imp__GetStringTypeExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T220287[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220287[ebp]

; 236  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220295
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L220295:
	DD	1
	DD	$L220294
$L220294:
	DD	-156					; ffffff64H
	DD	132					; 00000084H
	DD	$L220291
$L220291:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220288:
	lea	ecx, DWORD PTR _pszA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z:
	mov	eax, OFFSET FLAT:$T220290
	jmp	___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPBG0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	mov	eax, DWORD PTR __imp__lstrcmpiW@8
	push	eax
	push	OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPBG0@Z ; ATL::lstrcmpiWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz1$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 258  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?lstrcmpiWThunk@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPBG0@Z PROC NEAR			; ATL::lstrcmpiWFake, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 248  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

	mov	eax, DWORD PTR _psz2$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L220303
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L220304
$L220303:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv76[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv79[ebp], eax
$L220304:
	mov	ecx, DWORD PTR _psz1$[ebp]
	mov	DWORD PTR __lpw$[ebp], ecx
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L220305
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L220306
$L220305:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv91[ebp], esp
	mov	ecx, DWORD PTR __acp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv91[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv94[ebp], eax
$L220306:
	mov	esi, esp
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 251  : }

	lea	esp, DWORD PTR [ebp-36]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?lstrcmpiWFake@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPAGPAG@Z			; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	mov	eax, DWORD PTR __imp__CharLowerW@4
	push	eax
	push	OFFSET FLAT:?CharLowerWFake@ATL@@YGPAGPAG@Z ; ATL::CharLowerWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 277  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharLowerWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPAGPAGPBDHI@Z			; AtlA2WHelper
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	_wcscpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 262  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L220311
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L220312
$L220311:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L220312:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharLowerA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 267  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L220313
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L220314
$L220313:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L220314:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 268  : 
; 269  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 270  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharLowerWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWFake
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPAGPAG@Z			; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	mov	eax, DWORD PTR __imp__CharUpperW@4
	push	eax
	push	OFFSET FLAT:?CharUpperWFake@ATL@@YGPAGPAG@Z ; ATL::CharUpperWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 296  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharUpperWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 281  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L220319
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L220320
$L220319:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L220320:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 286  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L220321
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L220322
$L220321:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L220322:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 287  : 
; 288  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 289  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharUpperWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
EXTRN	__except_handler3:NEAR
EXTRN	__resetstkoflw:NEAR
;	COMDAT CONST
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T220331 DD	0ffffffffH
	DD	FLAT:$L220326
	DD	FLAT:$L220327
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -48						; size = 4
$T220330 = -44						; size = 4
_p$75737 = -36						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET FLAT:$T220331
	push	OFFSET FLAT:__except_handler3
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	add	esp, -32				; ffffffe0H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

	mov	BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 8195				; 00002003H
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv65[ebp], esp
	mov	DWORD PTR __$SEHRec$[ebp], esp
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _p$75737[ebp], eax
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $L220329
$L220326:
$L220338:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T220330[ebp], eax
	mov	eax, DWORD PTR $T220330[ebp]
	sub	eax, -1073741571			; c00000fdH
	neg	eax
	sbb	eax, eax
	inc	eax
$L220328:
$L220337:
	ret	0
$L220327:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

	mov	BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

	call	__resetstkoflw
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
$L220329:

; 345  :     }
; 346  :     return bStackAvailable;

	mov	al, BYTE PTR _bStackAvailable$[ebp]
$L220325:

; 347  : }

	lea	esp, DWORD PTR [ebp-60]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220336
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L220336:
	DD	1
	DD	$L220335
$L220335:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L220333
$L220333:
	DB	112					; 00000070H
	DB	0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

	mov	esi, esp
	mov	eax, DWORD PTR _pNew$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pp$[ebp]
	push	ecx
	call	DWORD PTR __imp__InterlockedExchange@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 93   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -156						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

	mov	DWORD PTR _ver$[ebp], 148		; 00000094H

; 139  : 	::GetVersionEx( &ver );

	mov	esi, esp
	lea	eax, DWORD PTR _ver$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

	cmp	DWORD PTR _ver$[ebp+16], 2
	jne	SHORT $L75782
	cmp	DWORD PTR _ver$[ebp+4], 5
	jb	SHORT $L75782

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

	jmp	SHORT $L75783
$L75782:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L75783:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	mov	ecx, DWORD PTR _pfnGetThreadACP$[ebp]
	push	ecx
	push	OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 152  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220349
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L220349:
	DD	1
	DD	$L220348
$L220348:
	DD	-156					; ffffff64H
	DD	148					; 00000094H
	DD	$L220346
$L220346:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$75770 = -32					; size = 4
_szACP$ = -24						; size = 7
_lcidThread$ = -12					; size = 4
_nACP$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

	mov	DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

	mov	esi, esp
	call	DWORD PTR __imp__GetThreadLocale@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

	mov	esi, esp
	push	7
	lea	eax, DWORD PTR _szACP$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _lcidThread$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetLocaleInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L75769

; 111  : 	{
; 112  : 		char* pch = szACP;

	lea	edx, DWORD PTR _szACP$[ebp]
	mov	DWORD PTR _pch$75770[ebp], edx
$L75772:

; 113  : 		while (*pch != '\0')

	mov	eax, DWORD PTR _pch$75770[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L75769

; 114  : 		{
; 115  : 			nACP *= 10;

	mov	edx, DWORD PTR _nACP$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

	mov	eax, DWORD PTR _pch$75770[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _nACP$[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _nACP$[ebp], eax
	mov	ecx, DWORD PTR _pch$75770[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$75770[ebp], ecx

; 117  : 		}

	jmp	SHORT $L75772
$L75769:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

	cmp	DWORD PTR _nACP$[ebp], 0
	jne	SHORT $L75774

; 121  : 		nACP = ::GetACP();

	mov	esi, esp
	call	DWORD PTR __imp__GetACP@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nACP$[ebp], eax
$L75774:

; 122  : 
; 123  : 	return nACP;

	mov	eax, DWORD PTR _nACP$[ebp]

; 124  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220356
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L220356:
	DD	1
	DD	$L220355
$L220355:
	DD	-24					; ffffffe8H
	DD	7
	DD	$L220353
$L220353:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	67					; 00000043H
	DB	80					; 00000050H
	DB	0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 128  : 	return( CP_THREAD_ACP );

	mov	eax, 3

; 129  : }

	pop	ebp
	ret	0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 158  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 159  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@ DB 'lpa != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lconv.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@ DB 'lpw != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPAGPAGPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 555  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L220363
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	555					; 0000022bH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220363
	int	3
$L220363:

; 556  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L220364
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	556					; 0000022cH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220364
	int	3
$L220364:

; 557  : 	if (lpw == NULL || lpa == NULL)

	cmp	DWORD PTR _lpw$[ebp], 0
	je	SHORT $L75944
	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L75943
$L75944:

; 558  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75937
$L75943:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

	mov	edx, DWORD PTR _lpw$[ebp]
	mov	WORD PTR [edx], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

	mov	esi, esp
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpw$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpa$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75946

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L220365
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220365
	int	3
$L220365:

; 567  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75937
$L75946:

; 568  : 	}		
; 569  : 	return lpw;

	mov	eax, DWORD PTR _lpw$[ebp]
$L75937:

; 570  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlA2WHelper@@YGPAGPAGPBDHI@Z ENDP			; AtlA2WHelper
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPBGHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 574  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L220368
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	574					; 0000023eH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220368
	int	3
$L220368:

; 575  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L220369
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	575					; 0000023fH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220369
	int	3
$L220369:

; 576  : 	if (lpa == NULL || lpw == NULL)

	cmp	DWORD PTR _lpa$[ebp], 0
	je	SHORT $L75958
	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L75957
$L75958:

; 577  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75954
$L75957:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

	mov	edx, DWORD PTR _lpa$[ebp]
	mov	BYTE PTR [edx], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpa$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpw$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75960

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L220370
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	585					; 00000249H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220370
	int	3
$L220370:

; 586  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75954
$L75960:

; 587  : 	}
; 588  : 	return lpa;

	mov	eax, DWORD PTR _lpa$[ebp]
$L75954:

; 589  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlW2AHelper@@YGPADPADPBGHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	?atlTraceException@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceException
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
CONST	SEGMENT
??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ DB 'AtlThrow: hr '
	DB	'= 0x%x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lexcept.h', 00H				; `string'
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T220375 = -16						; size = 4
$T220374 = -12						; size = 4
$T220373 = -8						; size = 8
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceException@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceException
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	62					; 0000003eH
	push	OFFSET FLAT:??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T220373[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T220375[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T220374[ebp], edx
	push	OFFSET FLAT:__TI1?AVCAtlException@ATL@@
	lea	eax, DWORD PTR $T220374[ebp]
	push	eax
	call	__CxxThrowException@8
$L220372:

; 74   : #endif
; 75   : };

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
; Function compile flags: /Odt /RTCsu
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 162  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 163  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
	call	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z	; ATL::CTrace::TraceV
	add	esp, 28					; 0000001cH

; 164  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 165  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_AtlTraceVA
	add	esp, 28					; 0000001cH

; 123  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 41   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?setLicenseFile@CLicense@@QAEXPAD@Z		; CLicense::setLicenseFile
PUBLIC	??0IObjectWithSite@@QAE@XZ			; IObjectWithSite::IObjectWithSite
PUBLIC	??0SigException@@QAE@PAD@Z			; SigException::SigException
PUBLIC	??1SigException@@UAE@XZ				; SigException::~SigException
PUBLIC	??0SigException@@QAE@ABV0@@Z			; SigException::SigException
PUBLIC	??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>
PUBLIC	??0CSignature@@QAE@XZ				; CSignature::CSignature
PUBLIC	?A2WBSTR@@YAPAGPBDH@Z				; A2WBSTR
PUBLIC	??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>
PUBLIC	??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
PUBLIC	?setConfigFile@CConfig@@QAEXPAD@Z		; CConfig::setConfigFile
PUBLIC	??0CConfig@@QAE@XZ				; CConfig::CConfig
PUBLIC	??4CConfig@@QAEAAV0@ABV0@@Z			; CConfig::operator=
PUBLIC	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance
PUBLIC	?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CComModule::GetResourceInstance
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??0_bstr_t@@QAE@PBD@Z				; _bstr_t::_bstr_t
PUBLIC	??1_bstr_t@@QAE@XZ				; _bstr_t::~_bstr_t
PUBLIC	??B_bstr_t@@QBEPBGXZ				; _bstr_t::operator unsigned short const *
PUBLIC	??0CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::CComBSTR
PUBLIC	??4CComBSTR@ATL@@QAEAAV01@PBG@Z			; ATL::CComBSTR::operator=
PUBLIC	__TI2?AVSigException@@
PUBLIC	??1CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::~CComBSTR
PUBLIC	__CTA2?AVSigException@@
PUBLIC	??_R0?AVSigException@@@8			; SigException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVSigException@@@8??0SigException@@QAE@ABV0@@Z16
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4CComBSTR@ATL@@QAEAAV01@PBD@Z			; ATL::CComBSTR::operator=
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	??0IOleCommandTarget@@QAE@XZ			; IOleCommandTarget::IOleCommandTarget
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
EXTRN	??0CLicense@@QAE@XZ:NEAR			; CLicense::CLicense
EXTRN	??1CLicense@@UAE@XZ:NEAR			; CLicense::~CLicense
EXTRN	?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z:NEAR ; CLicense::getLicenseDetails
EXTRN	?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z:NEAR ; CLicense::verifyLicense
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	__imp__lstrcpyA@8:NEAR
EXTRN	_GetFileVersionInfoSizeA@8:NEAR
EXTRN	_setError:NEAR
EXTRN	_GetFileVersionInfoA@16:NEAR
EXTRN	?HeapW2A@@YAPAEPAG@Z:NEAR			; HeapW2A
EXTRN	_VerQueryValueA@16:NEAR
EXTRN	_vbNowTimeToSystem:NEAR
EXTRN	_malloc:NEAR
EXTRN	_rFree:NEAR
EXTRN	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z:NEAR ; CShowSelectCert::CShowSelectCert
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z:NEAR	; ATL::CTime::CTime
EXTRN	?getConfigDetails@CConfig@@QAEHPAU_GLOBAL_SIG@@@Z:NEAR ; CConfig::getConfigDetails
EXTRN	??0CConfig@@QAE@PAVCSignature@@@Z:NEAR		; CConfig::CConfig
EXTRN	??1CConfig@@UAE@XZ:NEAR				; CConfig::~CConfig
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	__imp__RegOpenKeyExA@20:NEAR
EXTRN	__imp__LoadLibraryW@4:NEAR
EXTRN	__imp__RegQueryValueExA@24:NEAR
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_sprintf:NEAR
EXTRN	__imp__GetCommandLineA@0:NEAR
EXTRN	__strlwr:NEAR
EXTRN	_strstr:NEAR
EXTRN	_axInit:NEAR
EXTRN	_axGetCertificateList:NEAR
EXTRN	?_Module@@3VCComModule@ATL@@A:BYTE		; _Module
xdata$x	SEGMENT
$T220486 DD	0ffffffffH
	DD	FLAT:$L220413
	DD	00H
	DD	FLAT:$L220414
	DD	01H
	DD	FLAT:$L220415
	DD	02H
	DD	FLAT:$L220416
	DD	03H
	DD	FLAT:$L220417
	DD	04H
	DD	FLAT:$L220418
	DD	05H
	DD	FLAT:$L220419
	DD	06H
	DD	FLAT:$L220420
	DD	07H
	DD	FLAT:$L220421
	DD	08H
	DD	FLAT:$L220422
	DD	09H
	DD	FLAT:$L220423
	DD	0aH
	DD	FLAT:$L220424
	DD	0bH
	DD	FLAT:$L220425
	DD	0cH
	DD	FLAT:$L220426
	DD	0dH
	DD	FLAT:$L220427
	DD	0eH
	DD	FLAT:$L220428
	DD	0fH
	DD	FLAT:$L220429
	DD	010H
	DD	FLAT:$L220430
	DD	011H
	DD	FLAT:$L220431
	DD	012H
	DD	FLAT:$L220432
	DD	013H
	DD	FLAT:$L220433
	DD	014H
	DD	FLAT:$L220434
	DD	015H
	DD	FLAT:$L220435
	DD	016H
	DD	FLAT:$L220436
	DD	017H
	DD	FLAT:$L220437
	DD	018H
	DD	FLAT:$L220438
	DD	019H
	DD	FLAT:$L220439
	DD	01aH
	DD	FLAT:$L220440
	DD	01bH
	DD	FLAT:$L220441
	DD	01cH
	DD	FLAT:$L220442
	DD	01dH
	DD	FLAT:$L220443
	DD	01eH
	DD	FLAT:$L220444
	DD	01fH
	DD	FLAT:$L220445
	DD	020H
	DD	FLAT:$L220446
	DD	021H
	DD	FLAT:$L220447
	DD	022H
	DD	FLAT:$L220448
	DD	022H
	DD	FLAT:$L220450
	DD	024H
	DD	FLAT:$L220451
	DD	025H
	DD	FLAT:$L220452
	DD	026H
	DD	FLAT:$L220453
	DD	027H
	DD	FLAT:$L220454
	DD	028H
	DD	FLAT:$L220455
	DD	026H
	DD	FLAT:$L220456
	DD	02aH
	DD	FLAT:$L220457
	DD	02bH
	DD	FLAT:$L220458
	DD	026H
	DD	FLAT:$L220459
	DD	026H
	DD	FLAT:$L220461
	DD	02eH
	DD	FLAT:$L220462
	DD	02fH
	DD	FLAT:$L220463
	DD	026H
	DD	FLAT:$L220465
$T220467 DD	019930520H
	DD	032H
	DD	FLAT:$T220486
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __TI2?AVSigException@@
; File c:\activex\xmlsign\signature.cpp
xdata$x	SEGMENT
__TI2?AVSigException@@ DD 00H
	DD	FLAT:??1SigException@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVSigException@@
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT __CTA2?AVSigException@@
xdata$x	SEGMENT
__CTA2?AVSigException@@ DD 02H
	DD	FLAT:__CT??_R0?AVSigException@@@8??0SigException@@QAE@ABV0@@Z16
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVSigException@@@8??0SigException@@QAE@ABV0@@Z16
xdata$x	SEGMENT
__CT??_R0?AVSigException@@@8??0SigException@@QAE@ABV0@@Z16 DD 00H
	DD	FLAT:??_R0?AVSigException@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	010H
	DD	FLAT:??0SigException@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVSigException@@@8
_DATA	SEGMENT
??_R0?AVSigException@@@8 DD FLAT:??_7type_info@@6B@	; SigException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSigException@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
_TEXT	SEGMENT
tv954 = -1744						; size = 4
tv1054 = -1740						; size = 4
tv1052 = -1736						; size = 4
tv1063 = -1732						; size = 4
tv1050 = -1728						; size = 4
tv1062 = -1724						; size = 4
tv1048 = -1720						; size = 4
tv1061 = -1716						; size = 4
tv1046 = -1712						; size = 4
tv1044 = -1708						; size = 4
tv1060 = -1704						; size = 4
tv1042 = -1700						; size = 4
tv1059 = -1696						; size = 4
tv1040 = -1692						; size = 4
tv1058 = -1688						; size = 4
tv1038 = -1684						; size = 4
tv1057 = -1680						; size = 4
tv1036 = -1676						; size = 4
tv529 = -1672						; size = 4
tv1034 = -1668						; size = 4
tv533 = -1664						; size = 4
tv1032 = -1660						; size = 4
tv559 = -1656						; size = 4
tv1027 = -1652						; size = 4
tv455 = -1648						; size = 4
$T220410 = -1644					; size = 4
$T220409 = -1640					; size = 4
$T220408 = -1636					; size = 16
$T220407 = -1620					; size = 28
$T220406 = -1592					; size = 28
$T220405 = -1564					; size = 28
$T220404 = -1536					; size = 4
$T220403 = -1532					; size = 4
$T220402 = -1528					; size = 28
$T220401 = -1500					; size = 28
$T220400 = -1472					; size = 28
$T220399 = -1444					; size = 28
$T220398 = -1416					; size = 28
$T220397 = -1388					; size = 28
$T220396 = -1360					; size = 28
$T220395 = -1332					; size = 16
$T220394 = -1316					; size = 16
$T220391 = -1300					; size = 4
$T220390 = -1296					; size = 4
_i$205582 = -1292					; size = 4
_j$205573 = -1288					; size = 4
_certificateAllowed$205572 = -1284			; size = 4
_i$205568 = -1280					; size = 4
_j$205561 = -1276					; size = 4
_i$205557 = -1272					; size = 4
_allowedCertCount$205556 = -1268			; size = 4
_indexArray$205553 = -1264				; size = 4
_fHandle$ = -1260					; size = 4
_releaseTime$ = -1252					; size = 8
_releaseTimeStamp$ = -1240				; size = 4
_codePage$ = -1236					; size = 4
_languageCode$ = -1232					; size = 4
_buf$205506 = -1224					; size = 400
_pos$ = -820						; size = 4
_dll_file$ = -812					; size = 28
_config_file$ = -776					; size = 28
_license_file$ = -740					; size = 28
_FILE_SEP_STR$ = -708					; size = 4
_FILE_SEP$ = -701					; size = 1
_reg_entry$ = -700					; size = 4
_charVersionStr$ = -692					; size = 70
_charVerLS$ = -612					; size = 34
_versionLS$ = -572					; size = 4
_versionMS$ = -568					; size = 4
_versionStruct$ = -564					; size = 4
_puLen$ = -556						; size = 4
_lplpBuffer$ = -544					; size = 4
_versionBuffer$ = -536					; size = 4
_versionInfoSize$ = -532				; size = 4
_junk$ = -524						; size = 4
_buflen$ = -512						; size = 4
_securexml_path$ = -500					; size = 400
_BUF_SIZE$ = -96					; size = 4
_lret$ = -92						; size = 4
_hkey$ = -84						; size = 4
__lpa$ = -76						; size = 4
__lpw$ = -72						; size = 4
__acp$ = -68						; size = 4
__convert$ = -64					; size = 4
_i$205421 = -60						; size = 4
_i$205416 = -56						; size = 4
_commandLine$ = -52					; size = 4
_configfileStatus$ = -48				; size = 4
_fileStatus$ = -44					; size = 4
_tmpCharPtr$ = -40					; size = 4
_certPtr$ = -36						; size = 4
_numCerts$ = -28					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
??0CSignature@@QAE@XZ PROC NEAR				; CSignature::CSignature
; _this$ = ecx

; 185  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CSignature@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 1732				; 000006c4H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1744]
	mov	ecx, 433				; 000001b1H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0IOleCommandTarget@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0IObjectWithSite@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	??0CLicense@@QAE@XZ			; CLicense::CLicense
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	??0CConfig@@QAE@XZ			; CConfig::CConfig
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H

; 186  : 	int numCerts;
; 187  : 	PCERT_DESCR *certPtr;
; 188  : 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 189  : 
; 190  : 	sgArr=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 191  : 	err=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 192  : 	signum=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 193  : 	uriArr=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 194  : 	failedUriArr=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 195  : 	failedUriCount=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 196  : 	totalUriCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 197  : #ifdef WIN32
; 198  : 	dlg = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1808], 0

; 199  : 	dlgRecipient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1812], 0

; 200  : #endif
; 201  : 	BOOL fileStatus=FALSE;

	mov	DWORD PTR _fileStatus$[ebp], 0

; 202  : 	BOOL configfileStatus=FALSE;

	mov	DWORD PTR _configfileStatus$[ebp], 0

; 203  : 
; 204  : 	count = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 205  : 	EnvelopingFlag = DETACHED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+688], 0

; 206  : 	CertificateCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0

; 207  : 	RecipientCertCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 208  : 	RecipientCertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 209  : 	RecipientCertificateList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 210  : 	CurrentCertificate = NOT_INITIALIZED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -1

; 211  : 	PropertyCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 212  : 	Language = "EN";

	push	OFFSET FLAT:$SG204964
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 213  : 	m_hInstEnglish=	m_hInstFrench= m_hInstJapanese=m_hInstGerman=m_hInstSpanish=m_hInstHungarian=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3352], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3356], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3360], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3348], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3344], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3340], 0

; 214  : 	PfxPassword.pbData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+900], 0

; 215  : 	PfxPassword.cbData = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+904], 0

; 216  : 	PfxX509Cert = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], 0

; 217  : 	B64PfxDataPtr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+920], 0

; 218  : 	PfxCertDataBlob.cbData = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+928], 0

; 219  : 	PfxCertDataBlob.pbData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+924], 0

; 220  : 	PfxCertInfo = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+932], 0

; 221  : 	TimeStampOption = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+940], 0

; 222  : 	TimeStampFormat = TIME_RFC;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+944], 0

; 223  : 	TimeStampCritical = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+948], 0

; 224  : 	AddWindowImageFlag = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1796], 0

; 225  : 	DoDCompliance = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+952], 0

; 226  : 	PhysicalSigUsage = NO_PHYSICAL_SIG;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+956], 0

; 227  : 	CaptureSigOnce	 = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+960], 0

; 228  : 	SignatureCaptured = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+964], 0

; 229  : 	DetailedVerificationReportFlag = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1816], 1

; 230  : 	ExcludeSignerCertificateFlag = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1820], 0

; 231  : 	OverwriteFileFlag = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1824], 0

; 232  : 	UseHMAC = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1800], 0

; 233  : 	DetachedObjectCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+72], 0

; 234  : 	DetachedObjectList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], 0

; 235  : 	AttachedObjectCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 236  : 	AttachedObjectList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 237  : 	DecryptUsingPfxFileCert = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 238  : 	DecrytionPfxPassword.pbData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 239  : 	DecrytionPfxPassword.cbData = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 240  : 	XpathNamespaceCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 241  : 	XpathNamespaceList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 242  : 	camServerHost=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1896], 0

; 243  : 	camServerPort=7777;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+1900], 7777		; 00001e61H

; 244  : 	pCamClient=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1904], 0

; 245  : 	useCam = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1908], 0

; 246  : 	memset((void *)agencyId,0,MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1920				; 00000780H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 247  : 	strcpy((char *)agencyId, (const char *)"Infomosaic SecureXML");

	push	OFFSET FLAT:$SG204968
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1920				; 00000780H
	push	edx
	call	_strcpy
	add	esp, 8

; 248  : 	Base64EncodeXML = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2180], 0

; 249  : 	Base64DecodeXML = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2184], 0

; 250  : 	IncludeCamResponse = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2188], 0

; 251  : 	IncludeCRLInSignature = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2192], 0

; 252  : 	CamResponseCaSignedMsg = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2200], 0

; 253  : 	CamResponseAsciiCert = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2196], 0

; 254  : 	CamResponseCaSignedMsgSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2208], 0

; 255  : 	CamResponseAsciiCertSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2204], 0

; 256  : 	CertSerialNumberFormat = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3324], 0

; 257  : 	cVRecipient = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+112], 0

; 258  : 	cV = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0

; 259  : 	cVSigner = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0

; 260  : 	allowedCertIssuerNames=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3328], 0

; 261  : 	allowedCertIssuerCount=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3332], 0

; 262  : #ifdef WIN32
; 263  : 	pCrlCache = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3368], 0

; 264  : 	CRLCacheDbConnectionString = DEFAULT_CONN_STR;

	push	OFFSET FLAT:$SG204969
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 265  : 	crlCacheTimeoutInMinutes = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3376], 0

; 266  : #endif
; 267  : 	CanonicalizationMethod = WITH_COMMENTS;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3336], 1

; 268  : 	UsingNetscape = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3388], 0

; 269  : #ifdef WIN32
; 270  : 	nsCertStoreObj = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3380], 0

; 271  : 	FileAccessRestricted = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3364], 0

; 272  : #endif
; 273  : 	nsStorePassword = L"";

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3384], OFFSET FLAT:$SG204970

; 274  : 	HMACPassword.pbData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+908], 0

; 275  : 	HMACPassword.cbData = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+912], 0

; 276  : 	tmpFileList = new (TempFileList);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220391[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 35		; 00000023H
	cmp	DWORD PTR $T220391[ebp], 0
	je	SHORT $L220392
	mov	ecx, DWORD PTR $T220391[ebp]
	call	??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
	mov	DWORD PTR tv455[ebp], eax
	jmp	SHORT $L220393
$L220392:
	mov	DWORD PTR tv455[ebp], 0
$L220393:
	mov	edx, DWORD PTR tv455[ebp]
	mov	DWORD PTR $T220390[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220390[ebp]
	mov	DWORD PTR [eax+3400], ecx

; 277  : 	PhysicalSignatureB64Str = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3404], 0

; 278  : 	calculateDigestOnly = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3408], 0

; 279  : 	signerCertChain = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3412], 0

; 280  : 	signerCertChainSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3416], 0

; 281  : 	IgnoreIncompleteSignature = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3420], 0

; 282  : 	SigIndexToVerify = -1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3424], -1

; 283  : 	useOcsp = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1912], 0

; 284  : 	pOcspClient = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1916], 0

; 285  : 	IncludeOcspResponse = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2264], 0

; 286  : 	InclusiveNamespaceList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0

; 287  : 
; 288  : 	EnterLog;
; 289  : 	memset((void *)&CertVerifyParams,0, sizeof(VERIFICATION_PARAMS));

	push	68					; 00000044H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1828				; 00000724H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 290  : 	memset((void *)PhysicalSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 291  : 	memset((void *)CapturedSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 292  : 	memset((void *)szTempName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 293  : 
; 294  : #ifdef WIN32
; 295  : 	LPSTR commandLine = _strlwr(GetCommandLine());

	mov	esi, esp
	call	DWORD PTR __imp__GetCommandLineA@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__strlwr
	add	esp, 4
	mov	DWORD PTR _commandLine$[ebp], eax

; 296  : 	for (int i=0; i<RestrictedProgramCount;i++)

	mov	DWORD PTR _i$205416[ebp], 0
	jmp	SHORT $L205417
$L205418:
	mov	ecx, DWORD PTR _i$205416[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$205416[ebp], ecx
$L205417:
	cmp	DWORD PTR _i$205416[ebp], 4
	jae	SHORT $L205419

; 297  : 	{
; 298  : 		if (strstr(commandLine, RestrictedProgramList[i]) != NULL)

	mov	edx, DWORD PTR _i$205416[ebp]
	mov	eax, DWORD PTR _RestrictedProgramList[edx*4]
	push	eax
	mov	ecx, DWORD PTR _commandLine$[ebp]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L205420

; 299  : 		{
; 300  : 			FileAccessRestricted = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3364], 1

; 301  : 			break;

	jmp	SHORT $L205419
$L205420:

; 302  : 		}
; 303  : 	}

	jmp	SHORT $L205418
$L205419:

; 304  : //	AtlAxWinInit();
; 305  : #endif
; 306  : 
; 307  : 	CertVerifyParams.verificationOptions |= VERIFY_CRL_REC; // Always verify the certificate with the CRL included

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], ecx

; 308  : 															// current time is used for verification
; 309  : 
; 310  : 	for (int i=0; i < MAX_PROP_COUNT; i++)

	mov	DWORD PTR _i$205421[ebp], 0
	jmp	SHORT $L205422
$L205423:
	mov	eax, DWORD PTR _i$205421[ebp]
	add	eax, 1
	mov	DWORD PTR _i$205421[ebp], eax
$L205422:
	cmp	DWORD PTR _i$205421[ebp], 64		; 00000040H
	jge	SHORT $L205424

; 311  : 		Properties[i] = NULL;

	mov	ecx, DWORD PTR _i$205421[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+136], 0
	jmp	SHORT $L205423
$L205424:

; 312  : 
; 313  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 314  : #ifdef NSS
; 315  : 	SigHandle = axInit(NULL);

	push	0
	call	_axInit
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+692], eax

; 316  : 	if (!SigHandle) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+692], 0
	jne	SHORT $L205429

; 317  : 	   throw SigException("Library initialization failed");

	push	OFFSET FLAT:$SG205438
	lea	ecx, DWORD PTR $T220394[ebp]
	call	??0SigException@@QAE@PAD@Z		; SigException::SigException
	push	OFFSET FLAT:__TI2?AVSigException@@
	lea	eax, DWORD PTR $T220394[ebp]
	push	eax
	call	__CxxThrowException@8
$L205429:

; 318  : 	}	
; 319  : #else
; 320  : 	SigHandle = axInit();
; 321  : #endif
; 322  : 
; 323  : 	SigHandle->useFastC14N=TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	DWORD PTR [edx+44], 1

; 324  : 	ConfObj = CConfig(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220395[ebp]
	call	??0CConfig@@QAE@PAVCSignature@@@Z	; CConfig::CConfig
	mov	DWORD PTR tv1027[ebp], eax
	mov	ecx, DWORD PTR tv1027[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	??4CConfig@@QAEAAV0@ABV0@@Z
	lea	ecx, DWORD PTR $T220395[ebp]
	call	??1CConfig@@UAE@XZ			; CConfig::~CConfig

; 325  : 	StoreName = A2WBSTR((LPCSTR)"MY");

	push	-1
	push	OFFSET FLAT:$SG205441
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 326  : //	RecipientCertificateStore = A2WBSTR((LPCSTR)"addressbook");
; 327  : 
; 328  : 	HKEY hkey;
; 329  : 	LONG lret;
; 330  : 	const int BUF_SIZE = 400;

	mov	DWORD PTR _BUF_SIZE$[ebp], 400		; 00000190H

; 331  : 	TCHAR securexml_path[BUF_SIZE];
; 332  : 	DWORD buflen = BUF_SIZE;

	mov	DWORD PTR _buflen$[ebp], 400		; 00000190H

; 333  : 	DWORD junk, versionInfoSize;
; 334  : 	unsigned char *versionBuffer=NULL;

	mov	DWORD PTR _versionBuffer$[ebp], 0

; 335  : 	void *lplpBuffer;
; 336  : 	UINT puLen;
; 337  : 	VS_FIXEDFILEINFO *versionStruct;
; 338  : 	unsigned long versionMS, versionLS;
; 339  : 	char charVerLS[34], charVersionStr[70];
; 340  : 	const char *reg_entry = "CLSID\\{D300C133-A6F6-4FB4-A734-4865FBF5A3B1}\\InprocServer32";

	mov	DWORD PTR _reg_entry$[ebp], OFFSET FLAT:$SG205458

; 341  : #ifdef WIN32
; 342  : 	const char FILE_SEP = '\\';

	mov	BYTE PTR _FILE_SEP$[ebp], 92		; 0000005cH

; 343  : 	const char *FILE_SEP_STR = "\\";

	mov	DWORD PTR _FILE_SEP_STR$[ebp], OFFSET FLAT:$SG205461

; 344  : 	string license_file = "C:\\Program Files\\Infomosaic\\SecureXML\\SecureXMLLicense.xml";

	push	OFFSET FLAT:$SG205463
	lea	ecx, DWORD PTR _license_file$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 36		; 00000024H

; 345  : 	string config_file = "C:\\Program Files\\Infomosaic\\SecureXML\\SecureXML.config";

	push	OFFSET FLAT:$SG205465
	lea	ecx, DWORD PTR _config_file$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 37		; 00000025H

; 346  : #ifdef JNIBINDING
; 347  : 	LPTSTR lpFilePart=NULL;
; 348  : 	HMODULE hMod = GetModuleHandle("SignatureL.dll");
; 349  : 	DWORD retPathLen = GetModuleFileName(hMod,(LPTSTR)securexml_path,BUF_SIZE);
; 350  : 	//DWORD retPathLen = SearchPath(NULL,"SignatureL.dll",NULL,BUF_SIZE,(LPTSTR)securexml_path,&lpFilePart);
; 351  : 	if (retPathLen==0 || retPathLen > BUF_SIZE) {
; 352  : 		throw SigException("DLL not found");
; 353  : 	}
; 354  : #else
; 355  : 	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
; 356  : 		reg_entry, 0, KEY_QUERY_VALUE, &hkey) != ERROR_SUCCESS) {

	mov	esi, esp
	lea	edx, DWORD PTR _hkey$[ebp]
	push	edx
	push	1
	push	0
	mov	eax, DWORD PTR _reg_entry$[ebp]
	push	eax
	push	-2147483648				; 80000000H
	call	DWORD PTR __imp__RegOpenKeyExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L205469

; 357  : 		setError(SigHandle, DLL_NOT_REGISTERED);

	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 358  : 	} else {

	jmp	SHORT $L205470
$L205469:

; 359  : 		lret = RegQueryValueEx(hkey, NULL, NULL, NULL,
; 360  : 								(LPBYTE) securexml_path, &buflen);

	mov	esi, esp
	lea	eax, DWORD PTR _buflen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _securexml_path$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _hkey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegQueryValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lret$[ebp], eax

; 361  : 		if (lret != ERROR_SUCCESS)

	cmp	DWORD PTR _lret$[ebp], 0
	je	SHORT $L205470

; 362  : 			setError(SigHandle, DLL_NOT_REGISTERED);

	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8
$L205470:

; 363  : 	}
; 364  : 	RegCloseKey(hkey);

	mov	esi, esp
	mov	edx, DWORD PTR _hkey$[ebp]
	push	edx
	call	DWORD PTR __imp__RegCloseKey@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 365  : #endif
; 366  : 
; 367  : 	string dll_file = securexml_path;

	lea	eax, DWORD PTR _securexml_path$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H

; 368  : 	unsigned int pos = dll_file.rfind(FILE_SEP);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	92					; 0000005cH
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
	mov	DWORD PTR _pos$[ebp], eax

; 369  : 	if (pos != -1){

	cmp	DWORD PTR _pos$[ebp], -1
	je	$L205475

; 370  : 		// This looks at the registry entry for the actual install directory
; 371  : 		license_file = dll_file.substr(0, pos) + FILE_SEP_STR + SECUREXML_LICENSE_FILENAME;

	mov	edx, DWORD PTR _pos$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR $T220396[ebp]
	push	eax
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	DWORD PTR tv559[ebp], eax
	mov	ecx, DWORD PTR tv559[ebp]
	mov	DWORD PTR tv1032[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 39		; 00000027H
	mov	edx, DWORD PTR _FILE_SEP_STR$[ebp]
	push	edx
	mov	eax, DWORD PTR tv1032[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220397[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv533[ebp], eax
	mov	edx, DWORD PTR tv533[ebp]
	mov	DWORD PTR tv1034[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 40		; 00000028H
	push	OFFSET FLAT:$SG205486
	mov	eax, DWORD PTR tv1034[ebp]
	push	eax
	lea	ecx, DWORD PTR $T220398[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv529[ebp], eax
	mov	edx, DWORD PTR tv529[ebp]
	mov	DWORD PTR tv1036[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 41		; 00000029H
	mov	eax, DWORD PTR tv1036[ebp]
	push	eax
	lea	ecx, DWORD PTR _license_file$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 40		; 00000028H
	lea	ecx, DWORD PTR $T220398[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 39		; 00000027H
	lea	ecx, DWORD PTR $T220397[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	lea	ecx, DWORD PTR $T220396[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 372  : 		config_file = dll_file.substr(0, pos) + FILE_SEP_STR + SECUREXML_CONFIG_FILENAME;

	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR $T220399[ebp]
	push	edx
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	DWORD PTR tv1057[ebp], eax
	mov	eax, DWORD PTR tv1057[ebp]
	mov	DWORD PTR tv1038[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 42		; 0000002aH
	mov	ecx, DWORD PTR _FILE_SEP_STR$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv1038[ebp]
	push	edx
	lea	eax, DWORD PTR $T220400[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1058[ebp], eax
	mov	ecx, DWORD PTR tv1058[ebp]
	mov	DWORD PTR tv1040[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	push	OFFSET FLAT:$SG205490
	mov	edx, DWORD PTR tv1040[ebp]
	push	edx
	lea	eax, DWORD PTR $T220401[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1059[ebp], eax
	mov	ecx, DWORD PTR tv1059[ebp]
	mov	DWORD PTR tv1042[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 44		; 0000002cH
	mov	edx, DWORD PTR tv1042[ebp]
	push	edx
	lea	ecx, DWORD PTR _config_file$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 43		; 0000002bH
	lea	ecx, DWORD PTR $T220401[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 42		; 0000002aH
	lea	ecx, DWORD PTR $T220400[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	lea	ecx, DWORD PTR $T220399[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 373  : 		SecureXMLPath = A2WBSTR((char *)dll_file.substr(0, pos).c_str());

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR $T220402[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	DWORD PTR tv1060[ebp], eax
	mov	edx, DWORD PTR tv1060[ebp]
	mov	DWORD PTR tv1044[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 45		; 0000002dH
	push	-1
	mov	ecx, DWORD PTR tv1044[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	lea	ecx, DWORD PTR $T220402[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L205475:

; 374  : 	}
; 375  : /* Lets try to load the English dialog resource file */
; 376  : 	if(!m_hInstEnglish)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3340], 0
	jne	SHORT $L205493

; 377  : 		m_hInstEnglish = LoadLibraryW(_bstr_t("EnglishDiag.dll"));

	push	OFFSET FLAT:$SG205495
	lea	ecx, DWORD PTR $T220403[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv1046[ebp], eax
	mov	ecx, DWORD PTR tv1046[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3340], eax
	lea	ecx, DWORD PTR $T220403[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L205493:

; 378  : 	if (m_hInstEnglish == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3340], 0
	jne	$L205496

; 379  : 		m_hInstEnglish = LoadLibraryW(_bstr_t((dll_file.substr(0, pos) + FILE_SEP_STR + ENGLISH_RESOURCE_DLL).c_str()));

	mov	eax, DWORD PTR _pos$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR $T220405[ebp]
	push	ecx
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	DWORD PTR tv1061[ebp], eax
	mov	edx, DWORD PTR tv1061[ebp]
	mov	DWORD PTR tv1048[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 46		; 0000002eH
	mov	eax, DWORD PTR _FILE_SEP_STR$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1048[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220406[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1062[ebp], eax
	mov	eax, DWORD PTR tv1062[ebp]
	mov	DWORD PTR tv1050[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 47		; 0000002fH
	push	OFFSET FLAT:$SG205501
	mov	ecx, DWORD PTR tv1050[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220407[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv1063[ebp], eax
	mov	eax, DWORD PTR tv1063[ebp]
	mov	DWORD PTR tv1052[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 48		; 00000030H
	mov	ecx, DWORD PTR tv1052[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220404[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv1054[ebp], eax
	mov	ecx, DWORD PTR tv1054[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3340], eax
	lea	ecx, DWORD PTR $T220404[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 47		; 0000002fH
	lea	ecx, DWORD PTR $T220407[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 46		; 0000002eH
	lea	ecx, DWORD PTR $T220406[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	lea	ecx, DWORD PTR $T220405[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L205496:

; 380  : 	if (m_hInstEnglish != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3340], 0
	je	SHORT $L205502

; 381  : 		_Module.SetResourceInstance(m_hInstEnglish);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3340]
	push	ecx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 382  : 	else

	jmp	SHORT $L205503
$L205502:

; 383  : 		m_hInstEnglish = _Module.GetResourceInstance();

	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CComModule::GetResourceInstance
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3340], eax
$L205503:

; 384  : 
; 385  : #else
; 386  : 	const char FILE_SEP = '/';
; 387  : 	const char *FILE_SEP_STR = "/";
; 388  : 	string license_file = "/usr/local/infomosaic/SecureXMLLicense.xml";
; 389  : 	string config_file = "/usr/local/infomosaic/SecureXML.config";
; 390  : 	SecureXMLPath = A2WBSTR("/usr/local/infomosaic");
; 391  : #endif
; 392  : 
; 393  : #ifdef WIN32
; 394  : 	versionInfoSize = GetFileVersionInfoSize(
; 395  : 											 securexml_path,
; 396  : 											 (LPDWORD) &junk
; 397  : 											 );

	lea	eax, DWORD PTR _junk$[ebp]
	push	eax
	lea	ecx, DWORD PTR _securexml_path$[ebp]
	push	ecx
	call	_GetFileVersionInfoSizeA@8
	mov	DWORD PTR _versionInfoSize$[ebp], eax

; 398  : 
; 399  : 	if (versionInfoSize==0) {

	cmp	DWORD PTR _versionInfoSize$[ebp], 0
	jne	SHORT $L205505

; 400  : 		char buf[BUF_SIZE];
; 401  : 		sprintf(buf,"No version information found in DLL: %s",securexml_path);

	lea	edx, DWORD PTR _securexml_path$[ebp]
	push	edx
	push	OFFSET FLAT:$SG205507
	lea	eax, DWORD PTR _buf$205506[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 402  : 		throw SigException(buf);

	lea	ecx, DWORD PTR _buf$205506[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T220408[ebp]
	call	??0SigException@@QAE@PAD@Z		; SigException::SigException
	push	OFFSET FLAT:__TI2?AVSigException@@
	lea	edx, DWORD PTR $T220408[ebp]
	push	edx
	call	__CxxThrowException@8
$L205505:

; 403  : 	}
; 404  : 	versionBuffer = (unsigned char *)zMalloc(versionInfoSize);

	mov	eax, DWORD PTR _versionInfoSize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _versionBuffer$[ebp], eax

; 405  : 
; 406  : 	GetFileVersionInfo(	securexml_path,
; 407  : 						(DWORD) 0,
; 408  : 						versionInfoSize,
; 409  : 						(LPVOID) versionBuffer
; 410  : 						);

	mov	ecx, DWORD PTR _versionBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _versionInfoSize$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _securexml_path$[ebp]
	push	eax
	call	_GetFileVersionInfoA@16

; 411  : 
; 412  : 	VerQueryValue((const LPVOID) versionBuffer,
; 413  : 				  "\\",
; 414  : 				  &lplpBuffer,
; 415  : 				   &puLen
; 416  : 				);

	lea	ecx, DWORD PTR _puLen$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lplpBuffer$[ebp]
	push	edx
	push	OFFSET FLAT:$SG205514
	mov	eax, DWORD PTR _versionBuffer$[ebp]
	push	eax
	call	_VerQueryValueA@16

; 417  : 
; 418  : 	versionStruct = (VS_FIXEDFILEINFO *) lplpBuffer;

	mov	ecx, DWORD PTR _lplpBuffer$[ebp]
	mov	DWORD PTR _versionStruct$[ebp], ecx

; 419  : 
; 420  : 	versionMS = versionStruct->dwProductVersionMS;

	mov	edx, DWORD PTR _versionStruct$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _versionMS$[ebp], eax

; 421  : 	versionLS = versionStruct->dwProductVersionLS;

	mov	ecx, DWORD PTR _versionStruct$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _versionLS$[ebp], edx

; 422  : 
; 423  : 	sprintf(charVersionStr, "%d.%d", (versionMS >> 16), (versionMS & 0xFFFF));

	mov	eax, DWORD PTR _versionMS$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _versionMS$[ebp]
	shr	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:$SG205516
	lea	edx, DWORD PTR _charVersionStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 424  : 	sprintf(charVerLS, ".%d.%d", (versionLS >> 16), (versionLS & 0xFFFF));

	mov	eax, DWORD PTR _versionLS$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	mov	ecx, DWORD PTR _versionLS$[ebp]
	shr	ecx, 16					; 00000010H
	push	ecx
	push	OFFSET FLAT:$SG205517
	lea	edx, DWORD PTR _charVerLS$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 425  : 
; 426  : 	strcat(charVersionStr, (const char *)charVerLS);

	lea	eax, DWORD PTR _charVerLS$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charVersionStr$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 427  : 
; 428  : 	ReleaseVersion.m_str = A2WBSTR((LPCSTR)charVersionStr);

	push	-1
	lea	edx, DWORD PTR _charVersionStr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+896], eax

; 429  : 
; 430  :     //Before reading any strings out of the resource, we must first determine the code page
; 431  :     //and language.  The code to get this information follows.
; 432  :     VerQueryValue((const LPVOID) versionBuffer, "\\VarFileInfo\\Translation", &lplpBuffer, &puLen);

	lea	edx, DWORD PTR _puLen$[ebp]
	push	edx
	lea	eax, DWORD PTR _lplpBuffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG205521
	mov	ecx, DWORD PTR _versionBuffer$[ebp]
	push	ecx
	call	_VerQueryValueA@16

; 433  :     //Convert those four bytes into a 8-digit hexadecimal string.
; 434  : 	short *languageCode=NULL, *codePage=NULL;

	mov	DWORD PTR _languageCode$[ebp], 0
	mov	DWORD PTR _codePage$[ebp], 0

; 435  : 	languageCode = (short *)lplpBuffer;

	mov	edx, DWORD PTR _lplpBuffer$[ebp]
	mov	DWORD PTR _languageCode$[ebp], edx

; 436  : 	codePage = languageCode + 1;

	mov	eax, DWORD PTR _languageCode$[ebp]
	add	eax, 2
	mov	DWORD PTR _codePage$[ebp], eax

; 437  : 	sprintf(charVersionStr, "\\StringFileInfo\\%04x%04x\\PrivateBuild", *languageCode, *codePage);

	mov	ecx, DWORD PTR _codePage$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _languageCode$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:$SG205525
	lea	edx, DWORD PTR _charVersionStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 438  : 	DebugLog(charVersionStr);
; 439  : 
; 440  : 	VerQueryValue((const LPVOID) versionBuffer,
; 441  : 				  charVersionStr, // ==  \StringFileInfo\040904b0\PrivateBuild
; 442  : 				  &lplpBuffer,
; 443  : 				   &puLen
; 444  : 				);

	lea	eax, DWORD PTR _puLen$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lplpBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _charVersionStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _versionBuffer$[ebp]
	push	eax
	call	_VerQueryValueA@16

; 445  : 	lstrcpy((LPTSTR)charVersionStr, (LPCTSTR) lplpBuffer);

	mov	esi, esp
	mov	ecx, DWORD PTR _lplpBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _charVersionStr$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 446  : 	DebugLog(charVersionStr);
; 447  : 	LPSYSTEMTIME releaseTimeStamp = vbNowTimeToSystem((BYTE *)(char *)charVersionStr);

	lea	eax, DWORD PTR _charVersionStr$[ebp]
	push	eax
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	DWORD PTR _releaseTimeStamp$[ebp], eax

; 448  : 	CTime releaseTime(*releaseTimeStamp, -1);

	push	-1
	mov	ecx, DWORD PTR _releaseTimeStamp$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _releaseTime$[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 449  : 
; 450  : 	LicObj.releaseTime = releaseTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _releaseTime$[ebp]
	mov	DWORD PTR [edx+704], eax
	mov	ecx, DWORD PTR _releaseTime$[ebp+4]
	mov	DWORD PTR [edx+708], ecx

; 451  : 	
; 452  : 	zFree(versionBuffer);

	mov	edx, DWORD PTR _versionBuffer$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 453  : 	zFree(releaseTimeStamp);

	mov	eax, DWORD PTR _releaseTimeStamp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 454  : #else
; 455  : 	ReleaseVersion.m_str = A2WBSTR((LPCSTR)CSignature::SecureXMLVersion);
; 456  : 	LPSYSTEMTIME releaseTimeStamp = vbNowTimeToSystem((BYTE *)(char *)CSignature::ReleaseTime);
; 457  : 	LicObj.releaseYear = releaseTimeStamp->wYear;
; 458  : 	LicObj.releaseMonth = releaseTimeStamp->wMonth;
; 459  : 	LicObj.releaseDay	= releaseTimeStamp->wDay;
; 460  : #endif
; 461  : 
; 462  : 	// Check if the license file exists
; 463  : 	FILE *fHandle = fopen((char *)license_file.c_str(), "r");

	push	OFFSET FLAT:$SG205535
	lea	ecx, DWORD PTR _license_file$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fHandle$[ebp], eax

; 464  : 	if (fHandle == NULL)

	cmp	DWORD PTR _fHandle$[ebp], 0
	jne	SHORT $L205536

; 465  : 		fileStatus = FALSE;

	mov	DWORD PTR _fileStatus$[ebp], 0

; 466  : 	else

	jmp	SHORT $L205537
$L205536:

; 467  : 	{
; 468  : 		fileStatus = TRUE;

	mov	DWORD PTR _fileStatus$[ebp], 1

; 469  : 		fclose(fHandle);

	mov	ecx, DWORD PTR _fHandle$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4
$L205537:

; 470  : 	}
; 471  : 	fHandle = fopen((char *)config_file.c_str(), "r");

	push	OFFSET FLAT:$SG205539
	lea	ecx, DWORD PTR _config_file$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fHandle$[ebp], eax

; 472  : 	if (fHandle == NULL)

	cmp	DWORD PTR _fHandle$[ebp], 0
	jne	SHORT $L205540

; 473  : 		configfileStatus = FALSE;

	mov	DWORD PTR _configfileStatus$[ebp], 0

; 474  : 	else

	jmp	SHORT $L205541
$L205540:

; 475  : 	{
; 476  : 		configfileStatus = TRUE;

	mov	DWORD PTR _configfileStatus$[ebp], 1

; 477  : 		fclose(fHandle);

	mov	edx, DWORD PTR _fHandle$[ebp]
	push	edx
	call	_fclose
	add	esp, 4
$L205541:

; 478  : 	}
; 479  : 	if (fileStatus) // License file exists

	cmp	DWORD PTR _fileStatus$[ebp], 0
	je	SHORT $L205542

; 480  : 	{
; 481  : 		LicObj.setLicenseFile((char *)license_file.c_str());

	lea	ecx, DWORD PTR _license_file$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?setLicenseFile@CLicense@@QAEXPAD@Z	; CLicense::setLicenseFile

; 482  : 		if (LicObj.getLicenseDetails(SigHandle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ; CLicense::getLicenseDetails
	test	eax, eax
	je	SHORT $L205544

; 483  : 			LicObj.verifyLicense(SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ; CLicense::verifyLicense
$L205544:

; 484  : 	}
; 485  : 	else // License file not found

	jmp	SHORT $L205545
$L205542:

; 486  : 		setError(SigHandle, NO_SECUREXML_LIC);	

	push	46					; 0000002eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8
$L205545:

; 487  : 
; 488  : 	if (configfileStatus) // Config file exists

	cmp	DWORD PTR _configfileStatus$[ebp], 0
	je	SHORT $L205546

; 489  : 	{	
; 490  : 		ConfObj.setConfigFile((char *)config_file.c_str());

	lea	ecx, DWORD PTR _config_file$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	?setConfigFile@CConfig@@QAEXPAD@Z	; CConfig::setConfigFile

; 491  : 		ConfObj.getConfigDetails(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	?getConfigDetails@CConfig@@QAEHPAU_GLOBAL_SIG@@@Z ; CConfig::getConfigDetails
$L205546:

; 492  : 	}
; 493  : 
; 494  : 
; 495  : 	tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+696]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 496  : #ifdef NSS
; 497  : 	if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts, SigHandle )) != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	eax, DWORD PTR _numCerts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_axGetCertificateList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _certPtr$[ebp], eax
	cmp	DWORD PTR _certPtr$[ebp], 0
	je	SHORT $L205548

; 498  : #else
; 499  : 	if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts )) != NULL)
; 500  : #endif
; 501  : 	{
; 502  : 		CertificateCount = (long) numCerts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [edx+124], eax

; 503  : 		if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L205550

; 504  : 			cVSigner = certPtr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _certPtr$[ebp]
	mov	DWORD PTR [ecx+108], edx

; 505  : 		else

	jmp	SHORT $L205548
$L205550:

; 506  : 		{
; 507  : 			cVSigner = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0
$L205548:

; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	if ((allowedCertIssuerCount != 0) && (CertificateCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3332], 0
	je	$L205552
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	$L205552

; 512  : 	{
; 513  : 		int *indexArray = (int *)zMalloc(sizeof(int) * CertificateCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _indexArray$205553[ebp], eax

; 514  : 		int allowedCertCount = 0;

	mov	DWORD PTR _allowedCertCount$205556[ebp], 0

; 515  : 
; 516  : 		for (unsigned int i=0; i < allowedCertIssuerCount; i++)

	mov	DWORD PTR _i$205557[ebp], 0
	jmp	SHORT $L205558
$L205559:
	mov	edx, DWORD PTR _i$205557[ebp]
	add	edx, 1
	mov	DWORD PTR _i$205557[ebp], edx
$L205558:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$205557[ebp]
	cmp	ecx, DWORD PTR [eax+3332]
	jae	$L205560

; 517  : 		{
; 518  : 			for(int j=0; j < CertificateCount; j++)

	mov	DWORD PTR _j$205561[ebp], 0
	jmp	SHORT $L205562
$L205563:
	mov	edx, DWORD PTR _j$205561[ebp]
	add	edx, 1
	mov	DWORD PTR _j$205561[ebp], edx
$L205562:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$205561[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L205564

; 519  : 			{
; 520  : 				if (!strcmp((const char*)allowedCertIssuerNames[i], (const char *)cVSigner[j]->issuer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _j$205561[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 256				; 00000100H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3328]
	mov	edx, DWORD PTR _i$205557[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L205567

; 521  : 				{
; 522  : 					indexArray[allowedCertCount] = j;

	mov	ecx, DWORD PTR _allowedCertCount$205556[ebp]
	mov	edx, DWORD PTR _indexArray$205553[ebp]
	mov	eax, DWORD PTR _j$205561[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 523  : 					allowedCertCount++;

	mov	ecx, DWORD PTR _allowedCertCount$205556[ebp]
	add	ecx, 1
	mov	DWORD PTR _allowedCertCount$205556[ebp], ecx
$L205567:

; 524  : 				}
; 525  : 			}

	jmp	SHORT $L205563
$L205564:

; 526  : 		}

	jmp	$L205559
$L205560:

; 527  : 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$205568[ebp], 0
	jmp	SHORT $L205569
$L205570:
	mov	edx, DWORD PTR _i$205568[ebp]
	add	edx, 1
	mov	DWORD PTR _i$205568[ebp], edx
$L205569:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$205568[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	$L205571

; 528  : 		{
; 529  : 			BOOL certificateAllowed = FALSE;

	mov	DWORD PTR _certificateAllowed$205572[ebp], 0

; 530  : 			for (int j=0; j<allowedCertCount; j++)

	mov	DWORD PTR _j$205573[ebp], 0
	jmp	SHORT $L205574
$L205575:
	mov	edx, DWORD PTR _j$205573[ebp]
	add	edx, 1
	mov	DWORD PTR _j$205573[ebp], edx
$L205574:
	mov	eax, DWORD PTR _j$205573[ebp]
	cmp	eax, DWORD PTR _allowedCertCount$205556[ebp]
	jge	SHORT $L205576

; 531  : 			{
; 532  : 				if (indexArray[j] == i)

	mov	ecx, DWORD PTR _j$205573[ebp]
	mov	edx, DWORD PTR _indexArray$205553[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR _i$205568[ebp]
	jne	SHORT $L205577

; 533  : 				{
; 534  : 					certificateAllowed = TRUE;

	mov	DWORD PTR _certificateAllowed$205572[ebp], 1

; 535  : 					break;

	jmp	SHORT $L205576
$L205577:

; 536  : 				}
; 537  : 			}

	jmp	SHORT $L205575
$L205576:

; 538  : 			if (certificateAllowed == FALSE)

	cmp	DWORD PTR _certificateAllowed$205572[ebp], 0
	jne	SHORT $L205578

; 539  : 			{
; 540  : 				if (cVSigner[i]->certificate != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	eax, DWORD PTR _i$205568[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+2048], 0
	je	SHORT $L205579

; 541  : 					zFree(cVSigner[i]->certificate);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$205568[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+2048]
	push	eax
	call	_rFree
	add	esp, 4
$L205579:

; 542  : 				zFree(cVSigner[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	eax, DWORD PTR _i$205568[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L205578:

; 543  : 			}
; 544  : 		}

	jmp	$L205570
$L205571:

; 545  : 		CertificateCount = allowedCertCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _allowedCertCount$205556[ebp]
	mov	DWORD PTR [edx+124], eax

; 546  : 		cV = (PCERT_DESCR *)zMalloc(sizeof(PCERT_DESCR *) * CertificateCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 547  : 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$205582[ebp], 0
	jmp	SHORT $L205583
$L205584:
	mov	edx, DWORD PTR _i$205582[ebp]
	add	edx, 1
	mov	DWORD PTR _i$205582[ebp], edx
$L205583:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$205582[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L205585

; 548  : 			cV[i] = cVSigner[indexArray[i]];

	mov	edx, DWORD PTR _i$205582[ebp]
	mov	eax, DWORD PTR _indexArray$205553[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+104]
	mov	esi, DWORD PTR _i$205582[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+esi*4], eax
	jmp	SHORT $L205584
$L205585:

; 549  : 		zFree(cVSigner);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	call	_rFree
	add	esp, 4

; 550  : 		zFree(indexArray);

	mov	eax, DWORD PTR _indexArray$205553[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 551  : 	}
; 552  : 	else

	jmp	SHORT $L205586
$L205552:

; 553  : 		cV = cVSigner;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	DWORD PTR [ecx+104], eax
$L205586:

; 554  : #ifdef WIN32
; 555  : 	if (CertificateCount)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	SHORT $L205587

; 556  : 	{
; 557  : 		dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220410[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 49		; 00000031H
	cmp	DWORD PTR $T220410[ebp], 0
	je	SHORT $L220411
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220410[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv954[ebp], eax
	jmp	SHORT $L220412
$L220411:
	mov	DWORD PTR tv954[ebp], 0
$L220412:
	mov	ecx, DWORD PTR tv954[ebp]
	mov	DWORD PTR $T220409[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 38		; 00000026H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T220409[ebp]
	mov	DWORD PTR [edx+1808], eax
$L205587:

; 558  : //		dlg->Create(NULL);
; 559  : 	}
; 560  : #endif
; 561  : 	zFree(tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 562  : 
; 563  : #ifndef NSS
; 564  : 	tmpCharPtr = HeapW2A(RecipientCertificateStore.m_str);
; 565  : 	if ((certPtr = axGetRecipientCertificateList(tmpCharPtr, &numCerts )) != NULL)
; 566  : 	{
; 567  : 		RecipientCertCount = (long) numCerts;
; 568  : 		if (numCerts > 0)
; 569  : 			cVRecipient = certPtr;
; 570  : 		else
; 571  : 		{
; 572  : 			cVRecipient = NULL;
; 573  : 		}
; 574  : 	}
; 575  : #ifdef WIN32
; 576  : 	if (RecipientCertCount)
; 577  : 	{
; 578  : 		dlgRecipient = new CShowSelectCert(/*this,*/ tmpCharPtr, cVRecipient, RecipientCertCount);
; 579  : //		dlgRecipient->Create(NULL);
; 580  : 	}
; 581  : #endif
; 582  : 	zFree(tmpCharPtr);
; 583  : #endif
; 584  : 	// Initialize GDI+.
; 585  : //	GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
; 586  : 	ExitLog;
; 587  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 37		; 00000025H
	lea	ecx, DWORD PTR _dll_file$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 36		; 00000024H
	lea	ecx, DWORD PTR _config_file$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	lea	ecx, DWORD PTR _license_file$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
$L220389:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220485
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 1744				; 000006d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L220485:
	DD	14					; 0000000eH
	DD	$L220484
$L220484:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L220468
	DD	-84					; ffffffacH
	DD	4
	DD	$L220469
	DD	-500					; fffffe0cH
	DD	400					; 00000190H
	DD	$L220470
	DD	-512					; fffffe00H
	DD	4
	DD	$L220471
	DD	-524					; fffffdf4H
	DD	4
	DD	$L220472
	DD	-544					; fffffde0H
	DD	4
	DD	$L220473
	DD	-556					; fffffdd4H
	DD	4
	DD	$L220474
	DD	-612					; fffffd9cH
	DD	34					; 00000022H
	DD	$L220475
	DD	-692					; fffffd4cH
	DD	70					; 00000046H
	DD	$L220476
	DD	-740					; fffffd1cH
	DD	28					; 0000001cH
	DD	$L220477
	DD	-776					; fffffcf8H
	DD	28					; 0000001cH
	DD	$L220478
	DD	-812					; fffffcd4H
	DD	28					; 0000001cH
	DD	$L220479
	DD	-1224					; fffffb38H
	DD	400					; 00000190H
	DD	$L220480
	DD	-1252					; fffffb1cH
	DD	8
	DD	$L220481
$L220481:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L220480:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$L220479:
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L220478:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L220477:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L220476:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L220475:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	86					; 00000056H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	0
$L220474:
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L220473:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L220472:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$L220471:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L220470:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	95					; 0000005fH
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L220469:
	DB	104					; 00000068H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$L220468:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220413:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220414:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220415:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220416:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220417:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220418:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220419:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220420:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220421:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220422:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220423:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220424:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	jmp	??1CLicense@@UAE@XZ			; CLicense::~CLicense
$L220425:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	jmp	??1CConfig@@UAE@XZ			; CConfig::~CConfig
$L220426:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220427:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220428:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220429:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220430:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220431:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220432:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220433:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220434:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220435:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220436:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220437:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220438:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220439:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220440:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220441:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220442:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220443:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220444:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220445:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220446:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220447:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220448:
	mov	eax, DWORD PTR $T220391[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220450:
	lea	ecx, DWORD PTR _license_file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220451:
	lea	ecx, DWORD PTR _config_file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220452:
	lea	ecx, DWORD PTR _dll_file$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220453:
	lea	ecx, DWORD PTR $T220396[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220454:
	lea	ecx, DWORD PTR $T220397[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220455:
	lea	ecx, DWORD PTR $T220398[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220456:
	lea	ecx, DWORD PTR $T220399[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220457:
	lea	ecx, DWORD PTR $T220400[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220458:
	lea	ecx, DWORD PTR $T220401[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220459:
	lea	ecx, DWORD PTR $T220402[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220461:
	lea	ecx, DWORD PTR $T220405[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220462:
	lea	ecx, DWORD PTR $T220406[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220463:
	lea	ecx, DWORD PTR $T220407[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220465:
	mov	eax, DWORD PTR $T220410[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0CSignature@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T220467
	jmp	___CxxFrameHandler
text$x	ENDS
??0CSignature@@QAE@XZ ENDP				; CSignature::CSignature
PUBLIC	??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ ; `string'
EXTRN	__imp__SysAllocStringLen@8:NEAR
EXTRN	__imp__SysFreeString@4:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
xdata$x	SEGMENT
$T220498 DD	0ffffffffH
	DD	FLAT:$L220491
$T220493 DD	019930520H
	DD	01H
	DD	FLAT:$T220498
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT
??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ DB 'nResult == nC'
	DB	'onvertedLen', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT
$T220490 = -64						; size = 4
$T220489 = -60						; size = 4
_nResult$76113 = -56					; size = 4
_nAllocLen$ = -52					; size = 4
_nConvertedLen$ = -48					; size = 4
_str$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lp$ = 8						; size = 4
_nLen$ = 12						; size = 4
?A2WBSTR@@YAPAGPBDH@Z PROC NEAR				; A2WBSTR, COMDAT

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?A2WBSTR@@YAPAGPBDH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 776  : 	if (lp == NULL || nLen == 0)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $L76086
	cmp	DWORD PTR _nLen$[ebp], 0
	jne	SHORT $L76085
$L76086:

; 777  : 		return NULL;

	xor	eax, eax
	jmp	$L76084
$L76085:

; 778  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 779  : 	BSTR str = NULL;

	mov	DWORD PTR _str$[ebp], 0

; 780  : 	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
; 781  : 		nLen, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nConvertedLen$[ebp], eax

; 782  : 	int nAllocLen = nConvertedLen;

	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	mov	DWORD PTR _nAllocLen$[ebp], eax

; 783  : 	if (nLen == -1)

	cmp	DWORD PTR _nLen$[ebp], -1
	jne	SHORT $L76111

; 784  : 		nAllocLen -= 1;  // Don't allocate terminating '\0'

	mov	ecx, DWORD PTR _nAllocLen$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nAllocLen$[ebp], ecx
$L76111:

; 785  : 	str = ::SysAllocStringLen(NULL, nAllocLen);

	mov	esi, esp
	mov	edx, DWORD PTR _nAllocLen$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__SysAllocStringLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$[ebp], eax

; 786  : 
; 787  : 	if (str != NULL)

	cmp	DWORD PTR _str$[ebp], 0
	je	$L76112

; 788  : 	{
; 789  : 		int nResult;
; 790  : 		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);

	mov	esi, esp
	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _lp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nResult$76113[ebp], eax

; 791  : 		ATLASSERT(nResult == nConvertedLen);

	mov	edx, DWORD PTR _nResult$76113[ebp]
	cmp	edx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L220488
	push	OFFSET FLAT:??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
	push	0
	push	791					; 00000317H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L220488
	int	3
$L220488:

; 792  : 		if(nResult != nConvertedLen)

	mov	ecx, DWORD PTR _nResult$76113[ebp]
	cmp	ecx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L76112

; 793  : 		{
; 794  : 			SysFreeString(str);

	mov	esi, esp
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 795  : 			return NULL;

	mov	DWORD PTR $T220489[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220489[ebp]
	jmp	SHORT $L76084
$L76112:

; 796  : 		}
; 797  : 
; 798  : 	}
; 799  : 	return str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR $T220490[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T220490[ebp]
$L76084:

; 800  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220497
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L220497:
	DD	1
	DD	$L220496
$L220496:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L220494
$L220494:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220491:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?A2WBSTR@@YAPAGPBDH@Z:
	mov	eax, OFFSET FLAT:$T220493
	jmp	___CxxFrameHandler
text$x	ENDS
?A2WBSTR@@YAPAGPBDH@Z ENDP				; A2WBSTR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\config.h
;	COMDAT ?setConfigFile@CConfig@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_configFile$ = 8					; size = 4
?setConfigFile@CConfig@@QAEXPAD@Z PROC NEAR		; CConfig::setConfigFile, COMDAT
; _this$ = ecx

; 70   : 	void setConfigFile(char *configFile) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		ConfigFile = (char *)zMalloc(strlen(configFile) + 1);

	mov	eax, DWORD PTR _configFile$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 72   : 		strcpy(ConfigFile, configFile);

	mov	edx, DWORD PTR _configFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcpy
	add	esp, 8

; 73   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?setConfigFile@CConfig@@QAEXPAD@Z ENDP			; CConfig::setConfigFile
_TEXT	ENDS
PUBLIC	??_7CConfig@@6B@				; CConfig::`vftable'
PUBLIC	??_GCConfig@@UAEPAXI@Z				; CConfig::`scalar deleting destructor'
EXTRN	??_ECConfig@@UAEPAXI@Z:NEAR			; CConfig::`vector deleting destructor'
;	COMDAT ??_7CConfig@@6B@
CONST	SEGMENT
??_7CConfig@@6B@ DD FLAT:??_ECConfig@@UAEPAXI@Z		; CConfig::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0CConfig@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CConfig@@QAE@XZ PROC NEAR				; CConfig::CConfig, COMDAT
; _this$ = ecx

; 77   : 	CConfig()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CConfig@@6B@

; 78   : 	{
; 79   : 		ConfigFile = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 80   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CConfig@@QAE@XZ ENDP					; CConfig::CConfig
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GCConfig@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCConfig@@UAEPAXI@Z PROC NEAR			; CConfig::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CConfig@@UAE@XZ			; CConfig::~CConfig
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L187878
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L187878:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCConfig@@UAEPAXI@Z ENDP				; CConfig::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComBSTR@ATL@@QAE@XZ PROC NEAR			; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 545  : 	CComBSTR() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 	{
; 547  : 		m_str = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 548  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::CComBSTR
_TEXT	ENDS
EXTRN	__imp__SysAllocString@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
??4CComBSTR@ATL@@QAEAAV01@PBG@Z PROC NEAR		; ATL::CComBSTR::operator=, COMDAT
; _this$ = ecx

; 611  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		if (pSrc != m_str)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSrc$[ebp]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $L81672

; 613  : 		{
; 614  : 			::SysFreeString(m_str);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 615  : 			if (pSrc != NULL)

	cmp	DWORD PTR _pSrc$[ebp], 0
	je	SHORT $L81673

; 616  : 			{
; 617  : 				m_str = ::SysAllocString(pSrc);

	mov	esi, esp
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 618  : 				if (m_str == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L81674

; 619  : 					AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L81674:

; 620  : 			}
; 621  : 			else

	jmp	SHORT $L81672
$L81673:

; 622  : 				m_str = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0
$L81672:

; 623  : 		}
; 624  : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]
$L220510:

; 625  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CComBSTR@ATL@@QAEAAV01@PBG@Z ENDP			; ATL::CComBSTR::operator=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComBSTR@ATL@@QAE@XZ PROC NEAR			; ATL::CComBSTR::~CComBSTR, COMDAT
; _this$ = ecx

; 628  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 		::SysFreeString(m_str);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 630  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::~CComBSTR
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
??4CComBSTR@ATL@@QAEAAV01@PBD@Z PROC NEAR		; ATL::CComBSTR::operator=, COMDAT
; _this$ = ecx

; 1018 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1019 : 		::SysFreeString(m_str);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1020 : 		m_str = A2WBSTR(pSrc);

	push	-1
	mov	edx, DWORD PTR _pSrc$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1021 : 		if (m_str == NULL && pSrc != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L82005
	cmp	DWORD PTR _pSrc$[ebp], 0
	je	SHORT $L82005

; 1022 : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L82005:

; 1023 : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]
$L220514:

; 1024 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CComBSTR@ATL@@QAEAAV01@PBD@Z ENDP			; ATL::CComBSTR::operator=
_TEXT	ENDS
PUBLIC	?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CAtlBaseModule::SetResourceInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z PROC NEAR ; ATL::CComModule::SetResourceInstance, COMDAT
; _this$ = ecx

; 3981 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3982 : 		return _AtlBaseModule.SetResourceInstance(h);

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CAtlBaseModule::SetResourceInstance

; 3983 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ENDP ; ATL::CComModule::SetResourceInstance
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hInst$ = 8						; size = 4
?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z PROC NEAR ; ATL::CAtlBaseModule::SetResourceInstance, COMDAT
; _this$ = ecx

; 214  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 		return static_cast< HINSTANCE >(InterlockedExchangePointer((void**)&m_hInstResource, hInst));

	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 216  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ENDP ; ATL::CAtlBaseModule::SetResourceInstance
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CComModule::GetResourceInstance, COMDAT
; _this$ = ecx

; 3990 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3991 : 		return _AtlBaseModule.m_hInstResource;

	mov	eax, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+8

; 3992 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CComModule::GetResourceInstance
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
_TEXT	ENDS
;	COMDAT ?setLicenseFile@CLicense@@QAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_licFile$ = 8						; size = 4
?setLicenseFile@CLicense@@QAEXPAD@Z PROC NEAR		; CLicense::setLicenseFile, COMDAT
; _this$ = ecx

; 49   : 	void setLicenseFile(char *licFile) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		licenseFile = licFile;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _licFile$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 51   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLicenseFile@CLicense@@QAEXPAD@Z ENDP		; CLicense::setLicenseFile
_TEXT	ENDS
PUBLIC	??0Data_t@_bstr_t@@QAE@PBD@Z			; _bstr_t::Data_t::Data_t
PUBLIC	??2Data_t@_bstr_t@@SAPAXI@Z			; _bstr_t::Data_t::operator new
EXTRN	?_com_issue_error@@YGXJ@Z:NEAR			; _com_issue_error
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\comutil.h
xdata$x	SEGMENT
$T220533 DD	0ffffffffH
	DD	FLAT:$L220529
$T220531 DD	019930520H
	DD	01H
	DD	FLAT:$T220533
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
tv72 = -28						; size = 4
$T220526 = -24						; size = 4
$T220525 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0_bstr_t@@QAE@PBD@Z PROC NEAR				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 251  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	push	12					; 0000000cH
	call	??2Data_t@_bstr_t@@SAPAXI@Z		; _bstr_t::Data_t::operator new
	add	esp, 4
	mov	DWORD PTR $T220526[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T220526[ebp], 0
	je	SHORT $L220527
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220526[ebp]
	call	??0Data_t@_bstr_t@@QAE@PBD@Z		; _bstr_t::Data_t::Data_t
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $L220528
$L220527:
	mov	DWORD PTR tv72[ebp], 0
$L220528:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR $T220525[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T220525[ebp]
	mov	DWORD PTR [edx], eax

; 252  :     if (m_Data == NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L198336

; 253  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198336:

; 254  :     }
; 255  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220529:
	mov	eax, DWORD PTR $T220526[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0_bstr_t@@QAE@PBD@Z:
	mov	eax, OFFSET FLAT:$T220531
	jmp	___CxxFrameHandler
text$x	ENDS
??0_bstr_t@@QAE@PBD@Z ENDP				; _bstr_t::_bstr_t
PUBLIC	?_Free@_bstr_t@@AAEXXZ				; _bstr_t::_Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_bstr_t@@QAE@XZ PROC NEAR				; _bstr_t::~_bstr_t, COMDAT
; _this$ = ecx

; 281  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 282  :     _Free();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free@_bstr_t@@AAEXXZ			; _bstr_t::_Free

; 283  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_bstr_t@@QAE@XZ ENDP					; _bstr_t::~_bstr_t
_TEXT	ENDS
PUBLIC	?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ		; _bstr_t::Data_t::GetWString
; Function compile flags: /Odt /RTCsu
;	COMDAT ??B_bstr_t@@QBEPBGXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??B_bstr_t@@QBEPBGXZ PROC NEAR				; _bstr_t::operator unsigned short const *, COMDAT
; _this$ = ecx

; 404  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 405  :     return (m_Data != NULL) ? m_Data->GetWString() : NULL;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L220540
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ	; _bstr_t::Data_t::GetWString
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $L220541
$L220540:
	mov	DWORD PTR tv68[ebp], 0
$L220541:
	mov	eax, DWORD PTR tv68[ebp]

; 406  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??B_bstr_t@@QBEPBGXZ ENDP				; _bstr_t::operator unsigned short const *
_TEXT	ENDS
PUBLIC	?Release@Data_t@_bstr_t@@QAEKXZ			; _bstr_t::Data_t::Release
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Free@_bstr_t@@AAEXXZ PROC NEAR			; _bstr_t::_Free, COMDAT
; _this$ = ecx

; 568  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 569  :     if (m_Data != NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L198523

; 570  :         m_Data->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Release@Data_t@_bstr_t@@QAEKXZ		; _bstr_t::Data_t::Release

; 571  :         m_Data = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$L198523:

; 572  :     }
; 573  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Free@_bstr_t@@AAEXXZ ENDP				; _bstr_t::_Free
_TEXT	ENDS
EXTRN	?ConvertStringToBSTR@_com_util@@YGPAGPBD@Z:NEAR	; _com_util::ConvertStringToBSTR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??0Data_t@_bstr_t@@QAE@PBD@Z PROC NEAR			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 604  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 605  :     m_wstr = _com_util::ConvertStringToBSTR(s);

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?ConvertStringToBSTR@_com_util@@YGPAGPBD@Z ; _com_util::ConvertStringToBSTR
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0Data_t@_bstr_t@@QAE@PBD@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
PUBLIC	??_GData_t@_bstr_t@@AAEPAXI@Z			; _bstr_t::Data_t::`scalar deleting destructor'
EXTRN	__imp__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT
tv72 = -16						; size = 4
$T220549 = -12						; size = 4
$T220548 = -8						; size = 4
_this$ = -4						; size = 4
?Release@Data_t@_bstr_t@@QAEKXZ PROC NEAR		; _bstr_t::Data_t::Release, COMDAT
; _this$ = ecx

; 679  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 680  :     if (!InterlockedDecrement(reinterpret_cast<long*>(&m_RefCount))) {

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__InterlockedDecrement@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L198578

; 681  :         delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T220549[ebp], ecx
	mov	edx, DWORD PTR $T220549[ebp]
	mov	DWORD PTR $T220548[ebp], edx
	cmp	DWORD PTR $T220548[ebp], 0
	je	SHORT $L220550
	push	1
	mov	ecx, DWORD PTR $T220548[ebp]
	call	??_GData_t@_bstr_t@@AAEPAXI@Z
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $L220551
$L220550:
	mov	DWORD PTR tv72[ebp], 0
$L220551:

; 682  :         return 0;

	xor	eax, eax
	jmp	SHORT $L198576
$L198578:

; 683  :     }
; 684  : 
; 685  :     return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
$L198576:

; 686  : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Release@Data_t@_bstr_t@@QAEKXZ ENDP			; _bstr_t::Data_t::Release
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ PROC NEAR	; _bstr_t::Data_t::GetWString, COMDAT
; _this$ = ecx

; 725  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 726  :     return m_wstr;

	mov	eax, DWORD PTR _this$[ebp]

; 727  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ ENDP		; _bstr_t::Data_t::GetWString
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT
_sz$ = 8						; size = 4
??2Data_t@_bstr_t@@SAPAXI@Z PROC NEAR			; _bstr_t::Data_t::operator new, COMDAT

; 827  : {

	push	ebp
	mov	ebp, esp

; 828  :     return ::operator new(sz);

	mov	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 829  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??2Data_t@_bstr_t@@SAPAXI@Z ENDP			; _bstr_t::Data_t::operator new
_TEXT	ENDS
PUBLIC	??1Data_t@_bstr_t@@AAE@XZ			; _bstr_t::Data_t::~Data_t
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GData_t@_bstr_t@@AAEPAXI@Z PROC NEAR			; _bstr_t::Data_t::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Data_t@_bstr_t@@AAE@XZ		; _bstr_t::Data_t::~Data_t
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L201238
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L201238:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GData_t@_bstr_t@@AAEPAXI@Z ENDP			; _bstr_t::Data_t::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Free@Data_t@_bstr_t@@AAEXXZ			; _bstr_t::Data_t::_Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Data_t@_bstr_t@@AAE@XZ PROC NEAR			; _bstr_t::Data_t::~Data_t, COMDAT
; _this$ = ecx

; 835  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 836  :     _Free();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free@Data_t@_bstr_t@@AAEXXZ		; _bstr_t::Data_t::_Free

; 837  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1Data_t@_bstr_t@@AAE@XZ ENDP				; _bstr_t::Data_t::~Data_t
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT
$T220562 = -8						; size = 4
_this$ = -4						; size = 4
?_Free@Data_t@_bstr_t@@AAEXXZ PROC NEAR			; _bstr_t::Data_t::_Free, COMDAT
; _this$ = ecx

; 842  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 843  :     if (m_wstr != NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L198646

; 844  :         ::SysFreeString(m_wstr);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L198646:

; 845  :     }
; 846  : 
; 847  :     if (m_str != NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L198645

; 848  :         delete [] m_str;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR $T220562[ebp], edx
	mov	eax, DWORD PTR $T220562[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L198645:

; 849  :     }
; 850  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Free@Data_t@_bstr_t@@AAEXXZ ENDP			; _bstr_t::Data_t::_Free
_TEXT	ENDS
PUBLIC	?what@SigException@@UBEPBDXZ			; SigException::what
PUBLIC	??_7SigException@@6B@				; SigException::`vftable'
PUBLIC	??_GSigException@@UAEPAXI@Z			; SigException::`scalar deleting destructor'
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
EXTRN	??_ESigException@@UAEPAXI@Z:NEAR		; SigException::`vector deleting destructor'
;	COMDAT ??_7SigException@@6B@
; File c:\activex\xmlsign\signature.h
CONST	SEGMENT
??_7SigException@@6B@ DD FLAT:??_ESigException@@UAEPAXI@Z ; SigException::`vftable'
	DD	FLAT:?what@SigException@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0SigException@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_msg$ = 8						; size = 4
??0SigException@@QAE@PAD@Z PROC NEAR			; SigException::SigException, COMDAT
; _this$ = ecx

; 812  : 	SigException(char *msg = "Internal error occured.") {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@XZ			; exception::exception
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7SigException@@6B@

; 813  : 		err = msg;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _msg$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 814  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0SigException@@QAE@PAD@Z ENDP				; SigException::SigException
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?what@SigException@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@SigException@@UBEPBDXZ PROC NEAR			; SigException::what, COMDAT
; _this$ = ecx

; 815  : 	virtual const char *what() const throw() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 816  : 		return err;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 817  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@SigException@@UBEPBDXZ ENDP			; SigException::what
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GSigException@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSigException@@UAEPAXI@Z PROC NEAR			; SigException::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SigException@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L203964
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L203964:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSigException@@UAEPAXI@Z ENDP			; SigException::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1SigException@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SigException@@UAE@XZ PROC NEAR			; SigException::~SigException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@@UAE@XZ			; exception::~exception
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1SigException@@UAE@XZ ENDP				; SigException::~SigException
_TEXT	ENDS
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC NEAR ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $L92193
	push	OFFSET FLAT:??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $L92194
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L92194:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $L92192
$L92193:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L92196
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L92196:
	mov	eax, DWORD PTR _this$[ebp]
$L92192:
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC NEAR ; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
PUBLIC	??0ISignature@@QAE@XZ				; ISignature::ISignature
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ISignature@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ ENDP ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0IOleCommandTarget@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IOleCommandTarget@@QAE@XZ PROC NEAR			; IOleCommandTarget::IOleCommandTarget, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0IOleCommandTarget@@QAE@XZ ENDP			; IOleCommandTarget::IOleCommandTarget
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4CConfig@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CConfig@@QAEAAV0@ABV0@@Z PROC NEAR			; CConfig::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CConfig@@QAEAAV0@ABV0@@Z ENDP			; CConfig::operator=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0SigException@@QAE@ABV0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0SigException@@QAE@ABV0@@Z PROC NEAR			; SigException::SigException, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@ABV0@@Z		; exception::exception
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7SigException@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0SigException@@QAE@ABV0@@Z ENDP			; SigException::SigException
_TEXT	ENDS
PUBLIC	??0IDispatch@@QAE@XZ				; IDispatch::IDispatch
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0ISignature@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ISignature@@QAE@XZ PROC NEAR				; ISignature::ISignature, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IDispatch@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0ISignature@@QAE@XZ ENDP				; ISignature::ISignature
_TEXT	ENDS
PUBLIC	??1CSignature@@QAE@XZ				; CSignature::~CSignature
PUBLIC	?Empty@CSignature@@QAEXXZ			; CSignature::Empty
xdata$x	SEGMENT
$T220628 DD	0ffffffffH
	DD	FLAT:$L220590
	DD	00H
	DD	FLAT:$L220591
	DD	01H
	DD	FLAT:$L220592
	DD	02H
	DD	FLAT:$L220593
	DD	03H
	DD	FLAT:$L220594
	DD	04H
	DD	FLAT:$L220595
	DD	05H
	DD	FLAT:$L220596
	DD	06H
	DD	FLAT:$L220597
	DD	07H
	DD	FLAT:$L220598
	DD	08H
	DD	FLAT:$L220599
	DD	09H
	DD	FLAT:$L220600
	DD	0aH
	DD	FLAT:$L220601
	DD	0bH
	DD	FLAT:$L220602
	DD	0cH
	DD	FLAT:$L220603
	DD	0dH
	DD	FLAT:$L220604
	DD	0eH
	DD	FLAT:$L220605
	DD	0fH
	DD	FLAT:$L220606
	DD	010H
	DD	FLAT:$L220607
	DD	011H
	DD	FLAT:$L220608
	DD	012H
	DD	FLAT:$L220609
	DD	013H
	DD	FLAT:$L220610
	DD	014H
	DD	FLAT:$L220611
	DD	015H
	DD	FLAT:$L220612
	DD	016H
	DD	FLAT:$L220613
	DD	017H
	DD	FLAT:$L220614
	DD	018H
	DD	FLAT:$L220615
	DD	019H
	DD	FLAT:$L220616
	DD	01aH
	DD	FLAT:$L220617
	DD	01bH
	DD	FLAT:$L220618
	DD	01cH
	DD	FLAT:$L220619
	DD	01dH
	DD	FLAT:$L220620
	DD	01eH
	DD	FLAT:$L220621
	DD	01fH
	DD	FLAT:$L220622
	DD	020H
	DD	FLAT:$L220623
	DD	021H
	DD	FLAT:$L220624
$T220626 DD	019930520H
	DD	023H
	DD	FLAT:$T220628
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CSignature@@QAE@XZ PROC NEAR				; CSignature::~CSignature
; _this$ = ecx

; 590  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CSignature@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 34		; 00000022H

; 591  : 	EnterLog;
; 592  : 	Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Empty@CSignature@@QAEXXZ		; CSignature::Empty

; 593  : 
; 594  : //	GdiplusShutdown(gdiplusToken);
; 595  : #ifdef LOGGING
; 596  : 	DumpUnfreed();
; 597  : #endif
; 598  : 	ExitLog;
; 599  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	??1CConfig@@UAE@XZ			; CConfig::~CConfig
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	??1CLicense@@UAE@XZ			; CLicense::~CLicense
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
$L220590:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220591:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220592:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220593:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220594:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220595:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220596:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220597:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220598:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220599:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220600:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220601:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	jmp	??1CLicense@@UAE@XZ			; CLicense::~CLicense
$L220602:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	jmp	??1CConfig@@UAE@XZ			; CConfig::~CConfig
$L220603:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220604:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220605:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220606:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220607:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220608:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220609:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220610:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220611:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220612:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220613:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220614:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220615:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220616:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220617:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220618:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220619:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220620:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220621:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220622:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220623:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220624:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$??1CSignature@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T220626
	jmp	___CxxFrameHandler
text$x	ENDS
??1CSignature@@QAE@XZ ENDP				; CSignature::~CSignature
PUBLIC	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
PUBLIC	?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::end
PUBLIC	?FreeUriArr@CSignature@@QAEXXZ			; CSignature::FreeUriArr
PUBLIC	??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::`scalar deleting destructor'
PUBLIC	?Empty@CComBSTR@ATL@@QAEXXZ			; ATL::CComBSTR::Empty
PUBLIC	??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator!=
PUBLIC	??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*
PUBLIC	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
PUBLIC	??_GCCAMClient@@QAEPAXI@Z			; CCAMClient::`scalar deleting destructor'
EXTRN	__imp__DeleteFileA@4:NEAR
EXTRN	__imp__DeleteFileW@4:NEAR
EXTRN	__imp__CoUninitialize@0:NEAR
EXTRN	_axFree:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv563 = -604						; size = 4
tv310 = -600						; size = 4
tv300 = -596						; size = 4
tv134 = -592						; size = 4
$T220646 = -588						; size = 4
$T220645 = -584						; size = 4
$T220642 = -580						; size = 4
$T220641 = -576						; size = 4
$T220638 = -572						; size = 4
$T220637 = -568						; size = 4
$T220634 = -564						; size = 4
$T220633 = -560						; size = 4
$T220632 = -556						; size = 4
$T220631 = -552						; size = 4
_p$205698 = -548					; size = 4
_cbuf$205697 = -540					; size = 512
_j$205689 = -20						; size = 4
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?Empty@CSignature@@QAEXXZ PROC NEAR			; CSignature::Empty
; _this$ = ecx

; 602  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-604]
	mov	ecx, 151				; 00000097H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 603  : 	unsigned int i;
; 604  : 	EnterLog;
; 605  : 	EnvelopingFlag = DETACHED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+688], 0

; 606  : 	DigestMethod  = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+676], 1

; 607  : 
; 608  : 	if (tmpFileList != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3400], 0
	je	$L205611

; 609  : 	{
; 610  : 		for (TempFileList::iterator j = tmpFileList->begin(); j != tmpFileList->end(); j++)

	lea	eax, DWORD PTR _j$205689[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	jmp	SHORT $L205693
$L205694:
	push	0
	lea	edx, DWORD PTR $T220631[ebp]
	push	edx
	lea	ecx, DWORD PTR _j$205689[ebp]
	call	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
$L205693:
	lea	eax, DWORD PTR $T220632[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::end
	push	eax
	lea	ecx, DWORD PTR _j$205689[ebp]
	call	??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $L205695

; 611  : 		{
; 612  : 			if ((*j) != NULL)

	lea	ecx, DWORD PTR _j$205689[ebp]
	call	??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*
	cmp	DWORD PTR [eax], 0
	je	SHORT $L205696

; 613  : 			{
; 614  : 				char cbuf[512];				
; 615  : 				char *p = (char *)(*j)->fileName;

	lea	ecx, DWORD PTR _j$205689[ebp]
	call	??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _p$205698[ebp], eax

; 616  : 				if (p) {

	cmp	DWORD PTR _p$205698[ebp], 0
	je	SHORT $L205696

; 617  : 					strcpy(cbuf,p);

	mov	ecx, DWORD PTR _p$205698[ebp]
	push	ecx
	lea	edx, DWORD PTR _cbuf$205697[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 618  : #ifdef WIN32
; 619  : 					if (DeleteFile((LPCTSTR) cbuf) == 0)

	mov	esi, esp
	lea	eax, DWORD PTR _cbuf$205697[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L205696

; 620  : 					DeleteFileW((LPWSTR) cbuf);

	mov	esi, esp
	lea	ecx, DWORD PTR _cbuf$205697[ebp]
	push	ecx
	call	DWORD PTR __imp__DeleteFileW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L205696:

; 621  : #else
; 622  : 					if (unlink((LPCTSTR) cbuf) != 0)
; 623  : 					{
; 624  : 						unsigned char *afileName = HeapW2A((LPWSTR)cbuf);
; 625  : 						unlink(afileName);
; 626  : 						zFree(afileName);
; 627  : 					}
; 628  : #endif
; 629  : 				}
; 630  : 			}
; 631  : 		}

	jmp	$L205694
$L205695:

; 632  : 		delete tmpFileList;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3400]
	mov	DWORD PTR $T220634[ebp], eax
	mov	ecx, DWORD PTR $T220634[ebp]
	mov	DWORD PTR $T220633[ebp], ecx
	cmp	DWORD PTR $T220633[ebp], 0
	je	SHORT $L220635
	push	1
	mov	ecx, DWORD PTR $T220633[ebp]
	call	??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $L220636
$L220635:
	mov	DWORD PTR tv134[ebp], 0
$L220636:

; 633  : 		tmpFileList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3400], 0
$L205611:

; 634  : 	}
; 635  : 
; 636  : 	DocumentURI.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 637  : 	SignerCertificate.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 638  : 	SignatureID.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 639  : 	ReleaseVersion.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 640  : 	SignerSubject.Empty();		// Set after Verify

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 400				; 00000190H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 641  : 	CertIssuer.Empty();		// Set after Verify

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 404				; 00000194H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 642  : 	CertExpiry.Empty();		// Set after Verify

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 408				; 00000198H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 643  : 	CertSerialNumber.Empty();	// Set after Verify

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 412				; 0000019cH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 644  : 	DocumentURI.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 645  : 	RecipientCertificateStore.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 646  : 	SecureXMLPath.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 647  : 	StoreName.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 648  : 	TimeStampURL.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 649  : 	HMACKey.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 650  : #ifdef WiN32
; 651  : 	CRLCacheDbConnectionString.Empty();
; 652  : #endif
; 653  : 	ocspTextResponse.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 654  : 	ocspB64Response.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 655  : 	ocspRevocationTime.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 656  : 	ocspRevocationReason.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 657  : 
; 658  : 	if (signerCertChain != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	SHORT $L205706

; 659  : 		zFree(signerCertChain);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3412]
	push	edx
	call	_rFree
	add	esp, 4
$L205706:

; 660  : 
; 661  : 	if (PhysicalSignatureB64Str != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3404], 0
	je	SHORT $L205707

; 662  : 		zFree(PhysicalSignatureB64Str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3404]
	push	edx
	call	_rFree
	add	esp, 4
$L205707:

; 663  : 
; 664  : 	if (B64PfxDataPtr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+920], 0
	je	SHORT $L205708

; 665  : 		zFree(B64PfxDataPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	call	_rFree
	add	esp, 4
$L205708:

; 666  : 	
; 667  : 	if (PfxCertDataBlob.pbData != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+924], 0
	je	SHORT $L205709

; 668  : 		zFree(PfxCertDataBlob.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+924]
	push	edx
	call	_rFree
	add	esp, 4
$L205709:

; 669  : 	
; 670  : 	if (PfxPassword.pbData != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $L205710

; 671  : 		zFree(PfxPassword.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	push	edx
	call	_rFree
	add	esp, 4
$L205710:

; 672  : 	
; 673  : 	if (HMACPassword.pbData) 

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+908], 0
	je	SHORT $L205711

; 674  : 		zFree (HMACPassword.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	push	edx
	call	_rFree
	add	esp, 4
$L205711:

; 675  : 
; 676  : 	if (PfxX509Cert != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+916], 0
	je	SHORT $L205712

; 677  : 		zFree(PfxX509Cert);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+916]
	push	edx
	call	_rFree
	add	esp, 4
$L205712:

; 678  : 
; 679  : 	for (i=0; i<MAX_PROP_COUNT; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205713
$L205714:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L205713:
	cmp	DWORD PTR _i$[ebp], 64			; 00000040H
	jae	SHORT $L205715

; 680  : 	{
; 681  : 		if (Properties[i] != NULL)

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+136], 0
	je	SHORT $L205716

; 682  : 		{
; 683  : 			zFree(Properties[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	push	edx
	call	_rFree
	add	esp, 4

; 684  : 			Properties[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+136], 0
$L205716:

; 685  : 		}
; 686  : 	}

	jmp	SHORT $L205714
$L205715:

; 687  : 
; 688  : 	FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr

; 689  : 	if ((UsingNetscape == FALSE) || (allowedCertIssuerCount != 0))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 0
	je	SHORT $L205718
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3332], 0
	je	$L205717
$L205718:

; 690  : 		if (cV != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $L205717

; 691  : 		{
; 692  : 			for (i=0; i<(UINT)CertificateCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205721
$L205722:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L205721:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jae	SHORT $L205723

; 693  : 			{
; 694  : 				if (cV[i]->certificate != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L205724

; 695  : 					zFree(cV[i]->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	_rFree
	add	esp, 4
$L205724:

; 696  : 				zFree(cV[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 697  : 			}

	jmp	SHORT $L205722
$L205723:

; 698  : 			zFree(cV);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	_rFree
	add	esp, 4

; 699  : 			cV = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0
$L205717:

; 700  : 		}
; 701  : 	if (cVRecipient != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+112], 0
	je	$L205725

; 702  : 	{
; 703  : 		for (i=0; i<(UINT)RecipientCertCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205727
$L205728:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L205727:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+128]
	jae	SHORT $L205729

; 704  : 		{
; 705  : 			if (cVRecipient[i]->certificate != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+2048], 0
	je	SHORT $L205730

; 706  : 				zFree(cVRecipient[i]->certificate);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+2048]
	push	eax
	call	_rFree
	add	esp, 4
$L205730:

; 707  : 			zFree(cVRecipient[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 708  : 		}

	jmp	SHORT $L205728
$L205729:

; 709  : 		zFree(cVRecipient);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	call	_rFree
	add	esp, 4

; 710  : 		cVRecipient = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0
$L205725:

; 711  : 	}
; 712  : #ifdef WIN32
; 713  : 	if ((UsingNetscape == TRUE) && (nsCertStoreObj != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 1
	jne	SHORT $L205731
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3380], 0
	je	SHORT $L205731

; 714  : 	{
; 715  : 		nsCertStoreObj->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3380]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3380]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 716  : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$L205731:

; 717  : 	}
; 718  : #endif
; 719  : 	if ((useOcsp == TRUE) && (pOcspClient != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 1
	jne	SHORT $L205732
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 0
	je	SHORT $L205732

; 720  : 	{
; 721  : #ifdef WIN32
; 722  : 		pOcspClient->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1916]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1916]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 723  : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 724  : #endif
; 725  : 		pOcspClient = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1916], 0
$L205732:

; 726  : 	}
; 727  : 
; 728  : #ifdef WIN32
; 729  : 	//////////free show select cert obj
; 730  :    if (CertificateCount)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $L205733

; 731  : 	   delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T220638[ebp], ecx
	mov	edx, DWORD PTR $T220638[ebp]
	mov	DWORD PTR $T220637[ebp], edx
	cmp	DWORD PTR $T220637[ebp], 0
	je	SHORT $L220639
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T220637[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T220637[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv300[ebp], eax
	jmp	SHORT $L205733
$L220639:
	mov	DWORD PTR tv300[ebp], 0
$L205733:

; 732  :    if (RecipientCertCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $L205736

; 733  :        delete dlgRecipient;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1812]
	mov	DWORD PTR $T220642[ebp], edx
	mov	eax, DWORD PTR $T220642[ebp]
	mov	DWORD PTR $T220641[ebp], eax
	cmp	DWORD PTR $T220641[ebp], 0
	je	SHORT $L220643
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T220641[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T220641[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv310[ebp], eax
	jmp	SHORT $L205736
$L220643:
	mov	DWORD PTR tv310[ebp], 0
$L205736:

; 734  : #endif
; 735  : 
; 736  : 	if (CertVerifyParams.altCrlCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1836], 0
	je	SHORT $L205739

; 737  : 	{
; 738  : 		for (i=0; i < CertVerifyParams.altCrlCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205740
$L205741:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L205740:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+1836]
	jae	SHORT $L205742

; 739  : 			zFree(CertVerifyParams.crlAltUrl[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1832]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L205741
$L205742:

; 740  : 		zFree(CertVerifyParams.crlAltUrl);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1832]
	push	eax
	call	_rFree
	add	esp, 4
$L205739:

; 741  : 	}
; 742  : 	if ((CertVerifyParams.trustRootCertCount != 0) &&
; 743  : 		(CertVerifyParams.trustRootCerts != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1864], 0
	je	SHORT $L205743
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1860], 0
	je	SHORT $L205743

; 744  : 	{
; 745  : 		for (i=0; i < CertVerifyParams.trustRootCertCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205744
$L205745:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L205744:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+1864]
	jae	SHORT $L205746

; 746  : 			if (CertVerifyParams.trustRootCerts[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L205747

; 747  : 				zFree(CertVerifyParams.trustRootCerts[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L205747:

; 748  : 		zFree(CertVerifyParams.trustRootCerts);

	jmp	SHORT $L205745
$L205746:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1860]
	push	edx
	call	_rFree
	add	esp, 4
$L205743:

; 749  : 	}
; 750  : 	if ((CertVerifyParams.userPolicyCount != 0) && (CertVerifyParams.userPolicySet != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1852], 0
	je	$L205748
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1848], 0
	je	SHORT $L205748

; 751  : 	{
; 752  : 		for (i=0; i < CertVerifyParams.userPolicyCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205749
$L205750:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L205749:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1852]
	jae	SHORT $L205751

; 753  : 		{
; 754  : 			if (CertVerifyParams.userPolicySet[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1848]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L205752

; 755  : 				zFree(CertVerifyParams.userPolicySet[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1848]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L205752:

; 756  : 		}

	jmp	SHORT $L205750
$L205751:

; 757  : 		zFree(CertVerifyParams.userPolicySet);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1848]
	push	ecx
	call	_rFree
	add	esp, 4

; 758  : 		CertVerifyParams.userPolicyCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1852], 0

; 759  : 		CertVerifyParams.userPolicySet = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1848], 0
$L205748:

; 760  : 	}
; 761  : 	if ((CertVerifyParams.userPolicySetCountOut != 0) && 
; 762  : 		(CertVerifyParams.userPolicySetOut != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1880], 0
	je	$L205753
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1876], 0
	je	SHORT $L205753

; 763  : 	{
; 764  : 		for (i=0; i < CertVerifyParams.userPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205754
$L205755:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L205754:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+1880]
	jae	SHORT $L205756

; 765  : 		{
; 766  : 			if (CertVerifyParams.userPolicySetOut[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1876]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L205757

; 767  : 				zFree(CertVerifyParams.userPolicySetOut[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1876]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L205757:

; 768  : 		}

	jmp	SHORT $L205755
$L205756:

; 769  : 		zFree(CertVerifyParams.userPolicySetOut);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1876]
	push	edx
	call	_rFree
	add	esp, 4

; 770  : 		CertVerifyParams.userPolicySetCountOut = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1880], 0

; 771  : 		CertVerifyParams.userPolicySetOut = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1876], 0
$L205753:

; 772  : 	}
; 773  : 
; 774  : 	if ((CertVerifyParams.authPolicySetCountOut != 0) && 
; 775  : 		(CertVerifyParams.authPolicySetOut != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1872], 0
	je	$L205758
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1868], 0
	je	SHORT $L205758

; 776  : 	{
; 777  : 		for (i=0; i < CertVerifyParams.authPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205759
$L205760:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L205759:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+1872]
	jae	SHORT $L205761

; 778  : 		{
; 779  : 			if (CertVerifyParams.authPolicySetOut[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1868]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L205762

; 780  : 				zFree(CertVerifyParams.authPolicySetOut[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1868]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L205762:

; 781  : 		}

	jmp	SHORT $L205760
$L205761:

; 782  : 		zFree(CertVerifyParams.authPolicySetOut);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1868]
	push	eax
	call	_rFree
	add	esp, 4

; 783  : 		CertVerifyParams.authPolicySetCountOut = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1872], 0

; 784  : 		CertVerifyParams.authPolicySetOut = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1868], 0
$L205758:

; 785  : 	}
; 786  : 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 787  : 		(CertVerifyParams.usedCrlList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1888], 0
	je	$L205763
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1892], 0
	je	$L205763

; 788  : 	{
; 789  : 		for (i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205764
$L205765:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L205764:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+1888]
	jae	SHORT $L205766

; 790  : 		{
; 791  : 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L205767

; 792  : 			{
; 793  : 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 794  : 				CertVerifyParams.usedCrlList[i] = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L205767:

; 795  : 			}
; 796  : 		}

	jmp	SHORT $L205765
$L205766:

; 797  : 		zFree(CertVerifyParams.usedCrlList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	push	ecx
	call	_rFree
	add	esp, 4

; 798  : 		CertVerifyParams.usedCrlList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1892], 0

; 799  : 		CertVerifyParams.usedCrlCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1888], 0
$L205763:

; 800  : 	}
; 801  : 
; 802  : 	if ((RecipientCertificateCount != 0) && 
; 803  : 		(RecipientCertificateList != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $L205768
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $L205768

; 804  : 	{
; 805  : 		for (i=0; i < RecipientCertificateCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205769
$L205770:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L205769:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jae	SHORT $L205771

; 806  : 		{
; 807  : 			if (RecipientCertificateList[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L205772

; 808  : 				zFree(RecipientCertificateList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L205772:

; 809  : 		}

	jmp	SHORT $L205770
$L205771:

; 810  : 		zFree(RecipientCertificateList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_rFree
	add	esp, 4

; 811  : 		RecipientCertificateCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 812  : 		RecipientCertificateList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0
$L205768:

; 813  : 	}
; 814  : 
; 815  : 	if ((allowedCertIssuerCount != 0) && 
; 816  : 		(allowedCertIssuerNames != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3332], 0
	je	$L205773
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3328], 0
	je	SHORT $L205773

; 817  : 	{
; 818  : 		for (i=0; i < allowedCertIssuerCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205774
$L205775:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L205774:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+3332]
	jae	SHORT $L205776

; 819  : 		{
; 820  : 			if (allowedCertIssuerNames[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3328]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L205777

; 821  : 				SysFreeString(allowedCertIssuerNames[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3328]
	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L205777:

; 822  : 		}

	jmp	SHORT $L205775
$L205776:

; 823  : 		zFree(allowedCertIssuerNames);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3328]
	push	eax
	call	_rFree
	add	esp, 4

; 824  : 		allowedCertIssuerCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3332], 0

; 825  : 		allowedCertIssuerNames = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3328], 0
$L205773:

; 826  : 	}
; 827  : 
; 828  : 	if ((DetachedObjectCount != 0) && 
; 829  : 		(DetachedObjectList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $L205778
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $L205778

; 830  : 	{
; 831  : 		for (i=0; i < DetachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205779
$L205780:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L205779:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+72]
	jae	SHORT $L205781

; 832  : 		{
; 833  : 			if (DetachedObjectList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L205782

; 834  : 				zFree(DetachedObjectList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L205782:

; 835  : 		}

	jmp	SHORT $L205780
$L205781:

; 836  : 		zFree(DetachedObjectList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	_rFree
	add	esp, 4

; 837  : 		DetachedObjectCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+72], 0

; 838  : 		DetachedObjectList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0
$L205778:

; 839  : 	}
; 840  : 	if ((AttachedObjectCount != 0) && 
; 841  : 		(AttachedObjectList != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $L205783
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+84], 0
	je	SHORT $L205783

; 842  : 	{
; 843  : 		for (i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205784
$L205785:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L205784:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+80]
	jae	SHORT $L205786

; 844  : 		{
; 845  : 			if (AttachedObjectList[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L205787

; 846  : //				zFree(AttachedObjectList[i]);
; 847  : 				SysFreeString(AttachedObjectList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L205787:

; 848  : 		}

	jmp	SHORT $L205785
$L205786:

; 849  : 		zFree(AttachedObjectList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	_rFree
	add	esp, 4

; 850  : 		AttachedObjectCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 851  : 		AttachedObjectList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0
$L205783:

; 852  : 	}
; 853  : 	if ((XpathNamespaceCount != 0) && 
; 854  : 		(XpathNamespaceList != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 0
	je	SHORT $L205788
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+92], 0
	je	SHORT $L205788

; 855  : 	{
; 856  : 		for (i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205789
$L205790:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L205789:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	SHORT $L205791

; 857  : 		{
; 858  : 			if (XpathNamespaceList[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L205792

; 859  : 				zFree(XpathNamespaceList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L205792:

; 860  : 		}

	jmp	SHORT $L205790
$L205791:

; 861  : 		zFree(XpathNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	call	_rFree
	add	esp, 4

; 862  : 		XpathNamespaceCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 863  : 		XpathNamespaceList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0
$L205788:

; 864  : 	}
; 865  : 	if (pCamClient != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1904], 0
	je	SHORT $L205793

; 866  : 	{
; 867  : 		delete pCamClient;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1904]
	mov	DWORD PTR $T220646[ebp], edx
	mov	eax, DWORD PTR $T220646[ebp]
	mov	DWORD PTR $T220645[ebp], eax
	cmp	DWORD PTR $T220645[ebp], 0
	je	SHORT $L220647
	push	1
	mov	ecx, DWORD PTR $T220645[ebp]
	call	??_GCCAMClient@@QAEPAXI@Z
	mov	DWORD PTR tv563[ebp], eax
	jmp	SHORT $L220648
$L220647:
	mov	DWORD PTR tv563[ebp], 0
$L220648:

; 868  : 		pCamClient = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1904], 0
$L205793:

; 869  : 	}
; 870  : 	if (camServerHost != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1896], 0
	je	SHORT $L205796

; 871  : 		zFree(camServerHost);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1896]
	push	ecx
	call	_rFree
	add	esp, 4
$L205796:

; 872  : 	camServerHost = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1896], 0

; 873  : 	if (CamResponseCaSignedMsg != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2200], 0
	je	SHORT $L205797

; 874  : 		zFree(CamResponseCaSignedMsg);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2200]
	push	edx
	call	_rFree
	add	esp, 4
$L205797:

; 875  : 	if (CamResponseAsciiCert != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2196], 0
	je	SHORT $L205798

; 876  : 		zFree(CamResponseAsciiCert);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2196]
	push	edx
	call	_rFree
	add	esp, 4
$L205798:

; 877  : 	if (PfxCertInfo != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $L205799

; 878  : 		zFree(PfxCertInfo);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	call	_rFree
	add	esp, 4
$L205799:

; 879  : 	if (SigHandle != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+692], 0
	je	SHORT $L205800

; 880  : 	{
; 881  : 		axFree(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axFree
	add	esp, 4

; 882  : 		SigHandle = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+692], 0
$L205800:

; 883  : 	}
; 884  : 	if (InclusiveNamespaceList != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+96], 0
	je	SHORT $L205609

; 885  : 		zFree(InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	call	_rFree
	add	esp, 4
$L205609:

; 886  : 
; 887  : 	ExitLog;
; 888  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220653
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 604				; 0000025cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L220653:
	DD	2
	DD	$L220652
$L220652:
	DD	-20					; ffffffecH
	DD	4
	DD	$L220649
	DD	-540					; fffffde4H
	DD	512					; 00000200H
	DD	$L220650
$L220650:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$L220649:
	DB	106					; 0000006aH
	DB	0
?Empty@CSignature@@QAEXXZ ENDP				; CSignature::Empty
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ?Empty@CComBSTR@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Empty@CComBSTR@ATL@@QAEXXZ PROC NEAR			; ATL::CComBSTR::Empty, COMDAT
; _this$ = ecx

; 694  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 695  : 		::SysFreeString(m_str);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 696  : 		m_str = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 697  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Empty@CComBSTR@ATL@@QAEXXZ ENDP			; ATL::CComBSTR::Empty
_TEXT	ENDS
PUBLIC	??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::~list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::~list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L205806
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L205806:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEPAXI@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1CCAMClient@@QAE@XZ:NEAR			; CCAMClient::~CCAMClient
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCCAMClient@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCAMClient@@QAEPAXI@Z PROC NEAR			; CCAMClient::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CCAMClient@@QAE@XZ			; CCAMClient::~CCAMClient
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L205809
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L205809:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCCAMClient@@QAEPAXI@Z ENDP				; CCAMClient::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	ENDS
_TEXT	SEGMENT
_i$205814 = -8						; size = 4
_this$ = -4						; size = 4
?FreeUriArr@CSignature@@QAEXXZ PROC NEAR		; CSignature::FreeUriArr
; _this$ = ecx

; 891  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 892  : 	EnterLog;
; 893  : 	if (uriArr == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $L205813

; 894  : 		return;

	jmp	$L205812
$L205813:

; 895  : 	for (int i=0; i<totalUriCount; i++)

	mov	DWORD PTR _i$205814[ebp], 0
	jmp	SHORT $L205815
$L205816:
	mov	ecx, DWORD PTR _i$205814[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$205814[ebp], ecx
$L205815:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$205814[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	$L205817

; 896  : 	{
; 897  : 		if (uriArr[i]->sigId != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$205814[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L205818

; 898  : 		{
; 899  : 			zFree(uriArr[i]->sigId);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _i$205814[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4

; 900  : 			uriArr[i]->sigId=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$205814[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], 0
$L205818:

; 901  : 		}
; 902  : 		if (uriArr[i]->URI != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _i$205814[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L205819

; 903  : 		{
; 904  : 			zFree(uriArr[i]->URI);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$205814[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_rFree
	add	esp, 4

; 905  : 			uriArr[i]->URI = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _i$205814[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+4], 0
$L205819:

; 906  : 		}
; 907  : 		if (uriArr[i]->fullPath != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$205814[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L205820

; 908  : 		{
; 909  : 			zFree(uriArr[i]->fullPath);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$205814[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_rFree
	add	esp, 4

; 910  : 			uriArr[i]->fullPath = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _i$205814[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+8], 0
$L205820:

; 911  : 		}
; 912  : 		zFree(uriArr[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$205814[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 913  : 		uriArr[i] = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _i$205814[ebp]
	mov	DWORD PTR [eax+ecx*4], 0

; 914  : 	}

	jmp	$L205816
$L205817:

; 915  : 	zFree(uriArr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_rFree
	add	esp, 4

; 916  : 	uriArr=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 917  : 	if (failedUriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $L205821

; 918  : 		zFree(failedUriArr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_rFree
	add	esp, 4
$L205821:

; 919  : 	failedUriArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 920  : 	totalUriCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 921  : 	failedUriCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
$L205812:

; 922  : 	ExitLog;
; 923  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeUriArr@CSignature@@QAEXXZ ENDP			; CSignature::FreeUriArr
_TEXT	ENDS
PUBLIC	?AddRef@CSignature@@UAGKXZ			; CSignature::AddRef
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CSignature@@UAGKXZ PROC NEAR			; CSignature::AddRef

; 929  : {

	push	ebp
	mov	ebp, esp

; 930  : 	count++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], ecx

; 931  : 	return TRUE;

	mov	eax, 1

; 932  : }

	pop	ebp
	ret	4
?AddRef@CSignature@@UAGKXZ ENDP				; CSignature::AddRef
_TEXT	ENDS
PUBLIC	??_GCSignature@@QAEPAXI@Z			; CSignature::`scalar deleting destructor'
PUBLIC	?Release@CSignature@@UAGKXZ			; CSignature::Release
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv74 = -12						; size = 4
$T220664 = -8						; size = 4
$T220663 = -4						; size = 4
_this$ = 8						; size = 4
?Release@CSignature@@UAGKXZ PROC NEAR			; CSignature::Release

; 935  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 936  : 	count--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], ecx

; 937  : /*
; 938  : 	if (count == 0)
; 939  : 	{
; 940  : 		for (int i=0; i<CertificateCount; i++)
; 941  : 		{
; 942  : 			zFree(cV[i]);
; 943  : 		}
; 944  : 		zFree(cV);
; 945  : 		cV = NULL;
; 946  : 	}
; 947  : */
; 948  : 	if (count == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+116], 0
	jne	SHORT $L205828

; 949  : 		delete this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T220664[ebp], ecx
	mov	edx, DWORD PTR $T220664[ebp]
	mov	DWORD PTR $T220663[ebp], edx
	cmp	DWORD PTR $T220663[ebp], 0
	je	SHORT $L220665
	push	1
	mov	ecx, DWORD PTR $T220663[ebp]
	call	??_GCSignature@@QAEPAXI@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $L205828
$L220665:
	mov	DWORD PTR tv74[ebp], 0
$L205828:

; 950  :   return TRUE;

	mov	eax, 1

; 951  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@CSignature@@UAGKXZ ENDP			; CSignature::Release
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GCSignature@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSignature@@QAEPAXI@Z PROC NEAR			; CSignature::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CSignature@@QAE@XZ			; CSignature::~CSignature
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L205834
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L205834:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCSignature@@QAEPAXI@Z ENDP				; CSignature::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?get_EnvelopingFlag@CSignature@@UAGJPAF@Z	; CSignature::get_EnvelopingFlag
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_EnvelopingFlag@CSignature@@UAGJPAF@Z PROC NEAR	; CSignature::get_EnvelopingFlag

; 956  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 957  : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 958  : 	EnterLog;
; 959  : 
; 960  : 	*pVal = EnvelopingFlag;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+688]
	mov	WORD PTR [eax], dx

; 961  : 	ExitLog;
; 962  : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 963  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_EnvelopingFlag@CSignature@@UAGJPAF@Z ENDP		; CSignature::get_EnvelopingFlag
_TEXT	ENDS
PUBLIC	?put_EnvelopingFlag@CSignature@@UAGJF@Z		; CSignature::put_EnvelopingFlag
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 2
?put_EnvelopingFlag@CSignature@@UAGJF@Z PROC NEAR	; CSignature::put_EnvelopingFlag

; 966  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 967  : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 968  : 
; 969  : 	EnterLog;
; 970  : 	EnvelopingFlag = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _newVal$[ebp]
	mov	WORD PTR [eax+688], cx

; 971  : 	ExitLog;
; 972  : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 973  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?put_EnvelopingFlag@CSignature@@UAGJF@Z ENDP		; CSignature::put_EnvelopingFlag
_TEXT	ENDS
PUBLIC	?Copy@CComBSTR@ATL@@QBEPAGXZ			; ATL::CComBSTR::Copy
PUBLIC	?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z ; CSignature::get_RecipientCertificateStore
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_RecipientCertificateStore

; 976  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 977  : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 978  : 
; 979  : 	EnterLog;
; 980  : 	*pVal = RecipientCertificateStore.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 981  : 	ExitLog;
; 982  : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 983  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_RecipientCertificateStore
_TEXT	ENDS
EXTRN	__imp__SysStringByteLen@4:NEAR
EXTRN	__imp__SysAllocStringByteLen@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ?Copy@CComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Copy@CComBSTR@ATL@@QBEPAGXZ PROC NEAR			; ATL::CComBSTR::Copy, COMDAT
; _this$ = ecx

; 648  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 649  : 		if (m_str == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L81689

; 650  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L81688
$L81689:

; 651  : 		return ::SysAllocStringByteLen((char*)m_str, ::SysStringByteLen(m_str));

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$L81688:

; 652  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Copy@CComBSTR@ATL@@QBEPAGXZ ENDP			; ATL::CComBSTR::Copy
_TEXT	ENDS
PUBLIC	?Length@CComBSTR@ATL@@QBEIXZ			; ATL::CComBSTR::Length
PUBLIC	?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z ; CSignature::put_RecipientCertificateStore
EXTRN	_axGetRecipientCertificateList:NEAR
xdata$x	SEGMENT
$T220690 DD	0ffffffffH
	DD	FLAT:$L220683
$T220685 DD	019930520H
	DD	01H
	DD	FLAT:$T220690
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv169 = -80						; size = 4
tv155 = -76						; size = 4
$T220680 = -72						; size = 4
$T220679 = -68						; size = 4
$T220676 = -64						; size = 4
$T220675 = -60						; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_tmpCharPtr$ = -40					; size = 4
_hResult$ = -36						; size = 4
_certPtr$ = -32						; size = 4
_i$ = -28						; size = 4
_numCerts$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_RecipientCertificateStore

; 986  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 987  : 	int numCerts;
; 988  : 	UINT i;
; 989  : 	PCERT_DESCR *certPtr;
; 990  : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 991  : 	unsigned char *tmpCharPtr;
; 992  : 
; 993  : 	EnterLog;
; 994  : 
; 995  : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 996  : 
; 997  : 	RecipientCertificateStore.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 998  : 	RecipientCertificateStore = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 999  : 	if (RecipientCertificateStore.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L205867

; 1000 : 		RecipientCertificateStore = A2WBSTR((LPCSTR)"addressbook");

	push	-1
	push	OFFSET FLAT:$SG205869
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 684				; 000002acH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
$L205867:

; 1001 : 
; 1002 : 	if (cVRecipient != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+112], 0
	je	$L205870

; 1003 : 	{
; 1004 : 		for (i=0; i<(UINT)RecipientCertCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L205872
$L205873:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L205872:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+128]
	jae	SHORT $L205874

; 1005 : 		{
; 1006 : 			if (cVRecipient[i]->certificate)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L205875

; 1007 : 				zFree(cVRecipient[i]->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	_rFree
	add	esp, 4
$L205875:

; 1008 : 			zFree(cVRecipient[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 1009 : 		}

	jmp	SHORT $L205873
$L205874:

; 1010 : 		zFree(cVRecipient);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+112]
	push	ecx
	call	_rFree
	add	esp, 4

; 1011 : 		cVRecipient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0
$L205870:

; 1012 : 	}
; 1013 : 
; 1014 : 	tmpCharPtr = HeapW2A(RecipientCertificateStore.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+684]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 1015 : 	if ((certPtr = axGetRecipientCertificateList(tmpCharPtr, &numCerts )) != NULL)

	lea	edx, DWORD PTR _numCerts$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_axGetRecipientCertificateList
	add	esp, 8
	mov	DWORD PTR _certPtr$[ebp], eax
	cmp	DWORD PTR _certPtr$[ebp], 0
	je	SHORT $L205876

; 1016 : 	{
; 1017 : 		RecipientCertCount = (long) numCerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [ecx+128], edx

; 1018 : 		if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L205878

; 1019 : 			cVRecipient = certPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _certPtr$[ebp]
	mov	DWORD PTR [eax+112], ecx

; 1020 : 		else

	jmp	SHORT $L205876
$L205878:

; 1021 : 		{
; 1022 : 			cVRecipient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+112], 0
$L205876:

; 1023 : 		}
; 1024 : 	}
; 1025 : 
; 1026 : #ifdef WIN32
; 1027 : 	if (RecipientCertCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+128], 0
	je	$L205880

; 1028 : 	{
; 1029 : 		delete dlgRecipient;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1812]
	mov	DWORD PTR $T220676[ebp], edx
	mov	eax, DWORD PTR $T220676[ebp]
	mov	DWORD PTR $T220675[ebp], eax
	cmp	DWORD PTR $T220675[ebp], 0
	je	SHORT $L220677
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T220675[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T220675[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $L220678
$L220677:
	mov	DWORD PTR tv155[ebp], 0
$L220678:

; 1030 : 		dlgRecipient = new CShowSelectCert(/*this,*/ tmpCharPtr, cVRecipient, RecipientCertCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220680[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T220680[ebp], 0
	je	SHORT $L220681
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+128]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220680[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv169[ebp], eax
	jmp	SHORT $L220682
$L220681:
	mov	DWORD PTR tv169[ebp], 0
$L220682:
	mov	edx, DWORD PTR tv169[ebp]
	mov	DWORD PTR $T220679[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220679[ebp]
	mov	DWORD PTR [eax+1812], ecx
$L205880:

; 1031 : //		dlgRecipient->Create(NULL);
; 1032 : 	}
; 1033 : #endif
; 1034 : 	zFree(tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1035 : 	ExitLog;
; 1036 : 
; 1037 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1038 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220689
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220689:
	DD	1
	DD	$L220688
$L220688:
	DD	-20					; ffffffecH
	DD	4
	DD	$L220686
$L220686:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220683:
	mov	eax, DWORD PTR $T220680[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T220685
	jmp	___CxxFrameHandler
text$x	ENDS
?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_RecipientCertificateStore
EXTRN	__imp__SysStringLen@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ?Length@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?Length@CComBSTR@ATL@@QBEIXZ PROC NEAR			; ATL::CComBSTR::Length, COMDAT
; _this$ = ecx

; 632  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (m_str == NULL)? 0 : SysStringLen(m_str);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L220692
	mov	DWORD PTR tv67[ebp], 0
	jmp	SHORT $L220693
$L220692:
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SysStringLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv67[ebp], eax
$L220693:
	mov	eax, DWORD PTR tv67[ebp]

; 634  : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Length@CComBSTR@ATL@@QBEIXZ ENDP			; ATL::CComBSTR::Length
_TEXT	ENDS
PUBLIC	?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z	; CSignature::get_SignerCertificate
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
__lpa$ = -20						; size = 4
__lpw$ = -16						; size = 4
__acp$ = -12						; size = 4
__convert$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z PROC NEAR ; CSignature::get_SignerCertificate

; 1041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1042 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1043 : 
; 1044 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1045 : 	
; 1046 : 	EnterLog;
; 1047 : 	
; 1048 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L205894

; 1049 : 	{
; 1050 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1051 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L205891
$L205894:

; 1052 : 	}
; 1053 : 	if ((index >= signum) || (index < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L205897
	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L205896
$L205897:

; 1054 : 	{
; 1055 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1056 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L205891
$L205896:

; 1057 : 	}
; 1058 : 
; 1059 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1060 : 	*pVal = A2WBSTR((LPCSTR)sgArr[index]->signerCert->certificate);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 1061 : 	ExitLog;
; 1062 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L205891:

; 1063 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z ENDP	; CSignature::get_SignerCertificate
_TEXT	ENDS
PUBLIC	?put_SignerCertificate@CSignature@@UAGJJPAG@Z	; CSignature::put_SignerCertificate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_newVal$ = 16						; size = 4
?put_SignerCertificate@CSignature@@UAGJJPAG@Z PROC NEAR	; CSignature::put_SignerCertificate

; 1066 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1067 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1068 : 	EnterLog;
; 1069 : 
; 1070 : 	SignerCertificate = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 1071 : 
; 1072 : 	if (SignerCertificate.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 396				; 0000018cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L205911

; 1073 : 	{
; 1074 : 		CurrentCertificate = USE_BASE64_CERT;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], -3			; fffffffdH

; 1075 : 	}
; 1076 : 	else

	jmp	SHORT $L205912
$L205911:

; 1077 : 	{
; 1078 : 		CurrentCertificate = NOT_INITIALIZED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1
$L205912:

; 1079 : 	}
; 1080 : 	ExitLog;
; 1081 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1082 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?put_SignerCertificate@CSignature@@UAGJJPAG@Z ENDP	; CSignature::put_SignerCertificate
_TEXT	ENDS
PUBLIC	?get_SignatureID@CSignature@@UAGJJPAPAG@Z	; CSignature::get_SignatureID
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -20						; size = 4
__lpw$ = -16						; size = 4
__acp$ = -12						; size = 4
__convert$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_SignatureID@CSignature@@UAGJJPAPAG@Z PROC NEAR	; CSignature::get_SignatureID

; 1085 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1086 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1087 : 	EnterLog;
; 1088 : 
; 1089 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1090 : 
; 1091 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L205920

; 1092 : 	{
; 1093 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1094 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L205917
$L205920:

; 1095 : 	}
; 1096 : 	if ((index >= signum) || (index < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L205923
	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L205922
$L205923:

; 1097 : 	{
; 1098 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1099 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L205917
$L205922:

; 1100 : 	}
; 1101 : 
; 1102 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1103 : 	*pVal = A2WBSTR((LPCSTR)sgArr[index]->sigId);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 1104 : 	ExitLog;
; 1105 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L205917:

; 1106 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_SignatureID@CSignature@@UAGJJPAPAG@Z ENDP		; CSignature::get_SignatureID
_TEXT	ENDS
PUBLIC	?put_SignatureID@CSignature@@UAGJJPAG@Z		; CSignature::put_SignatureID
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_newVal$ = 16						; size = 4
?put_SignatureID@CSignature@@UAGJJPAG@Z PROC NEAR	; CSignature::put_SignatureID

; 1109 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1110 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1111 : 	EnterLog;
; 1112 : 
; 1113 : 	SignatureID = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 1114 : 	ExitLog;
; 1115 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1116 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?put_SignatureID@CSignature@@UAGJJPAG@Z ENDP		; CSignature::put_SignatureID
_TEXT	ENDS
PUBLIC	?get_Properties@CSignature@@UAGJJJPAPAG@Z	; CSignature::get_Properties
EXTRN	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z:NEAR		; UTF8ToUTF16LE
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_utf8ByteLen$ = -24					; size = 4
_utf16ByteLen$ = -12					; size = 4
_utf16CharStr$ = -4					; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_propIndex$ = 16					; size = 4
_pVal$ = 20						; size = 4
?get_Properties@CSignature@@UAGJJJPAPAG@Z PROC NEAR	; CSignature::get_Properties

; 1119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1120 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1121 : 
; 1122 : 	EnterLog;
; 1123 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L205943

; 1124 : 	{
; 1125 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1126 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L205942
$L205943:

; 1127 : 	}
; 1128 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L205946
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L205945
$L205946:

; 1129 : 	{
; 1130 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1131 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L205942
$L205945:

; 1132 : 	}
; 1133 : 	if (propIndex >= sgArr[sigIndex]->propNumber)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _propIndex$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jl	SHORT $L205948

; 1134 : 	{
; 1135 : 		setError(SigHandle, PROP_INDEX_ERROR);

	push	51					; 00000033H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 1136 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L205942
$L205948:

; 1137 : 	}
; 1138 : 	unsigned char *utf16CharStr=NULL;

	mov	DWORD PTR _utf16CharStr$[ebp], 0

; 1139 : 	int utf16ByteLen=0, utf8ByteLen=0;

	mov	DWORD PTR _utf16ByteLen$[ebp], 0
	mov	DWORD PTR _utf8ByteLen$[ebp], 0

; 1140 : 	utf8ByteLen = strlen((const char *)sgArr[sigIndex]->propArray[propIndex]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _propIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _utf8ByteLen$[ebp], eax

; 1141 : 	utf16ByteLen = utf8ByteLen * 2;

	mov	ecx, DWORD PTR _utf8ByteLen$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf16ByteLen$[ebp], ecx

; 1142 : 	utf16CharStr = (unsigned char *)zMalloc(utf16ByteLen);

	mov	edx, DWORD PTR _utf16ByteLen$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf16CharStr$[ebp], eax

; 1143 : 	UTF8ToUTF16LE(utf16CharStr, &utf16ByteLen, (const unsigned char*)sgArr[sigIndex]->propArray[propIndex], &utf8ByteLen);

	lea	eax, DWORD PTR _utf8ByteLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	lea	edx, DWORD PTR _utf16ByteLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _utf16CharStr$[ebp]
	push	eax
	call	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z		; UTF8ToUTF16LE
	add	esp, 16					; 00000010H

; 1144 : 	*pVal = SysAllocStringByteLen((LPCSTR)utf16CharStr, utf16ByteLen);

	mov	esi, esp
	mov	ecx, DWORD PTR _utf16ByteLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf16CharStr$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 1145 : 	zFree(utf16CharStr);

	mov	edx, DWORD PTR _utf16CharStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1146 : 	ExitLog;
; 1147 : 	return S_OK;

	xor	eax, eax
$L205942:

; 1148 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220703
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L220703:
	DD	2
	DD	$L220702
$L220702:
	DD	-12					; fffffff4H
	DD	4
	DD	$L220700
	DD	-24					; ffffffe8H
	DD	4
	DD	$L220701
$L220701:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L220700:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?get_Properties@CSignature@@UAGJJJPAPAG@Z ENDP		; CSignature::get_Properties
_TEXT	ENDS
PUBLIC	?put_Properties@CSignature@@UAGJJJPAG@Z		; CSignature::put_Properties
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_propIndex$ = 16					; size = 4
_newVal$ = 20						; size = 4
?put_Properties@CSignature@@UAGJJJPAG@Z PROC NEAR	; CSignature::put_Properties

; 1151 : {

	push	ebp
	mov	ebp, esp

; 1152 : 
; 1153 : 	EnterLog;
; 1154 : 
; 1155 : 	if (propIndex < MAX_PROP_COUNT)

	cmp	DWORD PTR _propIndex$[ebp], 64		; 00000040H
	jge	SHORT $L205964

; 1156 : 	{
; 1157 : 		if (Properties[propIndex] != NULL)

	mov	eax, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+136], 0
	je	SHORT $L205965

; 1158 : 		{
; 1159 : 			zFree(Properties[propIndex]);

	mov	edx, DWORD PTR _propIndex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+136]
	push	ecx
	call	_rFree
	add	esp, 4

; 1160 : 			Properties[propIndex] = NULL;

	mov	edx, DWORD PTR _propIndex$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx*4+136], 0
$L205965:

; 1161 : 		}
; 1162 : 			
; 1163 : 		Properties[propIndex] = HeapW2A(newVal);

	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	edx, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+edx*4+136], eax

; 1164 : 		PropertyCount = propIndex+1;

	mov	edx, DWORD PTR _propIndex$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 1165 : 	}
; 1166 : 	else

	jmp	SHORT $L205966
$L205964:

; 1167 : 	{
; 1168 : 		setError(SigHandle, PROP_INDEX_ERROR);

	push	51					; 00000033H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 1169 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L205963
$L205966:

; 1170 : 	}
; 1171 : 	ExitLog;
; 1172 : 	return S_OK;

	xor	eax, eax
$L205963:

; 1173 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	16					; 00000010H
?put_Properties@CSignature@@UAGJJJPAG@Z ENDP		; CSignature::put_Properties
_TEXT	ENDS
PUBLIC	?get_IncludeCamResponse@CSignature@@UAGJPAH@Z	; CSignature::get_IncludeCamResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_IncludeCamResponse@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_IncludeCamResponse

; 1176 : {

	push	ebp
	mov	ebp, esp

; 1177 : 	EnterLog;
; 1178 : 	*pVal = IncludeCamResponse;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2188]
	mov	DWORD PTR [eax], edx

; 1179 : 	ExitLog;
; 1180 : 	return S_OK;

	xor	eax, eax

; 1181 : }

	pop	ebp
	ret	8
?get_IncludeCamResponse@CSignature@@UAGJPAH@Z ENDP	; CSignature::get_IncludeCamResponse
_TEXT	ENDS
PUBLIC	?put_IncludeCamResponse@CSignature@@UAGJH@Z	; CSignature::put_IncludeCamResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_IncludeCamResponse@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_IncludeCamResponse

; 1183 : {

	push	ebp
	mov	ebp, esp

; 1184 : 	EnterLog;
; 1185 : 	IncludeCamResponse = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+2188], ecx

; 1186 : 	ExitLog;
; 1187 : 	return S_OK;

	xor	eax, eax

; 1188 : }

	pop	ebp
	ret	8
?put_IncludeCamResponse@CSignature@@UAGJH@Z ENDP	; CSignature::put_IncludeCamResponse
_TEXT	ENDS
PUBLIC	?get_Base64EncodeXML@CSignature@@UAGJPAH@Z	; CSignature::get_Base64EncodeXML
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_Base64EncodeXML@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_Base64EncodeXML

; 1192 : {

	push	ebp
	mov	ebp, esp

; 1193 : 	EnterLog;
; 1194 : 	*pVal = Base64EncodeXML;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2180]
	mov	DWORD PTR [eax], edx

; 1195 : 	ExitLog;
; 1196 : 	return S_OK;

	xor	eax, eax

; 1197 : }

	pop	ebp
	ret	8
?get_Base64EncodeXML@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_Base64EncodeXML
_TEXT	ENDS
PUBLIC	?put_Base64EncodeXML@CSignature@@UAGJH@Z	; CSignature::put_Base64EncodeXML
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_Base64EncodeXML@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_Base64EncodeXML

; 1199 : {

	push	ebp
	mov	ebp, esp

; 1200 : 	EnterLog;
; 1201 : 	Base64EncodeXML = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+2180], ecx

; 1202 : 	ExitLog;
; 1203 : 	return S_OK;

	xor	eax, eax

; 1204 : }

	pop	ebp
	ret	8
?put_Base64EncodeXML@CSignature@@UAGJH@Z ENDP		; CSignature::put_Base64EncodeXML
_TEXT	ENDS
PUBLIC	?get_Base64DecodeXML@CSignature@@UAGJPAH@Z	; CSignature::get_Base64DecodeXML
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_Base64DecodeXML@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_Base64DecodeXML

; 1207 : {

	push	ebp
	mov	ebp, esp

; 1208 : 	EnterLog;
; 1209 : 	*pVal = Base64DecodeXML;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2184]
	mov	DWORD PTR [eax], edx

; 1210 : 	ExitLog;
; 1211 : 	return S_OK;

	xor	eax, eax

; 1212 : }

	pop	ebp
	ret	8
?get_Base64DecodeXML@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_Base64DecodeXML
_TEXT	ENDS
PUBLIC	?put_Base64DecodeXML@CSignature@@UAGJH@Z	; CSignature::put_Base64DecodeXML
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_Base64DecodeXML@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_Base64DecodeXML

; 1214 : {

	push	ebp
	mov	ebp, esp

; 1215 : 	EnterLog;
; 1216 : 	Base64DecodeXML = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+2184], ecx

; 1217 : 	ExitLog;
; 1218 : 	return S_OK;

	xor	eax, eax

; 1219 : }

	pop	ebp
	ret	8
?put_Base64DecodeXML@CSignature@@UAGJH@Z ENDP		; CSignature::put_Base64DecodeXML
_TEXT	ENDS
PUBLIC	?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z	; CSignature::get_DocumentURI
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_utf8ByteLen$ = -48					; size = 4
_utf16ByteLen$ = -36					; size = 4
_utf16CharStr$ = -28					; size = 4
__lpa$ = -24						; size = 4
__lpw$ = -20						; size = 4
__acp$ = -16						; size = 4
__convert$ = -12					; size = 4
_maxUri$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_uriIndex$ = 16						; size = 4
_pVal$ = 20						; size = 4
?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z PROC NEAR	; CSignature::get_DocumentURI

; 1223 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1224 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1225 : 	int maxUri=0;

	mov	DWORD PTR _maxUri$[ebp], 0

; 1226 : 
; 1227 : 	EnterLog;
; 1228 : 
; 1229 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1230 : 
; 1231 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L206008

; 1232 : 	{
; 1233 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1234 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206004
$L206008:

; 1235 : 	}
; 1236 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L206011
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L206010
$L206011:

; 1237 : 	{
; 1238 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1239 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206004
$L206010:

; 1240 : 	}
; 1241 : 
; 1242 : 	maxUri = sgArr[sigIndex]->refNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _maxUri$[ebp], eax

; 1243 : 	
; 1244 : 	if ((uriIndex >= maxUri) || (uriIndex < 0))

	mov	ecx, DWORD PTR _uriIndex$[ebp]
	cmp	ecx, DWORD PTR _maxUri$[ebp]
	jge	SHORT $L206014
	cmp	DWORD PTR _uriIndex$[ebp], 0
	jge	SHORT $L206013
$L206014:

; 1245 : 	{
; 1246 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1247 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206004
$L206013:

; 1248 : 	}
; 1249 : 
; 1250 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1251 : 	unsigned char *utf16CharStr=NULL;

	mov	DWORD PTR _utf16CharStr$[ebp], 0

; 1252 : 	int utf16ByteLen=0, utf8ByteLen=0;

	mov	DWORD PTR _utf16ByteLen$[ebp], 0
	mov	DWORD PTR _utf8ByteLen$[ebp], 0

; 1253 : 	utf8ByteLen = strlen((const char *)sgArr[sigIndex]->refArray[uriIndex]->URI);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uriIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _utf8ByteLen$[ebp], eax

; 1254 : 	utf16ByteLen = utf8ByteLen * 2;

	mov	eax, DWORD PTR _utf8ByteLen$[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf16ByteLen$[ebp], eax

; 1255 : 	utf16CharStr = (unsigned char *)zMalloc(utf16ByteLen);

	mov	ecx, DWORD PTR _utf16ByteLen$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf16CharStr$[ebp], eax

; 1256 : 	UTF8ToUTF16LE(utf16CharStr, &utf16ByteLen, (const unsigned char*)sgArr[sigIndex]->refArray[uriIndex]->URI, &utf8ByteLen);

	lea	edx, DWORD PTR _utf8ByteLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _uriIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _utf16ByteLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _utf16CharStr$[ebp]
	push	eax
	call	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z		; UTF8ToUTF16LE
	add	esp, 16					; 00000010H

; 1257 : 	*pVal = SysAllocStringByteLen((LPCSTR)utf16CharStr, utf16ByteLen);

	mov	esi, esp
	mov	ecx, DWORD PTR _utf16ByteLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf16CharStr$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 1258 : 	zFree(utf16CharStr);

	mov	edx, DWORD PTR _utf16CharStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1259 : 
; 1260 : //	*pVal = A2WBSTR((LPCSTR)sgArr[sigIndex]->refArray[uriIndex]->URI);
; 1261 : 	ExitLog;
; 1262 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206004:

; 1263 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220715
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L220715:
	DD	2
	DD	$L220714
$L220714:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L220712
	DD	-48					; ffffffd0H
	DD	4
	DD	$L220713
$L220713:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L220712:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z ENDP		; CSignature::get_DocumentURI
_TEXT	ENDS
PUBLIC	?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z	; CSignature::get_DigestObjectStatus
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_maxUri$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_uriIndex$ = 16						; size = 4
_pVal$ = 20						; size = 4
?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z PROC NEAR ; CSignature::get_DigestObjectStatus

; 1266 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1267 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1268 : 	int maxUri=0;

	mov	DWORD PTR _maxUri$[ebp], 0

; 1269 : 
; 1270 : 	EnterLog;
; 1271 : 
; 1272 : 	*pVal = FALSE;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1273 : 
; 1274 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L206036

; 1275 : 	{
; 1276 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1277 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206032
$L206036:

; 1278 : 	}
; 1279 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L206039
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L206038
$L206039:

; 1280 : 	{
; 1281 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1282 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206032
$L206038:

; 1283 : 	}
; 1284 : 
; 1285 : 	maxUri = sgArr[sigIndex]->refNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _maxUri$[ebp], eax

; 1286 : 
; 1287 : 	if ((uriIndex >= maxUri) || (uriIndex < 0))

	mov	ecx, DWORD PTR _uriIndex$[ebp]
	cmp	ecx, DWORD PTR _maxUri$[ebp]
	jge	SHORT $L206042
	cmp	DWORD PTR _uriIndex$[ebp], 0
	jge	SHORT $L206041
$L206042:

; 1288 : 	{
; 1289 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1290 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206032
$L206041:

; 1291 : 	}
; 1292 : 
; 1293 : 	*pVal = sgArr[sigIndex]->refArray[uriIndex]->status;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uriIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax

; 1294 : 	ExitLog;
; 1295 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206032:

; 1296 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z ENDP	; CSignature::get_DigestObjectStatus
_TEXT	ENDS
PUBLIC	?get_Language@CSignature@@UAGJPAPAG@Z		; CSignature::get_Language
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_Language@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::get_Language

; 1299 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1300 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1301 : 	*pVal = Language.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 1302 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1303 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?get_Language@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_Language
_TEXT	ENDS
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?put_Language@CSignature@@UAGJPAG@Z		; CSignature::put_Language
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
xdata$x	SEGMENT
$T220825 DD	0ffffffffH
	DD	FLAT:$L220789
	DD	00H
	DD	FLAT:$L220790
	DD	01H
	DD	FLAT:$L220792
	DD	02H
	DD	FLAT:$L220793
	DD	01H
	DD	FLAT:$L220795
	DD	01H
	DD	FLAT:$L220797
	DD	05H
	DD	FLAT:$L220798
	DD	01H
	DD	FLAT:$L220800
	DD	01H
	DD	FLAT:$L220802
	DD	08H
	DD	FLAT:$L220803
	DD	01H
	DD	FLAT:$L220805
	DD	01H
	DD	FLAT:$L220807
	DD	0bH
	DD	FLAT:$L220808
	DD	01H
	DD	FLAT:$L220810
	DD	01H
	DD	FLAT:$L220812
	DD	0eH
	DD	FLAT:$L220813
	DD	01H
	DD	FLAT:$L220815
	DD	01H
	DD	FLAT:$L220816
$T220818 DD	019930520H
	DD	012H
	DD	FLAT:$T220825
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv591 = -724						; size = 4
tv570 = -720						; size = 4
tv555 = -716						; size = 4
tv534 = -712						; size = 4
tv669 = -708						; size = 4
tv667 = -704						; size = 4
tv684 = -700						; size = 4
tv665 = -696						; size = 4
tv683 = -692						; size = 4
tv663 = -688						; size = 4
tv474 = -684						; size = 4
tv453 = -680						; size = 4
tv660 = -676						; size = 4
tv658 = -672						; size = 4
tv681 = -668						; size = 4
tv656 = -664						; size = 4
tv680 = -660						; size = 4
tv654 = -656						; size = 4
tv393 = -652						; size = 4
tv372 = -648						; size = 4
tv651 = -644						; size = 4
tv649 = -640						; size = 4
tv678 = -636						; size = 4
tv647 = -632						; size = 4
tv677 = -628						; size = 4
tv645 = -624						; size = 4
tv280 = -620						; size = 4
tv259 = -616						; size = 4
tv642 = -612						; size = 4
tv640 = -608						; size = 4
tv675 = -604						; size = 4
tv606 = -600						; size = 4
tv674 = -596						; size = 4
tv604 = -592						; size = 4
tv199 = -588						; size = 4
tv178 = -584						; size = 4
tv601 = -580						; size = 4
tv599 = -576						; size = 4
tv69 = -572						; size = 4
tv597 = -568						; size = 4
tv83 = -564						; size = 4
tv595 = -560						; size = 4
$T220788 = -556						; size = 4
$T220785 = -552						; size = 4
$T220784 = -548						; size = 4
$T220781 = -544						; size = 4
$T220780 = -540						; size = 4
$T220777 = -536						; size = 4
$T220776 = -532						; size = 4
$T220773 = -528						; size = 4
$T220772 = -524						; size = 4
$T220771 = -520						; size = 28
$T220770 = -492						; size = 28
$T220769 = -464						; size = 4
$T220768 = -460						; size = 4
$T220765 = -456						; size = 4
$T220764 = -452						; size = 4
$T220761 = -448						; size = 4
$T220760 = -444						; size = 4
$T220759 = -440						; size = 28
$T220758 = -412						; size = 28
$T220757 = -384						; size = 4
$T220756 = -380						; size = 4
$T220753 = -376						; size = 4
$T220752 = -372						; size = 4
$T220749 = -368						; size = 4
$T220748 = -364						; size = 4
$T220747 = -360						; size = 28
$T220746 = -332						; size = 28
$T220745 = -304						; size = 4
$T220744 = -300						; size = 4
$T220741 = -296						; size = 4
$T220740 = -292						; size = 4
$T220737 = -288						; size = 4
$T220736 = -284						; size = 4
$T220735 = -280						; size = 28
$T220734 = -252						; size = 28
$T220733 = -224						; size = 4
$T220732 = -220						; size = 4
$T220729 = -216						; size = 4
$T220728 = -212						; size = 4
$T220725 = -208						; size = 4
$T220724 = -204						; size = 4
$T220723 = -200						; size = 28
$T220722 = -172						; size = 28
$T220721 = -144						; size = 4
$T220720 = -140						; size = 4
_tmpCharPtr$206188 = -136				; size = 4
_tmpCharPtr$206177 = -132				; size = 4
_tmpCharPtr$206155 = -128				; size = 4
_tmpCharPtr$206133 = -124				; size = 4
_tmpCharPtr$206111 = -120				; size = 4
_tmpCharPtr$206089 = -116				; size = 4
_lang$206065 = -108					; size = 28
_charLang$206064 = -76					; size = 4
_dllPath$ = -68						; size = 28
_charSecureXMLPath$ = -36				; size = 4
_FILE_SEP_STR$ = -32					; size = 4
_lcid$ = -28						; size = 4
_hInstLocal$ = -24					; size = 4
_hResult$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_Language@CSignature@@UAGJPAG@Z PROC NEAR		; CSignature::put_Language

; 1306 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_Language@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 712				; 000002c8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-724]
	mov	ecx, 178				; 000000b2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1307 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1308 : 	HINSTANCE	hInstLocal= NULL;

	mov	DWORD PTR _hInstLocal$[ebp], 0

; 1309 : 	LCID		lcid= NULL;

	mov	DWORD PTR _lcid$[ebp], 0

; 1310 : 	const char *FILE_SEP_STR = "\\";

	mov	DWORD PTR _FILE_SEP_STR$[ebp], OFFSET FLAT:$SG206059

; 1311 : 
; 1312 : #ifdef WIN32
; 1313 : 	unsigned char *charSecureXMLPath = HeapW2A(SecureXMLPath.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3392]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSecureXMLPath$[ebp], eax

; 1314 : 	string dllPath = (char *)charSecureXMLPath;

	mov	edx, DWORD PTR _charSecureXMLPath$[ebp]
	push	edx
	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1315 : 	zFree(charSecureXMLPath);

	mov	eax, DWORD PTR _charSecureXMLPath$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1316 : 
; 1317 : 	Language = newVal;

	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 1318 : 	if (Language.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3396				; 00000d44H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L206063

; 1319 : 	{
; 1320 : 		unsigned char *charLang = HeapW2A(newVal);

	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charLang$206064[ebp], eax

; 1321 : 		string lang = (char *)charLang;

	mov	eax, DWORD PTR _charLang$206064[ebp]
	push	eax
	lea	ecx, DWORD PTR _lang$206065[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1322 : 		zFree(charLang);

	mov	ecx, DWORD PTR _charLang$206064[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1323 : 		if (lang == "FR")

	push	OFFSET FLAT:$SG206075
	lea	edx, DWORD PTR _lang$206065[ebp]
	push	edx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$L206074

; 1324 : 		{
; 1325 : 			/* Lets try to load the English dialog resource file */
; 1326 : 			if(!m_hInstFrench)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3344], 0
	jne	SHORT $L206076

; 1327 : 				m_hInstFrench = LoadLibraryW(_bstr_t(FRENCH_RESOURCE_DLL));

	push	OFFSET FLAT:$SG206078
	lea	ecx, DWORD PTR $T220720[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv595[ebp], eax
	mov	ecx, DWORD PTR tv595[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3344], eax
	lea	ecx, DWORD PTR $T220720[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206076:

; 1328 : 			if (m_hInstFrench == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3344], 0
	jne	$L206079

; 1329 : 			{
; 1330 : 				if (dllPath.length() != 0)

	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L206079

; 1331 : 					m_hInstFrench = LoadLibraryW(_bstr_t((dllPath + FILE_SEP_STR + FRENCH_RESOURCE_DLL).c_str()));

	mov	ecx, DWORD PTR _FILE_SEP_STR$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dllPath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T220722[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv83[ebp], eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv597[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET FLAT:$SG206084
	mov	edx, DWORD PTR tv597[ebp]
	push	edx
	lea	eax, DWORD PTR $T220723[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv599[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv599[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220721[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv601[ebp], eax
	mov	ecx, DWORD PTR tv601[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3344], eax
	lea	ecx, DWORD PTR $T220721[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T220723[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T220722[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206079:

; 1332 : 			}
; 1333 : 			hInstLocal = m_hInstFrench;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3344]
	mov	DWORD PTR _hInstLocal$[ebp], ecx

; 1334 : 			if (hInstLocal != NULL)

	cmp	DWORD PTR _hInstLocal$[ebp], 0
	je	$L206085

; 1335 : 			{
; 1336 : 				_Module.SetResourceInstance(hInstLocal);

	mov	edx, DWORD PTR _hInstLocal$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1337 : 				if (dlg != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1808], 0
	je	SHORT $L206086

; 1338 : 				{
; 1339 : 					delete dlg;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1808]
	mov	DWORD PTR $T220725[ebp], edx
	mov	eax, DWORD PTR $T220725[ebp]
	mov	DWORD PTR $T220724[ebp], eax
	cmp	DWORD PTR $T220724[ebp], 0
	je	SHORT $L220726
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T220724[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T220724[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv178[ebp], eax
	jmp	SHORT $L220727
$L220726:
	mov	DWORD PTR tv178[ebp], 0
$L220727:

; 1340 : 					dlg = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 0
$L206086:

; 1341 : 				}
; 1342 : 				unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206089[ebp], eax

; 1343 : 				if (CertificateCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L206090

; 1344 : 				{
; 1345 : 					dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220729[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T220729[ebp], 0
	je	SHORT $L220730
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$206089[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220729[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv199[ebp], eax
	jmp	SHORT $L220731
$L220730:
	mov	DWORD PTR tv199[ebp], 0
$L220731:
	mov	eax, DWORD PTR tv199[ebp]
	mov	DWORD PTR $T220728[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T220728[ebp]
	mov	DWORD PTR [ecx+1808], edx
$L206090:

; 1346 : 				}
; 1347 : 				zFree(tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$206089[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206085:

; 1348 : 			}
; 1349 : 		}
; 1350 : 		else if (lang == "JP")

	jmp	$L206095
$L206074:
	push	OFFSET FLAT:$SG206097
	lea	ecx, DWORD PTR _lang$206065[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L206096

; 1351 : 			{
; 1352 : 				if(!m_hInstJapanese)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3348], 0
	jne	SHORT $L206098

; 1353 : 					m_hInstJapanese = LoadLibraryW(_bstr_t(JAPANESE_RESOURCE_DLL));

	push	OFFSET FLAT:$SG206100
	lea	ecx, DWORD PTR $T220732[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv604[ebp], eax
	mov	ecx, DWORD PTR tv604[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3348], eax
	lea	ecx, DWORD PTR $T220732[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206098:

; 1354 : 				if (m_hInstJapanese == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3348], 0
	jne	$L206101

; 1355 : 				{
; 1356 : 					if (dllPath.length() != 0)

	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L206101

; 1357 : 						m_hInstJapanese = LoadLibraryW(_bstr_t((dllPath + FILE_SEP_STR + JAPANESE_RESOURCE_DLL).c_str()));

	mov	eax, DWORD PTR _FILE_SEP_STR$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllPath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220734[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv674[ebp], eax
	mov	eax, DWORD PTR tv674[ebp]
	mov	DWORD PTR tv606[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET FLAT:$SG206106
	mov	ecx, DWORD PTR tv606[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220735[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv675[ebp], eax
	mov	eax, DWORD PTR tv675[ebp]
	mov	DWORD PTR tv640[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR tv640[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220733[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv642[ebp], eax
	mov	ecx, DWORD PTR tv642[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3348], eax
	lea	ecx, DWORD PTR $T220733[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T220735[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T220734[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206101:

; 1358 : 				}
; 1359 : 				hInstLocal = m_hInstJapanese;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3348]
	mov	DWORD PTR _hInstLocal$[ebp], eax

; 1360 : 				if (hInstLocal != NULL)

	cmp	DWORD PTR _hInstLocal$[ebp], 0
	je	$L206107

; 1361 : 				{
; 1362 : 					_Module.SetResourceInstance(hInstLocal);

	mov	ecx, DWORD PTR _hInstLocal$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1363 : 					if (dlg != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 0
	je	SHORT $L206108

; 1364 : 					{
; 1365 : 						delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T220737[ebp], ecx
	mov	edx, DWORD PTR $T220737[ebp]
	mov	DWORD PTR $T220736[ebp], edx
	cmp	DWORD PTR $T220736[ebp], 0
	je	SHORT $L220738
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T220736[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T220736[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv259[ebp], eax
	jmp	SHORT $L220739
$L220738:
	mov	DWORD PTR tv259[ebp], 0
$L220739:

; 1366 : 						dlg = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 0
$L206108:

; 1367 : 					}
; 1368 : 					unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206111[ebp], eax

; 1369 : 					if (CertificateCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L206112

; 1370 : 					{
; 1371 : 						dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220741[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	cmp	DWORD PTR $T220741[ebp], 0
	je	SHORT $L220742
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$206111[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220741[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $L220743
$L220742:
	mov	DWORD PTR tv280[ebp], 0
$L220743:
	mov	eax, DWORD PTR tv280[ebp]
	mov	DWORD PTR $T220740[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T220740[ebp]
	mov	DWORD PTR [ecx+1808], edx
$L206112:

; 1372 : 					}
; 1373 : 					zFree(tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$206111[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206107:

; 1374 : 				}
; 1375 : 			}
; 1376 : 		else if (lang == "HU")

	jmp	$L206095
$L206096:
	push	OFFSET FLAT:$SG206119
	lea	ecx, DWORD PTR _lang$206065[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L206118

; 1377 : 			{
; 1378 : 				if(!m_hInstHungarian)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3352], 0
	jne	SHORT $L206120

; 1379 : 					m_hInstHungarian = LoadLibraryW(_bstr_t(HUNGARIAN_RESOURCE_DLL));

	push	OFFSET FLAT:$SG206122
	lea	ecx, DWORD PTR $T220744[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv645[ebp], eax
	mov	ecx, DWORD PTR tv645[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3352], eax
	lea	ecx, DWORD PTR $T220744[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206120:

; 1380 : 				if (m_hInstHungarian == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3352], 0
	jne	$L206123

; 1381 : 				{
; 1382 : 					if (dllPath.length() != 0)

	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L206123

; 1383 : 						m_hInstHungarian = LoadLibraryW(_bstr_t((dllPath + FILE_SEP_STR + HUNGARIAN_RESOURCE_DLL).c_str()));

	mov	eax, DWORD PTR _FILE_SEP_STR$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllPath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220746[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv677[ebp], eax
	mov	eax, DWORD PTR tv677[ebp]
	mov	DWORD PTR tv647[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	OFFSET FLAT:$SG206128
	mov	ecx, DWORD PTR tv647[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220747[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv678[ebp], eax
	mov	eax, DWORD PTR tv678[ebp]
	mov	DWORD PTR tv649[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR tv649[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220745[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv651[ebp], eax
	mov	ecx, DWORD PTR tv651[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3352], eax
	lea	ecx, DWORD PTR $T220745[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T220747[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T220746[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206123:

; 1384 : 				}
; 1385 : 				hInstLocal = m_hInstHungarian;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3352]
	mov	DWORD PTR _hInstLocal$[ebp], eax

; 1386 : 				if (hInstLocal != NULL)

	cmp	DWORD PTR _hInstLocal$[ebp], 0
	je	$L206129

; 1387 : 				{
; 1388 : 					_Module.SetResourceInstance(hInstLocal);

	mov	ecx, DWORD PTR _hInstLocal$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1389 : 					if (dlg != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 0
	je	SHORT $L206130

; 1390 : 					{
; 1391 : 						delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T220749[ebp], ecx
	mov	edx, DWORD PTR $T220749[ebp]
	mov	DWORD PTR $T220748[ebp], edx
	cmp	DWORD PTR $T220748[ebp], 0
	je	SHORT $L220750
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T220748[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T220748[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv372[ebp], eax
	jmp	SHORT $L220751
$L220750:
	mov	DWORD PTR tv372[ebp], 0
$L220751:

; 1392 : 						dlg = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 0
$L206130:

; 1393 : 					}
; 1394 : 					unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206133[ebp], eax

; 1395 : 					if (CertificateCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L206134

; 1396 : 					{
; 1397 : 						dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220753[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	cmp	DWORD PTR $T220753[ebp], 0
	je	SHORT $L220754
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$206133[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220753[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv393[ebp], eax
	jmp	SHORT $L220755
$L220754:
	mov	DWORD PTR tv393[ebp], 0
$L220755:
	mov	eax, DWORD PTR tv393[ebp]
	mov	DWORD PTR $T220752[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T220752[ebp]
	mov	DWORD PTR [ecx+1808], edx
$L206134:

; 1398 : 					}
; 1399 : 					zFree(tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$206133[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206129:

; 1400 : 				}
; 1401 : 			}
; 1402 : 		else if (lang == "ES")

	jmp	$L206095
$L206118:
	push	OFFSET FLAT:$SG206141
	lea	ecx, DWORD PTR _lang$206065[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L206140

; 1403 : 			{
; 1404 : 				if(!m_hInstSpanish)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3356], 0
	jne	SHORT $L206142

; 1405 : 					m_hInstSpanish = LoadLibraryW(_bstr_t(SPANISH_RESOURCE_DLL));

	push	OFFSET FLAT:$SG206144
	lea	ecx, DWORD PTR $T220756[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv654[ebp], eax
	mov	ecx, DWORD PTR tv654[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3356], eax
	lea	ecx, DWORD PTR $T220756[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206142:

; 1406 : 				if (m_hInstSpanish == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3356], 0
	jne	$L206145

; 1407 : 				{
; 1408 : 					if (dllPath.length() != 0)

	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L206145

; 1409 : 						m_hInstSpanish = LoadLibraryW(_bstr_t((dllPath + FILE_SEP_STR + SPANISH_RESOURCE_DLL).c_str()));

	mov	eax, DWORD PTR _FILE_SEP_STR$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllPath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220758[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv680[ebp], eax
	mov	eax, DWORD PTR tv680[ebp]
	mov	DWORD PTR tv656[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	push	OFFSET FLAT:$SG206150
	mov	ecx, DWORD PTR tv656[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220759[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv681[ebp], eax
	mov	eax, DWORD PTR tv681[ebp]
	mov	DWORD PTR tv658[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR tv658[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220757[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv660[ebp], eax
	mov	ecx, DWORD PTR tv660[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3356], eax
	lea	ecx, DWORD PTR $T220757[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T220759[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T220758[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206145:

; 1410 : 				}
; 1411 : 				hInstLocal = m_hInstSpanish;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3356]
	mov	DWORD PTR _hInstLocal$[ebp], eax

; 1412 : 				if (hInstLocal != NULL)

	cmp	DWORD PTR _hInstLocal$[ebp], 0
	je	$L206151

; 1413 : 				{
; 1414 : 					_Module.SetResourceInstance(hInstLocal);

	mov	ecx, DWORD PTR _hInstLocal$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1415 : 					if (dlg != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 0
	je	SHORT $L206152

; 1416 : 					{
; 1417 : 						delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T220761[ebp], ecx
	mov	edx, DWORD PTR $T220761[ebp]
	mov	DWORD PTR $T220760[ebp], edx
	cmp	DWORD PTR $T220760[ebp], 0
	je	SHORT $L220762
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T220760[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T220760[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv453[ebp], eax
	jmp	SHORT $L220763
$L220762:
	mov	DWORD PTR tv453[ebp], 0
$L220763:

; 1418 : 						dlg = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 0
$L206152:

; 1419 : 					}
; 1420 : 					unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206155[ebp], eax

; 1421 : 					if (CertificateCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L206156

; 1422 : 					{
; 1423 : 						dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220765[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	cmp	DWORD PTR $T220765[ebp], 0
	je	SHORT $L220766
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$206155[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220765[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv474[ebp], eax
	jmp	SHORT $L220767
$L220766:
	mov	DWORD PTR tv474[ebp], 0
$L220767:
	mov	eax, DWORD PTR tv474[ebp]
	mov	DWORD PTR $T220764[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T220764[ebp]
	mov	DWORD PTR [ecx+1808], edx
$L206156:

; 1424 : 					}
; 1425 : 					zFree(tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$206155[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206151:

; 1426 : 				}
; 1427 : 			}
; 1428 : 		else if (lang == "DE")

	jmp	$L206095
$L206140:
	push	OFFSET FLAT:$SG206163
	lea	ecx, DWORD PTR _lang$206065[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$L206162

; 1429 : 			{
; 1430 : 				if(!m_hInstGerman)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3360], 0
	jne	SHORT $L206164

; 1431 : 					m_hInstGerman = LoadLibraryW(_bstr_t(GERMAN_RESOURCE_DLL));

	push	OFFSET FLAT:$SG206166
	lea	ecx, DWORD PTR $T220768[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv663[ebp], eax
	mov	ecx, DWORD PTR tv663[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3360], eax
	lea	ecx, DWORD PTR $T220768[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206164:

; 1432 : 				if (m_hInstGerman == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3360], 0
	jne	$L206167

; 1433 : 				{
; 1434 : 					if (dllPath.length() != 0)

	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L206167

; 1435 : 						m_hInstGerman = LoadLibraryW(_bstr_t((dllPath + FILE_SEP_STR + GERMAN_RESOURCE_DLL).c_str()));

	mov	eax, DWORD PTR _FILE_SEP_STR$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dllPath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220770[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv683[ebp], eax
	mov	eax, DWORD PTR tv683[ebp]
	mov	DWORD PTR tv665[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	push	OFFSET FLAT:$SG206172
	mov	ecx, DWORD PTR tv665[ebp]
	push	ecx
	lea	edx, DWORD PTR $T220771[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv684[ebp], eax
	mov	eax, DWORD PTR tv684[ebp]
	mov	DWORD PTR tv667[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR tv667[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	lea	ecx, DWORD PTR $T220769[ebp]
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv669[ebp], eax
	mov	ecx, DWORD PTR tv669[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__LoadLibraryW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3360], eax
	lea	ecx, DWORD PTR $T220769[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	lea	ecx, DWORD PTR $T220771[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T220770[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206167:

; 1436 : 				}
; 1437 : 				hInstLocal = m_hInstGerman;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3360]
	mov	DWORD PTR _hInstLocal$[ebp], eax

; 1438 : 				if (hInstLocal != NULL)

	cmp	DWORD PTR _hInstLocal$[ebp], 0
	je	$L206173

; 1439 : 				{
; 1440 : 					_Module.SetResourceInstance(hInstLocal);

	mov	ecx, DWORD PTR _hInstLocal$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1441 : 					if (dlg != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 0
	je	SHORT $L206174

; 1442 : 					{
; 1443 : 						delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T220773[ebp], ecx
	mov	edx, DWORD PTR $T220773[ebp]
	mov	DWORD PTR $T220772[ebp], edx
	cmp	DWORD PTR $T220772[ebp], 0
	je	SHORT $L220774
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T220772[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T220772[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv534[ebp], eax
	jmp	SHORT $L220775
$L220774:
	mov	DWORD PTR tv534[ebp], 0
$L220775:

; 1444 : 						dlg = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1808], 0
$L206174:

; 1445 : 					}
; 1446 : 					unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206177[ebp], eax

; 1447 : 					if (CertificateCount)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L206178

; 1448 : 					{
; 1449 : 						dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220777[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	cmp	DWORD PTR $T220777[ebp], 0
	je	SHORT $L220778
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$206177[ebp]
	push	edx
	mov	ecx, DWORD PTR $T220777[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv555[ebp], eax
	jmp	SHORT $L220779
$L220778:
	mov	DWORD PTR tv555[ebp], 0
$L220779:
	mov	eax, DWORD PTR tv555[ebp]
	mov	DWORD PTR $T220776[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T220776[ebp]
	mov	DWORD PTR [ecx+1808], edx
$L206178:

; 1450 : 					}
; 1451 : 					zFree(tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$206177[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206173:

; 1452 : 				}
; 1453 : 			}
; 1454 : 		else

	jmp	$L206095
$L206162:

; 1455 : 			{
; 1456 : 				if (m_hInstEnglish != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3340], 0
	je	$L206095

; 1457 : 				{
; 1458 : 					_Module.SetResourceInstance(m_hInstEnglish);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3340]
	push	eax
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?SetResourceInstance@CComModule@ATL@@QAEPAUHINSTANCE__@@PAU3@@Z ; ATL::CComModule::SetResourceInstance

; 1459 : 					if (dlg != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1808], 0
	je	SHORT $L206185

; 1460 : 					{
; 1461 : 						delete dlg;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1808]
	mov	DWORD PTR $T220781[ebp], eax
	mov	ecx, DWORD PTR $T220781[ebp]
	mov	DWORD PTR $T220780[ebp], ecx
	cmp	DWORD PTR $T220780[ebp], 0
	je	SHORT $L220782
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T220780[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T220780[ebp]
	call	DWORD PTR [eax+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv570[ebp], eax
	jmp	SHORT $L220783
$L220782:
	mov	DWORD PTR tv570[ebp], 0
$L220783:

; 1462 : 						dlg = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1808], 0
$L206185:

; 1463 : 					}
; 1464 : 					unsigned char *tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+696]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$206188[ebp], eax

; 1465 : 					if (CertificateCount)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	SHORT $L206189

; 1466 : 					{
; 1467 : 						dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV,  CertificateCount);

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T220785[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	cmp	DWORD PTR $T220785[ebp], 0
	je	SHORT $L220786
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR _tmpCharPtr$206188[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220785[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv591[ebp], eax
	jmp	SHORT $L220787
$L220786:
	mov	DWORD PTR tv591[ebp], 0
$L220787:
	mov	ecx, DWORD PTR tv591[ebp]
	mov	DWORD PTR $T220784[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T220784[ebp]
	mov	DWORD PTR [edx+1808], eax
$L206189:

; 1468 : 					}
; 1469 : 					zFree(tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$206188[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L206095:

; 1470 : 				}
; 1471 : 			}
; 1472 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _lang$206065[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L206063:

; 1473 : #endif
; 1474 : 	return hResult;

	mov	edx, DWORD PTR _hResult$[ebp]
	mov	DWORD PTR $T220788[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _dllPath$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T220788[ebp]

; 1475 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220824
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 724				; 000002d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220824:
	DD	2
	DD	$L220823
$L220823:
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$L220819
	DD	-108					; ffffff94H
	DD	28					; 0000001cH
	DD	$L220820
$L220820:
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$L220819:
	DB	100					; 00000064H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220789:
	lea	ecx, DWORD PTR _dllPath$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220790:
	lea	ecx, DWORD PTR _lang$206065[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220792:
	lea	ecx, DWORD PTR $T220722[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220793:
	lea	ecx, DWORD PTR $T220723[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220795:
	mov	eax, DWORD PTR $T220729[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220797:
	lea	ecx, DWORD PTR $T220734[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220798:
	lea	ecx, DWORD PTR $T220735[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220800:
	mov	eax, DWORD PTR $T220741[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220802:
	lea	ecx, DWORD PTR $T220746[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220803:
	lea	ecx, DWORD PTR $T220747[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220805:
	mov	eax, DWORD PTR $T220753[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220807:
	lea	ecx, DWORD PTR $T220758[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220808:
	lea	ecx, DWORD PTR $T220759[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220810:
	mov	eax, DWORD PTR $T220765[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220812:
	lea	ecx, DWORD PTR $T220770[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220813:
	lea	ecx, DWORD PTR $T220771[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L220815:
	mov	eax, DWORD PTR $T220777[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L220816:
	mov	eax, DWORD PTR $T220785[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?put_Language@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T220818
	jmp	___CxxFrameHandler
text$x	ENDS
?put_Language@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_Language
PUBLIC	?get_SignatureStatus@CSignature@@UAGJJPAH@Z	; CSignature::get_SignatureStatus
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -20						; size = 4
__lpw$ = -16						; size = 4
__acp$ = -12						; size = 4
__convert$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_SignatureStatus@CSignature@@UAGJJPAH@Z PROC NEAR	; CSignature::get_SignatureStatus

; 1478 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1479 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1480 : 	*pVal = FALSE;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 1481 : 	EnterLog;
; 1482 : 
; 1483 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1484 : 
; 1485 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L206206

; 1486 : 	{
; 1487 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1488 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206199
$L206206:

; 1489 : 	}
; 1490 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L206209
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L206208
$L206209:

; 1491 : 	{
; 1492 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1493 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206199
$L206208:

; 1494 : 	}
; 1495 : 
; 1496 : 	*pVal = sgArr[sigIndex]->status;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax], ecx

; 1497 : 	ExitLog;
; 1498 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206199:

; 1499 : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_SignatureStatus@CSignature@@UAGJJPAH@Z ENDP	; CSignature::get_SignatureStatus
_TEXT	ENDS
PUBLIC	?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z ; CSignature::get_PhysicalSignatureUsage
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z PROC NEAR ; CSignature::get_PhysicalSignatureUsage

; 1502 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1503 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1504 : 	EnterLog;
; 1505 : 	*pVal = PhysicalSigUsage;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR [eax], edx

; 1506 : 	ExitLog;
; 1507 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1508 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_PhysicalSignatureUsage
_TEXT	ENDS
PUBLIC	?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z	; CSignature::put_PhysicalSignatureUsage
EXTRN	__imp__GetClientRect@8:NEAR
EXTRN	__imp__GetDesktopWindow@0:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_desktopHwnd$ = -8					; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z PROC NEAR ; CSignature::put_PhysicalSignatureUsage

; 1511 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1512 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1513 : 	HWND	desktopHwnd;
; 1514 : 	EnterLog;
; 1515 : 	PhysicalSigUsage = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+956], ecx

; 1516 : 	
; 1517 : 
; 1518 : 	if (newVal != NO_PHYSICAL_SIG)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L206224

; 1519 : 	{
; 1520 : #ifdef WIN32	
; 1521 : 		desktopHwnd = GetDesktopWindow();	

	mov	esi, esp
	call	DWORD PTR __imp__GetDesktopWindow@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _desktopHwnd$[ebp], eax

; 1522 : 		GetClientRect(desktopHwnd, &SignatureCaptureWindowDim);		

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1752				; 000006d8H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _desktopHwnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1523 : 		SignatureCaptureWindowDim.left = (SignatureCaptureWindowDim.right / 2) - 175; // UpperX		

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+1760]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 175				; 000000afH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1752], eax

; 1524 : 		SignatureCaptureWindowDim.top = (SignatureCaptureWindowDim.bottom / 2) - 125; // UpperY		

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1764]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 125				; 0000007dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1756], eax

; 1525 : 		SignatureCaptureWindowDim.bottom = 250; // Height

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1764], 250		; 000000faH

; 1526 : 		SignatureCaptureWindowDim.right = 350;  // Width

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1760], 350		; 0000015eH
$L206224:

; 1527 : #endif
; 1528 : 	}
; 1529 : 	ExitLog;
; 1530 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1531 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z ENDP	; CSignature::put_PhysicalSignatureUsage
_TEXT	ENDS
PUBLIC	?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z ; CSignature::get_PhysicalSignatureFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -24						; size = 4
__lpw$ = -20						; size = 4
__acp$ = -16						; size = 4
__convert$ = -12					; size = 4
_filePathSize$ = -8					; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_PhysicalSignatureFile

; 1534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1535 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1536 : 	int		filePathSize;
; 1537 : 	EnterLog;
; 1538 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1539 : 
; 1540 : 	filePathSize = strlen((const char *)PhysicalSignatureFileName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 968				; 000003c8H
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _filePathSize$[ebp], eax

; 1541 : 
; 1542 : 	if (filePathSize != 0)

	cmp	DWORD PTR _filePathSize$[ebp], 0
	je	SHORT $L206237

; 1543 : 		*pVal = A2WBSTR((LPCSTR)PhysicalSignatureFileName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 968				; 000003c8H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 1544 : 	else

	jmp	SHORT $L206239
$L206237:

; 1545 : 		setError(SigHandle, FILE_PATH_NOT_SET);

	push	63					; 0000003fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8
$L206239:

; 1546 : 
; 1547 : 	ExitLog;
; 1548 : 
; 1549 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1550 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_PhysicalSignatureFile
_TEXT	ENDS
PUBLIC	?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z ; CSignature::put_PhysicalSignatureFile
xdata$x	SEGMENT
$T220840 DD	0ffffffffH
	DD	FLAT:$L220833
$T220835 DD	019930520H
	DD	01H
	DD	FLAT:$T220840
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T220832 = -60						; size = 4
$T220831 = -56						; size = 4
__lpa$ = -52						; size = 4
__lpw$ = -48						; size = 4
__acp$ = -44						; size = 4
__convert$ = -40					; size = 4
_ccBstrNewVal$ = -32					; size = 4
_filePathSize$ = -24					; size = 4
_charNewVal$ = -20					; size = 4
_hResult$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_PhysicalSignatureFile

; 1553 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1554 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1555 : 	EnterLog;
; 1556 : 	char *charNewVal;
; 1557 : 	int		filePathSize;
; 1558 : 	CComBSTR ccBstrNewVal;

	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1559 : 
; 1560 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1561 : 
; 1562 : 	ccBstrNewVal = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 1563 : 
; 1564 : 	if (ccBstrNewVal.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206253

; 1565 : 	{
; 1566 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 1567 : 		return S_FALSE;

	mov	DWORD PTR $T220831[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220831[ebp]
	jmp	SHORT $L206243
$L206253:

; 1568 : 	}
; 1569 : 
; 1570 : 	charNewVal = (char *)HeapW2A(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charNewVal$[ebp], eax

; 1571 : 	filePathSize = strlen(charNewVal);

	mov	ecx, DWORD PTR _charNewVal$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _filePathSize$[ebp], eax

; 1572 : 
; 1573 : 	if (filePathSize < MAX_PATH)

	cmp	DWORD PTR _filePathSize$[ebp], 260	; 00000104H
	jge	SHORT $L206257

; 1574 : 	{
; 1575 : 		strcpy((char *) PhysicalSignatureFileName, charNewVal);

	mov	edx, DWORD PTR _charNewVal$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 968				; 000003c8H
	push	eax
	call	_strcpy
	add	esp, 8

; 1576 : 		//Image image(newVal);
; 1577 : 		//SignatureCaptureWindowDim.bottom = image.GetHeight(); // Height
; 1578 : 		//SignatureCaptureWindowDim.right = image.GetWidth();  // Width
; 1579 : 	}
; 1580 : 	else

	jmp	SHORT $L206259
$L206257:

; 1581 : 		setError(SigHandle, FILE_PATH_TOO_LONG);

	push	62					; 0000003eH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8
$L206259:

; 1582 : 	
; 1583 : 	zFree(charNewVal);

	mov	eax, DWORD PTR _charNewVal$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1584 : 	ExitLog;
; 1585 : 	return hResult;

	mov	ecx, DWORD PTR _hResult$[ebp]
	mov	DWORD PTR $T220832[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220832[ebp]
$L206243:

; 1586 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220839
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220839:
	DD	1
	DD	$L220838
$L220838:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L220836
$L220836:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220833:
	lea	ecx, DWORD PTR _ccBstrNewVal$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T220835
	jmp	___CxxFrameHandler
text$x	ENDS
?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_PhysicalSignatureFile
PUBLIC	?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z ; CSignature::get_CapturedSignatureFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -24						; size = 4
__lpw$ = -20						; size = 4
__acp$ = -16						; size = 4
__convert$ = -12					; size = 4
_filePathSize$ = -8					; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_CapturedSignatureFile

; 1589 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 1590 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1591 : 	int		filePathSize;
; 1592 : 	EnterLog;
; 1593 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1594 : 
; 1595 : 	filePathSize = strlen((const char *)CapturedSignatureFileName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _filePathSize$[ebp], eax

; 1596 : 
; 1597 : 	if (filePathSize != 0)

	cmp	DWORD PTR _filePathSize$[ebp], 0
	je	SHORT $L206273

; 1598 : 		*pVal = A2WBSTR((LPCSTR)CapturedSignatureFileName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 1599 : 	else

	jmp	SHORT $L206275
$L206273:

; 1600 : 		setError(SigHandle, FILE_PATH_NOT_SET);

	push	63					; 0000003fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8
$L206275:

; 1601 : 	ExitLog;
; 1602 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 1603 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_CapturedSignatureFile
_TEXT	ENDS
PUBLIC	?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z	; CSignature::xsRemoveBstrPath
EXTRN	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z:NEAR		; UTF16LEToUTF8
EXTRN	_memcpy:NEAR
EXTRN	_strnicmp:NEAR
EXTRN	_wcsrchr:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -68						; size = 4
__lpw$ = -64						; size = 4
__acp$ = -60						; size = 4
__convert$ = -56					; size = 4
_tmpBuf$ = -52						; size = 4
_bstrByteSize$ = -48					; size = 4
_utf8CharStr$ = -44					; size = 4
_utf8CharStrLen$ = -36					; size = 4
_bareFileNameLen$ = -24					; size = 4
_wporg$ = -16						; size = 4
_p$ = -12						; size = 4
_porg$ = -8						; size = 4
_this$ = -4						; size = 4
_fileName$ = 8						; size = 4
?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z PROC NEAR	; CSignature::xsRemoveBstrPath
; _this$ = ecx

; 1613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1614 : 	char *porg;
; 1615 : 	wchar_t *p, *wporg;
; 1616 : 	int bareFileNameLen = 0;

	mov	DWORD PTR _bareFileNameLen$[ebp], 0

; 1617 : 	int utf8CharStrLen = 0;

	mov	DWORD PTR _utf8CharStrLen$[ebp], 0

; 1618 : 	unsigned char *utf8CharStr = NULL;

	mov	DWORD PTR _utf8CharStr$[ebp], 0

; 1619 : 	unsigned int bstrByteSize = SysStringByteLen(fileName);

	mov	esi, esp
	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrByteSize$[ebp], eax

; 1620 : 	unsigned char *tmpBuf = (unsigned char *)zMalloc(bstrByteSize+2);

	mov	ecx, DWORD PTR _bstrByteSize$[ebp]
	add	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmpBuf$[ebp], eax

; 1621 : 
; 1622 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1623 : 
; 1624 : 	memcpy(tmpBuf, fileName, bstrByteSize+2);

	mov	edx, DWORD PTR _bstrByteSize$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpBuf$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1625 : 
; 1626 : 	porg = (char *)HeapW2A(fileName);

	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _porg$[ebp], eax

; 1627 : 
; 1628 : 	//porg = (char *)fileName;
; 1629 : 	if (((strnicmp(porg,"http://",7))==0) || ((strnicmp(porg,"ldap://",7))==0))

	push	7
	push	OFFSET FLAT:$SG206296
	mov	eax, DWORD PTR _porg$[ebp]
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L206295
	push	7
	push	OFFSET FLAT:$SG206297
	mov	ecx, DWORD PTR _porg$[ebp]
	push	ecx
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L206294
$L206295:

; 1630 : 	{
; 1631 : 		bareFileNameLen = bstrByteSize;

	mov	edx, DWORD PTR _bstrByteSize$[ebp]
	mov	DWORD PTR _bareFileNameLen$[ebp], edx

; 1632 : 		utf8CharStrLen = bareFileNameLen * 2;

	mov	eax, DWORD PTR _bareFileNameLen$[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf8CharStrLen$[ebp], eax

; 1633 : 		utf8CharStr = (unsigned char *) zMalloc(utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$[ebp], eax

; 1634 : 		memset(utf8CharStr, 0, utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _utf8CharStr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1635 : 		UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)tmpBuf, &bareFileNameLen);

	lea	ecx, DWORD PTR _bareFileNameLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpBuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _utf8CharStrLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf8CharStr$[ebp]
	push	ecx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 1636 : 		zFree(tmpBuf);

	mov	edx, DWORD PTR _tmpBuf$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1637 : 		zFree(porg);

	mov	eax, DWORD PTR _porg$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1638 : 		return utf8CharStr;

	mov	eax, DWORD PTR _utf8CharStr$[ebp]
	jmp	$L206279
$L206294:

; 1639 : 	}
; 1640 : 
; 1641 : 	wporg = (wchar_t *)tmpBuf;

	mov	ecx, DWORD PTR _tmpBuf$[ebp]
	mov	DWORD PTR _wporg$[ebp], ecx

; 1642 : 	if ((p = wcsrchr (wporg,L'\\')) != NULL) {

	push	92					; 0000005cH
	mov	edx, DWORD PTR _wporg$[ebp]
	push	edx
	call	_wcsrchr
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L206301

; 1643 : 		wporg = ++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _wporg$[ebp], ecx
$L206301:

; 1644 : 	}
; 1645 : 
; 1646 : 	if ((p = wcsrchr(wporg,L'/')) != NULL) {

	push	47					; 0000002fH
	mov	edx, DWORD PTR _wporg$[ebp]
	push	edx
	call	_wcsrchr
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax
	cmp	DWORD PTR _p$[ebp], 0
	je	SHORT $L206302

; 1647 : 		wporg = ++p;

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	mov	DWORD PTR _p$[ebp], eax
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _wporg$[ebp], ecx
$L206302:

; 1648 : 	}
; 1649 : 
; 1650 : 	bareFileNameLen = bstrByteSize + 2 - ((char *)wporg - (char *)tmpBuf);

	mov	edx, DWORD PTR _bstrByteSize$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _wporg$[ebp]
	sub	eax, DWORD PTR _tmpBuf$[ebp]
	sub	edx, eax
	mov	DWORD PTR _bareFileNameLen$[ebp], edx

; 1651 : 	utf8CharStrLen = bareFileNameLen +10;

	mov	ecx, DWORD PTR _bareFileNameLen$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _utf8CharStrLen$[ebp], ecx

; 1652 : 	utf8CharStr = (unsigned char *) zMalloc(utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$[ebp], eax

; 1653 : 	memset(utf8CharStr, 0, utf8CharStrLen);

	mov	eax, DWORD PTR _utf8CharStrLen$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _utf8CharStr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1654 : 	UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)wporg, &bareFileNameLen);

	lea	edx, DWORD PTR _bareFileNameLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _wporg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$[ebp]
	push	edx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 1655 : 	zFree(tmpBuf);

	mov	eax, DWORD PTR _tmpBuf$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1656 : 	zFree(porg);

	mov	ecx, DWORD PTR _porg$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1657 : 
; 1658 : 	return utf8CharStr;

	mov	eax, DWORD PTR _utf8CharStr$[ebp]
$L206279:

; 1659 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220846
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L220846:
	DD	2
	DD	$L220845
$L220845:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L220843
	DD	-36					; ffffffdcH
	DD	4
	DD	$L220844
$L220844:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L220843:
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z ENDP		; CSignature::xsRemoveBstrPath
_TEXT	ENDS
PUBLIC	?getSignAllowed@CLicense@@QAEHXZ		; CLicense::getSignAllowed
PUBLIC	?checkLicense@CLicense@@QAEHXZ			; CLicense::checkLicense
PUBLIC	?GuidToString@@YAXPAU_GUID@@PAD@Z		; GuidToString
PUBLIC	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
PUBLIC	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
PUBLIC	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
PUBLIC	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
PUBLIC	?Sign@CSignature@@UAGJPAGPAPAG@Z		; CSignature::Sign
EXTRN	_xmlParseMemory:NEAR
EXTRN	_base64encodeSize:NEAR
EXTRN	_base64encode:NEAR
EXTRN	__imp__CoCreateGuid@4:NEAR
EXTRN	_xmlFree:DWORD
EXTRN	__RTC_UninitUse:NEAR
EXTRN	_xmlNewNs:NEAR
EXTRN	_xmlNewDoc:NEAR
EXTRN	_xmlFreeDoc:NEAR
EXTRN	_xmlNewProp:NEAR
EXTRN	_xmlNewDocNode:NEAR
EXTRN	_xmlNewNode:NEAR
EXTRN	_xmlCopyNode:NEAR
EXTRN	_xmlDocGetRootElement:NEAR
EXTRN	_xmlDocSetRootElement:NEAR
EXTRN	_xmlAddChild:NEAR
EXTRN	_xmlNodeSetContent:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv167 = -776						; size = 4
$T220849 = -769						; size = 1
_wSavedFileName$ = -768					; size = 4
_savedFileName$ = -760					; size = 4
_dataPtr$206501 = -752					; size = 4
_bareFileName$206481 = -748				; size = 4
_intCur$206469 = -744					; size = 4
_nCur$206468 = -740					; size = 4
_pxdoc$206451 = -736					; size = 4
__lpa$ = -732						; size = 4
__lpw$ = -728						; size = 4
__acp$ = -724						; size = 4
__convert$ = -720					; size = 4
_freeCharSigId$ = -716					; size = 4
_cbData$ = -712						; size = 4
_pbData$ = -708						; size = 4
_cbDocument$ = -700					; size = 4
_pbDocument$ = -692					; size = 4
_pout2$ = -684						; size = 256
_pout$ = -420						; size = 256
_signedInfoNode$ = -160					; size = 4
_sigNode$ = -156					; size = 4
_parent$ = -152						; size = 4
_cur$ = -148						; size = 4
_root$ = -144						; size = 4
_doc$ = -140						; size = 4
_charSigId$ = -136					; size = 4
_guidStr$ = -128					; size = 50
_sigGuid$ = -68						; size = 16
_dwBytesToWrite$ = -44					; size = 4
_signedXMLStr$ = -32					; size = 4
_fileDataStr$ = -24					; size = 4
_byteArraySig$ = -16					; size = 4
_hResult$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_URI$ = 12						; size = 4
_tempFileName$ = 16					; size = 4
?Sign@CSignature@@UAGJPAGPAPAG@Z PROC NEAR		; CSignature::Sign

; 1662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 776				; 00000308H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-776]
	mov	ecx, 194				; 000000c2H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	BYTE PTR $T220849[ebp], 0

; 1663 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1664 : 	unsigned char *byteArraySig;
; 1665 : 	BSTR fileDataStr;
; 1666 : 	BSTR signedXMLStr;
; 1667 : 	DWORD  dwBytesToWrite;
; 1668 : #ifdef WIN32
; 1669 : 	GUID sigGuid;
; 1670 : #else
; 1671 : 	uuid_t sigGuid;
; 1672 : #endif
; 1673 : 	char guidStr[50];
; 1674 : 	char *charSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 1675 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 1676 : 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 1677 : 	char pout[256], pout2[256];
; 1678 : 	BYTE *pbDocument;		// Object BLOB to sign
; 1679 : 	DWORD cbDocument=0;

	mov	DWORD PTR _cbDocument$[ebp], 0

; 1680 : 	BYTE *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 1681 : 	DWORD cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 1682 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 1683 : 
; 1684 : 	EnterLog;
; 1685 : 
; 1686 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L206334

; 1687 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1688 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206334:

; 1689 : 	}
; 1690 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L206336

; 1691 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1692 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206336:

; 1693 : 	}
; 1694 : 
; 1695 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 1696 : 
; 1697 : 	DocumentURI = URI;

	mov	ecx, DWORD PTR _URI$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 1698 : 
; 1699 : 	if (DocumentURI.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 680				; 000002a8H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206342

; 1700 : 	{
; 1701 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1702 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206342:

; 1703 : 	}
; 1704 : 
; 1705 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L206344

; 1706 : 	{
; 1707 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L206345

; 1708 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L206345:

; 1709 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1710 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L206344:

; 1711 : 	}
; 1712 : 
; 1713 :   if (EnvelopingFlag != ENVELOPED) // Creating enveloping or detached signature

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+688]
	cmp	eax, 2
	je	$L206346

; 1714 :   {
; 1715 : 	/*
; 1716 : 	* Signature
; 1717 : 	*/
; 1718 : 
; 1719 : 	if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206347

; 1720 : 	{
; 1721 : #ifdef WIN32
; 1722 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1723 : 		GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 1724 : #else
; 1725 : 		uuid_generate(sigGuid);
; 1726 : 		uuid_unparse(sigGuid, guidStr);
; 1727 : #endif
; 1728 : 		charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 1729 : 	}
; 1730 : 	else

	jmp	SHORT $L206348
$L206347:

; 1731 : 	{
; 1732 : 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 1733 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L206348:

; 1734 : 	}
; 1735 : 
; 1736 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG206351
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 1737 : 	// document, namespace, element name, element content
; 1738 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"Signature",NULL);

	push	0
	push	OFFSET FLAT:$SG206353
	push	0
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 1739 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG206356
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 1740 : 	sigNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], eax

; 1741 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG206359
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1742 : 	// add root element
; 1743 : 	xmlDocSetRootElement(doc,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocSetRootElement
	add	esp, 8

; 1744 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1745 : 
; 1746 : 	/*
; 1747 : 	* SignedInfo
; 1748 : 	*/
; 1749 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG206361
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1750 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 1751 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1752 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 1753 : 
; 1754 : 	/*
; 1755 : 	* Canonicalization Method
; 1756 : 	*/
; 1757 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG206363
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1758 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv167[ebp], edx
	cmp	DWORD PTR tv167[ebp], 3
	ja	SHORT $L206388
	mov	eax, DWORD PTR tv167[ebp]
	jmp	DWORD PTR $L220865[eax*4]
$L206368:

; 1759 : 	{
; 1760 : 		case WITH_COMMENTS:
; 1761 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG206371
	push	OFFSET FLAT:$SG206372
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1762 : 			break;

	jmp	SHORT $L206365
$L206373:

; 1763 : 		case WITHOUT_COMMENTS:
; 1764 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG206376
	push	OFFSET FLAT:$SG206377
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1765 : 			break;

	jmp	SHORT $L206365
$L206378:

; 1766 : 		case EXC_WITH_COMMENTS:
; 1767 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG206381
	push	OFFSET FLAT:$SG206382
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1768 : 			break;

	jmp	SHORT $L206365
$L206383:

; 1769 : 		case EXC_WITHOUT_COMMENTS:
; 1770 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG206386
	push	OFFSET FLAT:$SG206387
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1771 : 			break;

	jmp	SHORT $L206365
$L206388:

; 1772 : 		default:
; 1773 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG206391
	push	OFFSET FLAT:$SG206392
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L206365:

; 1774 : 	}
; 1775 : 
; 1776 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1777 : 	/*
; 1778 : 	* Reference
; 1779 : 	*/
; 1780 : 	if (EnvelopingFlag == ENVELOPING)

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+688]
	cmp	eax, 1
	jne	$L206393

; 1781 : 	{
; 1782 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG206395
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1783 : 		sprintf (pout,"REF_Enveloping_%s",charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG206396
	lea	edx, DWORD PTR _pout$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1784 : 		sprintf (pout2,"#OBJECT_%s",charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG206397
	lea	ecx, DWORD PTR _pout2$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1785 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)pout);

	lea	edx, DWORD PTR _pout$[ebp]
	push	edx
	push	OFFSET FLAT:$SG206400
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1786 : 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)pout2);

	lea	ecx, DWORD PTR _pout2$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG206403
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1787 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1788 : /***
; 1789 :  ***	<ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#">
; 1790 : 			<ec:InclusiveNamespaces PrefixList="dsig soap #default"
; 1791 : 				xmlns:ec="http://www.w3.org/2001/10/xml-exc-c14n#"/>
; 1792 : 		</ds:Transform>
; 1793 : */
; 1794 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1795 : 
; 1796 : 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 1797 : 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L206405
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L206404
$L206405:

; 1798 : 		{
; 1799 : 			/*
; 1800 : 			* Transforms
; 1801 : 			*/
; 1802 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG206407
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1803 : 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1804 : 			parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 1805 : 
; 1806 : 			/*
; 1807 : 			* Transform
; 1808 : 			*/
; 1809 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG206409
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1810 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L206410

; 1811 : 			{
; 1812 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG206413
	push	OFFSET FLAT:$SG206414
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1813 : 			}
; 1814 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L206415
$L206410:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L206415

; 1815 : 			{
; 1816 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG206419
	push	OFFSET FLAT:$SG206420
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L206415:

; 1817 : 			}
; 1818 : 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1819 : 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1820 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L206421

; 1821 : 			{
; 1822 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG206423
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1823 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG206426
	push	OFFSET FLAT:$SG206427
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 1824 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG206430
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1825 : 			}
; 1826 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L206431
$L206421:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L206431

; 1827 : 			{
; 1828 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG206434
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1829 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG206437
	push	OFFSET FLAT:$SG206438
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 1830 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG206441
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L206431:

; 1831 : 			}
; 1832 : 			cur = xmlAddChild(parent,cur);		

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L206404:

; 1833 : 		}
; 1834 : 
; 1835 : 		//read file/web page
; 1836 : 		if ((pbDocument = xsDereferenceBstrURI(
; 1837 : 			DocumentURI.m_str,					// file name or URI
; 1838 : 			&cbDocument))==NULL) {		// (in/out) size of data

	lea	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+680]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	DWORD PTR _pbDocument$[ebp], eax
	cmp	DWORD PTR _pbDocument$[ebp], 0
	jne	SHORT $L206442

; 1839 : 				setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1840 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206443

; 1841 : 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L206443:

; 1842 : 				return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206442:

; 1843 : 			}
; 1844 : 
; 1845 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Object");

	push	OFFSET FLAT:$SG206446
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1846 : 		sprintf (pout,"OBJECT_%s",charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG206447
	lea	ecx, DWORD PTR _pout$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1847 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)pout);

	lea	edx, DWORD PTR _pout$[ebp]
	push	edx
	push	OFFSET FLAT:$SG206450
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1848 : 
; 1849 : 		xmlDocPtr pxdoc=NULL;

	mov	DWORD PTR _pxdoc$206451[ebp], 0

; 1850 : 		pxdoc = xmlParseMemory((const char *)pbDocument,cbDocument);

	mov	ecx, DWORD PTR _cbDocument$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _pxdoc$206451[ebp], eax

; 1851 : 		if (pxdoc == NULL) {

	cmp	DWORD PTR _pxdoc$206451[ebp], 0
	jne	$L206453

; 1852 : 			// no xml content
; 1853 : 			// Base64 encode the data since we don't know what it is
; 1854 : 			cbData = base64encodeSize(cbDocument);

	mov	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 1855 : 			// allocate memory
; 1856 : 			if(!(pbData = (BYTE*)zMalloc(cbData+1)))

	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax
	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L206455

; 1857 : 				{
; 1858 : 				setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 1859 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206456

; 1860 : 					zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L206456:

; 1861 : 				return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206455:

; 1862 : 			}
; 1863 : 			if (base64encode(pbDocument,cbDocument,(unsigned char*)pbData,cbData)==-1) {

	mov	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cbDocument$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L206459

; 1864 : 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1865 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206460

; 1866 : 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L206460:

; 1867 : 				return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206459:

; 1868 : 			}
; 1869 : 			*(pbData+cbData)='\0';

	mov	eax, DWORD PTR _pbData$[ebp]
	add	eax, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [eax], 0

; 1870 : 			xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG206464
	push	OFFSET FLAT:$SG206465
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1871 : 			xmlNodeSetContent(cur,(const unsigned char *)pbData);	

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 1872 : 			zFree(pbData);

	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1873 : 			zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1874 : 			pbData = NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 1875 : 			pbDocument = NULL;

	mov	DWORD PTR _pbDocument$[ebp], 0

; 1876 : 		}else{

	jmp	SHORT $L206467
$L206453:

; 1877 : 			// render internal 
; 1878 : 			xmlNodePtr nCur = NULL;

	mov	DWORD PTR _nCur$206468[ebp], 0

; 1879 : 		    xmlNodePtr intCur = NULL;

	mov	DWORD PTR _intCur$206469[ebp], 0

; 1880 : 			intCur = xmlDocGetRootElement(pxdoc);

	mov	eax, DWORD PTR _pxdoc$206451[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _intCur$206469[ebp], eax

; 1881 : 			nCur = xmlCopyNode(intCur,1);

	push	1
	mov	ecx, DWORD PTR _intCur$206469[ebp]
	push	ecx
	call	_xmlCopyNode
	add	esp, 8
	mov	DWORD PTR _nCur$206468[ebp], eax

; 1882 : 			xmlAddChild(cur,nCur);

	mov	edx, DWORD PTR _nCur$206468[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 1883 : 			xmlFreeDoc(pxdoc);

	mov	ecx, DWORD PTR _pxdoc$206451[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1884 : 			zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1885 : 			pbDocument = NULL;

	mov	DWORD PTR _pbDocument$[ebp], 0
$L206467:

; 1886 : 		}
; 1887 : 		cur = xmlAddChild(sigNode,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1888 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1889 : 
; 1890 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureProperties"); 

	push	OFFSET FLAT:$SG206471
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1891 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1892 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 1893 : 
; 1894 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureProperty"); 

	push	OFFSET FLAT:$SG206473
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1895 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)"URI");

	push	OFFSET FLAT:$SG206476
	push	OFFSET FLAT:$SG206477
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1896 : 		xmlNewProp(cur, (const unsigned char *)"Target", (const unsigned char *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG206480
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 1897 : 		unsigned char *bareFileName = xsRemoveBstrPath(DocumentURI.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+680]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z ; CSignature::xsRemoveBstrPath
	mov	DWORD PTR _bareFileName$206481[ebp], eax

; 1898 : 		xmlNodeSetContent(cur,(const unsigned char *)bareFileName);

	mov	edx, DWORD PTR _bareFileName$206481[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 1899 : 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 1900 : 		zFree(bareFileName);

	mov	eax, DWORD PTR _bareFileName$206481[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206393:

; 1901 : 	} // ENVELOPING
; 1902 : 
; 1903 : #ifdef WIN32
; 1904 : 	if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L206483

; 1905 : 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L206483:

; 1906 : 
; 1907 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L206484

; 1908 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L206484:

; 1909 : #endif
; 1910 : 
; 1911 : 	//xmlDocDumpMemory(doc,&crBlob.pbData,(int *)&crBlob.cbData);
; 1912 : 	//xmlFreeDoc(doc);
; 1913 : 
; 1914 : 	/*
; 1915 : 	 * init Signature. crBlob contains XML - envelope document
; 1916 : 	 */
; 1917 : 
; 1918 : 	if (!(CreateSigFromTmplBlob(
; 1919 : 								//&crBlob,
; 1920 : 								doc,
; 1921 : 								charSigId, &byteArraySig, (int *)&dwBytesToWrite)))

	lea	eax, DWORD PTR _dwBytesToWrite$[ebp]
	push	eax
	lea	ecx, DWORD PTR _byteArraySig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L206486

; 1922 : 	{
; 1923 : 		//zFree(crBlob.pbData);
; 1924 : 		if (byteArraySig != NULL)

	cmp	DWORD PTR _byteArraySig$[ebp], 0
	je	SHORT $L206487

; 1925 : 		{
; 1926 : 			xmlFree(byteArraySig);

	mov	esi, esp
	mov	ecx, DWORD PTR _byteArraySig$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L206487:

; 1927 : 		}
; 1928 : 		*tempFileName = A2WBSTR((const char *) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _tempFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 1929 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206489

; 1930 : 			zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206489:

; 1931 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206486:

; 1932 : 	}
; 1933 : 	else
; 1934 : 	{
; 1935 : 		if (byteArraySig != NULL)

	cmp	DWORD PTR _byteArraySig$[ebp], 0
	je	SHORT $L206491

; 1936 : 		{
; 1937 : 			signedXMLStr = A2WBSTR((LPCSTR)byteArraySig, (int)dwBytesToWrite);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _byteArraySig$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	BYTE PTR $T220849[ebp], 1
	mov	DWORD PTR _signedXMLStr$[ebp], eax

; 1938 : 			if (Base64EncodeXML == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2180], 1
	jne	SHORT $L206495

; 1939 : 				zFree(byteArraySig);

	mov	ecx, DWORD PTR _byteArraySig$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1940 : 			else

	jmp	SHORT $L206491
$L206495:

; 1941 : 				xmlFree(byteArraySig);

	mov	esi, esp
	mov	edx, DWORD PTR _byteArraySig$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L206491:

; 1942 : 		}
; 1943 : 	}
; 1944 :   }
; 1945 :   else

	jmp	$L206497
$L206346:

; 1946 :   {
; 1947 : 	if ((pbDocument = xsDereferenceBstrURI(
; 1948 : 		DocumentURI.m_str,					// file name or URI
; 1949 : 		&cbDocument))==NULL) 

	lea	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+680]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	DWORD PTR _pbDocument$[ebp], eax
	cmp	DWORD PTR _pbDocument$[ebp], 0
	jne	SHORT $L206498

; 1950 : 	{		// (in/out) size of data
; 1951 : 		setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 1952 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206499

; 1953 : 			zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L206499:

; 1954 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206498:

; 1955 : 	}
; 1956 : 
; 1957 : 	unsigned char *dataPtr = pbDocument;

	mov	eax, DWORD PTR _pbDocument$[ebp]
	mov	DWORD PTR _dataPtr$206501[ebp], eax

; 1958 : 	if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) || // Little Endian
; 1959 : 		((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff))) // Big Endian

	mov	ecx, DWORD PTR _dataPtr$206501[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L206504
	mov	eax, DWORD PTR _dataPtr$206501[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L206503
$L206504:
	mov	edx, DWORD PTR _dataPtr$206501[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L206502
	mov	ecx, DWORD PTR _dataPtr$206501[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L206502
$L206503:

; 1960 : 	{
; 1961 : 		// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 1962 : 		// Just allocate memory and copy data and put the size information in front
; 1963 : 		fileDataStr = ::SysAllocStringByteLen((LPCSTR)dataPtr, (UINT)cbDocument);

	mov	esi, esp
	mov	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$206501[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fileDataStr$[ebp], eax

; 1964 : 	}
; 1965 : 	else

	jmp	SHORT $L206507
$L206502:

; 1966 : 	{
; 1967 : 		fileDataStr = A2WBSTR((LPCSTR)dataPtr, cbDocument);

	mov	edx, DWORD PTR _cbDocument$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$206501[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _fileDataStr$[ebp], eax
$L206507:

; 1968 : 	}
; 1969 : 	zFree(pbDocument);

	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1970 : 	  
; 1971 : 	if (SignXMLStr(fileDataStr, SignatureID.m_str, &signedXMLStr) != S_OK)

	mov	BYTE PTR $T220849[ebp], 1
	mov	esi, esp
	lea	edx, DWORD PTR _signedXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	push	ecx
	mov	edx, DWORD PTR _fileDataStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+232]
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L206510

; 1972 : 	{
; 1973 : 		SysFreeString(fileDataStr);

	mov	esi, esp
	mov	eax, DWORD PTR _fileDataStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1974 : 		*tempFileName = A2WBSTR((const char *) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _tempFileName$[ebp]
	mov	DWORD PTR [ecx], eax

; 1975 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206311
$L206510:

; 1976 : 	}
; 1977 : 	SysFreeString(fileDataStr);

	mov	esi, esp
	mov	edx, DWORD PTR _fileDataStr$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L206497:

; 1978 :   }
; 1979 : 	BSTR savedFileName=NULL;

	mov	DWORD PTR _savedFileName$[ebp], 0

; 1980 : 	SaveXMLStr(signedXMLStr, NULL, &savedFileName);

	cmp	BYTE PTR $T220849[ebp], 0
	jne	SHORT $L220850
	push	OFFSET FLAT:$L220851
	call	__RTC_UninitUse
	add	esp, 4
$L220850:
	mov	esi, esp
	lea	eax, DWORD PTR _savedFileName$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _signedXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+240]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1981 : 	char *wSavedFileName = (char *)HeapW2A(savedFileName);

	mov	edx, DWORD PTR _savedFileName$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wSavedFileName$[ebp], eax

; 1982 : 	strcpy(szTempName, wSavedFileName);

	mov	eax, DWORD PTR _wSavedFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1983 : 	zFree(wSavedFileName);

	mov	edx, DWORD PTR _wSavedFileName$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1984 : 	SysFreeString(signedXMLStr);

	cmp	BYTE PTR $T220849[ebp], 0
	jne	SHORT $L220853
	push	OFFSET FLAT:$L220851
	call	__RTC_UninitUse
	add	esp, 4
$L220853:
	mov	esi, esp
	mov	eax, DWORD PTR _signedXMLStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1985 : 	*tempFileName = A2WBSTR(szTempName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _tempFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 1986 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L206516

; 1987 : 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L206516:

; 1988 : 	ExitLog;
; 1989 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206311:

; 1990 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220864
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 776				; 00000308H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L220864:
	DD	9
	DD	$L220863
$L220863:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L220851
	DD	-16					; fffffff0H
	DD	4
	DD	$L220854
	DD	-44					; ffffffd4H
	DD	4
	DD	$L220855
	DD	-68					; ffffffbcH
	DD	16					; 00000010H
	DD	$L220856
	DD	-128					; ffffff80H
	DD	50					; 00000032H
	DD	$L220857
	DD	-420					; fffffe5cH
	DD	256					; 00000100H
	DD	$L220858
	DD	-684					; fffffd54H
	DD	256					; 00000100H
	DD	$L220859
	DD	-700					; fffffd44H
	DD	4
	DD	$L220860
	DD	-760					; fffffd08H
	DD	4
	DD	$L220861
$L220861:
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L220860:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L220859:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L220858:
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	0
$L220857:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L220856:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L220855:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	87					; 00000057H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$L220854:
	DB	98					; 00000062H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	0
$L220851:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L220865:
	DD	$L206373
	DD	$L206368
	DD	$L206383
	DD	$L206378
?Sign@CSignature@@UAGJPAGPAPAG@Z ENDP			; CSignature::Sign
_TEXT	ENDS
EXTRN	?floatingLicenseStatus@CLicense@@QAEHXZ:NEAR	; CLicense::floatingLicenseStatus
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
;	COMDAT ?getSignAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSignAllowed@CLicense@@QAEHXZ PROC NEAR		; CLicense::getSignAllowed, COMDAT
; _this$ = ecx

; 55   : 	BOOL getSignAllowed() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		if (isSignAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+68], 0
	je	SHORT $L197864

; 57   : 			return isSignAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+68]
	jmp	SHORT $L197863
$L197864:

; 58   : 		else
; 59   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197863:

; 60   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getSignAllowed@CLicense@@QAEHXZ ENDP			; CLicense::getSignAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?checkLicense@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?checkLicense@CLicense@@QAEHXZ PROC NEAR		; CLicense::checkLicense, COMDAT
; _this$ = ecx

; 103  : 	BOOL checkLicense(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 		if (isLicenseValid)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], 0
	je	SHORT $L197894

; 105  : 			return isLicenseValid;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+120]
	jmp	SHORT $L197893
$L197894:

; 106  : 		else
; 107  : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197893:

; 108  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?checkLicense@CLicense@@QAEHXZ ENDP			; CLicense::checkLicense
_TEXT	ENDS
PUBLIC	?SaveXMLSignature@CSignature@@UAGJPAG@Z		; CSignature::SaveXMLSignature
EXTRN	__imp__MoveFileA@8:NEAR
xdata$x	SEGMENT
$T220881 DD	0ffffffffH
	DD	FLAT:$L220874
$T220876 DD	019930520H
	DD	01H
	DD	FLAT:$T220881
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T220873 = -60						; size = 4
$T220872 = -56						; size = 4
$T220871 = -52						; size = 4
_wSigFileName$ = -48					; size = 4
__lpa$ = -44						; size = 4
__lpw$ = -40						; size = 4
__acp$ = -36						; size = 4
__convert$ = -32					; size = 4
_ccBstrSigFileName$ = -24				; size = 4
_hResult$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigFileName$ = 12					; size = 4
?SaveXMLSignature@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::SaveXMLSignature

; 1993 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SaveXMLSignature@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1994 : 
; 1995 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 1996 : 	CComBSTR ccBstrSigFileName;

	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1997 : 	
; 1998 : 	EnterLog;
; 1999 : 
; 2000 : 	ccBstrSigFileName = sigFileName;

	mov	eax, DWORD PTR _sigFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2001 : 
; 2002 : 	if (ccBstrSigFileName.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206524

; 2003 : 	{
; 2004 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2005 : 		return S_FALSE;

	mov	DWORD PTR $T220871[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220871[ebp]
	jmp	$L206520
$L206524:

; 2006 : 	}
; 2007 : 	
; 2008 : 	// Move the temporary file to the new text file.
; 2009 :  USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2010 : 
; 2011 : 	char *wSigFileName = (char *)HeapW2A(sigFileName);

	mov	eax, DWORD PTR _sigFileName$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wSigFileName$[ebp], eax

; 2012 : #ifdef WIN32
; 2013 : 	if (OverwriteFileFlag)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1824], 0
	je	SHORT $L206533

; 2014 : 		DeleteFile(wSigFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _wSigFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L206533:

; 2015 : 
; 2016 : 	if (!MoveFile(szTempName, wSigFileName)) 

	mov	esi, esp
	mov	eax, DWORD PTR _wSigFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	DWORD PTR __imp__MoveFileA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L206534

; 2017 : 	{
; 2018 : #else
; 2019 : 	if (OverwriteFileFlag)
; 2020 : 		unlink(wSigFileName);
; 2021 : 	
; 2022 : 	if (rename(szTempName, wSigFileName) != 0)
; 2023 : 	{ 
; 2024 : #endif
; 2025 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2026 : 		zFree(wSigFileName);

	mov	ecx, DWORD PTR _wSigFileName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 2027 : 		return S_FALSE;

	mov	DWORD PTR $T220872[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220872[ebp]
	jmp	SHORT $L206520
$L206534:

; 2028 : 	} 	
; 2029 : 	zFree(wSigFileName);

	mov	edx, DWORD PTR _wSigFileName$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2030 : 	ExitLog;
; 2031 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
	mov	DWORD PTR $T220873[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220873[ebp]
$L206520:

; 2032 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220880
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220880:
	DD	1
	DD	$L220879
$L220879:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L220877
$L220877:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220874:
	lea	ecx, DWORD PTR _ccBstrSigFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SaveXMLSignature@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T220876
	jmp	___CxxFrameHandler
text$x	ENDS
?SaveXMLSignature@CSignature@@UAGJPAG@Z ENDP		; CSignature::SaveXMLSignature
PUBLIC	?Verify@CSignature@@UAGJPAGPAH@Z		; CSignature::Verify
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_inputXML$ = -12					; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_signatureFileName$ = 12				; size = 4
_sigStatus$ = 16					; size = 4
?Verify@CSignature@@UAGJPAGPAH@Z PROC NEAR		; CSignature::Verify

; 2035 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2036 : 
; 2037 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 2038 : 	BSTR inputXML;
; 2039 : 	EnterLog;
; 2040 : 	*sigStatus = FALSE;

	mov	eax, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [eax], 0

; 2041 : 	hResult = ReadAll(signatureFileName, &inputXML);

	mov	esi, esp
	lea	ecx, DWORD PTR _inputXML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signatureFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+236]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 2042 : 	if (hResult != S_OK)

	cmp	DWORD PTR _hResult$[ebp], 0
	je	SHORT $L206547

; 2043 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206542
$L206547:

; 2044 : 	if (uriArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L206549

; 2045 : 	{
; 2046 : 		SigHandle->locArray = uriArr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+12], ecx

; 2047 : 		SigHandle->locNumber = totalUriCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+16], edx
$L206549:

; 2048 : 	}
; 2049 : 	hResult = VerifyXMLStr(inputXML, sigStatus);

	mov	esi, esp
	mov	eax, DWORD PTR _sigStatus$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputXML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+300]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 2050 : 	SysFreeString(inputXML);

	mov	esi, esp
	mov	edx, DWORD PTR _inputXML$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2051 : 	ExitLog;
; 2052 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206542:

; 2053 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220885
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L220885:
	DD	1
	DD	$L220884
$L220884:
	DD	-12					; fffffff4H
	DD	4
	DD	$L220883
$L220883:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
?Verify@CSignature@@UAGJPAGPAH@Z ENDP			; CSignature::Verify
_TEXT	ENDS
PUBLIC	?VerifyDetached@CSignature@@UAGJPAGPAH@Z	; CSignature::VerifyDetached
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_signatureFileName$ = 12				; size = 4
_sigStatus$ = 16					; size = 4
?VerifyDetached@CSignature@@UAGJPAGPAH@Z PROC NEAR	; CSignature::VerifyDetached

; 2056 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2057 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 2058 : 	EnterLog;
; 2059 : 	*sigStatus = 0;

	mov	eax, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [eax], 0

; 2060 : 	if (uriArr == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $L206557

; 2061 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206554
$L206557:

; 2062 : 
; 2063 : 	SigHandle->locArray = uriArr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 2064 : 	SigHandle->locNumber = totalUriCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+16], eax

; 2065 : 	hResult = Verify(signatureFileName,sigStatus);

	mov	esi, esp
	mov	ecx, DWORD PTR _sigStatus$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signatureFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+140]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 2066 : 	ExitLog;
; 2067 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L206554:

; 2068 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?VerifyDetached@CSignature@@UAGJPAGPAH@Z ENDP		; CSignature::VerifyDetached
_TEXT	ENDS
PUBLIC	?GetError@CSignature@@UAGJPAPAG@Z		; CSignature::GetError
EXTRN	_axGetError:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_err$ = -8						; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_errorString$ = 12					; size = 4
?GetError@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::GetError

; 2071 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2072 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 2073 : 	EnterLog;
; 2074 : 	const char *err = (const char *) axGetError(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_axGetError
	add	esp, 4
	mov	DWORD PTR _err$[ebp], eax

; 2075 : 
; 2076 : 	if (err != NULL)

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L206567

; 2077 : 	{
; 2078 : 		ErrorString = err;

	mov	edx, DWORD PTR _err$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 2079 : 		*errorString = ErrorString.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _errorString$[ebp]
	mov	DWORD PTR [ecx], eax

; 2080 : 		zFree((void *)err);

	mov	edx, DWORD PTR _err$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2081 : 	}
; 2082 : 	else

	jmp	SHORT $L206569
$L206567:

; 2083 : 		*errorString = NULL;

	mov	eax, DWORD PTR _errorString$[ebp]
	mov	DWORD PTR [eax], 0
$L206569:

; 2084 : 	ExitLog;
; 2085 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 2086 : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetError@CSignature@@UAGJPAPAG@Z ENDP			; CSignature::GetError
_TEXT	ENDS
PUBLIC	?GetLastError@CSignature@@UAGJPAJ@Z		; CSignature::GetLastError
EXTRN	_axGetLastError:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_errorNum$ = 12						; size = 4
?GetLastError@CSignature@@UAGJPAJ@Z PROC NEAR		; CSignature::GetLastError

; 2090 : {

	push	ebp
	mov	ebp, esp

; 2091 : 	EnterLog;
; 2092 : 	*errorNum = axGetLastError(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_axGetLastError
	add	esp, 4
	mov	edx, DWORD PTR _errorNum$[ebp]
	mov	DWORD PTR [edx], eax

; 2093 : 	ExitLog;
; 2094 : 	return S_OK;

	xor	eax, eax

; 2095 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?GetLastError@CSignature@@UAGJPAJ@Z ENDP		; CSignature::GetLastError
_TEXT	ENDS
PUBLIC	?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z	; CSignature::GetX509Certificate
PUBLIC	?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z	; CSignature::PlainHexToBase64Bin
EXTRN	__imp__lstrcmpA@8:NEAR
xdata$x	SEGMENT
$T220900 DD	0ffffffffH
	DD	FLAT:$L220893
$T220895 DD	019930520H
	DD	01H
	DD	FLAT:$T220900
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T220892 = -68						; size = 4
$T220891 = -64						; size = 4
$T220890 = -60						; size = 4
_i$206593 = -56						; size = 4
_wCertID$206591 = -52					; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_certificateFound$ = -32				; size = 4
_base64CertId$ = -28					; size = 4
_tmpCertId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
_certData$ = 16						; size = 4
?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::GetX509Certificate

; 2098 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2099 : 	CComBSTR tmpCertId;

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2100 : 	unsigned char *base64CertId;
; 2101 : 	BOOL certificateFound = FALSE;

	mov	DWORD PTR _certificateFound$[ebp], 0

; 2102 : 	EnterLog;
; 2103 : 	tmpCertId = certID;

	mov	eax, DWORD PTR _certID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2104 : 	if (tmpCertId.Length() == 0)

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206583

; 2105 : 	{
; 2106 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2107 : 		DebugLog("tmpCertId.Length() == 0");
; 2108 : 		return S_FALSE;

	mov	DWORD PTR $T220890[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220890[ebp]
	jmp	$L206579
$L206583:

; 2109 : 	}
; 2110 : 
; 2111 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2112 : 	if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3324], 1
	jne	SHORT $L206590

; 2113 : 	{
; 2114 : 		unsigned char *wCertID = HeapW2A(certID);

	mov	ecx, DWORD PTR _certID$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wCertID$206591[ebp], eax

; 2115 : 		base64CertId = PlainHexToBase64Bin(wCertID);

	mov	edx, DWORD PTR _wCertID$206591[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z ; CSignature::PlainHexToBase64Bin
	mov	DWORD PTR _base64CertId$[ebp], eax

; 2116 : 		zFree(wCertID);

	mov	eax, DWORD PTR _wCertID$206591[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2117 : 	}
; 2118 : 	else

	jmp	SHORT $L206592
$L206590:

; 2119 : 		base64CertId = HeapW2A(certID);

	mov	ecx, DWORD PTR _certID$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _base64CertId$[ebp], eax
$L206592:

; 2120 : 	DebugLog((const char *)base64CertId);
; 2121 : 	for (int i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$206593[ebp], 0
	jmp	SHORT $L206594
$L206595:
	mov	edx, DWORD PTR _i$206593[ebp]
	add	edx, 1
	mov	DWORD PTR _i$206593[ebp], edx
$L206594:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$206593[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L206596

; 2122 : 	{
; 2123 : 		if (!(StrCmp((const char *)cV[i]->serialNumber, (const char *)base64CertId)))

	mov	esi, esp
	mov	edx, DWORD PTR _base64CertId$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$206593[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L206599

; 2124 : 		{
; 2125 : 			*certData = A2WBSTR((LPCSTR) cV[i]->certificate);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$206593[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _certData$[ebp]
	mov	DWORD PTR [ecx], eax

; 2126 : 			certificateFound = TRUE;

	mov	DWORD PTR _certificateFound$[ebp], 1

; 2127 : 			break;

	jmp	SHORT $L206596
$L206599:

; 2128 : 		}
; 2129 : 	}

	jmp	SHORT $L206595
$L206596:

; 2130 : 	if (base64CertId)

	cmp	DWORD PTR _base64CertId$[ebp], 0
	je	SHORT $L206601

; 2131 : 	{
; 2132 : 		zFree(base64CertId);

	mov	edx, DWORD PTR _base64CertId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2133 : 		base64CertId = NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0
$L206601:

; 2134 : 	}
; 2135 : 	if (certificateFound == FALSE)

	cmp	DWORD PTR _certificateFound$[ebp], 0
	jne	SHORT $L206602

; 2136 : 	{
; 2137 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2138 : 		return S_FALSE;

	mov	DWORD PTR $T220891[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220891[ebp]
	jmp	SHORT $L206579
$L206602:

; 2139 : 	}
; 2140 : 	ExitLog;
; 2141 : 	return S_OK;

	mov	DWORD PTR $T220892[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220892[ebp]
$L206579:

; 2142 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220899
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L220899:
	DD	1
	DD	$L220898
$L220898:
	DD	-20					; ffffffecH
	DD	4
	DD	$L220896
$L220896:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220893:
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T220895
	jmp	___CxxFrameHandler
text$x	ENDS
?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::GetX509Certificate
PUBLIC	?ViewCertificate@CSignature@@UAGJPAG@Z		; CSignature::ViewCertificate
EXTRN	_axViewAnyCertificate:NEAR
xdata$x	SEGMENT
$T220912 DD	0ffffffffH
	DD	FLAT:$L220905
$T220907 DD	019930520H
	DD	01H
	DD	FLAT:$T220912
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T220904 = -68						; size = 4
$T220903 = -64						; size = 4
$T220902 = -60						; size = 4
_i$206624 = -56						; size = 4
_wCertID$206622 = -52					; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_certificateFound$ = -32				; size = 4
_base64CertId$ = -28					; size = 4
_tmpCertId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
?ViewCertificate@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::ViewCertificate

; 2145 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ViewCertificate@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2146 : 	CComBSTR tmpCertId;

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2147 : 	unsigned char *base64CertId;
; 2148 : 	BOOL certificateFound = FALSE;

	mov	DWORD PTR _certificateFound$[ebp], 0

; 2149 : 
; 2150 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2151 : 	EnterLog;
; 2152 : 	tmpCertId = certID;

	mov	eax, DWORD PTR _certID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2153 : 	if (tmpCertId.Length() == 0)

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206618

; 2154 : 	{
; 2155 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2156 : 		return S_FALSE;

	mov	DWORD PTR $T220902[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220902[ebp]
	jmp	$L206610
$L206618:

; 2157 : 	}
; 2158 : 	if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3324], 1
	jne	SHORT $L206621

; 2159 : 	{
; 2160 : 		unsigned char *wCertID = HeapW2A(certID);

	mov	ecx, DWORD PTR _certID$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wCertID$206622[ebp], eax

; 2161 : 		base64CertId = PlainHexToBase64Bin(wCertID);

	mov	edx, DWORD PTR _wCertID$206622[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z ; CSignature::PlainHexToBase64Bin
	mov	DWORD PTR _base64CertId$[ebp], eax

; 2162 : 		zFree(wCertID);

	mov	eax, DWORD PTR _wCertID$206622[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2163 : 	}
; 2164 : 	else

	jmp	SHORT $L206623
$L206621:

; 2165 : 		base64CertId = HeapW2A(certID);

	mov	ecx, DWORD PTR _certID$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _base64CertId$[ebp], eax
$L206623:

; 2166 : 
; 2167 : 	for (int i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$206624[ebp], 0
	jmp	SHORT $L206625
$L206626:
	mov	edx, DWORD PTR _i$206624[ebp]
	add	edx, 1
	mov	DWORD PTR _i$206624[ebp], edx
$L206625:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$206624[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L206627

; 2168 : 	{
; 2169 : 		if (!(StrCmp((const char *)cV[i]->serialNumber, (const char *)base64CertId)))

	mov	esi, esp
	mov	edx, DWORD PTR _base64CertId$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$206624[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L206630

; 2170 : 		{
; 2171 : 			axViewAnyCertificate(cV[i]->certificate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$206624[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	_axViewAnyCertificate
	add	esp, 4

; 2172 : 			certificateFound = TRUE;

	mov	DWORD PTR _certificateFound$[ebp], 1

; 2173 : 			break;

	jmp	SHORT $L206627
$L206630:

; 2174 : 		}
; 2175 : 	}

	jmp	SHORT $L206626
$L206627:

; 2176 : 	if (base64CertId)

	cmp	DWORD PTR _base64CertId$[ebp], 0
	je	SHORT $L206631

; 2177 : 	{
; 2178 : 		zFree(base64CertId);

	mov	eax, DWORD PTR _base64CertId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2179 : 		base64CertId = NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0
$L206631:

; 2180 : 	}
; 2181 : 
; 2182 : 	if (certificateFound == FALSE)

	cmp	DWORD PTR _certificateFound$[ebp], 0
	jne	SHORT $L206632

; 2183 : 	{
; 2184 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2185 : 		return S_FALSE;

	mov	DWORD PTR $T220903[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220903[ebp]
	jmp	SHORT $L206610
$L206632:

; 2186 : 	}
; 2187 : 	ExitLog;
; 2188 : 	return S_OK;

	mov	DWORD PTR $T220904[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220904[ebp]
$L206610:

; 2189 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220911
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220911:
	DD	1
	DD	$L220910
$L220910:
	DD	-20					; ffffffecH
	DD	4
	DD	$L220908
$L220908:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220905:
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?ViewCertificate@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T220907
	jmp	___CxxFrameHandler
text$x	ENDS
?ViewCertificate@CSignature@@UAGJPAG@Z ENDP		; CSignature::ViewCertificate
PUBLIC	?get_CertificateCount@CSignature@@UAGJPAJ@Z	; CSignature::get_CertificateCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CertificateCount@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_CertificateCount

; 2192 : {

	push	ebp
	mov	ebp, esp

; 2193 : 	EnterLog;
; 2194 : 	*pVal = CertificateCount;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+124]
	mov	DWORD PTR [eax], edx

; 2195 : 	ExitLog;
; 2196 : 	return S_OK;

	xor	eax, eax

; 2197 : }

	pop	ebp
	ret	8
?get_CertificateCount@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_CertificateCount
_TEXT	ENDS
PUBLIC	?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z	; CSignature::GetCertificateInfo
PUBLIC	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z	; CSignature::Base64BinToPlainHex
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv81 = -20						; size = 4
_plainHexPtr$ = -16					; size = 4
_provideBase64CertInfo$ = -12				; size = 4
_provideActiveCertInfo$ = -8				; size = 4
_providePfxCertInfo$ = -4				; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_valIndex$ = 16						; size = 4
_value$ = 20						; size = 4
?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z PROC NEAR	; CSignature::GetCertificateInfo

; 2200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2201 : 	BOOL providePfxCertInfo = FALSE;

	mov	DWORD PTR _providePfxCertInfo$[ebp], 0

; 2202 : 	BOOL provideActiveCertInfo = FALSE;

	mov	DWORD PTR _provideActiveCertInfo$[ebp], 0

; 2203 : 	BOOL provideBase64CertInfo = FALSE;

	mov	DWORD PTR _provideBase64CertInfo$[ebp], 0

; 2204 : 	unsigned char *plainHexPtr=NULL;

	mov	DWORD PTR _plainHexPtr$[ebp], 0

; 2205 : 
; 2206 : 	EnterLog;
; 2207 : 
; 2208 : 	//The following logic does not cover the case when CurrentCertificate == USE_BASE64_CERT
; 2209 : 	//It will lead to a memory fault
; 2210 : 
; 2211 : 	if ((CurrentCertificate == USE_PFX_CERT) &&
; 2212 : 		(index == USE_PFX_CERT))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], -2			; fffffffeH
	jne	SHORT $L206652
	cmp	DWORD PTR _index$[ebp], -2		; fffffffeH
	jne	SHORT $L206652

; 2213 : 		providePfxCertInfo = TRUE;

	mov	DWORD PTR _providePfxCertInfo$[ebp], 1

; 2214 : 	else

	jmp	SHORT $L206653
$L206652:

; 2215 : 		if ((CurrentCertificate >= 0) && (index == ACTIVE_CERT_INFO))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+120], 0
	jl	SHORT $L206654
	cmp	DWORD PTR _index$[ebp], -3		; fffffffdH
	jne	SHORT $L206654

; 2216 : 			provideActiveCertInfo = TRUE;

	mov	DWORD PTR _provideActiveCertInfo$[ebp], 1

; 2217 : 		else

	jmp	SHORT $L206653
$L206654:

; 2218 : 			if ((CurrentCertificate == USE_BASE64_CERT) && (index == ACTIVE_CERT_INFO))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -3			; fffffffdH
	jne	SHORT $L206653
	cmp	DWORD PTR _index$[ebp], -3		; fffffffdH
	jne	SHORT $L206653

; 2219 : 				provideBase64CertInfo = TRUE;

	mov	DWORD PTR _provideBase64CertInfo$[ebp], 1
$L206653:

; 2220 : 
; 2221 : 	if ((providePfxCertInfo == FALSE) && 
; 2222 : 		(provideActiveCertInfo == FALSE) && 
; 2223 : 		((index < 0) || (index >= CertificateCount)))

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	jne	SHORT $L206657
	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	jne	SHORT $L206657
	cmp	DWORD PTR _index$[ebp], 0
	jl	SHORT $L206658
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jl	SHORT $L206657
$L206658:

; 2224 : 	{
; 2225 : 		setError(SigHandle, CERT_INDEX_ERROR);

	push	53					; 00000035H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2226 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206647
$L206657:

; 2227 : 	}
; 2228 : 	else
; 2229 : 	{
; 2230 : 		switch (valIndex)

	mov	ecx, DWORD PTR _valIndex$[ebp]
	mov	DWORD PTR tv81[ebp], ecx
	mov	edx, DWORD PTR tv81[ebp]
	sub	edx, 1
	mov	DWORD PTR tv81[ebp], edx
	cmp	DWORD PTR tv81[ebp], 4
	ja	$L206714
	mov	eax, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $L220915[eax*4]
$L206665:

; 2231 : 		{
; 2232 : 			case 1:	if (providePfxCertInfo)

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	je	SHORT $L206666

; 2233 : 						if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3324], 1
	jne	SHORT $L206667

; 2234 : 						{
; 2235 : 							plainHexPtr = Base64BinToPlainHex(PfxCertInfo->serialNumber);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainHexPtr$[ebp], eax

; 2236 : 							*value = A2WBSTR((LPCSTR)plainHexPtr);

	push	-1
	mov	ecx, DWORD PTR _plainHexPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx], eax

; 2237 : 							zFree(plainHexPtr);

	mov	eax, DWORD PTR _plainHexPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2238 : 						}
; 2239 : 						else

	jmp	SHORT $L206669
$L206667:

; 2240 : 							*value = A2WBSTR((LPCSTR)PfxCertInfo->serialNumber);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206669:

; 2241 : 					else 

	jmp	$L206671
$L206666:

; 2242 : 						if (provideActiveCertInfo)

	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	je	SHORT $L206672

; 2243 : 							if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3324], 1
	jne	SHORT $L206673

; 2244 : 							{
; 2245 : 								plainHexPtr = Base64BinToPlainHex(cV[CurrentCertificate]->serialNumber);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainHexPtr$[ebp], eax

; 2246 : 								*value = A2WBSTR((LPCSTR)plainHexPtr);

	push	-1
	mov	edx, DWORD PTR _plainHexPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2247 : 								zFree(plainHexPtr);

	mov	edx, DWORD PTR _plainHexPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2248 : 							}
; 2249 : 							else

	jmp	SHORT $L206675
$L206673:

; 2250 : 								*value = A2WBSTR((LPCSTR)cV[CurrentCertificate]->serialNumber);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [edx], eax
$L206675:

; 2251 : 						else

	jmp	SHORT $L206671
$L206672:

; 2252 : 							if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3324], 1
	jne	SHORT $L206678

; 2253 : 							{
; 2254 : 								plainHexPtr = Base64BinToPlainHex(cV[index]->serialNumber);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _index$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainHexPtr$[ebp], eax

; 2255 : 								*value = A2WBSTR((LPCSTR)plainHexPtr);

	push	-1
	mov	edx, DWORD PTR _plainHexPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2256 : 								zFree(plainHexPtr);

	mov	edx, DWORD PTR _plainHexPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2257 : 							}
; 2258 : 							else

	jmp	SHORT $L206671
$L206678:

; 2259 : 								*value = A2WBSTR((LPCSTR)cV[index]->serialNumber);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206671:

; 2260 : 					break;

	jmp	$L206660
$L206682:

; 2261 : 			case 2: if (providePfxCertInfo)

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	je	SHORT $L206683

; 2262 :                          *value = SysAllocString((const OLECHAR *)PfxCertInfo->issuer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	add	eax, 256				; 00000100H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2263 : 					else if (provideActiveCertInfo)

	jmp	SHORT $L206685
$L206683:
	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	je	SHORT $L206686

; 2264 : 						*value = SysAllocString((const OLECHAR *)cV[CurrentCertificate]->issuer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 256				; 00000100H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2265 : 					else

	jmp	SHORT $L206685
$L206686:

; 2266 : 						*value = SysAllocString((const OLECHAR *)cV[index]->issuer);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 256				; 00000100H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206685:

; 2267 : 					break;

	jmp	$L206660
$L206690:

; 2268 : 			case 3:	if (providePfxCertInfo)

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	je	SHORT $L206691

; 2269 :                          *value = SysAllocString((const OLECHAR *)PfxCertInfo->subject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	add	eax, 768				; 00000300H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2270 : 					else if (provideActiveCertInfo)

	jmp	SHORT $L206693
$L206691:
	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	je	SHORT $L206694

; 2271 : 						*value = SysAllocString((const OLECHAR *)cV[CurrentCertificate]->subject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 768				; 00000300H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2272 : 					else

	jmp	SHORT $L206693
$L206694:

; 2273 : 						*value = SysAllocString((const OLECHAR *)cV[index]->subject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 768				; 00000300H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206693:

; 2274 : 					break;

	jmp	$L206660
$L206698:

; 2275 : 			case 4: if (providePfxCertInfo)

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	je	SHORT $L206699

; 2276 :                          *value = A2WBSTR((LPCSTR)PfxCertInfo->notAfter);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	add	eax, 1792				; 00000700H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2277 : 					else if (provideActiveCertInfo)

	jmp	SHORT $L206701
$L206699:
	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	je	SHORT $L206702

; 2278 : 						*value = A2WBSTR((LPCSTR)cV[CurrentCertificate]->notAfter);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 1792				; 00000700H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2279 : 					else

	jmp	SHORT $L206701
$L206702:

; 2280 : 						*value = A2WBSTR((LPCSTR)cV[index]->notAfter);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 1792				; 00000700H
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206701:

; 2281 : 					break;

	jmp	$L206660
$L206706:

; 2282 : 			case 5: if (providePfxCertInfo)

	cmp	DWORD PTR _providePfxCertInfo$[ebp], 0
	je	SHORT $L206707

; 2283 :                          *value = SysAllocString((const OLECHAR *)PfxCertInfo->shortSubject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	add	eax, 1280				; 00000500H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2284 : 					else if (provideActiveCertInfo)

	jmp	SHORT $L206709
$L206707:
	cmp	DWORD PTR _provideActiveCertInfo$[ebp], 0
	je	SHORT $L206710

; 2285 : 						*value = SysAllocString((const OLECHAR *)cV[CurrentCertificate]->shortSubject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	add	eax, 1280				; 00000500H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax

; 2286 : 					else

	jmp	SHORT $L206709
$L206710:

; 2287 : 						*value = SysAllocString((const OLECHAR *)cV[index]->shortSubject);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 1280				; 00000500H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], eax
$L206709:

; 2288 : 					break;

	jmp	SHORT $L206660
$L206714:

; 2289 : 			default: 
; 2290 : 					setError(SigHandle, CERT_VAL_INDEX_ERROR);

	push	54					; 00000036H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2291 : 					return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L206647
$L206660:

; 2292 : 					break;
; 2293 : 		}
; 2294 : 	}
; 2295 : 	ExitLog;
; 2296 : 	return S_OK;

	xor	eax, eax
$L206647:

; 2297 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L220915:
	DD	$L206665
	DD	$L206682
	DD	$L206690
	DD	$L206698
	DD	$L206706
?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z ENDP	; CSignature::GetCertificateInfo
_TEXT	ENDS
PUBLIC	??0_variant_t@@QAE@_N@Z				; _variant_t::_variant_t
PUBLIC	??1_variant_t@@QAE@XZ				; _variant_t::~_variant_t
PUBLIC	?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z	; CSignature::SetActiveCertificate
PUBLIC	?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ; NetscapeCert::ICertStore::ExportNetscapeCert
PUBLIC	??0_bstr_t@@QAE@ABV_variant_t@@@Z		; _bstr_t::_bstr_t
PUBLIC	??B_bstr_t@@QBEPAGXZ				; _bstr_t::operator unsigned short *
PUBLIC	??B_bstr_t@@QBEPADXZ				; _bstr_t::operator char *
xdata$x	SEGMENT
$T220934 DD	0ffffffffH
	DD	FLAT:$L220922
	DD	00H
	DD	FLAT:$L220923
	DD	01H
	DD	FLAT:$L220925
	DD	00H
	DD	FLAT:$L220925
$T220927 DD	019930520H
	DD	04H
	DD	FLAT:$T220934
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv203 = -116						; size = 4
tv202 = -112						; size = 4
$T220921 = -108						; size = 4
$T220920 = -104						; size = 16
$T220919 = -88						; size = 4
$T220918 = -84						; size = 4
$T220917 = -80						; size = 4
_pfxFilePath$206749 = -72				; size = 4
_pfxX509Cert$206748 = -60				; size = 4
_wCertID$206733 = -52					; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_base64CertId$ = -32					; size = 4
_tmpCertId$ = -24					; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
_status$ = 16						; size = 4
?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z PROC NEAR ; CSignature::SetActiveCertificate

; 2301 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2302 : #ifdef LOGGING
; 2303 : 	char buffer[BUFSIZ];
; 2304 : 	memset(buffer, 0, BUFSIZ);
; 2305 : #endif
; 2306 : 	int i;
; 2307 : 	CComBSTR tmpCertId;

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2308 : 	unsigned char *base64CertId=NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0

; 2309 : 
; 2310 : 	*status = FALSE;

	mov	eax, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax], 0

; 2311 : 
; 2312 : 	EnterLog;
; 2313 : 
; 2314 : 	tmpCertId = certID;

	mov	ecx, DWORD PTR _certID$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2315 : #ifdef LOGGING
; 2316 : 	sprintf((char *)buffer, "tmpCertId.Length() = %d", tmpCertId.Length());
; 2317 : 	DebugLog((const char *)buffer);
; 2318 : #endif
; 2319 : 	if (tmpCertId.Length() == 0)

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206725

; 2320 : 	{
; 2321 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2322 : 		return S_FALSE;

	mov	DWORD PTR $T220917[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220917[ebp]
	jmp	$L206721
$L206725:

; 2323 : 	}
; 2324 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2325 : 	if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3324], 1
	jne	SHORT $L206732

; 2326 : 	{
; 2327 : 		unsigned char *wCertID = HeapW2A(certID);

	mov	edx, DWORD PTR _certID$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wCertID$206733[ebp], eax

; 2328 : 		base64CertId = PlainHexToBase64Bin(wCertID);

	mov	eax, DWORD PTR _wCertID$206733[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z ; CSignature::PlainHexToBase64Bin
	mov	DWORD PTR _base64CertId$[ebp], eax

; 2329 : 		zFree(wCertID);

	mov	ecx, DWORD PTR _wCertID$206733[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 2330 : 	}
; 2331 : 	else

	jmp	SHORT $L206734
$L206732:

; 2332 : 		base64CertId = HeapW2A(certID);

	mov	edx, DWORD PTR _certID$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _base64CertId$[ebp], eax
$L206734:

; 2333 : 	DebugLog((const char *)base64CertId);
; 2334 : 	for (i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L206735
$L206736:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L206735:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	SHORT $L206737

; 2335 : 	{
; 2336 : 		if (!(StrCmp((const char *)cV[i]->serialNumber, (const char *)base64CertId)))

	mov	esi, esp
	mov	eax, DWORD PTR _base64CertId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L206740

; 2337 : 		{
; 2338 : 			CurrentCertificate = i;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+120], eax

; 2339 : 			*status = TRUE;

	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx], 1

; 2340 : 			break;

	jmp	SHORT $L206737
$L206740:

; 2341 : 		}
; 2342 : 		*status = FALSE;

	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [edx], 0

; 2343 : 	}

	jmp	SHORT $L206736
$L206737:

; 2344 : 	if (base64CertId)

	cmp	DWORD PTR _base64CertId$[ebp], 0
	je	SHORT $L206741

; 2345 : 	{
; 2346 : 		zFree(base64CertId);

	mov	eax, DWORD PTR _base64CertId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2347 : 		base64CertId = NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0
$L206741:

; 2348 : 	}
; 2349 : 
; 2350 : 	if ((i==CertificateCount) && (*status == FALSE))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jne	SHORT $L206742
	mov	eax, DWORD PTR _status$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L206742

; 2351 : 	{
; 2352 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2353 : 		CurrentCertificate = NOT_INITIALIZED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -1

; 2354 : 		DebugLog((const char *)"(i==CertificateCount) && (*status == FALSE)");
; 2355 : 		return S_FALSE;

	mov	DWORD PTR $T220918[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220918[ebp]
	jmp	$L206721
$L206742:

; 2356 : 	}
; 2357 : 	if (PfxCertInfo != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+932], 0
	je	SHORT $L206745

; 2358 : 	{
; 2359 : 		if (PfxCertInfo->certificate != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+932]
	cmp	DWORD PTR [eax+2048], 0
	je	SHORT $L206746

; 2360 : 		{
; 2361 : 			zFree(PfxCertInfo->certificate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	eax, DWORD PTR [edx+2048]
	push	eax
	call	_rFree
	add	esp, 4

; 2362 : 			PfxCertInfo->certificate = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	mov	DWORD PTR [edx+2048], 0
$L206746:

; 2363 : 		}
; 2364 : 		zFree(PfxCertInfo);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	call	_rFree
	add	esp, 4

; 2365 : 		PfxCertInfo = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+932], 0
$L206745:

; 2366 : 	}
; 2367 : #ifdef WIN32
; 2368 : 	if ((UsingNetscape) && (nsCertStoreObj != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3388], 0
	je	$L206747
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3380], 0
	je	$L206747

; 2369 : 	{
; 2370 : 		BSTR pfxX509Cert;
; 2371 : 
; 2372 : 		_bstr_t pfxFilePath = nsCertStoreObj->ExportNetscapeCert(_bstr_t(cV[CurrentCertificate]->serialNumber));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	cmp	DWORD PTR [edx+eax*4], 0
	setne	al
	push	eax
	lea	ecx, DWORD PTR $T220920[ebp]
	call	??0_variant_t@@QAE@_N@Z			; _variant_t::_variant_t
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T220919[ebp], esp
	lea	edx, DWORD PTR $T220920[ebp]
	push	edx
	call	??0_bstr_t@@QAE@ABV_variant_t@@@Z	; _bstr_t::_bstr_t
	mov	DWORD PTR tv202[ebp], eax
	lea	eax, DWORD PTR _pfxFilePath$206749[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3380]
	call	?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ; NetscapeCert::ICertStore::ExportNetscapeCert
	mov	DWORD PTR tv203[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T220920[ebp]
	call	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t

; 2373 : 		SetActivePFXFileCert(pfxFilePath, nsStorePassword, &pfxX509Cert);

	mov	esi, esp
	lea	edx, DWORD PTR _pfxX509Cert$206748[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3384]
	push	ecx
	lea	ecx, DWORD PTR _pfxFilePath$206749[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+304]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2374 : 		DeleteFile((LPCTSTR)(char *)pfxFilePath);

	lea	ecx, DWORD PTR _pfxFilePath$206749[ebp]
	call	??B_bstr_t@@QBEPADXZ			; _bstr_t::operator char *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2375 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pfxFilePath$206749[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L206747:

; 2376 : #endif
; 2377 : 	ExitLog;
; 2378 : 	return S_OK;

	mov	DWORD PTR $T220921[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T220921[ebp]
$L206721:

; 2379 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220933
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L220933:
	DD	3
	DD	$L220932
$L220932:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L220928
	DD	-60					; ffffffc4H
	DD	4
	DD	$L220929
	DD	-72					; ffffffb8H
	DD	4
	DD	$L220930
$L220930:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L220929:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L220928:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L220922:
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L220923:
	lea	ecx, DWORD PTR $T220920[ebp]
	jmp	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t
$L220925:
	lea	ecx, DWORD PTR _pfxFilePath$206749[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z:
	mov	eax, OFFSET FLAT:$T220927
	jmp	___CxxFrameHandler
text$x	ENDS
?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z ENDP	; CSignature::SetActiveCertificate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\comutil.h
;	COMDAT ??B_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??B_bstr_t@@QBEPAGXZ PROC NEAR				; _bstr_t::operator unsigned short *, COMDAT
; _this$ = ecx

; 411  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 412  :     return const_cast<wchar_t*>((m_Data != NULL) ? m_Data->GetWString() : NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L220936
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ	; _bstr_t::Data_t::GetWString
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $L220937
$L220936:
	mov	DWORD PTR tv68[ebp], 0
$L220937:
	mov	eax, DWORD PTR tv68[ebp]

; 413  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??B_bstr_t@@QBEPAGXZ ENDP				; _bstr_t::operator unsigned short *
_TEXT	ENDS
PUBLIC	?GetString@Data_t@_bstr_t@@QBEPBDXZ		; _bstr_t::Data_t::GetString
; Function compile flags: /Odt /RTCsu
;	COMDAT ??B_bstr_t@@QBEPADXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??B_bstr_t@@QBEPADXZ PROC NEAR				; _bstr_t::operator char *, COMDAT
; _this$ = ecx

; 425  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 426  :     return const_cast<char*>((m_Data != NULL) ? m_Data->GetString() : NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L220940
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?GetString@Data_t@_bstr_t@@QBEPBDXZ	; _bstr_t::Data_t::GetString
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $L220941
$L220940:
	mov	DWORD PTR tv68[ebp], 0
$L220941:
	mov	eax, DWORD PTR tv68[ebp]

; 427  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??B_bstr_t@@QBEPADXZ ENDP				; _bstr_t::operator char *
_TEXT	ENDS
EXTRN	?ConvertBSTRToString@_com_util@@YGPADPAG@Z:NEAR	; _com_util::ConvertBSTRToString
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetString@Data_t@_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetString@Data_t@_bstr_t@@QBEPBDXZ PROC NEAR		; _bstr_t::Data_t::GetString, COMDAT
; _this$ = ecx

; 730  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 731  :     if (m_str == NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L198599

; 732  :         m_str = _com_util::ConvertBSTRToString(m_wstr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?ConvertBSTRToString@_com_util@@YGPADPAG@Z ; _com_util::ConvertBSTRToString
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L198599:

; 733  :     }
; 734  : 
; 735  :     return m_str;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]

; 736  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetString@Data_t@_bstr_t@@QBEPBDXZ ENDP		; _bstr_t::Data_t::GetString
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_boolSrc$ = 8						; size = 1
??0_variant_t@@QAE@_N@Z PROC NEAR			; _variant_t::_variant_t, COMDAT
; _this$ = ecx

; 1225 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1226 :     V_VT(this) = VT_BOOL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax], 11			; 0000000bH

; 1227 :     V_BOOL(this) = (boolSrc ? VARIANT_TRUE : VARIANT_FALSE);

	movzx	ecx, BYTE PTR _boolSrc$[ebp]
	neg	ecx
	sbb	ecx, ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+8], cx

; 1228 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_variant_t@@QAE@_N@Z ENDP				; _variant_t::_variant_t
_TEXT	ENDS
PUBLIC	?CheckError@_com_util@@YAXJ@Z			; _com_util::CheckError
EXTRN	__imp__VariantClear@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_variant_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_variant_t@@QAE@XZ PROC NEAR				; _variant_t::~_variant_t, COMDAT
; _this$ = ecx

; 2231 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2232 :     _com_util::CheckError(::VariantClear(this));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	?CheckError@_com_util@@YAXJ@Z		; _com_util::CheckError
	add	esp, 4

; 2233 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_variant_t@@QAE@XZ ENDP				; _variant_t::~_variant_t
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?CheckError@_com_util@@YAXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?CheckError@_com_util@@YAXJ@Z PROC NEAR			; _com_util::CheckError, COMDAT

; 54   :     {

	push	ebp
	mov	ebp, esp

; 55   :         if (FAILED(hr)) {

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L198204

; 56   :             _com_issue_error(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198204:

; 57   :         }
; 58   :     }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?CheckError@_com_util@@YAXJ@Z ENDP			; _com_util::CheckError
_TEXT	ENDS
PUBLIC	?ChangeType@_variant_t@@QAEXGPBV1@@Z		; _variant_t::ChangeType
PUBLIC	??4_bstr_t@@QAEAAV0@PBG@Z			; _bstr_t::operator=
PUBLIC	??0_variant_t@@QAE@XZ				; _variant_t::_variant_t
;	COMDAT xdata$x
xdata$x	SEGMENT
$T220959 DD	0ffffffffH
	DD	FLAT:$L220952
$T220954 DD	019930520H
	DD	01H
	DD	FLAT:$T220959
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@ABV_variant_t@@@Z
_TEXT	SEGMENT
_varDest$ = -36						; size = 16
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_var$ = 8						; size = 4
??0_bstr_t@@QAE@ABV_variant_t@@@Z PROC NEAR		; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 2245 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@ABV_variant_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2246 :     if (V_VT(&var) == VT_BSTR) {

	mov	ecx, DWORD PTR _var$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 8
	jne	SHORT $L199308

; 2247 :         *this = V_BSTR(&var);

	mov	eax, DWORD PTR _var$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_bstr_t@@QAEAAV0@PBG@Z		; _bstr_t::operator=

; 2248 :         return;

	jmp	SHORT $L199307
$L199308:

; 2249 :     }
; 2250 : 
; 2251 :     _variant_t varDest;

	lea	ecx, DWORD PTR _varDest$[ebp]
	call	??0_variant_t@@QAE@XZ			; _variant_t::_variant_t
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2252 :     varDest.ChangeType(VT_BSTR, &var);

	mov	edx, DWORD PTR _var$[ebp]
	push	edx
	push	8
	lea	ecx, DWORD PTR _varDest$[ebp]
	call	?ChangeType@_variant_t@@QAEXGPBV1@@Z	; _variant_t::ChangeType

; 2253 : 
; 2254 :     *this = V_BSTR(&varDest);

	mov	eax, DWORD PTR _varDest$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_bstr_t@@QAEAAV0@PBG@Z		; _bstr_t::operator=

; 2255 : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _varDest$[ebp]
	call	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t
$L199307:
	mov	eax, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220958
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L220958:
	DD	1
	DD	$L220957
$L220957:
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$L220955
$L220955:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220952:
	lea	ecx, DWORD PTR _varDest$[ebp]
	jmp	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t
__ehhandler$??0_bstr_t@@QAE@ABV_variant_t@@@Z:
	mov	eax, OFFSET FLAT:$T220954
	jmp	___CxxFrameHandler
text$x	ENDS
??0_bstr_t@@QAE@ABV_variant_t@@@Z ENDP			; _bstr_t::_bstr_t
PUBLIC	??0Data_t@_bstr_t@@QAE@PBG@Z			; _bstr_t::Data_t::Data_t
PUBLIC	??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@ ; `string'
EXTRN	__assert:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T220973 DD	0ffffffffH
	DD	FLAT:$L220969
$T220971 DD	019930520H
	DD	01H
	DD	FLAT:$T220973
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\include\comutil.h'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@
CONST	SEGMENT
??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@ DB 's'
	DB	' == 0 || (const wchar_t*) *this != s', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??4_bstr_t@@QAEAAV0@PBG@Z
_TEXT	SEGMENT
tv81 = -28						; size = 4
$T220966 = -24						; size = 4
$T220965 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??4_bstr_t@@QAEAAV0@PBG@Z PROC NEAR			; _bstr_t::operator=, COMDAT
; _this$ = ecx

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_bstr_t@@QAEAAV0@PBG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 325  :     _COM_ASSERT(s == NULL || (const wchar_t*) *this != s);

	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $L220964
	mov	ecx, DWORD PTR _this$[ebp]
	call	??B_bstr_t@@QBEPBGXZ			; _bstr_t::operator unsigned short const *
	cmp	eax, DWORD PTR _s$[ebp]
	jne	SHORT $L220964
	push	325					; 00000145H
	push	OFFSET FLAT:??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@
	call	__assert
	add	esp, 12					; 0000000cH
$L220964:

; 326  : 
; 327  :     _Free();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free@_bstr_t@@AAEXXZ			; _bstr_t::_Free

; 328  : 
; 329  :     m_Data = new Data_t(s);

	push	12					; 0000000cH
	call	??2Data_t@_bstr_t@@SAPAXI@Z		; _bstr_t::Data_t::operator new
	add	esp, 4
	mov	DWORD PTR $T220966[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T220966[ebp], 0
	je	SHORT $L220967
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T220966[ebp]
	call	??0Data_t@_bstr_t@@QAE@PBG@Z		; _bstr_t::Data_t::Data_t
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $L220968
$L220967:
	mov	DWORD PTR tv81[ebp], 0
$L220968:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR $T220965[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220965[ebp]
	mov	DWORD PTR [eax], ecx

; 330  :     if (m_Data == NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L198393

; 331  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198393:

; 332  :     }
; 333  : 
; 334  :     return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 335  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220969:
	mov	eax, DWORD PTR $T220966[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??4_bstr_t@@QAEAAV0@PBG@Z:
	mov	eax, OFFSET FLAT:$T220971
	jmp	___CxxFrameHandler
text$x	ENDS
??4_bstr_t@@QAEAAV0@PBG@Z ENDP				; _bstr_t::operator=
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??0Data_t@_bstr_t@@QAE@PBG@Z PROC NEAR			; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 612  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 613  :     m_wstr = ::SysAllocString(s);

	mov	esi, esp
	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 614  : 
; 615  :     if (m_wstr == NULL && s != NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L198539
	cmp	DWORD PTR _s$[ebp], 0
	je	SHORT $L198539

; 616  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198539:

; 617  :     }
; 618  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0Data_t@_bstr_t@@QAE@PBG@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
EXTRN	__imp__VariantInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_variant_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_variant_t@@QAE@XZ PROC NEAR				; _variant_t::_variant_t, COMDAT
; _this$ = ecx

; 1034 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1035 :     ::VariantInit(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1036 : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_variant_t@@QAE@XZ ENDP				; _variant_t::_variant_t
_TEXT	ENDS
EXTRN	__imp__VariantChangeType@16:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?ChangeType@_variant_t@@QAEXGPBV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vartype$ = 8						; size = 2
_pSrc$ = 12						; size = 4
?ChangeType@_variant_t@@QAEXGPBV1@@Z PROC NEAR		; _variant_t::ChangeType, COMDAT
; _this$ = ecx

; 2204 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2205 :     //
; 2206 :     // If pDest is NULL, convert type in place
; 2207 :     //
; 2208 :     if (pSrc == NULL) {

	cmp	DWORD PTR _pSrc$[ebp], 0
	jne	SHORT $L199291

; 2209 :         pSrc = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pSrc$[ebp], eax
$L199291:

; 2210 :     }
; 2211 : 
; 2212 :     if ((this != pSrc) || (vartype != V_VT(this))) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR _pSrc$[ebp]
	jne	SHORT $L199293
	movzx	edx, WORD PTR _vartype$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	edx, ecx
	je	SHORT $L199290
$L199293:

; 2213 :         _com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
; 2214 :                                                   const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
; 2215 :                                                   0, vartype));

	mov	esi, esp
	mov	dx, WORD PTR _vartype$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__VariantChangeType@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	?CheckError@_com_util@@YAXJ@Z		; _com_util::CheckError
	add	esp, 4
$L199290:

; 2216 :     }
; 2217 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?ChangeType@_variant_t@@QAEXGPBV1@@Z ENDP		; _variant_t::ChangeType
_TEXT	ENDS
PUBLIC	__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
PUBLIC	??0_bstr_t@@QAE@PAG_N@Z				; _bstr_t::_bstr_t
EXTRN	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z:NEAR ; _com_issue_errorex
;	COMDAT xdata$x
; File c:\activex\xmlsign\nssdebug\netscapecert.tli
xdata$x	SEGMENT
$T220994 DD	0ffffffffH
	DD	FLAT:$L220984
$T220989 DD	019930520H
	DD	01H
	DD	FLAT:$T220994
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
CONST	SEGMENT
__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd DD 0d61aa35H
	DW	048d5H
	DW	047f5H
	DB	082H
	DB	049H
	DB	0f6H
	DB	085H
	DB	0f7H
	DB	052H
	DB	050H
	DB	0fdH
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT
$T220986 = -36						; size = 4
__hr$ = -32						; size = 4
__result$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_certSerialNumber$ = 12					; size = 4
?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z PROC NEAR ; NetscapeCert::ICertStore::ExportNetscapeCert, COMDAT
; _this$ = ecx

; 26   : inline _bstr_t ICertStore::ExportNetscapeCert ( _bstr_t certSerialNumber ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T220986[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 27   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 28   :     HRESULT _hr = raw_ExportNetscapeCert(certSerialNumber, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	lea	ecx, DWORD PTR _certSerialNumber$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+36]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 29   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201298
	push	OFFSET FLAT:__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201298:

; 30   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T220986[ebp]
	or	ecx, 1
	mov	DWORD PTR $T220986[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _certSerialNumber$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 31   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L220993
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L220993:
	DD	1
	DD	$L220992
$L220992:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L220990
$L220990:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L220984:
	lea	ecx, DWORD PTR _certSerialNumber$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z:
	mov	eax, OFFSET FLAT:$T220989
	jmp	___CxxFrameHandler
text$x	ENDS
?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ENDP ; NetscapeCert::ICertStore::ExportNetscapeCert
PUBLIC	??0Data_t@_bstr_t@@QAE@PAG_N@Z			; _bstr_t::Data_t::Data_t
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\comutil.h
xdata$x	SEGMENT
$T221007 DD	0ffffffffH
	DD	FLAT:$L221003
$T221005 DD	019930520H
	DD	01H
	DD	FLAT:$T221007
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT
tv73 = -28						; size = 4
$T221000 = -24						; size = 4
$T220999 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_bstr$ = 8						; size = 4
_fCopy$ = 12						; size = 1
??0_bstr_t@@QAE@PAG_N@Z PROC NEAR			; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 272  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@PAG_N@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	push	12					; 0000000cH
	call	??2Data_t@_bstr_t@@SAPAXI@Z		; _bstr_t::Data_t::operator new
	add	esp, 4
	mov	DWORD PTR $T221000[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T221000[ebp], 0
	je	SHORT $L221001
	mov	al, BYTE PTR _fCopy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221000[ebp]
	call	??0Data_t@_bstr_t@@QAE@PAG_N@Z		; _bstr_t::Data_t::Data_t
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $L221002
$L221001:
	mov	DWORD PTR tv73[ebp], 0
$L221002:
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T220999[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T220999[ebp]
	mov	DWORD PTR [eax], ecx

; 273  :     if (m_Data == NULL) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L198357

; 274  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198357:

; 275  :     }
; 276  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L221003:
	mov	eax, DWORD PTR $T221000[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0_bstr_t@@QAE@PAG_N@Z:
	mov	eax, OFFSET FLAT:$T221005
	jmp	___CxxFrameHandler
text$x	ENDS
??0_bstr_t@@QAE@PAG_N@Z ENDP				; _bstr_t::_bstr_t
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0Data_t@_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bstr$ = 8						; size = 4
_fCopy$ = 12						; size = 1
??0Data_t@_bstr_t@@QAE@PAG_N@Z PROC NEAR		; _bstr_t::Data_t::Data_t, COMDAT
; _this$ = ecx

; 625  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 1

; 626  :     if (fCopy && bstr != NULL) {

	movzx	edx, BYTE PTR _fCopy$[ebp]
	test	edx, edx
	je	SHORT $L198547
	cmp	DWORD PTR _bstr$[ebp], 0
	je	SHORT $L198547

; 627  :         m_wstr = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
; 628  :                                          ::SysStringByteLen(bstr));

	mov	esi, esp
	mov	eax, DWORD PTR _bstr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _bstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 629  : 
; 630  :         if (m_wstr == NULL) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L198549

; 631  :             _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198549:

; 632  :         }
; 633  :     }
; 634  :     else {

	jmp	SHORT $L198546
$L198547:

; 635  :         m_wstr = bstr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _bstr$[ebp]
	mov	DWORD PTR [ecx], edx
$L198546:

; 636  :     }
; 637  : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0Data_t@_bstr_t@@QAE@PAG_N@Z ENDP			; _bstr_t::Data_t::Data_t
_TEXT	ENDS
PUBLIC	?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z ; CSignature::get_SignedDocumentPath
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_k$206779 = -24						; size = 4
__lpa$ = -20						; size = 4
__lpw$ = -16						; size = 4
__acp$ = -12						; size = 4
__convert$ = -8						; size = 4
_maxUri$ = -4						; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_uriIndex$ = 16						; size = 4
_pVal$ = 20						; size = 4
?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z PROC NEAR ; CSignature::get_SignedDocumentPath

; 2382 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2383 : 	int maxUri=0;

	mov	DWORD PTR _maxUri$[ebp], 0

; 2384 : 
; 2385 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 2386 : 
; 2387 : 	EnterLog;
; 2388 : 
; 2389 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L206765

; 2390 : 	{
; 2391 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2392 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206763
$L206765:

; 2393 : 	}
; 2394 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L206768
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L206767
$L206768:

; 2395 : 	{
; 2396 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2397 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206763
$L206767:

; 2398 : 	}
; 2399 : 
; 2400 : 	maxUri = sgArr[sigIndex]->refNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _maxUri$[ebp], eax

; 2401 : 
; 2402 : 	if ((uriIndex >= maxUri) || (uriIndex < 0))

	mov	ecx, DWORD PTR _uriIndex$[ebp]
	cmp	ecx, DWORD PTR _maxUri$[ebp]
	jge	SHORT $L206771
	cmp	DWORD PTR _uriIndex$[ebp], 0
	jge	SHORT $L206770
$L206771:

; 2403 : 	{
; 2404 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2405 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206763
$L206770:

; 2406 : 	}
; 2407 : 
; 2408 : 	if (uriArr == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $L206773

; 2409 : 	{
; 2410 : 		setError(SigHandle, DOC_PATH_NOT_FOUND);

	push	55					; 00000037H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2411 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L206763
$L206773:

; 2412 : 	}
; 2413 : 
; 2414 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2415 : 
; 2416 : 	for (int k=0; k<totalUriCount; k++)

	mov	DWORD PTR _k$206779[ebp], 0
	jmp	SHORT $L206780
$L206781:
	mov	ecx, DWORD PTR _k$206779[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$206779[ebp], ecx
$L206780:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _k$206779[ebp]
	cmp	eax, DWORD PTR [edx+40]
	jge	SHORT $L206782

; 2417 : 	{
; 2418 : 		if (!(strcmp((const char *)sgArr[sigIndex]->refArray[uriIndex]->URI, (const char *)uriArr[k]->URI)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _k$206779[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _uriIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L206785

; 2419 : 		{
; 2420 : 			*pVal = A2WBSTR((LPCSTR)uriArr[k]->fullPath);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _k$206779[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 2421 : 			ExitLog;
; 2422 : 			return S_OK;

	xor	eax, eax
	jmp	SHORT $L206763
$L206785:

; 2423 : 		}
; 2424 : 	}

	jmp	SHORT $L206781
$L206782:

; 2425 : 	setError(SigHandle, DOC_PATH_NOT_FOUND);

	push	55					; 00000037H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2426 : 	return S_FALSE;

	mov	eax, 1
$L206763:

; 2427 : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z ENDP	; CSignature::get_SignedDocumentPath
_TEXT	ENDS
PUBLIC	?FetchSignatureStatus@CSignature@@QAEXHH@Z	; CSignature::FetchSignatureStatus
PUBLIC	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert
EXTRN	__imp__GetTempFileNameA@16:NEAR
EXTRN	__imp__CreateFileA@28:NEAR
EXTRN	_base64decodeSize:NEAR
EXTRN	_base64decode:NEAR
EXTRN	__imp__WriteFile@20:NEAR
EXTRN	__imp__CloseHandle@4:NEAR
EXTRN	_axGetSignature:NEAR
EXTRN	__imp__GetTempPathA@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T221021 = -408						; size = 4
$T221020 = -404						; size = 4
$T221019 = -400						; size = 4
$T221018 = -396						; size = 4
$T221017 = -392						; size = 4
$T221016 = -388						; size = 4
_tmpFilePath$206943 = -380				; size = 4
_k$206924 = -372					; size = 4
_m$206920 = -368					; size = 4
_tmpFilePath$206889 = -360				; size = 4
_k$206870 = -352					; size = 4
_m$206866 = -348					; size = 4
__lpa$ = -344						; size = 4
__lpw$ = -340						; size = 4
__acp$ = -336						; size = 4
__convert$ = -332					; size = 4
_decodedDataPtr$ = -328					; size = 4
_TempPath$ = -320					; size = 260
_dwBytesToWrite$ = -56					; size = 4
_dwBytesWritten$ = -48					; size = 4
_hTempFile$ = -40					; size = 4
_uriPath$ = -36						; size = 4
_refArr$ = -32						; size = 4
_failedLocNum$ = -28					; size = 4
_totalLocNum$ = -24					; size = 4
_refNum$ = -20						; size = 4
_j$ = -16						; size = 4
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_verifyResult$ = 8					; size = 4
_extractSignedContent$ = 12				; size = 4
?FetchSignatureStatus@CSignature@@QAEXHH@Z PROC NEAR	; CSignature::FetchSignatureStatus
; _this$ = ecx

; 2432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 408				; 00000198H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-408]
	mov	ecx, 102				; 00000066H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2433 : 	int i,j, refNum=0, totalLocNum=0, failedLocNum=0;

	mov	DWORD PTR _refNum$[ebp], 0
	mov	DWORD PTR _totalLocNum$[ebp], 0
	mov	DWORD PTR _failedLocNum$[ebp], 0

; 2434 : 	PURI_STATUS *refArr=NULL;

	mov	DWORD PTR _refArr$[ebp], 0

; 2435 : 	PURI_PATH uriPath=NULL;

	mov	DWORD PTR _uriPath$[ebp], 0

; 2436 : #ifdef WIN32
; 2437 : 	HANDLE hTempFile; 
; 2438 : #else
; 2439 : 	FILE *hTempFile;
; 2440 : #endif
; 2441 : 	DWORD  dwBytesWritten, dwBytesToWrite;
; 2442 : 	char TempPath[MAX_PATH];
; 2443 : 	char *decodedDataPtr;
; 2444 : 
; 2445 : 	EnterLog;
; 2446 : 	
; 2447 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2448 : 	if (uriArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L206810

; 2449 : 		FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L206810:

; 2450 : 	failedUriCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 2451 : 	totalUriCount  = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 2452 : 	sgArr = axGetSignature(&signum, SigHandle); // Get the full signature stats

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 2453 : 
; 2454 : 	if (signum == 0) // No signature was found or XML error

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $L206811

; 2455 : 		return;

	jmp	$L206793
$L206811:

; 2456 : 
; 2457 : 	if (verifyResult != TRUE) // At Least One Signature Verification failed

	cmp	DWORD PTR _verifyResult$[ebp], 1
	je	$L206812

; 2458 : 	{
; 2459 : 	// Find out how many URIs were signed and how many failed verification
; 2460 : 
; 2461 : 		for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L206813
$L206814:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L206813:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L206815

; 2462 : 		{
; 2463 : 			refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _refNum$[ebp], ecx

; 2464 : 			refArr = sgArr[i]->refArray;  // The URI Array itself

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _refArr$[ebp], eax

; 2465 : 				
; 2466 : 			if (sgArr[i]->status == FALSE) // Signature verification failed

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $L206816

; 2467 : 				for (j=0; j<refNum; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L206817
$L206818:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L206817:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _refNum$[ebp]
	jge	SHORT $L206819

; 2468 : 				{
; 2469 : 					if (refArr[j]->status == FALSE)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L206820

; 2470 : 						failedUriCount++; // Increase the number of failed URI by one

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+36], edx
$L206820:

; 2471 : 					totalUriCount++;	  // Increase the total URI count by one

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx

; 2472 : 				}

	jmp	SHORT $L206818
$L206819:
	jmp	SHORT $L206821
$L206816:

; 2473 : 			else // Signature verification was successful
; 2474 : 				totalUriCount += refNum; // Increase the total number of URIs by refNum

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	add	edx, DWORD PTR _refNum$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], edx
$L206821:

; 2475 : 		}

	jmp	$L206814
$L206815:

; 2476 : 
; 2477 : 		uriArr = (PURI_PATH *)zMalloc(sizeof(PURI_PATH)*totalUriCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2478 : 		failedUriArr = (PURI_PATH *)zMalloc(sizeof(PURI_PATH)*failedUriCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 2479 : 
; 2480 : 		for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L206826
$L206827:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L206826:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L206828

; 2481 : 		{
; 2482 : 			refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _refNum$[ebp], eax

; 2483 : 			refArr = sgArr[i]->refArray;  // The URI Array itself

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _refArr$[ebp], edx

; 2484 : 				
; 2485 : 			if (sgArr[i]->status == FALSE) // Signature verification failed

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 0
	jne	$L206829

; 2486 : 			{
; 2487 : 				for (j=0; j<refNum; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L206830
$L206831:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L206830:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _refNum$[ebp]
	jge	$L206832

; 2488 : 				{
; 2489 : 					uriPath = (PURI_PATH) zMalloc(sizeof(URI_PATH));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _uriPath$[ebp], eax

; 2490 : 					uriPath->fullPath = (unsigned char *)zMalloc(MAX_PATH * 2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2491 : 					uriPath->sigId = (unsigned char *)zMalloc(MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx], eax

; 2492 : 					uriPath->URI = (unsigned char *)zMalloc (MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2493 : 					
; 2494 : 					if (sgArr[i]->sigId != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L206838

; 2495 : 						strcpy((char *)uriPath->sigId,(const char *)sgArr[i]->sigId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcpy
	add	esp, 8
$L206838:

; 2496 : 					if (refArr[j]->URI != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L206841

; 2497 : 						strcpy((char *)uriPath->URI,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8
$L206841:

; 2498 : 					if (refArr[j]->URI != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L206844

; 2499 : 						strcpy((char *)uriPath->fullPath,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8
$L206844:

; 2500 : 
; 2501 : 						
; 2502 : 					if (refArr[j]->status == FALSE)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L206847

; 2503 : 					{
; 2504 : 						failedUriArr[failedLocNum] = uriPath;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _failedLocNum$[ebp]
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2505 : 						failedLocNum++;

	mov	edx, DWORD PTR _failedLocNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _failedLocNum$[ebp], edx
$L206847:

; 2506 : 					}
; 2507 : 					uriArr[totalLocNum] = uriPath; // Failed Uris are referenced 2 places

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _totalLocNum$[ebp]
	mov	eax, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 2508 : 					totalLocNum++;

	mov	ecx, DWORD PTR _totalLocNum$[ebp]
	add	ecx, 1
	mov	DWORD PTR _totalLocNum$[ebp], ecx

; 2509 : 				}

	jmp	$L206831
$L206832:

; 2510 : 			}
; 2511 : 			else // Signature verification was successful

	jmp	$L206848
$L206829:

; 2512 : 				for (j=0; j<refNum; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L206849
$L206850:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L206849:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _refNum$[ebp]
	jge	$L206848

; 2513 : 				{
; 2514 : 					uriPath = (PURI_PATH) zMalloc(sizeof(URI_PATH));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _uriPath$[ebp], eax

; 2515 : 					uriPath->fullPath = (unsigned char *)zMalloc(MAX_PATH * 2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2516 : 					uriPath->sigId = (unsigned char *)zMalloc(MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx], eax

; 2517 : 					uriPath->URI = (unsigned char *)zMalloc (MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2518 : 
; 2519 : 					if (sgArr[i]->sigId != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L206857

; 2520 : 						strcpy((char *)uriPath->sigId,(const char *)sgArr[i]->sigId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcpy
	add	esp, 8
$L206857:

; 2521 : 					if (refArr[j]->URI != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L206860

; 2522 : 					{
; 2523 : 						strcpy((char *)uriPath->URI,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8

; 2524 : 						strcpy((char *)uriPath->fullPath,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8
$L206860:

; 2525 : 					}
; 2526 : 
; 2527 : 
; 2528 : 					uriArr[totalLocNum] = uriPath;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _totalLocNum$[ebp]
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2529 : 					totalLocNum++;

	mov	edx, DWORD PTR _totalLocNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _totalLocNum$[ebp], edx

; 2530 : 				}

	jmp	$L206850
$L206848:

; 2531 : 			if (extractSignedContent == TRUE)

	cmp	DWORD PTR _extractSignedContent$[ebp], 1
	jne	$L206865

; 2532 : 			{
; 2533 : 				for (int m=0; m<refNum; m++)

	mov	DWORD PTR _m$206866[ebp], 0
	jmp	SHORT $L206867
$L206868:
	mov	eax, DWORD PTR _m$206866[ebp]
	add	eax, 1
	mov	DWORD PTR _m$206866[ebp], eax
$L206867:
	mov	ecx, DWORD PTR _m$206866[ebp]
	cmp	ecx, DWORD PTR _refNum$[ebp]
	jge	$L206865

; 2534 : 				{
; 2535 : 					for (int k=0; k<totalLocNum; k++) 

	mov	DWORD PTR _k$206870[ebp], 0
	jmp	SHORT $L206871
$L206872:
	mov	edx, DWORD PTR _k$206870[ebp]
	add	edx, 1
	mov	DWORD PTR _k$206870[ebp], edx
$L206871:
	mov	eax, DWORD PTR _k$206870[ebp]
	cmp	eax, DWORD PTR _totalLocNum$[ebp]
	jge	$L206873

; 2536 : 					{
; 2537 : 						if ((!(strcmp((const char *)refArr[m]->URI, (const char *)uriArr[k]->URI))) &&
; 2538 : 							(refArr[m]->refObject != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _k$206870[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _m$206866[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$L206876
	mov	ecx, DWORD PTR _m$206866[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+12], 0
	je	$L206876

; 2539 : 						{
; 2540 : 							GetTempPath((DWORD)MAX_PATH, TempPath);

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2541 : 							GetTempFileName(TempPath, // dir. for temp. files 
; 2542 : 								"INFM",                // temp. file name prefix 
; 2543 : 								0,                    // create unique name 
; 2544 : 								szTempName);          // buffer for name 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG206878
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2545 : #ifdef WIN32
; 2546 : 							hTempFile = CreateFile((LPCSTR) szTempName,  // file name 
; 2547 : 								GENERIC_READ | GENERIC_WRITE, // open for read/write 
; 2548 : 								0,                            // do not share 
; 2549 : 								NULL,                         // no security 
; 2550 : 								CREATE_ALWAYS,                // overwrite existing file
; 2551 : 								FILE_ATTRIBUTE_NORMAL,        // normal file 
; 2552 : 								NULL);                        // no attr. template 

	mov	esi, esp
	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hTempFile$[ebp], eax

; 2553 : 							if (hTempFile == INVALID_HANDLE_VALUE) 

	cmp	DWORD PTR _hTempFile$[ebp], -1
	jne	SHORT $L206882

; 2554 : 								break;

	jmp	$L206873
$L206882:

; 2555 : #else
; 2556 : 							hTempFile = fopen(szTempName, "w+");
; 2557 : 							if (!hTempFile)
; 2558 : 								break;
; 2559 : #endif
; 2560 : 							dwBytesToWrite = base64decodeSize((DWORD)strlen((const char *)refArr[m]->refObject->encodedData));

	mov	edx, DWORD PTR _m$206866[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 2561 : 							decodedDataPtr = (char *)zMalloc (dwBytesToWrite+1);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _decodedDataPtr$[ebp], eax

; 2562 : 							memset(decodedDataPtr,0,dwBytesToWrite+1);

	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	add	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2563 : 							if ((dwBytesToWrite = base64decode(refArr[m]->refObject->encodedData,(unsigned char *)decodedDataPtr,dwBytesToWrite))==-1) 

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$206866[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax
	cmp	DWORD PTR _dwBytesToWrite$[ebp], -1
	jne	SHORT $L206887

; 2564 : 						{
; 2565 : 							// Close file. 
; 2566 : #ifdef WIN32
; 2567 : 							CloseHandle(hTempFile); 

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2568 : #else
; 2569 : 							fclose(hTempFile);
; 2570 : #endif
; 2571 : 							zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2572 : 							continue;

	jmp	$L206872
$L206887:

; 2573 : 						}
; 2574 : 
; 2575 : 							// Write the signature buffer to the temporary file. 
; 2576 : #ifdef WIN32
; 2577 : 							WriteFile(hTempFile, decodedDataPtr, dwBytesToWrite , 
; 2578 : 										&dwBytesWritten, NULL); 

	mov	esi, esp
	push	0
	lea	ecx, DWORD PTR _dwBytesWritten$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	push	edx
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hTempFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2579 : 							// Close file. 
; 2580 : 							CloseHandle(hTempFile);

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2581 : #else
; 2582 : 							dwBytesWritten = fwrite(decodedDataPtr, 1, dwBytesToWrite, hTempFile);
; 2583 : 							fclose(hTempFile);
; 2584 : #endif
; 2585 : 							zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2586 : 							strcpy((char *)uriArr[k]->fullPath, szTempName);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _k$206870[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8

; 2587 : 							TEMP_FILE_INFO *tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221016[ebp], eax
	mov	ecx, DWORD PTR $T221016[ebp]
	mov	DWORD PTR _tmpFilePath$206889[ebp], ecx

; 2588 : 							strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$206889[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2589 : 							tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$206889[ebp]
	push	ecx
	lea	edx, DWORD PTR $T221017[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T221018[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 2590 : 							break;

	jmp	SHORT $L206873
$L206876:

; 2591 : 						}
; 2592 : 					}

	jmp	$L206872
$L206873:

; 2593 : 				}

	jmp	$L206868
$L206865:

; 2594 : 			}
; 2595 : 
; 2596 : 		} /* end for each signature in the document loop */

	jmp	$L206827
$L206828:

; 2597 : 		return;

	jmp	$L206793
$L206812:

; 2598 : 	} // end if signature failed
; 2599 : 
; 2600 : 	// signature verification was successful
; 2601 : 
; 2602 : 	for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L206895
$L206896:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L206895:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L206897

; 2603 : 	{
; 2604 : 		refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _refNum$[ebp], edx

; 2605 : 		totalUriCount += refNum; // Increase the total number of URIs by refNum

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	add	ecx, DWORD PTR _refNum$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], ecx

; 2606 : 	}

	jmp	SHORT $L206896
$L206897:

; 2607 : 
; 2608 : 	uriArr = (PURI_PATH *)zMalloc(sizeof(PURI_PATH)*totalUriCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], eax

; 2609 : 	failedUriArr = NULL; // Signature verification was successful

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 2610 : 	totalLocNum = 0;

	mov	DWORD PTR _totalLocNum$[ebp], 0

; 2611 : 
; 2612 : 	for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L206900
$L206901:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L206900:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	$L206793

; 2613 : 	{
; 2614 : 		refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _refNum$[ebp], edx

; 2615 : 		refArr = sgArr[i]->refArray;  // The URI Array itself

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _refArr$[ebp], ecx

; 2616 : 				
; 2617 : 		for (j=0; j<refNum; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L206903
$L206904:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L206903:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _refNum$[ebp]
	jge	$L206905

; 2618 : 		{
; 2619 : 			uriPath = (PURI_PATH) zMalloc(sizeof(URI_PATH));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _uriPath$[ebp], eax

; 2620 : 			uriPath->fullPath = (unsigned char *)zMalloc(MAX_PATH * 2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2621 : 			uriPath->sigId = (unsigned char *)zMalloc(MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx], eax

; 2622 : 			uriPath->URI = (unsigned char *)zMalloc (MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2623 : 
; 2624 : 			if (sgArr[i]->sigId != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L206911

; 2625 : 				strcpy((char *)uriPath->sigId,(const char *)sgArr[i]->sigId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcpy
	add	esp, 8
$L206911:

; 2626 : 			if (refArr[j]->URI != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L206914

; 2627 : 			{
; 2628 : 				strcpy((char *)uriPath->URI,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8

; 2629 : 				strcpy((char *)uriPath->fullPath,(const char *)refArr[j]->URI);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _uriPath$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8
$L206914:

; 2630 : 			}
; 2631 : 
; 2632 : 
; 2633 : 			uriArr[totalLocNum] = uriPath;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _totalLocNum$[ebp]
	mov	ecx, DWORD PTR _uriPath$[ebp]
	mov	DWORD PTR [edx+eax*4], ecx

; 2634 : 			totalLocNum++;

	mov	edx, DWORD PTR _totalLocNum$[ebp]
	add	edx, 1
	mov	DWORD PTR _totalLocNum$[ebp], edx

; 2635 : 		}

	jmp	$L206904
$L206905:

; 2636 : 
; 2637 : 		if (extractSignedContent == TRUE)

	cmp	DWORD PTR _extractSignedContent$[ebp], 1
	jne	$L206919

; 2638 : 		{
; 2639 : 			for (int m=0; m<refNum; m++)

	mov	DWORD PTR _m$206920[ebp], 0
	jmp	SHORT $L206921
$L206922:
	mov	eax, DWORD PTR _m$206920[ebp]
	add	eax, 1
	mov	DWORD PTR _m$206920[ebp], eax
$L206921:
	mov	ecx, DWORD PTR _m$206920[ebp]
	cmp	ecx, DWORD PTR _refNum$[ebp]
	jge	$L206919

; 2640 : 			{
; 2641 : 				for (int k=0; k<totalLocNum; k++) 

	mov	DWORD PTR _k$206924[ebp], 0
	jmp	SHORT $L206925
$L206926:
	mov	edx, DWORD PTR _k$206924[ebp]
	add	edx, 1
	mov	DWORD PTR _k$206924[ebp], edx
$L206925:
	mov	eax, DWORD PTR _k$206924[ebp]
	cmp	eax, DWORD PTR _totalLocNum$[ebp]
	jge	$L206927

; 2642 : 				{
; 2643 : 					if ((!(strcmp((const char *)refArr[m]->URI, (const char *)uriArr[k]->URI))) &&
; 2644 : 						(refArr[m]->refObject != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _k$206924[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _m$206920[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$L206930
	mov	ecx, DWORD PTR _m$206920[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+12], 0
	je	$L206930

; 2645 : 					{
; 2646 : 						GetTempPath((DWORD)MAX_PATH, TempPath);

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2647 : 						GetTempFileName(TempPath, // dir. for temp. files 
; 2648 : 							"INFM",                // temp. file name prefix 
; 2649 : 							0,                    // create unique name 
; 2650 : 							szTempName);          // buffer for name 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG206932
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2651 : #ifdef WIN32
; 2652 : 						hTempFile = CreateFile((LPCSTR) szTempName,  // file name 
; 2653 : 							GENERIC_READ | GENERIC_WRITE, // open for read/write 
; 2654 : 							0,                            // do not share 
; 2655 : 							NULL,                         // no security 
; 2656 : 							CREATE_ALWAYS,                // overwrite existing file
; 2657 : 							FILE_ATTRIBUTE_NORMAL,        // normal file 
; 2658 : 							NULL);                        // no attr. template 

	mov	esi, esp
	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	-1073741824				; c0000000H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hTempFile$[ebp], eax

; 2659 : 						if (hTempFile == INVALID_HANDLE_VALUE) 

	cmp	DWORD PTR _hTempFile$[ebp], -1
	jne	SHORT $L206936

; 2660 : 							break;

	jmp	$L206927
$L206936:

; 2661 : #else
; 2662 : 						hTempFile = fopen(szTempName, "w+");
; 2663 : 						if (!hTempFile)
; 2664 : 							break;
; 2665 : #endif
; 2666 : 						dwBytesToWrite = base64decodeSize((DWORD)strlen((const char *)refArr[m]->refObject->encodedData));

	mov	edx, DWORD PTR _m$206920[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 2667 : 						decodedDataPtr = (char *)zMalloc (dwBytesToWrite+1);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _decodedDataPtr$[ebp], eax

; 2668 : 						memset(decodedDataPtr,0,dwBytesToWrite+1);

	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	add	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2669 : 						if ((dwBytesToWrite = base64decode(refArr[m]->refObject->encodedData,(unsigned char *)decodedDataPtr,dwBytesToWrite))==-1) 

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _m$206920[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax
	cmp	DWORD PTR _dwBytesToWrite$[ebp], -1
	jne	SHORT $L206941

; 2670 : 						{
; 2671 : #ifdef WIN32
; 2672 : 							// Close file. 
; 2673 : 							CloseHandle(hTempFile);

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2674 : #else
; 2675 : 							fclose(hTempFile);
; 2676 : #endif
; 2677 : 							zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2678 : 							continue;

	jmp	$L206926
$L206941:

; 2679 : 						}
; 2680 : #ifdef WIN32
; 2681 : 						// Write the signature buffer to the temporary file. 
; 2682 : 						WriteFile(hTempFile, decodedDataPtr, dwBytesToWrite , 
; 2683 : 									&dwBytesWritten, NULL); 

	mov	esi, esp
	push	0
	lea	ecx, DWORD PTR _dwBytesWritten$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	push	edx
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hTempFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2684 : 						// Close file. 
; 2685 : 						CloseHandle(hTempFile); 

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2686 : #else
; 2687 : 						dwBytesWritten = fwrite(decodedDataPtr, 1, dwBytesToWrite, hTempFile);
; 2688 : 						fclose(hTempFile);
; 2689 : #endif
; 2690 : 						zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2691 : 						strcpy((char *)uriArr[k]->fullPath, szTempName);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _k$206924[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8

; 2692 : 						TEMP_FILE_INFO *tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221019[ebp], eax
	mov	ecx, DWORD PTR $T221019[ebp]
	mov	DWORD PTR _tmpFilePath$206943[ebp], ecx

; 2693 : 						strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$206943[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2694 : 						tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$206943[ebp]
	push	ecx
	lea	edx, DWORD PTR $T221020[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T221021[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 2695 : 						break;

	jmp	SHORT $L206927
$L206930:

; 2696 : 					}
; 2697 : 				}

	jmp	$L206926
$L206927:

; 2698 : 			}

	jmp	$L206922
$L206919:

; 2699 : 		}
; 2700 : 	}

	jmp	$L206901
$L206793:

; 2701 : 	ExitLog;
; 2702 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221028
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 408				; 00000198H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221028:
	DD	4
	DD	$L221027
$L221027:
	DD	-48					; ffffffd0H
	DD	4
	DD	$L221022
	DD	-320					; fffffec0H
	DD	260					; 00000104H
	DD	$L221023
	DD	-360					; fffffe98H
	DD	4
	DD	$L221024
	DD	-380					; fffffe84H
	DD	4
	DD	$L221025
$L221025:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221024:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221023:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221022:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	87					; 00000057H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?FetchSignatureStatus@CSignature@@QAEXHH@Z ENDP		; CSignature::FetchSignatureStatus
_TEXT	ENDS
PUBLIC	?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z	; CSignature::get_SignerSubject
xdata$x	SEGMENT
$T221041 DD	0ffffffffH
	DD	FLAT:$L221034
$T221036 DD	019930520H
	DD	01H
	DD	FLAT:$T221041
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221033 = -64						; size = 4
$T221032 = -60						; size = 4
$T221031 = -56						; size = 4
$T221030 = -52						; size = 4
_wSigId$206970 = -48					; size = 4
_i$206966 = -44						; size = 4
__lpa$ = -40						; size = 4
__lpw$ = -36						; size = 4
__acp$ = -32						; size = 4
__convert$ = -28					; size = 4
_tmpSigId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigId$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::get_SignerSubject

; 2706 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2707 : 	CComBSTR tmpSigId;

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2708 : 	EnterLog;
; 2709 : 	tmpSigId = sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2710 : 	if (tmpSigId.Length() == 0)

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206955

; 2711 : 	{
; 2712 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2713 : 		return S_FALSE;

	mov	DWORD PTR $T221030[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221030[ebp]
	jmp	$L206953
$L206955:

; 2714 : 	}
; 2715 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2716 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 2717 : 
; 2718 : 	if ((sgArr==NULL) || (signum == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L206963
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $L206962
$L206963:

; 2719 : 	{
; 2720 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2721 : 		return S_FALSE;

	mov	DWORD PTR $T221031[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221031[ebp]
	jmp	$L206953
$L206962:

; 2722 : 	}
; 2723 : 
; 2724 : 	for (int i=0; i < signum; i++)

	mov	DWORD PTR _i$206966[ebp], 0
	jmp	SHORT $L206967
$L206968:
	mov	edx, DWORD PTR _i$206966[ebp]
	add	edx, 1
	mov	DWORD PTR _i$206966[ebp], edx
$L206967:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$206966[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L206969

; 2725 : 	{
; 2726 : 		unsigned char *wSigId = HeapW2A(sigId);

	mov	edx, DWORD PTR _sigId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wSigId$206970[ebp], eax

; 2727 : 		if (!strcmp((const char *)sgArr[i]->sigId, (const char *)wSigId))

	mov	eax, DWORD PTR _wSigId$206970[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$206966[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L206973

; 2728 : 		{
; 2729 : 			*pVal = SysAllocString((const OLECHAR *)sgArr[i]->signerCert->subject);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$206966[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 768				; 00000300H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 2730 : 			zFree(wSigId);

	mov	eax, DWORD PTR _wSigId$206970[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2731 : 			ExitLog;
; 2732 : 			return S_OK;

	mov	DWORD PTR $T221032[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221032[ebp]
	jmp	SHORT $L206953
$L206973:

; 2733 : 		}
; 2734 : 		zFree(wSigId);

	mov	ecx, DWORD PTR _wSigId$206970[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 2735 : 	}

	jmp	$L206968
$L206969:

; 2736 : 	setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2737 : 	return S_FALSE;

	mov	DWORD PTR $T221033[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221033[ebp]
$L206953:

; 2738 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221040
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221040:
	DD	1
	DD	$L221039
$L221039:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221037
$L221037:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221034:
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221036
	jmp	___CxxFrameHandler
text$x	ENDS
?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::get_SignerSubject
PUBLIC	?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z	; CSignature::get_CertIssuer
xdata$x	SEGMENT
$T221054 DD	0ffffffffH
	DD	FLAT:$L221047
$T221049 DD	019930520H
	DD	01H
	DD	FLAT:$T221054
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221046 = -64						; size = 4
$T221045 = -60						; size = 4
$T221044 = -56						; size = 4
$T221043 = -52						; size = 4
_wSigId$207000 = -48					; size = 4
_i$206996 = -44						; size = 4
__lpa$ = -40						; size = 4
__lpw$ = -36						; size = 4
__acp$ = -32						; size = 4
__convert$ = -28					; size = 4
_tmpSigId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigId$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::get_CertIssuer

; 2741 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2742 : 	CComBSTR tmpSigId;

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2743 : 	EnterLog;
; 2744 : 	tmpSigId = sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2745 : 	if (tmpSigId.Length() == 0)

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L206985

; 2746 : 	{
; 2747 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2748 : 		return S_FALSE;

	mov	DWORD PTR $T221043[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221043[ebp]
	jmp	$L206983
$L206985:

; 2749 : 	}
; 2750 : 
; 2751 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2752 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 2753 : 
; 2754 : 	if ((sgArr==NULL) || (signum == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L206993
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $L206992
$L206993:

; 2755 : 	{
; 2756 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2757 : 		return S_FALSE;

	mov	DWORD PTR $T221044[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221044[ebp]
	jmp	$L206983
$L206992:

; 2758 : 	}
; 2759 : 	for (int i=0; i < signum; i++)

	mov	DWORD PTR _i$206996[ebp], 0
	jmp	SHORT $L206997
$L206998:
	mov	edx, DWORD PTR _i$206996[ebp]
	add	edx, 1
	mov	DWORD PTR _i$206996[ebp], edx
$L206997:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$206996[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L206999

; 2760 : 	{
; 2761 : 		unsigned char *wSigId = HeapW2A(sigId);

	mov	edx, DWORD PTR _sigId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wSigId$207000[ebp], eax

; 2762 : 		if (!strcmp((const char *)sgArr[i]->sigId, (const char *)wSigId))

	mov	eax, DWORD PTR _wSigId$207000[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$206996[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L207003

; 2763 : 		{
; 2764 : 			*pVal = SysAllocString((const OLECHAR *)sgArr[i]->signerCert->issuer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$206996[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 256				; 00000100H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 2765 : 			zFree(wSigId);

	mov	eax, DWORD PTR _wSigId$207000[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2766 : 			ExitLog;
; 2767 : 			return S_OK;

	mov	DWORD PTR $T221045[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221045[ebp]
	jmp	SHORT $L206983
$L207003:

; 2768 : 		}
; 2769 : 		zFree(wSigId);

	mov	ecx, DWORD PTR _wSigId$207000[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 2770 : 	}

	jmp	$L206998
$L206999:

; 2771 : 	setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2772 : 	return S_FALSE;

	mov	DWORD PTR $T221046[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221046[ebp]
$L206983:

; 2773 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221053
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221053:
	DD	1
	DD	$L221052
$L221052:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221050
$L221050:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221047:
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221049
	jmp	___CxxFrameHandler
text$x	ENDS
?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::get_CertIssuer
PUBLIC	?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z	; CSignature::get_CertExpiry
xdata$x	SEGMENT
$T221067 DD	0ffffffffH
	DD	FLAT:$L221060
$T221062 DD	019930520H
	DD	01H
	DD	FLAT:$T221067
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221059 = -64						; size = 4
$T221058 = -60						; size = 4
$T221057 = -56						; size = 4
$T221056 = -52						; size = 4
_wSigId$207030 = -48					; size = 4
_i$207026 = -44						; size = 4
__lpa$ = -40						; size = 4
__lpw$ = -36						; size = 4
__acp$ = -32						; size = 4
__convert$ = -28					; size = 4
_tmpSigId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigId$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::get_CertExpiry

; 2776 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2777 : 	CComBSTR tmpSigId;

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2778 : 	EnterLog;
; 2779 : 	tmpSigId = sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2780 : 	if (tmpSigId.Length() == 0)

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207015

; 2781 : 	{
; 2782 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2783 : 		return S_FALSE;

	mov	DWORD PTR $T221056[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221056[ebp]
	jmp	$L207013
$L207015:

; 2784 : 	}
; 2785 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2786 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 2787 : 
; 2788 : 	if ((sgArr==NULL) || (signum == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L207023
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $L207022
$L207023:

; 2789 : 	{
; 2790 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2791 : 		return S_FALSE;

	mov	DWORD PTR $T221057[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221057[ebp]
	jmp	$L207013
$L207022:

; 2792 : 	}
; 2793 : 	for (int i=0; i < signum; i++)

	mov	DWORD PTR _i$207026[ebp], 0
	jmp	SHORT $L207027
$L207028:
	mov	edx, DWORD PTR _i$207026[ebp]
	add	edx, 1
	mov	DWORD PTR _i$207026[ebp], edx
$L207027:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$207026[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L207029

; 2794 : 	{
; 2795 : 		unsigned char *wSigId = HeapW2A(sigId);

	mov	edx, DWORD PTR _sigId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wSigId$207030[ebp], eax

; 2796 : 		if (!strcmp((const char *)sgArr[i]->sigId, (const char *)wSigId))

	mov	eax, DWORD PTR _wSigId$207030[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$207026[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L207033

; 2797 : 		{
; 2798 : 			*pVal = A2WBSTR((LPCSTR)sgArr[i]->signerCert->notAfter);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$207026[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1792				; 00000700H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 2799 : 			zFree(wSigId);

	mov	eax, DWORD PTR _wSigId$207030[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2800 : 			ExitLog;
; 2801 : 			return S_OK;

	mov	DWORD PTR $T221058[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221058[ebp]
	jmp	SHORT $L207013
$L207033:

; 2802 : 		}
; 2803 : 		zFree(wSigId);

	mov	ecx, DWORD PTR _wSigId$207030[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 2804 : 	}

	jmp	$L207028
$L207029:

; 2805 : 	setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2806 : 	return S_FALSE;

	mov	DWORD PTR $T221059[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221059[ebp]
$L207013:

; 2807 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221066
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221066:
	DD	1
	DD	$L221065
$L221065:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221063
$L221063:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221060:
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221062
	jmp	___CxxFrameHandler
text$x	ENDS
?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::get_CertExpiry
PUBLIC	?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z ; CSignature::get_CertSerialNumber
xdata$x	SEGMENT
$T221080 DD	0ffffffffH
	DD	FLAT:$L221073
$T221075 DD	019930520H
	DD	01H
	DD	FLAT:$T221080
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221072 = -68						; size = 4
$T221071 = -64						; size = 4
$T221070 = -60						; size = 4
$T221069 = -56						; size = 4
_i$207058 = -52						; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_charSigId$ = -32					; size = 4
_plainTextHex$ = -28					; size = 4
_tmpSigId$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigId$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::get_CertSerialNumber

; 2810 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2811 : 	CComBSTR tmpSigId;

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2812 : 	unsigned char *plainTextHex;
; 2813 : 	unsigned char *charSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 2814 : 	EnterLog;
; 2815 : 	tmpSigId = sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2816 : 	if (tmpSigId.Length() == 0)

	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207047

; 2817 : 	{
; 2818 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2819 : 		return S_FALSE;

	mov	DWORD PTR $T221069[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221069[ebp]
	jmp	$L207043
$L207047:

; 2820 : 	}
; 2821 : 
; 2822 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2823 : 	*pVal = NULL;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 2824 : 
; 2825 : 	if ((sgArr==NULL) || (signum == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L207055
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $L207054
$L207055:

; 2826 : 	{
; 2827 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2828 : 		return S_FALSE;

	mov	DWORD PTR $T221070[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221070[ebp]
	jmp	$L207043
$L207054:

; 2829 : 	}
; 2830 : 	charSigId = HeapW2A(sigId);

	mov	edx, DWORD PTR _sigId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 2831 : 	for (int i=0; i < signum; i++)

	mov	DWORD PTR _i$207058[ebp], 0
	jmp	SHORT $L207059
$L207060:
	mov	eax, DWORD PTR _i$207058[ebp]
	add	eax, 1
	mov	DWORD PTR _i$207058[ebp], eax
$L207059:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$207058[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L207061

; 2832 : 	{
; 2833 : 		if (!strcmp((const char *)sgArr[i]->sigId, (const char *)charSigId))

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$207058[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	$L207064

; 2834 : 		{
; 2835 : 			if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3324], 1
	jne	SHORT $L207065

; 2836 : 			{
; 2837 : 				plainTextHex = Base64BinToPlainHex(sgArr[i]->signerCert->serialNumber);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$207058[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainTextHex$[ebp], eax

; 2838 : 				*pVal = A2WBSTR((LPCSTR)plainTextHex);

	push	-1
	mov	eax, DWORD PTR _plainTextHex$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 2839 : 				zFree(plainTextHex);

	mov	edx, DWORD PTR _plainTextHex$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 2840 : 			}
; 2841 : 			else

	jmp	SHORT $L207067
$L207065:

; 2842 : 				*pVal = A2WBSTR((LPCSTR)sgArr[i]->signerCert->serialNumber);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$207058[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax
$L207067:

; 2843 : 			zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2844 : 			ExitLog;
; 2845 : 			return S_OK;

	mov	DWORD PTR $T221071[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221071[ebp]
	jmp	SHORT $L207043
$L207064:

; 2846 : 		}
; 2847 : 	}

	jmp	$L207060
$L207061:

; 2848 : 	setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 2849 : 	zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 2850 : 	ExitLog;
; 2851 : 	return S_FALSE;

	mov	DWORD PTR $T221072[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221072[ebp]
$L207043:

; 2852 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221079
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221079:
	DD	1
	DD	$L221078
$L221078:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221076
$L221076:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221073:
	lea	ecx, DWORD PTR _tmpSigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221075
	jmp	___CxxFrameHandler
text$x	ENDS
?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::get_CertSerialNumber
PUBLIC	?FileExists@CSignature@@UAGJPAGPAH@Z		; CSignature::FileExists
EXTRN	__wfopen:NEAR
xdata$x	SEGMENT
$T221091 DD	0ffffffffH
	DD	FLAT:$L221084
$T221086 DD	019930520H
	DD	01H
	DD	FLAT:$T221091
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221083 = -52						; size = 4
$T221082 = -48						; size = 4
__lpa$ = -44						; size = 4
__lpw$ = -40						; size = 4
__acp$ = -36						; size = 4
__convert$ = -32					; size = 4
_tmpFileName$ = -24					; size = 4
_hFileHandle$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_fileName$ = 12						; size = 4
_fileStatus$ = 16					; size = 4
?FileExists@CSignature@@UAGJPAGPAH@Z PROC NEAR		; CSignature::FileExists

; 2855 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FileExists@CSignature@@UAGJPAGPAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2856 : 	FILE *hFileHandle; 
; 2857 : 
; 2858 : 	CComBSTR tmpFileName;

	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2859 : 	EnterLog;
; 2860 : 	tmpFileName = fileName;

	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2861 : 	if (tmpFileName.Length() == 0)

	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207080

; 2862 : 	{
; 2863 : 		*fileStatus = FALSE; // File does not exist

	mov	ecx, DWORD PTR _fileStatus$[ebp]
	mov	DWORD PTR [ecx], 0

; 2864 : 		return S_FALSE;

	mov	DWORD PTR $T221082[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221082[ebp]
	jmp	SHORT $L207077
$L207080:

; 2865 : 	}
; 2866 : 
; 2867 : 
; 2868 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2869 : 
; 2870 : 	// open file and read contest
; 2871 : #ifdef WIN32
; 2872 : 	if ((hFileHandle = _wfopen (fileName,L"rb"))==NULL) 

	push	OFFSET FLAT:$SG207088
	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFileHandle$[ebp], eax
	cmp	DWORD PTR _hFileHandle$[ebp], 0
	jne	SHORT $L207087

; 2873 : #elif LINUX
; 2874 : 	unsigned char *utf8Name = HeapW2A(fileName);
; 2875 : 	if ((hFileHandle = fopen((const char *)utf8Name, "rb")) == NULL)
; 2876 : #endif
; 2877 : 	{
; 2878 : 		*fileStatus = FALSE; // File does not exist

	mov	eax, DWORD PTR _fileStatus$[ebp]
	mov	DWORD PTR [eax], 0

; 2879 : 	}
; 2880 : 	else

	jmp	SHORT $L207089
$L207087:

; 2881 : 	{
; 2882 : 		*fileStatus = TRUE;   // File exists

	mov	ecx, DWORD PTR _fileStatus$[ebp]
	mov	DWORD PTR [ecx], 1

; 2883 : 		// Close file. 
; 2884 : 		fclose(hFileHandle); 

	mov	edx, DWORD PTR _hFileHandle$[ebp]
	push	edx
	call	_fclose
	add	esp, 4
$L207089:

; 2885 : 	}
; 2886 : #ifdef LINUX
; 2887 : 	zFree(utf8Name);
; 2888 : #endif
; 2889 : 	ExitLog;
; 2890 : 	return S_OK;

	mov	DWORD PTR $T221083[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221083[ebp]
$L207077:

; 2891 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221090
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221090:
	DD	1
	DD	$L221089
$L221089:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221087
$L221087:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221084:
	lea	ecx, DWORD PTR _tmpFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?FileExists@CSignature@@UAGJPAGPAH@Z:
	mov	eax, OFFSET FLAT:$T221086
	jmp	___CxxFrameHandler
text$x	ENDS
?FileExists@CSignature@@UAGJPAGPAH@Z ENDP		; CSignature::FileExists
PUBLIC	?get_FailedUriCount@CSignature@@UAGJPAJ@Z	; CSignature::get_FailedUriCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_FailedUriCount@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_FailedUriCount

; 2894 : {

	push	ebp
	mov	ebp, esp

; 2895 : 	EnterLog;
; 2896 : 	*pVal = (long)failedUriCount;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax], edx

; 2897 : 	ExitLog;
; 2898 : 	return S_OK;

	xor	eax, eax

; 2899 : }

	pop	ebp
	ret	8
?get_FailedUriCount@CSignature@@UAGJPAJ@Z ENDP		; CSignature::get_FailedUriCount
_TEXT	ENDS
PUBLIC	?get_TotalUriCount@CSignature@@UAGJPAJ@Z	; CSignature::get_TotalUriCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_TotalUriCount@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_TotalUriCount

; 2902 : {

	push	ebp
	mov	ebp, esp

; 2903 : 	EnterLog;
; 2904 : 	*pVal = (long)totalUriCount;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax], edx

; 2905 : 	ExitLog;
; 2906 : 	return S_OK;

	xor	eax, eax

; 2907 : }

	pop	ebp
	ret	8
?get_TotalUriCount@CSignature@@UAGJPAJ@Z ENDP		; CSignature::get_TotalUriCount
_TEXT	ENDS
PUBLIC	?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z	; CSignature::get_FailedUriFullPath
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z PROC NEAR ; CSignature::get_FailedUriFullPath

; 2910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2911 : 	EnterLog;
; 2912 : 	if ((sgArr==NULL) || (signum == 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L207110
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $L207109
$L207110:

; 2913 : 	{
; 2914 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2915 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207108
$L207109:

; 2916 : 	}
; 2917 : 
; 2918 : 	if ((index >= failedUriCount) || (index < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	SHORT $L207113
	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L207112
$L207113:

; 2919 : 	{
; 2920 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2921 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207108
$L207112:

; 2922 : 	}
; 2923 : 	if (failedUriArr == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $L207115

; 2924 : 	{
; 2925 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2926 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207108
$L207115:

; 2927 : 	}
; 2928 : 
; 2929 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2930 : 	*pVal = A2WBSTR((LPCSTR)failedUriArr[index]->fullPath);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 2931 : 	ExitLog;
; 2932 : 	return S_OK;

	xor	eax, eax
$L207108:

; 2933 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z ENDP	; CSignature::get_FailedUriFullPath
_TEXT	ENDS
PUBLIC	?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z	; CSignature::put_FailedUriFullPath
xdata$x	SEGMENT
$T221105 DD	0ffffffffH
	DD	FLAT:$L221098
$T221100 DD	019930520H
	DD	01H
	DD	FLAT:$T221105
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221097 = -48						; size = 4
$T221096 = -44						; size = 4
__lpa$ = -40						; size = 4
__lpw$ = -36						; size = 4
__acp$ = -32						; size = 4
__convert$ = -28					; size = 4
_tmpNewVal$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_newVal$ = 16						; size = 4
?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z PROC NEAR	; CSignature::put_FailedUriFullPath

; 2936 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax

; 2937 : 	EnterLog;
; 2938 : 	if ((sgArr==NULL) || (signum == 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L207129
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $L207128
$L207129:

; 2939 : 	{
; 2940 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2941 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207127
$L207128:

; 2942 : 	}
; 2943 : 	if ((index >= failedUriCount) || (index < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	SHORT $L207132
	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L207131
$L207132:

; 2944 : 	{
; 2945 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2946 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207127
$L207131:

; 2947 : 	}
; 2948 : 	if (failedUriArr == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $L207134

; 2949 : 	{
; 2950 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2951 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207127
$L207134:

; 2952 : 	}
; 2953 : 
; 2954 : 	CComBSTR tmpNewVal;

	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2955 : 
; 2956 : 	tmpNewVal = newVal;

	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 2957 : 	if (tmpNewVal.Length() == 0)

	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207137

; 2958 : 	{
; 2959 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2960 : 		return S_FALSE;

	mov	DWORD PTR $T221096[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221096[ebp]
	jmp	$L207127
$L207137:

; 2961 : 	}
; 2962 : 
; 2963 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2964 : 
; 2965 : 	if (failedUriArr[index]->fullPath != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $L207144

; 2966 : 	{
; 2967 : 		zFree(failedUriArr[index]->fullPath);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _index$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_rFree
	add	esp, 4

; 2968 : 		failedUriArr[index]->fullPath = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+8], 0
$L207144:

; 2969 : 	}
; 2970 : 
; 2971 : 	failedUriArr[index]->fullPath = (unsigned char *)HeapW2A(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [edx+8], eax

; 2972 : 	ExitLog;
; 2973 : 	return S_OK;

	mov	DWORD PTR $T221097[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221097[ebp]
$L207127:

; 2974 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221104
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221104:
	DD	1
	DD	$L221103
$L221103:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221101
$L221101:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221098:
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z:
	mov	eax, OFFSET FLAT:$T221100
	jmp	___CxxFrameHandler
text$x	ENDS
?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z ENDP	; CSignature::put_FailedUriFullPath
PUBLIC	?get_FailedUri@CSignature@@UAGJJPAPAG@Z		; CSignature::get_FailedUri
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_FailedUri@CSignature@@UAGJJPAPAG@Z PROC NEAR	; CSignature::get_FailedUri

; 2977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2978 : 	EnterLog;
; 2979 : 	if ((sgArr==NULL) || (signum == 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L207154
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $L207153
$L207154:

; 2980 : 	{
; 2981 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 2982 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207152
$L207153:

; 2983 : 	}
; 2984 : 
; 2985 : 	if ((index >= failedUriCount) || (index < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jge	SHORT $L207157
	cmp	DWORD PTR _index$[ebp], 0
	jge	SHORT $L207156
$L207157:

; 2986 : 	{
; 2987 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2988 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207152
$L207156:

; 2989 : 	}
; 2990 : 	if (failedUriArr == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 0
	jne	SHORT $L207159

; 2991 : 	{
; 2992 : 		setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 2993 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207152
$L207159:

; 2994 : 	}
; 2995 : 
; 2996 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 2997 : 
; 2998 : 	*pVal = A2WBSTR((LPCSTR)failedUriArr[index]->URI);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 2999 : 	ExitLog;
; 3000 : 	return S_OK;

	xor	eax, eax
$L207152:

; 3001 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_FailedUri@CSignature@@UAGJJPAPAG@Z ENDP		; CSignature::get_FailedUri
_TEXT	ENDS
PUBLIC	?get_SignatureCount@CSignature@@UAGJPAJ@Z	; CSignature::get_SignatureCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_SignatureCount@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_SignatureCount

; 3004 : {

	push	ebp
	mov	ebp, esp

; 3005 : 	EnterLog;
; 3006 : 	*pVal = signum;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 3007 : 	ExitLog;
; 3008 : 	return S_OK;

	xor	eax, eax

; 3009 : }

	pop	ebp
	ret	8
?get_SignatureCount@CSignature@@UAGJPAJ@Z ENDP		; CSignature::get_SignatureCount
_TEXT	ENDS
PUBLIC	?PrepareSignatureEnvelopeFromObjects@CSignature@@QAEPAU_xmlDoc@@PADPAPAU_xmlNode@@1@Z ; CSignature::PrepareSignatureEnvelopeFromObjects
PUBLIC	?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z		; CSignature::SignXMLStr
EXTRN	?FileEncoding@@YAXPAE@Z:NEAR			; FileEncoding
EXTRN	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z:NEAR ; CLicense::getFormSignAllowed
EXTRN	_xmlStrcmp:NEAR
EXTRN	_xsSigNodeById:NEAR
xdata$x	SEGMENT
$T221132 DD	0ffffffffH
	DD	FLAT:$L221117
$T221119 DD	019930520H
	DD	01H
	DD	FLAT:$T221132
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv277 = -292						; size = 4
$T221116 = -288						; size = 4
$T221115 = -284						; size = 4
$T221114 = -280						; size = 4
$T221113 = -276						; size = 4
$T221112 = -272						; size = 4
$T221111 = -268						; size = 4
$T221110 = -264						; size = 4
_dataPtr$207369 = -260					; size = 4
_tmpEnvFlag$ = -256					; size = 2
_freeCharSigId$ = -252					; size = 4
__lpa$ = -248						; size = 4
__lpw$ = -244						; size = 4
__acp$ = -240						; size = 4
__convert$ = -236					; size = 4
_templateFound$ = -232					; size = 4
_guidStr$ = -224					; size = 50
_sigGuid$ = -164					; size = 16
_freeNewPtr$ = -144					; size = 4
_ptemp$ = -140						; size = 4
_xpathResultPtr$ = -136					; size = 4
_xpathPtr$ = -132					; size = 4
_sizeM$ = -128						; size = 4
_szPtr$ = -124						; size = 4
_curPtr$ = -120						; size = 4
_newPtr$ = -116						; size = 4
_ptr$ = -112						; size = 4
_sigId$ = -104						; size = 4
_iSize$ = -92						; size = 4
_mem$ = -84						; size = 4
_signedInfoNode$ = -76					; size = 4
_sigNode$ = -64						; size = 4
_parent$ = -56						; size = 4
_cur$ = -52						; size = 4
_root$ = -48						; size = 4
_doc$ = -44						; size = 4
_charSignedXMLStr$ = -36				; size = 4
_curCharSigId$ = -28					; size = 4
_charSigId$ = -24					; size = 4
_charXMLStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_xmlStr$ = 12						; size = 4
_signatureId$ = 16					; size = 4
_signedXMLStr$ = 20					; size = 4
?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::SignXMLStr

; 3012 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 280				; 00000118H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-292]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3013 : 	char *charXMLStr=NULL, *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charXMLStr$[ebp], 0
	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 3014 : 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 3015 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 3016 : 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 3017 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 3018 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 3019 : 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3020 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 3021 : 	unsigned int *szPtr;
; 3022 : 	unsigned int sizeM;
; 3023 : 
; 3024 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 3025 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 3026 : 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 3027 : 	BOOL freeNewPtr = FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 3028 : 
; 3029 : #ifdef WIN32
; 3030 : 	GUID sigGuid;
; 3031 : #else
; 3032 : 	uuid_t sigGuid;
; 3033 : #endif
; 3034 : 	char guidStr[50];
; 3035 : 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 3036 : 
; 3037 : 	EnterLog;
; 3038 : 	//if (! LicObj.checkLicense()) {
; 3039 : 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 3040 : 	//	return S_FALSE;
; 3041 : 	//}
; 3042 : //DebugBreak();
; 3043 : 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L207203

; 3044 : 	{
; 3045 : 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L207204

; 3046 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L207204:

; 3047 : 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 3048 : 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L207203:

; 3049 : 	}
; 3050 : 
; 3051 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3052 : 
; 3053 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 3054 : 	sigId = signatureId;

	mov	ecx, DWORD PTR _signatureId$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 3055 : 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207210

; 3056 : 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 3057 : 	else

	jmp	SHORT $L207211
$L207210:

; 3058 : 	{
; 3059 : 		charSigId = (char *)HeapW2A(signatureId);

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 3060 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L207211:

; 3061 : 	}
; 3062 : 
; 3063 : 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L207213

; 3064 : 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207214

; 3065 : 		{
; 3066 : #ifdef WIN32
; 3067 : 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3068 : 			GuidToString(&sigGuid, guidStr);

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 3069 : #else
; 3070 : 			uuid_generate(sigGuid);
; 3071 : 			uuid_unparse(sigGuid, guidStr);
; 3072 : #endif
; 3073 : 			charSigId = guidStr;

	lea	eax, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], eax

; 3074 : 		}
; 3075 : 		else

	jmp	SHORT $L207213
$L207214:

; 3076 : 		{
; 3077 : 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 3078 : 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L207213:

; 3079 : 		}
; 3080 : 
; 3081 : 	if ((xmlStr != 0) && (SysStringByteLen(xmlStr) != 0))

	cmp	DWORD PTR _xmlStr$[ebp], 0
	je	$L207217
	mov	esi, esp
	mov	eax, DWORD PTR _xmlStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$L207217

; 3082 : 	{
; 3083 : 		if (Base64DecodeXML == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2184], 0
	jne	$L207218

; 3084 : 		{
; 3085 : 			ptr = (unsigned char *)xmlStr;

	mov	edx, DWORD PTR _xmlStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 3086 : 			szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _szPtr$[ebp], eax

; 3087 : 			sizeM = (*szPtr);

	mov	ecx, DWORD PTR _szPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _sizeM$[ebp], edx

; 3088 : 
; 3089 : 			if (((*ptr == 0xff) && (*(ptr + 1) == 0xfe)) ||
; 3090 : 				((*ptr == 0xfe) && (*(ptr + 1) == 0xff)))

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207224
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L207223
$L207224:
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L207222
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207222
$L207223:

; 3091 : 			{
; 3092 : 				// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 3093 : 				newPtr = ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], edx

; 3094 : 			}
; 3095 : 			else

	jmp	SHORT $L207225
$L207222:

; 3096 : 			{
; 3097 : 				newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 3098 : 				freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 3099 : 				FileEncoding(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 3100 : 				memcpy(newPtr+2, ptr, sizeM + 2);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	add	ecx, 2
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3101 : 				sizeM += 4;

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	mov	DWORD PTR _sizeM$[ebp], edx
$L207225:

; 3102 : 			}
; 3103 : 		}
; 3104 : 		else

	jmp	$L207227
$L207218:

; 3105 : 		{
; 3106 : 			ptr = HeapW2A(xmlStr);

	mov	eax, DWORD PTR _xmlStr$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 3107 : 			sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 3108 : 			sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 3109 : 			newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 3110 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 3111 : 			if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L207230

; 3112 : 			{
; 3113 : 				zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3114 : 				zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3115 : 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3116 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207231

; 3117 : 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207231:

; 3118 : 				return S_FALSE;

	mov	DWORD PTR $T221110[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221110[ebp]
	jmp	$L207177
$L207230:

; 3119 : 			}
; 3120 : 			zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207227:

; 3121 : 		}
; 3122 : 		if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L207234

; 3123 : 		{
; 3124 : 			if (!LicObj.getFormSignAllowed(newPtr, sizeM, SigHandle))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	SHORT $L207234

; 3125 : 			{
; 3126 : 				setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 3127 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207236

; 3128 : 					zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207236:

; 3129 : 				if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L207237

; 3130 : 					zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207237:

; 3131 : 				return S_FALSE;

	mov	DWORD PTR $T221111[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221111[ebp]
	jmp	$L207177
$L207234:

; 3132 : 			}
; 3133 : 		}
; 3134 : 
; 3135 : 		// original document
; 3136 : 		doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 3137 : 		if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L207241

; 3138 : 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207241:

; 3139 : 
; 3140 : 		if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L207242

; 3141 : 		{
; 3142 : 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3143 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207243

; 3144 : 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207243:

; 3145 : 			return S_FALSE;

	mov	DWORD PTR $T221112[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221112[ebp]
	jmp	$L207177
$L207242:

; 3146 : 		}
; 3147 : 
; 3148 : 		root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 3149 : 		sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 3150 : 		if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L207248

; 3151 : 		{
; 3152 : 			templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 3153 : 			cur = sigNode->xmlChildrenNode;

	mov	eax, DWORD PTR _sigNode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$L207250:

; 3154 : 			while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L207248

; 3155 : 			{
; 3156 : 					if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG207254
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L207253

; 3157 : 					{
; 3158 : 						signedInfoNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], ecx

; 3159 : 						break;

	jmp	SHORT $L207248
$L207253:

; 3160 : 					}
; 3161 : 					cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 3162 : 			}  // end while cur != NULL

	jmp	SHORT $L207250
$L207248:

; 3163 : 		}
; 3164 : 		cur = root->xmlChildrenNode;

	mov	ecx, DWORD PTR _root$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 3165 : 		if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L207255

; 3166 : 		{
; 3167 : 			// Add a new Signature element
; 3168 : 
; 3169 : 			/*
; 3170 : 			* Signature
; 3171 : 			*/
; 3172 : 
; 3173 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207257
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3174 : 			sigNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], eax

; 3175 : 			if (charSigId != NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	je	SHORT $L207258

; 3176 : 				xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG207261
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207258:

; 3177 : 			cur = xmlAddChild(root,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3178 : 			//xmlNewNs(cur,(const unsigned char *)"http://www.w3.org/2000/09/xmldsig#",(const unsigned char *)NULL);
; 3179 : 
; 3180 : 			xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG207264
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 3181 : 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 3182 : 
; 3183 : 			/*
; 3184 : 			* SignedInfo
; 3185 : 			*/
; 3186 : 			cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207266
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3187 : 			signedInfoNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], ecx

; 3188 : 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3189 : 			parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 3190 : 
; 3191 : 			/*
; 3192 : 			* Canonicalization Method
; 3193 : 			*/
; 3194 : 			cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG207268
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3195 : 			switch(CanonicalizationMethod)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3336]
	mov	DWORD PTR tv277[ebp], eax
	cmp	DWORD PTR tv277[ebp], 3
	ja	SHORT $L207293
	mov	ecx, DWORD PTR tv277[ebp]
	jmp	DWORD PTR $L221131[ecx*4]
$L207273:

; 3196 : 			{
; 3197 : 				case WITH_COMMENTS:
; 3198 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG207276
	push	OFFSET FLAT:$SG207277
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3199 : 					break;

	jmp	SHORT $L207270
$L207278:

; 3200 : 				case WITHOUT_COMMENTS:
; 3201 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG207281
	push	OFFSET FLAT:$SG207282
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3202 : 					break;

	jmp	SHORT $L207270
$L207283:

; 3203 : 				case EXC_WITH_COMMENTS:
; 3204 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG207286
	push	OFFSET FLAT:$SG207287
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3205 : 					break;

	jmp	SHORT $L207270
$L207288:

; 3206 : 				case EXC_WITHOUT_COMMENTS:
; 3207 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG207291
	push	OFFSET FLAT:$SG207292
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3208 : 					break;

	jmp	SHORT $L207270
$L207293:

; 3209 : 				default:
; 3210 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG207296
	push	OFFSET FLAT:$SG207297
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207270:

; 3211 : 			}
; 3212 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3213 : 			/*
; 3214 : 			* Reference
; 3215 : 			*/
; 3216 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207299
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3217 : 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3218 : 
; 3219 : 			xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG207302
	push	OFFSET FLAT:$SG207303
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3220 : 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 3221 : 
; 3222 : 			/*
; 3223 : 			* Transforms
; 3224 : 			*/
; 3225 : 		
; 3226 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG207305
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3227 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3228 : 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 3229 : 
; 3230 : 			/*
; 3231 : 			* Transform
; 3232 : 			*/
; 3233 : 
; 3234 : 			if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 3235 : 				(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	je	SHORT $L207307
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	$L207306
$L207307:

; 3236 : 			{
; 3237 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG207309
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3238 : 				if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L207310

; 3239 : 				{
; 3240 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG207313
	push	OFFSET FLAT:$SG207314
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3241 : 				}
; 3242 : 				else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L207315
$L207310:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L207315

; 3243 : 				{
; 3244 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG207319
	push	OFFSET FLAT:$SG207320
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207315:

; 3245 : 				}
; 3246 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3247 : 				parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 3248 : 				if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L207321

; 3249 : 				{
; 3250 : 					cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG207323
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3251 : 					xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG207326
	push	OFFSET FLAT:$SG207327
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 3252 : 					xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG207330
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3253 : 				}
; 3254 : 				else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L207331
$L207321:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L207331

; 3255 : 				{
; 3256 : 					cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG207334
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3257 : 					xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG207337
	push	OFFSET FLAT:$SG207338
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 3258 : 					xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG207341
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207331:

; 3259 : 				}
; 3260 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3261 : 				parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx
$L207306:

; 3262 : 			}
; 3263 : 
; 3264 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG207343
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3265 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG207346
	push	OFFSET FLAT:$SG207347
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3266 : 			cur = xmlAddChild(parent,cur);		

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L207255:

; 3267 : 		}
; 3268 : 	}
; 3269 : 	else

	jmp	$L207348
$L207217:

; 3270 : 	{
; 3271 : 		if ((AttachedObjectCount != 0) || (DetachedObjectCount !=0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	jne	SHORT $L207350
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $L207349
$L207350:

; 3272 : 		{
; 3273 : 			doc = PrepareSignatureEnvelopeFromObjects(charSigId, &sigNode, &signedInfoNode);

	lea	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareSignatureEnvelopeFromObjects@CSignature@@QAEPAU_xmlDoc@@PADPAPAU_xmlNode@@1@Z ; CSignature::PrepareSignatureEnvelopeFromObjects
	mov	DWORD PTR _doc$[ebp], eax

; 3274 : 			if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L207351

; 3275 : 			{
; 3276 : 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207352

; 3277 : 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207352:

; 3278 : 				return S_FALSE;

	mov	DWORD PTR $T221113[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221113[ebp]
	jmp	$L207177
$L207351:

; 3279 : 			}
; 3280 : 		}
; 3281 : 		else

	jmp	SHORT $L207348
$L207349:

; 3282 : 		{
; 3283 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207356

; 3284 : 				zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207356:

; 3285 : 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 3286 : 			return S_FALSE;

	mov	DWORD PTR $T221114[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221114[ebp]
	jmp	$L207177
$L207348:

; 3287 : 		}
; 3288 : 	}
; 3289 : 
; 3290 : #ifdef WIN32
; 3291 : 	  if (AddWindowImageFlag == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 1
	jne	SHORT $L207359

; 3292 : 		  AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L207359:

; 3293 : 
; 3294 : 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+956], 0
	je	SHORT $L207360

; 3295 : 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L207360:

; 3296 : #endif 
; 3297 : 	/*
; 3298 : 	 * init Signature. crBlob contains XML - envelope document
; 3299 : 	 */
; 3300 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], ax

; 3301 : 	EnvelopingFlag = ENVELOPED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+688], 2

; 3302 : 
; 3303 : 	if (!(CreateSigFromTmplBlob(
; 3304 : 								//&crBlob,
; 3305 : 								doc,
; 3306 : 								charSigId, &charSignedXMLStr, &iSize)))

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L207362

; 3307 : 	{
; 3308 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L207363

; 3309 : 		{
; 3310 : 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L207363:

; 3311 : 		}
; 3312 : 		EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 3313 : 		*signedXMLStr = NULL;

	mov	eax, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [eax], 0

; 3314 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207364

; 3315 : 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207364:

; 3316 : 		ExitLog;
; 3317 : 		return S_FALSE;

	mov	DWORD PTR $T221115[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221115[ebp]
	jmp	$L207177
$L207362:

; 3318 : 	}
; 3319 : 	else
; 3320 : 	{
; 3321 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	$L207367

; 3322 : 		{
; 3323 : 			unsigned char *dataPtr = charSignedXMLStr;

	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	mov	DWORD PTR _dataPtr$207369[ebp], edx

; 3324 : 
; 3325 : 			if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) ||
; 3326 : 				((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff)))

	mov	eax, DWORD PTR _dataPtr$207369[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207372
	mov	edx, DWORD PTR _dataPtr$207369[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L207371
$L207372:
	mov	ecx, DWORD PTR _dataPtr$207369[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L207370
	mov	eax, DWORD PTR _dataPtr$207369[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207370
$L207371:

; 3327 : 			{
; 3328 : 				// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 3329 : 				// Just allocate memory and copy data and put the size information in front
; 3330 : 				*signedXMLStr = ::SysAllocStringByteLen((LPCSTR)dataPtr, iSize);

	mov	esi, esp
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$207369[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 3331 : 				xmlFree(dataPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _dataPtr$207369[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3332 : 			}
; 3333 : 			else

	jmp	SHORT $L207367
$L207370:

; 3334 : 			{
; 3335 : 				*signedXMLStr = A2WBSTR((LPCSTR)dataPtr, iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$207369[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [edx], eax

; 3336 : 				if (Base64EncodeXML == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2180], 1
	jne	SHORT $L207376

; 3337 : 					zFree(dataPtr);

	mov	ecx, DWORD PTR _dataPtr$207369[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3338 : 				else

	jmp	SHORT $L207367
$L207376:

; 3339 : 					xmlFree(dataPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _dataPtr$207369[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L207367:

; 3340 : 			}
; 3341 : 		}
; 3342 : 	}
; 3343 : 	EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 3344 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207378

; 3345 : 		zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207378:

; 3346 : 	ExitLog;
; 3347 : 	return S_OK;

	mov	DWORD PTR $T221116[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221116[ebp]
$L207177:

; 3348 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221130
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 292				; 00000124H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221130:
	DD	7
	DD	$L221129
$L221129:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L221120
	DD	-64					; ffffffc0H
	DD	4
	DD	$L221121
	DD	-76					; ffffffb4H
	DD	4
	DD	$L221122
	DD	-92					; ffffffa4H
	DD	4
	DD	$L221123
	DD	-104					; ffffff98H
	DD	4
	DD	$L221124
	DD	-164					; ffffff5cH
	DD	16					; 00000010H
	DD	$L221125
	DD	-224					; ffffff20H
	DD	50					; 00000032H
	DD	$L221126
$L221126:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221125:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221124:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221123:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221122:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$L221121:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$L221120:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221131:
	DD	$L207278
	DD	$L207273
	DD	$L207288
	DD	$L207283
_TEXT	ENDS
text$x	SEGMENT
$L221117:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221119
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::SignXMLStr
EXTRN	_fetchLDAP_URL:NEAR
EXTRN	__wstat:NEAR
EXTRN	_fread:NEAR
EXTRN	_printf:NEAR
EXTRN	_xsHTTPFetch:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$207411 = -96						; size = 4
_abstrRef$ = -92					; size = 4
__lpa$ = -88						; size = 4
__lpw$ = -84						; size = 4
__acp$ = -80						; size = 4
__convert$ = -76					; size = 4
_ref$ = -72						; size = 4
_pDataBlob$ = -68					; size = 4
_content$ = -64						; size = 4
_contentType$ = -60					; size = 4
_res$ = -56						; size = 4
_statbuf$ = -48						; size = 36
_fdoc$ = -8						; size = 4
_this$ = -4						; size = 4
_bstrRef$ = 8						; size = 4
_cbRef$ = 12						; size = 4
?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z PROC NEAR ; CSignature::xsDereferenceBstrURI
; _this$ = ecx

; 3362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 3363 : FILE *fdoc;
; 3364 : #ifdef WIN32
; 3365 : struct _stat statbuf;
; 3366 : #elif LINUX
; 3367 : struct stat statbuf;
; 3368 : #endif
; 3369 : unsigned int res=0;

	mov	DWORD PTR _res$[ebp], 0

; 3370 : char *contentType = NULL;

	mov	DWORD PTR _contentType$[ebp], 0

; 3371 : unsigned char *content=NULL;

	mov	DWORD PTR _content$[ebp], 0

; 3372 : DS_DATA_BLOB **pDataBlob;
; 3373 : URI ref;
; 3374 : 
; 3375 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3376 : 
; 3377 : 	unsigned char *abstrRef = HeapW2A(bstrRef);

	mov	eax, DWORD PTR _bstrRef$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _abstrRef$[ebp], eax

; 3378 : 	ref = (URI)abstrRef;

	mov	ecx, DWORD PTR _abstrRef$[ebp]
	mov	DWORD PTR _ref$[ebp], ecx

; 3379 : 
; 3380 : 	if (ref == NULL) {

	cmp	DWORD PTR _ref$[ebp], 0
	jne	SHORT $L207399

; 3381 : 		return NULL;

	xor	eax, eax
	jmp	$L207385
$L207399:

; 3382 : 	}
; 3383 : 
; 3384 : 		// is it URI?
; 3385 : 	if ((strnicmp(ref,"http://",7))==0) {

	push	7
	push	OFFSET FLAT:$SG207401
	mov	edx, DWORD PTR _ref$[ebp]
	push	edx
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L207400

; 3386 : 		content = xsHTTPFetch(ref, (int *) cbRef);

	mov	eax, DWORD PTR _cbRef$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	call	_xsHTTPFetch
	add	esp, 8
	mov	DWORD PTR _content$[ebp], eax

; 3387 : 		if (content == NULL) {

	cmp	DWORD PTR _content$[ebp], 0
	jne	SHORT $L207403

; 3388 : #ifdef _DEBUG
; 3389 : 	printf("Cannot fetch content: %s\n",ref);

	mov	edx, DWORD PTR _ref$[ebp]
	push	edx
	push	OFFSET FLAT:$SG207404
	call	_printf
	add	esp, 8

; 3390 : #endif
; 3391 : 			zFree(abstrRef);

	mov	eax, DWORD PTR _abstrRef$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 3392 : 			return NULL;

	xor	eax, eax
	jmp	$L207385
$L207403:

; 3393 : 		}
; 3394 : 		zFree(abstrRef);

	mov	ecx, DWORD PTR _abstrRef$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3395 : 		return content;

	mov	eax, DWORD PTR _content$[ebp]
	jmp	$L207385
$L207400:

; 3396 : 	}
; 3397 : 	if (strnicmp(ref,"ldap:",5)==0) 

	push	5
	push	OFFSET FLAT:$SG207406
	mov	edx, DWORD PTR _ref$[ebp]
	push	edx
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L207405

; 3398 : 	{
; 3399 : 		pDataBlob = fetchLDAP_URL((BYTE *)ref);

	mov	eax, DWORD PTR _ref$[ebp]
	push	eax
	call	_fetchLDAP_URL
	add	esp, 4
	mov	DWORD PTR _pDataBlob$[ebp], eax

; 3400 : 		if (pDataBlob == NULL || pDataBlob[0] == NULL) {

	cmp	DWORD PTR _pDataBlob$[ebp], 0
	je	SHORT $L207409
	mov	ecx, DWORD PTR _pDataBlob$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L207408
$L207409:

; 3401 : 			zFree(abstrRef);

	mov	edx, DWORD PTR _abstrRef$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3402 : 			return NULL;

	xor	eax, eax
	jmp	$L207385
$L207408:

; 3403 : 		}
; 3404 : 		else
; 3405 : 		{
; 3406 : 			*cbRef = pDataBlob[0]->cbData;

	mov	eax, DWORD PTR _pDataBlob$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _cbRef$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 3407 : 			content = pDataBlob[0]->pbData;

	mov	ecx, DWORD PTR _pDataBlob$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _content$[ebp], eax

; 3408 : 			int i=0;

	mov	DWORD PTR _i$207411[ebp], 0
$L207413:

; 3409 : 			while (pDataBlob[i]) {

	mov	ecx, DWORD PTR _i$207411[ebp]
	mov	edx, DWORD PTR _pDataBlob$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L207414

; 3410 : 				zFree(pDataBlob[i]->pbData);

	mov	eax, DWORD PTR _i$207411[ebp]
	mov	ecx, DWORD PTR _pDataBlob$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4

; 3411 : 				zFree(pDataBlob[i]);

	mov	ecx, DWORD PTR _i$207411[ebp]
	mov	edx, DWORD PTR _pDataBlob$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 3412 : 				i++;

	mov	ecx, DWORD PTR _i$207411[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$207411[ebp], ecx

; 3413 : 			}

	jmp	SHORT $L207413
$L207414:

; 3414 : 			zFree(pDataBlob);

	mov	edx, DWORD PTR _pDataBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3415 : 			zFree(abstrRef);

	mov	eax, DWORD PTR _abstrRef$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 3416 : 			return(content);

	mov	eax, DWORD PTR _content$[ebp]
	jmp	$L207385
$L207405:

; 3417 : 		}
; 3418 : 	}
; 3419 : 
; 3420 : 	if ((strnicmp(ref,"file://",7))==0) {

	push	7
	push	OFFSET FLAT:$SG207416
	mov	ecx, DWORD PTR _ref$[ebp]
	push	ecx
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L207415

; 3421 : 		ref = ref+8;

	mov	edx, DWORD PTR _ref$[ebp]
	add	edx, 8
	mov	DWORD PTR _ref$[ebp], edx
$L207415:

; 3422 : 	}
; 3423 : 	zFree(abstrRef);

	mov	eax, DWORD PTR _abstrRef$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 3424 : 		// open file and read contest
; 3425 : #ifdef WIN32
; 3426 : 	if ((fdoc = _wfopen(bstrRef,L"rb"))==NULL) {

	push	OFFSET FLAT:$SG207418
	mov	ecx, DWORD PTR _bstrRef$[ebp]
	push	ecx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _fdoc$[ebp], eax
	cmp	DWORD PTR _fdoc$[ebp], 0
	jne	SHORT $L207417

; 3427 : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L207385
$L207417:

; 3428 : 	}
; 3429 : 	_wstat (bstrRef, &statbuf );

	lea	edx, DWORD PTR _statbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrRef$[ebp]
	push	eax
	call	__wstat
	add	esp, 8

; 3430 : #elif LINUX
; 3431 : 	unsigned char *utf8Ref = HeapW2A(bstrRef);
; 3432 : 	if ((fdoc = fopen((const char *)utf8Ref, "rb")) == NULL)
; 3433 : 	{
; 3434 : 		zFree(utf8Ref);
; 3435 : 		return NULL;
; 3436 : 	}
; 3437 : 	stat((const char *)utf8Ref, &statbuf);
; 3438 : 	zFree(utf8Ref);
; 3439 : #endif
; 3440 : 
; 3441 : #ifdef __powerpc__
; 3442 : 	*cbRef = statbuf.st_gen;
; 3443 : #else
; 3444 : 	*cbRef = statbuf.st_size;

	mov	ecx, DWORD PTR _cbRef$[ebp]
	mov	edx, DWORD PTR _statbuf$[ebp+20]
	mov	DWORD PTR [ecx], edx

; 3445 : #endif
; 3446 : 	content = (unsigned char *) zMalloc (*cbRef+1);

	mov	eax, DWORD PTR _cbRef$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _content$[ebp], eax

; 3447 : 	memset(content,0,*cbRef+1);

	mov	edx, DWORD PTR _cbRef$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3448 : 	fread(content, 1, statbuf.st_size, fdoc);

	mov	edx, DWORD PTR _fdoc$[ebp]
	push	edx
	mov	eax, DWORD PTR _statbuf$[ebp+20]
	push	eax
	push	1
	mov	ecx, DWORD PTR _content$[ebp]
	push	ecx
	call	_fread
	add	esp, 16					; 00000010H

; 3449 : 	fclose( fdoc );

	mov	edx, DWORD PTR _fdoc$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 3450 : 	return content;

	mov	eax, DWORD PTR _content$[ebp]
$L207385:

; 3451 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221136
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221136:
	DD	1
	DD	$L221135
$L221135:
	DD	-48					; ffffffd0H
	DD	36					; 00000024H
	DD	$L221134
$L221134:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ENDP	; CSignature::xsDereferenceBstrURI
_TEXT	ENDS
PUBLIC	?ReadAll@CSignature@@UAGJPAGPAPAG@Z		; CSignature::ReadAll
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -36						; size = 4
__lpw$ = -32						; size = 4
__acp$ = -28						; size = 4
__convert$ = -24					; size = 4
_charFileName$ = -20					; size = 4
_dwFileSize$ = -12					; size = 4
_dataPtr$ = -4						; size = 4
_this$ = 8						; size = 4
_fileName$ = 12						; size = 4
_fileDataStr$ = 16					; size = 4
?ReadAll@CSignature@@UAGJPAGPAPAG@Z PROC NEAR		; CSignature::ReadAll

; 3455 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 3456 : 	unsigned char *dataPtr;
; 3457 : 	DWORD	dwFileSize;
; 3458 : 	unsigned char *charFileName;
; 3459 : 
; 3460 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3461 : 	EnterLog;
; 3462 : 	*fileDataStr = A2WBSTR((LPCSTR)NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _fileDataStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 3463 : 	charFileName = HeapW2A(fileName);

	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charFileName$[ebp], eax

; 3464 : 
; 3465 : 	if ((charFileName == NULL) || (strlen((const char *)charFileName) == 0))

	cmp	DWORD PTR _charFileName$[ebp], 0
	je	SHORT $L207435
	mov	eax, DWORD PTR _charFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L207434
$L207435:

; 3466 : 	{
; 3467 : 		setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 3468 : 		zFree(charFileName);

	mov	eax, DWORD PTR _charFileName$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 3469 : 		ExitLog;
; 3470 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207424
$L207434:

; 3471 : 	}
; 3472 : 
; 3473 : 	dataPtr = xsDereferenceBstrURI(fileName, &dwFileSize);

	lea	ecx, DWORD PTR _dwFileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	DWORD PTR _dataPtr$[ebp], eax

; 3474 : 	if (dataPtr == NULL)

	cmp	DWORD PTR _dataPtr$[ebp], 0
	jne	SHORT $L207437

; 3475 : 	{
; 3476 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3477 : 		zFree(charFileName);

	mov	edx, DWORD PTR _charFileName$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3478 : 		ExitLog;
; 3479 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207424
$L207437:

; 3480 : 	}
; 3481 : 	else
; 3482 : 	{
; 3483 : 		if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) ||
; 3484 : 			((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff)))

	mov	eax, DWORD PTR _dataPtr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207442
	mov	edx, DWORD PTR _dataPtr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L207441
$L207442:
	mov	ecx, DWORD PTR _dataPtr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L207440
	mov	eax, DWORD PTR _dataPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L207440
$L207441:

; 3485 : 		{
; 3486 : 			// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 3487 : 			// Just allocate memory and copy data and put the size information in front
; 3488 : 			*fileDataStr = ::SysAllocStringByteLen((LPCSTR)dataPtr, (UINT)dwFileSize);

	mov	esi, esp
	mov	edx, DWORD PTR _dwFileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _fileDataStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 3489 : 			zFree(dataPtr);

	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3490 : 		}
; 3491 : 		else

	jmp	SHORT $L207445
$L207440:

; 3492 : 		{
; 3493 : 			*fileDataStr = A2WBSTR((LPCSTR)dataPtr, dwFileSize);

	mov	eax, DWORD PTR _dwFileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _fileDataStr$[ebp]
	mov	DWORD PTR [edx], eax

; 3494 : 			zFree(dataPtr);

	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207445:

; 3495 : 		}
; 3496 : 		zFree(charFileName);

	mov	ecx, DWORD PTR _charFileName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3497 : 		ExitLog;
; 3498 : 		return S_OK;

	xor	eax, eax
$L207424:

; 3499 : 	}
; 3500 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221140
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221140:
	DD	1
	DD	$L221139
$L221139:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221138
$L221138:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
?ReadAll@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::ReadAll
_TEXT	ENDS
PUBLIC	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z	; CSignature::ReadAllBin
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fileName$ = 8						; size = 4
_binData$ = 12						; size = 4
_dwFileSize$ = 16					; size = 4
?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z PROC NEAR	; CSignature::ReadAllBin
; _this$ = ecx

; 3503 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3504 : 	EnterLog;
; 3505 : 	if ((fileName == NULL) || (SysStringLen(fileName) == 0))

	cmp	DWORD PTR _fileName$[ebp], 0
	je	SHORT $L207455
	mov	esi, esp
	mov	eax, DWORD PTR _fileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L207454
$L207455:

; 3506 : 	{
; 3507 : 		setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 3508 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207453
$L207454:

; 3509 : 	}
; 3510 : 	*binData = xsDereferenceBstrURI(fileName, dwFileSize);

	mov	eax, DWORD PTR _dwFileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	edx, DWORD PTR _binData$[ebp]
	mov	DWORD PTR [edx], eax

; 3511 : 	if (binData == NULL)

	cmp	DWORD PTR _binData$[ebp], 0
	jne	SHORT $L207457

; 3512 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207453
$L207457:

; 3513 : 	else
; 3514 : 	{
; 3515 : 		ExitLog;
; 3516 : 		return S_OK;

	xor	eax, eax
$L207453:

; 3517 : 	}
; 3518 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ENDP		; CSignature::ReadAllBin
_TEXT	ENDS
PUBLIC	?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z		; CSignature::SaveXMLStr
PUBLIC	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
EXTRN	_fwrite:NEAR
xdata$x	SEGMENT
$T221164 DD	0ffffffffH
	DD	FLAT:$L221152
	DD	00H
	DD	FLAT:$L221153
$T221155 DD	019930520H
	DD	02H
	DD	FLAT:$T221164
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221151 = -400						; size = 4
$T221150 = -396						; size = 4
$T221149 = -392						; size = 4
$T221148 = -388						; size = 4
$T221147 = -384						; size = 4
$T221146 = -380						; size = 4
$T221145 = -376						; size = 4
$T221144 = -372						; size = 4
_szPtr$ = -368						; size = 4
_ptr$ = -364						; size = 4
__lpa$ = -360						; size = 4
__lpw$ = -356						; size = 4
__acp$ = -352						; size = 4
__convert$ = -348					; size = 4
_tmpFilePath$ = -340					; size = 4
_freeMemory$ = -332					; size = 4
_tmpXmlStr$ = -324					; size = 4
_TempPath$ = -312					; size = 260
_bstrFileName$ = -48					; size = 4
_ccBstrFileName$ = -40					; size = 4
_fileSize$ = -32					; size = 4
_charInputXMLStr$ = -28					; size = 4
_writeResult$ = -24					; size = 4
_hInFile$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputXMLStr$ = 12					; size = 4
_fileName$ = 16						; size = 4
_path$ = 20						; size = 4
?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::SaveXMLStr

; 3522 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 388				; 00000184H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-400]
	mov	ecx, 97					; 00000061H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3523 : 	FILE *hInFile; 
; 3524 : 	BOOL writeResult;
; 3525 : 	char *charInputXMLStr;
; 3526 : 	int fileSize;
; 3527 : 	CComBSTR ccBstrFileName;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3528 : 	BSTR bstrFileName;
; 3529 : 	char TempPath[MAX_PATH];
; 3530 : 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3531 : 	BOOL freeMemory=FALSE;

	mov	DWORD PTR _freeMemory$[ebp], 0

; 3532 : 	TEMP_FILE_INFO	*tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 3533 : 
; 3534 : 	EnterLog;
; 3535 : 	*path = A2WBSTR((const char *) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _path$[ebp]
	mov	DWORD PTR [ecx], eax

; 3536 : 	tmpXmlStr = inputXMLStr;

	mov	edx, DWORD PTR _inputXMLStr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 3537 : 	if (tmpXmlStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207478

; 3538 : 	{
; 3539 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3540 : 		DebugLog("Input XML String is empty");
; 3541 : 		return S_FALSE;

	mov	DWORD PTR $T221144[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221144[ebp]
	jmp	$L207466
$L207478:

; 3542 : 	}
; 3543 : 
; 3544 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3545 : 	ccBstrFileName = fileName;

	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 3546 : 
; 3547 : 	if ((ccBstrFileName.Length() == 0) || (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L207486
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3364], 1
	jne	$L207485
$L207486:

; 3548 : 	{
; 3549 : 		// Create temporary file for saving input XML String
; 3550 : 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3551 : 		GetTempFileName(TempPath, // dir. for temp. files 
; 3552 : 			"INF",                // temp. file name prefix 
; 3553 : 			0,                    // create unique name 
; 3554 : 			szTempName);          // buffer for name 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG207488
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3555 : 		bstrFileName = A2WBSTR(szTempName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 3556 : 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221145[ebp], eax
	mov	edx, DWORD PTR $T221145[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], edx

; 3557 : 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3558 : 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T221146[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T221147[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 3559 : 	}
; 3560 : 	else

	jmp	SHORT $L207494
$L207485:

; 3561 : 		bstrFileName = SysAllocString(fileName);

	mov	esi, esp
	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L207494:

; 3562 : 
; 3563 : 	// open file in write mode 
; 3564 : #ifdef WIN32
; 3565 : 	if ((hInFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG207496
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hInFile$[ebp], eax
	cmp	DWORD PTR _hInFile$[ebp], 0
	jne	SHORT $L207495

; 3566 : #elif LINUX
; 3567 : 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 3568 : 	if ((hInFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 3569 : 			zFree(utf8FileName);
; 3570 : #endif
; 3571 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 3572 : 			DebugLog("Could not create file");
; 3573 : 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L207497

; 3574 : 			{
; 3575 : 				tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L207497:

; 3576 : 			}
; 3577 : 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3578 : 			return S_FALSE;

	mov	DWORD PTR $T221148[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221148[ebp]
	jmp	$L207466
$L207495:

; 3579 : 	}
; 3580 : #ifdef LINUX
; 3581 : 	zFree(utf8FileName);
; 3582 : #endif
; 3583 : 
; 3584 : 	unsigned char *ptr = (unsigned char *)inputXMLStr;

	mov	eax, DWORD PTR _inputXMLStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 3585 : 	unsigned int *szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 3586 : 	fileSize = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _fileSize$[ebp], eax

; 3587 : 
; 3588 : 	if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 3589 : 		((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L207507
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L207506
$L207507:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L207505
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L207505
$L207506:

; 3590 : 	{
; 3591 : 		// The data is in utf-16 format so do not convert to char *
; 3592 : 		charInputXMLStr = (char *)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _charInputXMLStr$[ebp], eax

; 3593 : 	}
; 3594 : 	else

	jmp	SHORT $L207509
$L207505:

; 3595 : 	{
; 3596 : 		charInputXMLStr = (char *)HeapW2A(inputXMLStr);

	mov	ecx, DWORD PTR _inputXMLStr$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charInputXMLStr$[ebp], eax

; 3597 : 		fileSize = strlen(charInputXMLStr);

	mov	edx, DWORD PTR _charInputXMLStr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _fileSize$[ebp], eax

; 3598 : 		freeMemory = TRUE;

	mov	DWORD PTR _freeMemory$[ebp], 1
$L207509:

; 3599 : 	}
; 3600 : 
; 3601 : 	if ((writeResult = fwrite(charInputXMLStr, 1, fileSize, hInFile)) == 0)

	mov	eax, DWORD PTR _hInFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _charInputXMLStr$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _writeResult$[ebp], eax
	cmp	DWORD PTR _writeResult$[ebp], 0
	jne	SHORT $L207511

; 3602 : 	{
; 3603 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3604 : 		DebugLog("Could not write to file");
; 3605 : 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L207512

; 3606 : 		{
; 3607 : 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L207512:

; 3608 : 		}
; 3609 : 		return S_FALSE;

	mov	DWORD PTR $T221149[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221149[ebp]
	jmp	$L207466
$L207511:

; 3610 : 	}
; 3611 : 	if (ferror(hInFile))

	mov	ecx, DWORD PTR _hInFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 32					; 00000020H
	je	SHORT $L207515

; 3612 : 	{
; 3613 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3614 : 		DebugLog("Could not write to file");
; 3615 : 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L207516

; 3616 : 		{
; 3617 : 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L207516:

; 3618 : 		}
; 3619 : 		return S_FALSE;

	mov	DWORD PTR $T221150[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221150[ebp]
	jmp	SHORT $L207466
$L207515:

; 3620 : 	}
; 3621 : 
; 3622 : 	fclose(hInFile);

	mov	ecx, DWORD PTR _hInFile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 3623 : 	//tmpXmlStr = bstrFileName;
; 3624 : 	//*path = tmpXmlStr.Copy();
; 3625 : 	*path = bstrFileName;

	mov	edx, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 3626 : 	if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L207519

; 3627 : 		zFree(charInputXMLStr);

	mov	ecx, DWORD PTR _charInputXMLStr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207519:

; 3628 : 	ExitLog;
; 3629 : 	return S_OK;

	mov	DWORD PTR $T221151[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221151[ebp]
$L207466:

; 3630 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221163
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 400				; 00000190H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221163:
	DD	4
	DD	$L221162
$L221162:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221156
	DD	-312					; fffffec8H
	DD	260					; 00000104H
	DD	$L221157
	DD	-324					; fffffebcH
	DD	4
	DD	$L221158
	DD	-340					; fffffeacH
	DD	4
	DD	$L221159
$L221159:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221158:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221157:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221156:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221152:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221153:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221155
	jmp	___CxxFrameHandler
text$x	ENDS
?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::SaveXMLStr
PUBLIC	?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z	; CSignature::SignHTML
EXTRN	_IID_IHTMLDocument3:BYTE
EXTRN	_xmlSetNs:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv243 = -252						; size = 4
_tmpEnvFlag$ = -248					; size = 2
_freeCharSigId$ = -244					; size = 4
__lpa$ = -240						; size = 4
__lpw$ = -236						; size = 4
__acp$ = -232						; size = 4
__convert$ = -228					; size = 4
_iSize$ = -220						; size = 4
_dtd$ = -212						; size = 4
_mem$ = -208						; size = 4
_curNs$ = -204						; size = 4
_signedInfoNode$ = -200					; size = 4
_sigNode$ = -196					; size = 4
_commNode$ = -192					; size = 4
_parent$ = -188						; size = 4
_rootNode$ = -184					; size = 4
_cur$ = -180						; size = 4
_doc$ = -176						; size = 4
_sigGuid$ = -168					; size = 16
_guidStr$ = -144					; size = 50
_signedXML$ = -84					; size = 4
_charSigId$ = -76					; size = 4
_ki$ = -72						; size = 4
_certData$ = -68					; size = 4
_htmlSize$ = -64					; size = 4
_crBlob$ = -56						; size = 8
_charHtmlStr$ = -44					; size = 4
_htmlstr$ = -36						; size = 4
_htmlElement$ = -24					; size = 4
_curDoc$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_document$ = 12						; size = 4
_signedHTML$ = 16					; size = 4
?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z PROC NEAR ; CSignature::SignHTML

; 3634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 63					; 0000003fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3635 : 	IHTMLDocument3 *curDoc;
; 3636 : 	IHTMLElement	*htmlElement;
; 3637 : 	BSTR htmlstr;
; 3638 : 	char *charHtmlStr;
; 3639 : 	DS_DATA_BLOB crBlob;
; 3640 : 	int htmlSize;
; 3641 : 	unsigned char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 3642 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 3643 : 	char *charSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 3644 : 	unsigned char *signedXML=NULL;

	mov	DWORD PTR _signedXML$[ebp], 0

; 3645 : 	char guidStr[50];
; 3646 : #ifdef WIN32
; 3647 : 	GUID sigGuid;
; 3648 : #else
; 3649 : 	uuid_t sigGuid;
; 3650 : #endif
; 3651 : 
; 3652 : 	EnterLog;
; 3653 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L207539

; 3654 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3655 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207526
$L207539:

; 3656 : 	}
; 3657 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L207541

; 3658 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 3659 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207526
$L207541:

; 3660 : 	}
; 3661 : 
; 3662 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L207543

; 3663 : 	{
; 3664 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L207544

; 3665 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L207544:

; 3666 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 3667 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L207543:

; 3668 : 	}
; 3669 : 
; 3670 : 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 3671 : 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 3672 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 3673 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 3674 : 	xmlDtdPtr dtd=NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 3675 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 3676 : 
; 3677 : 	crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 3678 : 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 3679 : 
; 3680 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3681 : 
; 3682 : 	document->QueryInterface(IID_IHTMLDocument3, (void **)&curDoc);

	mov	esi, esp
	lea	edx, DWORD PTR _curDoc$[ebp]
	push	edx
	push	OFFSET FLAT:_IID_IHTMLDocument3
	mov	eax, DWORD PTR _document$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _document$[ebp]
	push	edx
	call	DWORD PTR [ecx]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3683 : 
; 3684 : 	curDoc->get_documentElement(&htmlElement);

	mov	esi, esp
	lea	eax, DWORD PTR _htmlElement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curDoc$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _curDoc$[ebp]
	push	eax
	call	DWORD PTR [edx+40]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3685 : 	htmlElement->get_outerHTML(&htmlstr);

	mov	esi, esp
	lea	ecx, DWORD PTR _htmlstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _htmlElement$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _htmlElement$[ebp]
	push	ecx
	call	DWORD PTR [eax+248]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3686 : 
; 3687 : 	charHtmlStr = (char *)HeapW2A(htmlstr);

	mov	edx, DWORD PTR _htmlstr$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charHtmlStr$[ebp], eax

; 3688 : /* To be Added by Alex
; 3689 : <!DOCTYPE InfomosaicSecureXML [
; 3690 :   <!ATTLIST SignedHTML Id ID #IMPLIED>
; 3691 : ]>
; 3692 : 
; 3693 : */
; 3694 : 
; 3695 : 
; 3696 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG207563
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 3697 : 	// document, namespace, element name, element content
; 3698 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"InfomosaicSecureXML",NULL);

	push	0
	push	OFFSET FLAT:$SG207565
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 3699 : 
; 3700 : 	// if you want any namespace definition here
; 3701 : 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/SignHTML/DTD.htm",(const unsigned char *)"infomosaic");

	push	OFFSET FLAT:$SG207568
	push	OFFSET FLAT:$SG207569
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 3702 : 	xmlSetNs(cur,curNs);

	mov	edx, DWORD PTR _curNs$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlSetNs
	add	esp, 8

; 3703 : 
; 3704 : 
; 3705 : 	// add root element
; 3706 : 	xmlDocSetRootElement(doc,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocSetRootElement
	add	esp, 8

; 3707 : 	rootNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], eax

; 3708 : 
; 3709 : 	//// add some comment
; 3710 : 	//commNode = xmlNewDocComment(doc,(const unsigned char *)"HTML Signed by Infomosaic SecureXML http://www.infomosaic.net");
; 3711 : 	//cur = xmlAddChild(rootNode,commNode);
; 3712 : 	/*
; 3713 : 	 * SignedHTML
; 3714 : 	*/
; 3715 : 	cur = xmlNewNode(curNs,(const unsigned char *)"SignedHTML"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207571
	mov	ecx, DWORD PTR _curNs$[ebp]
	push	ecx
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3716 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3717 : 	xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG207574
	push	OFFSET FLAT:$SG207575
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3718 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)"HTMLData");

	push	OFFSET FLAT:$SG207578
	push	OFFSET FLAT:$SG207579
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3719 : 
; 3720 : 	// Base64 encode
; 3721 : 	htmlSize = strlen((const char *)charHtmlStr);

	mov	eax, DWORD PTR _charHtmlStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _htmlSize$[ebp], eax

; 3722 : 	crBlob.cbData = base64encodeSize(htmlSize);

	mov	ecx, DWORD PTR _htmlSize$[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 3723 : 	// allocate memory
; 3724 : 	if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	edx, DWORD PTR _crBlob$[ebp+4]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L207582

; 3725 : 	{
; 3726 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207526
$L207582:

; 3727 : 	}
; 3728 : 	if (base64encode((unsigned char *)charHtmlStr,htmlSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) {

	mov	eax, DWORD PTR _crBlob$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _htmlSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charHtmlStr$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L207586

; 3729 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207526
$L207586:

; 3730 : 	}
; 3731 : 	*(crBlob.pbData+crBlob.cbData)='\0';

	mov	ecx, DWORD PTR _crBlob$[ebp]
	add	ecx, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [ecx], 0

; 3732 : 
; 3733 : 	zFree(charHtmlStr);

	mov	edx, DWORD PTR _charHtmlStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3734 : 
; 3735 : 	xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 3736 : 
; 3737 : 	/*
; 3738 : 	 * Signature
; 3739 : 	*/
; 3740 : 
; 3741 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 3742 : 	if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207590

; 3743 : 	{
; 3744 : #ifdef WIN32
; 3745 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3746 : 		GuidToString(&sigGuid, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 3747 : #else
; 3748 : 		uuid_generate(sigGuid);
; 3749 : 		uuid_unparse(sigGuid, guidStr);
; 3750 : #endif
; 3751 : 		charSigId = guidStr;

	lea	edx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], edx

; 3752 : 	}
; 3753 : 	else

	jmp	SHORT $L207591
$L207590:

; 3754 : 	{
; 3755 : 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 3756 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L207591:

; 3757 : 	}
; 3758 : 
; 3759 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207594
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3760 : 	sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 3761 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG207597
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3762 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3763 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG207600
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 3764 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 3765 : 
; 3766 : 	/*
; 3767 : 	 * SignedInfo
; 3768 : 	*/
; 3769 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207602
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3770 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 3771 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3772 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 3773 : 
; 3774 : 	/*
; 3775 : 	 * Canonicalization Method
; 3776 : 	*/
; 3777 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG207604
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3778 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv243[ebp], edx
	cmp	DWORD PTR tv243[ebp], 3
	ja	SHORT $L207629
	mov	eax, DWORD PTR tv243[ebp]
	jmp	DWORD PTR $L221178[eax*4]
$L207609:

; 3779 : 	{
; 3780 : 		case WITH_COMMENTS:
; 3781 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG207612
	push	OFFSET FLAT:$SG207613
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3782 : 			break;

	jmp	SHORT $L207606
$L207614:

; 3783 : 		case WITHOUT_COMMENTS:
; 3784 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG207617
	push	OFFSET FLAT:$SG207618
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3785 : 			break;

	jmp	SHORT $L207606
$L207619:

; 3786 : 		case EXC_WITH_COMMENTS:
; 3787 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG207622
	push	OFFSET FLAT:$SG207623
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3788 : 			break;

	jmp	SHORT $L207606
$L207624:

; 3789 : 		case EXC_WITHOUT_COMMENTS:
; 3790 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG207627
	push	OFFSET FLAT:$SG207628
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3791 : 			break;

	jmp	SHORT $L207606
$L207629:

; 3792 : 		default:
; 3793 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG207632
	push	OFFSET FLAT:$SG207633
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207606:

; 3794 : 	}
; 3795 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3796 : 
; 3797 : 	/*
; 3798 : 	 * Reference
; 3799 : 	*/
; 3800 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207635
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3801 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3802 : 	xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"#HTMLData");

	push	OFFSET FLAT:$SG207638
	push	OFFSET FLAT:$SG207639
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3803 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 3804 : 
; 3805 : 	/*
; 3806 : 	 * Transforms
; 3807 : 	 */
; 3808 : 	
; 3809 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG207641
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3810 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3811 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 3812 : 
; 3813 : 	/*
; 3814 : 	 * Transform
; 3815 : 	 */
; 3816 : 	
; 3817 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG207643
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3818 : 	xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG207646
	push	OFFSET FLAT:$SG207647
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 3819 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 3820 : 
; 3821 : 	if (AddWindowImageFlag == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1796], 1
	jne	SHORT $L207648

; 3822 :         AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L207648:

; 3823 : 
; 3824 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+956], 0
	je	SHORT $L207649

; 3825 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L207649:

; 3826 : 
; 3827 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], ax

; 3828 : 	EnvelopingFlag = ENVELOPED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+688], 2

; 3829 : 
; 3830 : 	if (!(CreateSigFromTmplBlob(
; 3831 : 								doc,
; 3832 : 								(char *)charSigId, &signedXML, &iSize)))

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L207652

; 3833 : 	{
; 3834 : 		if (signedXML != NULL)

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L207653

; 3835 : 			zFree(signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207653:

; 3836 : 		EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 3837 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207654

; 3838 : 			zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207654:

; 3839 : 		ExitLog;
; 3840 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207526
$L207652:

; 3841 : 	}
; 3842 : 	EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 3843 : 
; 3844 : 	*signedHTML = A2WBSTR((LPCSTR)signedXML, iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _signedHTML$[ebp]
	mov	DWORD PTR [edx], eax

; 3845 : 	if (Base64EncodeXML == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2180], 1
	jne	SHORT $L207657

; 3846 : 		zFree(signedXML);

	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3847 : 	else

	jmp	SHORT $L207658
$L207657:

; 3848 : 		xmlFree(signedXML);

	mov	esi, esp
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L207658:

; 3849 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L207659

; 3850 : 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207659:

; 3851 : 	ExitLog;
; 3852 : 	return S_OK;

	xor	eax, eax
$L207526:

; 3853 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221177
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221177:
	DD	8
	DD	$L221176
$L221176:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221167
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221168
	DD	-36					; ffffffdcH
	DD	4
	DD	$L221169
	DD	-56					; ffffffc8H
	DD	8
	DD	$L221170
	DD	-84					; ffffffacH
	DD	4
	DD	$L221171
	DD	-144					; ffffff70H
	DD	50					; 00000032H
	DD	$L221172
	DD	-168					; ffffff58H
	DD	16					; 00000010H
	DD	$L221173
	DD	-220					; ffffff24H
	DD	4
	DD	$L221174
$L221174:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221173:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221172:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221171:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221170:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221169:
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221168:
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	69					; 00000045H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221167:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	0
$L221178:
	DD	$L207614
	DD	$L207609
	DD	$L207624
	DD	$L207619
?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z ENDP	; CSignature::SignHTML
_TEXT	ENDS
PUBLIC	?getVerifyAllowed@CLicense@@QAEHXZ		; CLicense::getVerifyAllowed
PUBLIC	?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z	; CSignature::SecureXMLVerify
EXTRN	_xsCoreSetCSP:NEAR
EXTRN	_itoa:NEAR
EXTRN	_wcslen:NEAR
EXTRN	_xmlNewDocComment:NEAR
EXTRN	_axVerify:NEAR
EXTRN	_errorMsgTable:BYTE
EXTRN	__imp__StrChrA@8:NEAR
EXTRN	_xmlDocDumpMemoryEnc:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_equalPtr$207890 = -404					; size = 4
_charTsProp$207889 = -400				; size = 4
_utf16StrByteLen$207820 = -392				; size = 4
_utf16CharStrLen$207819 = -384				; size = 4
_utf8CharStrLen$207818 = -376				; size = 4
_utf8CharStr$207817 = -368				; size = 4
_errStr$207807 = -364					; size = 4
_certStatus$207790 = -356				; size = 4
__lpa$ = -348						; size = 4
__lpw$ = -344						; size = 4
__acp$ = -340						; size = 4
__convert$ = -336					; size = 4
_plainTextHex$ = -332					; size = 4
_pbDocument$ = -328					; size = 4
_pbData$ = -324						; size = 4
_freeNewPtr$ = -320					; size = 4
_sizeM$ = -316						; size = 4
_szPtr$ = -312						; size = 4
_curPtr$ = -308						; size = 4
_newPtr$ = -304						; size = 4
_ptr$ = -300						; size = 4
_buffer$ = -292						; size = 200
_iSize$ = -84						; size = 4
_dtd$ = -76						; size = 4
_mem$ = -68						; size = 4
_curNs$ = -60						; size = 4
_commNode$ = -56					; size = 4
_parent$ = -52						; size = 4
_rootNode$ = -48					; size = 4
_cur$ = -44						; size = 4
_doc$ = -40						; size = 4
_sigStatus$ = -36					; size = 4
_uriPath$ = -32						; size = 4
_refArr$ = -28						; size = 4
_failedLocNum$ = -24					; size = 4
_totalLocNum$ = -20					; size = 4
_refNum$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_signedXML$ = 12					; size = 4
_verificationResponse$ = 16				; size = 4
?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::SecureXMLVerify

; 3857 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 404				; 00000194H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-404]
	mov	ecx, 101				; 00000065H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3858 : 	int i,j,refNum=0, totalLocNum=0, failedLocNum=0;

	mov	DWORD PTR _refNum$[ebp], 0
	mov	DWORD PTR _totalLocNum$[ebp], 0
	mov	DWORD PTR _failedLocNum$[ebp], 0

; 3859 : 	PURI_STATUS *refArr=NULL;

	mov	DWORD PTR _refArr$[ebp], 0

; 3860 : 	PURI_PATH uriPath=NULL;

	mov	DWORD PTR _uriPath$[ebp], 0

; 3861 : 	long sigStatus;
; 3862 : 
; 3863 : #ifdef LOG_WS
; 3864 : 	char charTempFileName[MAX_PATH];
; 3865 : 	char xmlTempFileName[MAX_PATH];
; 3866 : 	BSTR bstrTempFileName, returnBstrTempFileName;
; 3867 : #endif
; 3868 : 
; 3869 : 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 3870 : 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0

; 3871 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 3872 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 3873 : 	xmlDtdPtr dtd=NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 3874 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 3875 : 	char buffer[200];
; 3876 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 3877 : 	unsigned int *szPtr;
; 3878 : 	unsigned int sizeM;
; 3879 : 	BOOL freeNewPtr=FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 3880 : 
; 3881 : 	unsigned char *pbData=NULL, *pbDocument=NULL, *plainTextHex=NULL;

	mov	DWORD PTR _pbData$[ebp], 0
	mov	DWORD PTR _pbDocument$[ebp], 0
	mov	DWORD PTR _plainTextHex$[ebp], 0

; 3882 : 
; 3883 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 3884 : 
; 3885 : 	EnterLog;
; 3886 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L207697

; 3887 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3888 : 		*verificationResponse = A2WBSTR((LPCSTR)"<?xml version=\"1.0\" ?>\n<Error>Invalid SecureXML License</Error>");

	push	-1
	push	OFFSET FLAT:$SG207699
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [edx], eax

; 3889 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207665
$L207697:

; 3890 : 	}
; 3891 : 	if (!LicObj.getVerifyAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getVerifyAllowed@CLicense@@QAEHXZ	; CLicense::getVerifyAllowed
	test	eax, eax
	jne	SHORT $L207701

; 3892 : 		setError(SigHandle, NO_VERIFICATION_LIC);

	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 3893 : 		*verificationResponse = A2WBSTR((LPCSTR)"<?xml version=\"1.0\" ?>\n<Error>No SecureXML Verification License</Error>");

	push	-1
	push	OFFSET FLAT:$SG207703
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [edx], eax

; 3894 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207665
$L207701:

; 3895 : 	}
; 3896 : 
; 3897 : 	if ((signedXML == NULL) || (SysStringByteLen(signedXML) == 0))

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L207706
	mov	esi, esp
	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L207705
$L207706:

; 3898 : 	{
; 3899 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 3900 : 		*verificationResponse = A2WBSTR((LPCSTR)"<?xml version=\"1.0\" ?>\n<Error>XML Parser Error</Error>");

	push	-1
	push	OFFSET FLAT:$SG207708
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [ecx], eax

; 3901 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207665
$L207705:

; 3902 : 	}
; 3903 : 
; 3904 : 	if (Base64EncodeXML == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2180], 1
	jne	$L207710

; 3905 : 	{
; 3906 : 		ptr = HeapW2A(signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 3907 : 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 3908 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 3909 : 		if(!(newPtr = (BYTE *)zMalloc(sizeM+1)))

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax
	cmp	DWORD PTR _newPtr$[ebp], 0
	jne	SHORT $L207713

; 3910 : 		{
; 3911 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3912 : 			*verificationResponse = A2WBSTR((LPCSTR)"<?xml version=\"1.0\" ?>\n<Error>Out of memory</Error>");

	push	-1
	push	OFFSET FLAT:$SG207715
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [edx], eax

; 3913 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L207665
$L207713:

; 3914 : 		}
; 3915 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 3916 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L207717

; 3917 : 		{
; 3918 : 			zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 3919 : 			zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 3920 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 3921 : 			*verificationResponse = A2WBSTR((LPCSTR)"<?xml version=\"1.0\" ?>\n<Error>Base64 Decode Error</Error>");

	push	-1
	push	OFFSET FLAT:$SG207719
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [ecx], eax

; 3922 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L207665
$L207717:

; 3923 : 		}
; 3924 : 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 3925 : 	}
; 3926 : 	else

	jmp	$L207721
$L207710:

; 3927 : 	{
; 3928 : 		ptr = (unsigned char *)signedXML;

	mov	eax, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 3929 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 3930 : 		sizeM = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sizeM$[ebp], eax

; 3931 : 
; 3932 : 		if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 3933 : 			((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L207727
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L207726
$L207727:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L207725
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L207725
$L207726:

; 3934 : 		{
; 3935 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 3936 : 			newPtr = ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], eax

; 3937 : 		}
; 3938 : 		else

	jmp	SHORT $L207721
$L207725:

; 3939 : 		{
; 3940 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 3941 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 3942 : 
; 3943 : 			FileEncoding(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 3944 : //			*newPtr = 0xFF;
; 3945 : //			*(newPtr + 1) = 0xFE;
; 3946 : 
; 3947 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	add	edx, 2
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3948 : 			sizeM += 4;

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	mov	DWORD PTR _sizeM$[ebp], eax
$L207721:

; 3949 : 		}
; 3950 : 	}
; 3951 : 
; 3952 : #ifdef LOG_WS
; 3953 : 	GetTempFileName((LPCTSTR)"C:\\temp\\SecureXML_WS_LOGS", "sxvf", 0, (char *)charTempFileName);
; 3954 : 	bstrTempFileName = A2WBSTR((LPCSTR)charTempFileName);
; 3955 : 	SaveXMLStr(signedXML, bstrTempFileName, &returnBstrTempFileName);
; 3956 : 	strcpy(xmlTempFileName, charTempFileName);
; 3957 : 	strcat(xmlTempFileName, (char *)".xml");
; 3958 : 	MoveFile((LPCTSTR)charTempFileName, xmlTempFileName);
; 3959 : 	SysFreeString(bstrTempFileName);
; 3960 : #endif
; 3961 : 
; 3962 : 	SigHandle->locArray = uriArr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+12], ecx

; 3963 : 	SigHandle->locNumber = totalUriCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+16], edx

; 3964 : 
; 3965 : 
; 3966 : 	if (HMACKey.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207730

; 3967 : 		sigStatus = (BOOL) axVerify((const unsigned char *)newPtr, sizeM, NULL, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3420]
	push	ecx
	push	0
	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _sigStatus$[ebp], eax

; 3968 : 	else

	jmp	SHORT $L207733
$L207730:

; 3969 : 	{
; 3970 : 		/*
; 3971 : 		 * This might not work on Windows 95/98
; 3972 : 		 */
; 3973 : 		xsCoreSetCSP((unsigned char *)"Microsoft Enhanced Cryptographic Provider v1.0",SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	push	OFFSET FLAT:$SG207735
	call	_xsCoreSetCSP
	add	esp, 8

; 3974 : 		sigStatus = (BOOL) axVerify((const unsigned char *)newPtr, sizeM, &HMACPassword, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3420]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 908				; 0000038cH
	push	edx
	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _sigStatus$[ebp], eax
$L207733:

; 3975 : 	}
; 3976 : 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L207738

; 3977 : 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L207738:

; 3978 : 
; 3979 : 	//if (DetailedVerificationReportFlag == TRUE)
; 3980 : 	//	FetchSignatureStatus(sigStatus);
; 3981 : 	//else
; 3982 : 	//	sgArr = axGetSignature(&signum, SigHandle); // Get the full signature stats
; 3983 : 	FetchSignatureStatus(sigStatus, DetailedVerificationReportFlag);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	push	ecx
	mov	edx, DWORD PTR _sigStatus$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FetchSignatureStatus@CSignature@@QAEXHH@Z ; CSignature::FetchSignatureStatus

; 3984 : 
; 3985 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG207740
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 3986 : 	// document, namespace, element name, element content
; 3987 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"XMLSignatureVerificationResponse",NULL);

	push	0
	push	OFFSET FLAT:$SG207742
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 3988 : 
; 3989 : 	// if you want any namespace definition here
; 3990 : 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/XMLSign/VerifyResponse/DTD.htm",NULL/*(const unsigned char *)"infomosaic"*/);

	push	0
	push	OFFSET FLAT:$SG207744
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 3991 : 	//xmlSetNs(cur,curNs);
; 3992 : 
; 3993 : 	// add root element
; 3994 : 	xmlDocSetRootElement(doc,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocSetRootElement
	add	esp, 8

; 3995 : 	rootNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], ecx

; 3996 : 
; 3997 : 	// add some comment
; 3998 : 	commNode = xmlNewDocComment(doc,(const unsigned char *)"1.2 Verified by Infomosaic SecureXML http://www.infomosaic.net");

	push	OFFSET FLAT:$SG207746
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 3999 : 	cur = xmlAddChild(rootNode,commNode);

	mov	eax, DWORD PTR _commNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4000 : 	/*
; 4001 : 	 * SignatureCount
; 4002 : 	*/
; 4003 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignatureCount"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207748
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4004 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4005 : 	itoa(signum, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_itoa
	add	esp, 12					; 0000000cH

; 4006 : 	xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 4007 : 
; 4008 : 	if (signum == 0) // No signature was found or XML error

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	$L207751

; 4009 : 	{
; 4010 : 		/*
; 4011 : 		* SignatureStatus
; 4012 : 		*/
; 4013 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureStatus"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207753
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4014 : 		cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4015 : 
; 4016 : 		/*
; 4017 : 		* subnodes of SignatureStatus
; 4018 : 		*/
; 4019 : 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 4020 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureId");

	push	OFFSET FLAT:$SG207755
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4021 : 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4022 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureAlgorithm");

	push	OFFSET FLAT:$SG207757
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4023 : 		cur = xmlAddChild(parent,cur);	

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4024 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Status");

	push	OFFSET FLAT:$SG207759
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4025 : 		// Add signature status value of failed
; 4026 : 		itoa(FALSE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	0
	call	_itoa
	add	esp, 12					; 0000000cH

; 4027 : 		xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 4028 : 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4029 : 
; 4030 : 		cur = xmlNewNode(NULL,(const unsigned char *)"LastError");

	push	OFFSET FLAT:$SG207763
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4031 : 		// Add last error code
; 4032 : 		itoa(axGetLastError(SigHandle), (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_axGetLastError
	add	esp, 4
	push	eax
	call	_itoa
	add	esp, 12					; 0000000cH

; 4033 : 		xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 4034 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4035 : 
; 4036 : 		if (axGetLastError(SigHandle) != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_axGetLastError
	add	esp, 4
	test	eax, eax
	je	SHORT $L207766

; 4037 : 		{
; 4038 : 			// add comment with additional errors
; 4039 : 			commNode = xmlNewDocComment(doc,(const unsigned char *)axGetError(SigHandle));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetError
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 4040 : 			cur = xmlAddChild(parent,commNode);

	mov	ecx, DWORD PTR _commNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L207766:

; 4041 : 		}
; 4042 : 
; 4043 : 		
; 4044 : 		cur = xmlNewNode(NULL,(const unsigned char *)"ReferenceCount");

	push	OFFSET FLAT:$SG207769
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4045 : 		// Set reference count to zero
; 4046 : 		xmlNodeSetContent(cur,(const unsigned char *)"0");

	push	OFFSET FLAT:$SG207771
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4047 : 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4048 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference");

	push	OFFSET FLAT:$SG207773
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4049 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4050 : 	}
; 4051 : 	else // There was at least one signature in the document

	jmp	$L207774
$L207751:

; 4052 : 	{
; 4053 : 		for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L207775
$L207776:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L207775:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	$L207774

; 4054 : 		{
; 4055 : 			refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _refNum$[ebp], eax

; 4056 : 			refArr = sgArr[i]->refArray;  // The URI Array itself

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _refArr$[ebp], edx

; 4057 : 
; 4058 : 		    /*
; 4059 : 			 * SignatureStatus
; 4060 : 			 */
; 4061 : 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureStatus"); // Using the parent element's name space

	push	OFFSET FLAT:$SG207779
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4062 : 			cur = xmlAddChild(rootNode,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4063 : 
; 4064 : 			/*
; 4065 : 			* subnodes of SignatureStatus
; 4066 : 			*/
; 4067 : 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 4068 : 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureId");

	push	OFFSET FLAT:$SG207781
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4069 : 
; 4070 : 			if (sgArr[i]->sigId != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L207782

; 4071 : 			{
; 4072 : 				xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->sigId);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L207782:

; 4073 : 			}
; 4074 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4075 : 				
; 4076 : 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureAlgorithm");

	push	OFFSET FLAT:$SG207785
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4077 : 			if (sgArr[i]->sigMethod != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L207786

; 4078 : 			{
; 4079 : 				xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->sigMethod);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L207786:

; 4080 : 			}
; 4081 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4082 : 			
; 4083 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Status");

	push	OFFSET FLAT:$SG207789
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4084 : 			long certStatus=0;

	mov	DWORD PTR _certStatus$207790[ebp], 0

; 4085 : 
; 4086 : 			if ((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 4087 : 				(sgArr[i]->status != FALSE) && (sgArr[i]->certificatesCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	je	$L207791
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+8], 0
	je	$L207791
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L207791

; 4088 : 			{
; 4089 : 				sigStatus = 0;

	mov	DWORD PTR _sigStatus$[ebp], 0

; 4090 : 				get_SigCertStatus(i, NULL, 0, &certStatus);

	mov	esi, esp
	lea	ecx, DWORD PTR _certStatus$207790[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+344]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4091 : 				if (certStatus != 0)

	cmp	DWORD PTR _certStatus$207790[ebp], 0
	je	SHORT $L207792

; 4092 : 				{
; 4093 : 					// Add signature status value of failed
; 4094 : 					itoa(FALSE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	0
	call	_itoa
	add	esp, 12					; 0000000cH

; 4095 : 					sgArr[i]->status = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+8], 0

; 4096 : 				}
; 4097 : 				else

	jmp	SHORT $L207794
$L207792:

; 4098 : 					itoa(TRUE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	1
	call	_itoa
	add	esp, 12					; 0000000cH
$L207794:

; 4099 : 			}
; 4100 : 			else

	jmp	SHORT $L207796
$L207791:

; 4101 : 				itoa(sgArr[i]->status, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH
$L207796:

; 4102 : 
; 4103 : 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 4104 : 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4105 : 
; 4106 : 			cur = xmlNewNode(NULL,(const unsigned char *)"LastError");

	push	OFFSET FLAT:$SG207800
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4107 : 			if ((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 4108 : 				(certStatus != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -65				; ffffffbfH
	je	SHORT $L207801
	cmp	DWORD PTR _certStatus$207790[ebp], 0
	je	SHORT $L207801

; 4109 : 			{
; 4110 : 				itoa(certStatus, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certStatus$207790[ebp]
	push	ecx
	call	_itoa
	add	esp, 12					; 0000000cH

; 4111 : 			}
; 4112 : 			else

	jmp	SHORT $L207803
$L207801:

; 4113 : 				itoa(sgArr[i]->lasterror, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_itoa
	add	esp, 12					; 0000000cH
$L207803:

; 4114 : 
; 4115 : 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4116 : 			cur = xmlAddChild(parent,cur);	

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4117 : 
; 4118 : 			if ((axGetLastError(SigHandle) != 0) && (CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 4119 : 				(certStatus != 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_axGetLastError
	add	esp, 4
	test	eax, eax
	je	SHORT $L207806
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -65				; ffffffbfH
	je	SHORT $L207806
	cmp	DWORD PTR _certStatus$207790[ebp], 0
	je	SHORT $L207806

; 4120 : 			{
; 4121 : 				// add comment with additional errors
; 4122 : 				unsigned char * errStr = axGetError(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetError
	add	esp, 4
	mov	DWORD PTR _errStr$207807[ebp], eax

; 4123 : 				commNode = xmlNewDocComment(doc,(const unsigned char *)errStr);

	mov	eax, DWORD PTR _errStr$207807[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 4124 : 				zFree(errStr);

	mov	edx, DWORD PTR _errStr$207807[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4125 : 				cur = xmlAddChild(parent,commNode);

	mov	eax, DWORD PTR _commNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4126 : 			}
; 4127 : 			else

	jmp	SHORT $L207809
$L207806:

; 4128 : 				if (sgArr[i]->lasterror != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L207809

; 4129 : 				{
; 4130 : 					commNode = xmlNewDocComment(doc,(const unsigned char *)errorMsgTable[sgArr[i]->lasterror]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _errorMsgTable[ecx*4]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 4131 : 					cur = xmlAddChild(parent,commNode);

	mov	ecx, DWORD PTR _commNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L207809:

; 4132 : 				}
; 4133 : 					
; 4134 : 
; 4135 : 			cur = xmlNewNode(NULL,(const unsigned char *)"ReferenceCount");

	push	OFFSET FLAT:$SG207813
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4136 : 			itoa(refNum, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _refNum$[ebp]
	push	ecx
	call	_itoa
	add	esp, 12					; 0000000cH

; 4137 : 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4138 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4139 : 
; 4140 : 			if (sgArr[i]->signerCert != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+24], 0
	je	$L207816

; 4141 : 			{
; 4142 : 				unsigned char *utf8CharStr=NULL;

	mov	DWORD PTR _utf8CharStr$207817[ebp], 0

; 4143 : 				int	utf8CharStrLen=0, utf16CharStrLen=0, utf16StrByteLen=0;

	mov	DWORD PTR _utf8CharStrLen$207818[ebp], 0
	mov	DWORD PTR _utf16CharStrLen$207819[ebp], 0
	mov	DWORD PTR _utf16StrByteLen$207820[ebp], 0

; 4144 : 
; 4145 : 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateInfo");

	push	OFFSET FLAT:$SG207822
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4146 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4147 : 				// Adding subnodes of CertificateInfo
; 4148 : 				parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 4149 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Subject");

	push	OFFSET FLAT:$SG207824
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4150 : 				if (sgArr[i]->certificatesCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	$L207825

; 4151 : 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->subject)) != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 768				; 00000300H
	push	eax
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$207819[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$207819[ebp], 0
	je	$L207825

; 4152 : 					{
; 4153 : 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	ecx, DWORD PTR _utf16CharStrLen$207819[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf16StrByteLen$207820[ebp], ecx

; 4154 : 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	edx, DWORD PTR _utf16StrByteLen$207820[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf8CharStrLen$207818[ebp], edx

; 4155 : 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$207817[ebp], eax

; 4156 : 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 4157 : 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->subject, &utf16StrByteLen);

	lea	eax, DWORD PTR _utf16StrByteLen$207820[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 768				; 00000300H
	push	edx
	lea	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 4158 : 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4159 : 						zFree(utf8CharStr);

	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207825:

; 4160 : 					}
; 4161 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4162 : 
; 4163 : 				cur = xmlNewNode(NULL,(const unsigned char *)"ShortSubject");

	push	OFFSET FLAT:$SG207831
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4164 : 				if (sgArr[i]->certificatesCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	$L207832

; 4165 : 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->shortSubject)) != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1280				; 00000500H
	push	eax
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$207819[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$207819[ebp], 0
	je	$L207832

; 4166 : 					{
; 4167 : 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	ecx, DWORD PTR _utf16CharStrLen$207819[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf16StrByteLen$207820[ebp], ecx

; 4168 : 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	edx, DWORD PTR _utf16StrByteLen$207820[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf8CharStrLen$207818[ebp], edx

; 4169 : 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$207817[ebp], eax

; 4170 : 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 4171 : 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->shortSubject, &utf16StrByteLen);

	lea	eax, DWORD PTR _utf16StrByteLen$207820[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1280				; 00000500H
	push	edx
	lea	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 4172 : 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4173 : 						zFree(utf8CharStr);

	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207832:

; 4174 : 					}
; 4175 : 					//if (sgArr[i]->signerCert->subject != NULL)
; 4176 : 					//	xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->shortSubject);
; 4177 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4178 : 
; 4179 : 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateIssuer");

	push	OFFSET FLAT:$SG207838
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4180 : 				if (sgArr[i]->certificatesCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	$L207839

; 4181 : 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->issuer)) != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 256				; 00000100H
	push	eax
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$207819[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$207819[ebp], 0
	je	$L207839

; 4182 : 					{
; 4183 : 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	ecx, DWORD PTR _utf16CharStrLen$207819[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf16StrByteLen$207820[ebp], ecx

; 4184 : 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	edx, DWORD PTR _utf16StrByteLen$207820[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf8CharStrLen$207818[ebp], edx

; 4185 : 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$207817[ebp], eax

; 4186 : 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 4187 : 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->issuer, &utf16StrByteLen);

	lea	eax, DWORD PTR _utf16StrByteLen$207820[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 256				; 00000100H
	push	edx
	lea	eax, DWORD PTR _utf8CharStrLen$207818[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 4188 : 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$207817[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4189 : 						zFree(utf8CharStr);

	mov	ecx, DWORD PTR _utf8CharStr$207817[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L207839:

; 4190 : 					}
; 4191 : 					//if (sgArr[i]->signerCert->issuer != NULL)
; 4192 : 					//	xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->issuer);
; 4193 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4194 : 				
; 4195 : 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateSerialNumber");

	push	OFFSET FLAT:$SG207845
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4196 : 				if (sgArr[i]->certificatesCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L207846

; 4197 : 					if (sgArr[i]->signerCert->serialNumber != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $L207846

; 4198 : 					{
; 4199 : 						if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3324], 1
	jne	SHORT $L207848

; 4200 : 						{
; 4201 : 							plainTextHex = Base64BinToPlainHex(sgArr[i]->signerCert->serialNumber);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainTextHex$[ebp], eax

; 4202 : 							xmlNodeSetContent(cur,(const unsigned char *)plainTextHex);

	mov	eax, DWORD PTR _plainTextHex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 4203 : 							zFree(plainTextHex);

	mov	edx, DWORD PTR _plainTextHex$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4204 : 						}
; 4205 : 						else

	jmp	SHORT $L207846
$L207848:

; 4206 : 							xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->serialNumber);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8
$L207846:

; 4207 : 					}
; 4208 : 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4209 : 				
; 4210 : 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateExpiration");

	push	OFFSET FLAT:$SG207853
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4211 : 				if (sgArr[i]->certificatesCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $L207854

; 4212 : 					if (sgArr[i]->signerCert->notAfter != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1792				; 00000700H
	je	SHORT $L207854

; 4213 : 						xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->notAfter);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1792				; 00000700H
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L207854:

; 4214 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4215 : 				parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx
$L207816:

; 4216 : 			}
; 4217 : 
; 4218 : 
; 4219 : 			for (j=0; j<refNum; j++) // for each reference that was signed

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L207857
$L207858:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L207857:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _refNum$[ebp]
	jge	$L207859

; 4220 : 			{
; 4221 : 
; 4222 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Reference");

	push	OFFSET FLAT:$SG207861
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4223 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4224 : 
; 4225 : 				// Add subnodes of Reference
; 4226 : 				parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 4227 : 
; 4228 : 				cur = xmlNewNode(NULL,(const unsigned char *)"URI");

	push	OFFSET FLAT:$SG207863
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4229 : 				if (refArr[j]->URI != NULL)

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L207864

; 4230 : 				{
; 4231 : 					xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->URI);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L207864:

; 4232 : 				}
; 4233 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4234 : 
; 4235 : 				cur = xmlNewNode(NULL,(const unsigned char *)"DigestMethod");

	push	OFFSET FLAT:$SG207867
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4236 : 				if (refArr[j]->digestMethod != NULL)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L207868

; 4237 : 				{
; 4238 : 					xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->digestMethod);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L207868:

; 4239 : 				}
; 4240 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4241 : 				
; 4242 : 				cur = xmlNewNode(NULL,(const unsigned char *)"DigestStatus");

	push	OFFSET FLAT:$SG207871
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4243 : 				itoa(refArr[j]->status, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH

; 4244 : 				xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 4245 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4246 : 
; 4247 : 				
; 4248 : 				cur = xmlNewNode(NULL,(const unsigned char *)"SignedObject");

	push	OFFSET FLAT:$SG207875
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4249 : 				if (refArr[j]->refObject != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L207876

; 4250 : 				{
; 4251 : 					if (refArr[j]->refObject->encoding != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L207877

; 4252 : 						xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)refArr[j]->refObject->encoding);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET FLAT:$SG207880
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L207877:

; 4253 : 					if (refArr[j]->refObject->encodedData != NULL)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+256], 0
	je	SHORT $L207876

; 4254 : 					{
; 4255 : 						xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->refObject->encodedData);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L207876:

; 4256 : 					}
; 4257 : 				}
; 4258 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4259 : 				parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx

; 4260 : 			} // end for each reference

	jmp	$L207858
$L207859:

; 4261 : 
; 4262 : 			cur = xmlNewNode(NULL,(const unsigned char *)"PropertyCount");

	push	OFFSET FLAT:$SG207884
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4263 : 			itoa(sgArr[i]->propNumber, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_itoa
	add	esp, 12					; 0000000cH

; 4264 : 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4265 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4266 : 
; 4267 : 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureProperties");

	push	OFFSET FLAT:$SG207888
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4268 : 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4269 : 
; 4270 : 			// Add subnodes of SignatureProperties
; 4271 : 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 4272 : 
; 4273 : 			char *charTsProp;
; 4274 : 			char *equalPtr;
; 4275 : 
; 4276 : 			for (j = 0; j < sgArr[i]->propNumber;  j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L207891
$L207892:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L207891:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR [ecx+32]
	jge	$L207893

; 4277 : 			{
; 4278 : 				// Adding Signature properties
; 4279 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Property");

	push	OFFSET FLAT:$SG207895
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4280 : 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4281 : 
; 4282 : 				// Adding subnodes of Property
; 4283 : 				parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 4284 : 				charTsProp = (char *)sgArr[i]->propArray[j];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _charTsProp$207889[ebp], eax

; 4285 : 
; 4286 : 				equalPtr = StrChr(charTsProp, '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _charTsProp$207889[ebp]
	push	ecx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$207890[ebp], eax

; 4287 : 				*equalPtr = '\0';

	mov	edx, DWORD PTR _equalPtr$207890[ebp]
	mov	BYTE PTR [edx], 0

; 4288 : 
; 4289 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Name");

	push	OFFSET FLAT:$SG207898
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4290 : 				xmlNodeSetContent(cur,(const unsigned char *)charTsProp);

	mov	eax, DWORD PTR _charTsProp$207889[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 4291 : 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4292 : 
; 4293 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Value");

	push	OFFSET FLAT:$SG207901
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4294 : 				xmlNodeSetContent(cur,(const unsigned char *)(equalPtr+1));

	mov	ecx, DWORD PTR _equalPtr$207890[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 4295 : 				*equalPtr = '='; //Restore the value

	mov	eax, DWORD PTR _equalPtr$207890[ebp]
	mov	BYTE PTR [eax], 61			; 0000003dH

; 4296 : 
; 4297 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4298 : 				parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx

; 4299 : 			}

	jmp	$L207892
$L207893:

; 4300 : 
; 4301 : 		} /* end for each signature in the document loop */

	jmp	$L207776
$L207774:

; 4302 : 	}
; 4303 : 	xmlDocDumpMemoryEnc(doc,&mem,&iSize, "UTF-16");

	push	OFFSET FLAT:$SG207903
	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocDumpMemoryEnc
	add	esp, 16					; 00000010H

; 4304 : 	*verificationResponse = SysAllocStringByteLen((LPCSTR)mem, iSize);

	mov	esi, esp
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _verificationResponse$[ebp]
	mov	DWORD PTR [ecx], eax

; 4305 : 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 4306 : 	xmlFree(mem);

	mov	esi, esp
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4307 : 	ExitLog;
; 4308 : 	return S_OK;

	xor	eax, eax
$L207665:

; 4309 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221189
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 404				; 00000194H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221189:
	DD	6
	DD	$L221188
$L221188:
	DD	-68					; ffffffbcH
	DD	4
	DD	$L221181
	DD	-84					; ffffffacH
	DD	4
	DD	$L221182
	DD	-292					; fffffedcH
	DD	200					; 000000c8H
	DD	$L221183
	DD	-356					; fffffe9cH
	DD	4
	DD	$L221184
	DD	-376					; fffffe88H
	DD	4
	DD	$L221185
	DD	-392					; fffffe78H
	DD	4
	DD	$L221186
$L221186:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221185:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221184:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$L221183:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L221182:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221181:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	0
?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::SecureXMLVerify
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
_TEXT	ENDS
;	COMDAT ?getVerifyAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVerifyAllowed@CLicense@@QAEHXZ PROC NEAR		; CLicense::getVerifyAllowed, COMDAT
; _this$ = ecx

; 61   : 	BOOL getVerifyAllowed() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 		if (isVerifyAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $L197868

; 63   : 			return isVerifyAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	jmp	SHORT $L197867
$L197868:

; 64   : 		else
; 65   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197867:

; 66   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getVerifyAllowed@CLicense@@QAEHXZ ENDP			; CLicense::getVerifyAllowed
_TEXT	ENDS
PUBLIC	??0CComObjectRootBase@ATL@@QAE@XZ		; ATL::CComObjectRootBase::CComObjectRootBase
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComObjectRootBase@ATL@@QAE@XZ	; ATL::CComObjectRootBase::CComObjectRootBase
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComObjectRootBase@ATL@@QAE@XZ PROC NEAR		; ATL::CComObjectRootBase::CComObjectRootBase, COMDAT
; _this$ = ecx

; 2128 : 	CComObjectRootBase()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2129 : 	{
; 2130 : 		m_dwRef = 0L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2131 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComObjectRootBase@ATL@@QAE@XZ ENDP			; ATL::CComObjectRootBase::CComObjectRootBase
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
PUBLIC	?SetCSP@CSignature@@UAGJPAG@Z			; CSignature::SetCSP
xdata$x	SEGMENT
$T221208 DD	0ffffffffH
	DD	FLAT:$L221201
$T221203 DD	019930520H
	DD	01H
	DD	FLAT:$T221208
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T221200 = -52						; size = 4
$T221199 = -48						; size = 4
_wCSPName$ = -44					; size = 4
_tmpNewVal$ = -36					; size = 4
__lpa$ = -28						; size = 4
__lpw$ = -24						; size = 4
__acp$ = -20						; size = 4
__convert$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_CSPName$ = 12						; size = 4
?SetCSP@CSignature@@UAGJPAG@Z PROC NEAR			; CSignature::SetCSP

; 4312 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetCSP@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4313 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 4314 : 	
; 4315 : 	CComBSTR tmpNewVal;

	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4316 : 
; 4317 : 	EnterLog;
; 4318 : 	tmpNewVal = CSPName;

	mov	eax, DWORD PTR _CSPName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4319 : 	if (tmpNewVal.Length() == 0)

	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207915

; 4320 : 	{
; 4321 : 		setError(SigHandle, INVALID_CSP);

	push	65					; 00000041H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4322 : 		return S_FALSE;

	mov	DWORD PTR $T221199[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221199[ebp]
	jmp	SHORT $L207909
$L207915:

; 4323 : 	}
; 4324 : 	unsigned char *wCSPName = HeapW2A(CSPName);

	mov	eax, DWORD PTR _CSPName$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wCSPName$[ebp], eax

; 4325 : 	xsCoreSetCSP(wCSPName, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _wCSPName$[ebp]
	push	eax
	call	_xsCoreSetCSP
	add	esp, 8

; 4326 : 	zFree(wCSPName);

	mov	ecx, DWORD PTR _wCSPName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4327 : 	ExitLog;
; 4328 : 	return S_OK;

	mov	DWORD PTR $T221200[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221200[ebp]
$L207909:

; 4329 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221207
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221207:
	DD	1
	DD	$L221206
$L221206:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L221204
$L221204:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221201:
	lea	ecx, DWORD PTR _tmpNewVal$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SetCSP@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T221203
	jmp	___CxxFrameHandler
text$x	ENDS
?SetCSP@CSignature@@UAGJPAG@Z ENDP			; CSignature::SetCSP
PUBLIC	?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z	; CSignature::GetSignedHTML
EXTRN	_xmlNodeListGetString:NEAR
xdata$x	SEGMENT
$T221220 DD	0ffffffffH
	DD	FLAT:$L221213
$T221215 DD	019930520H
	DD	01H
	DD	FLAT:$T221220
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221212 = -80						; size = 4
$T221211 = -76						; size = 4
$T221210 = -72						; size = 4
__lpa$ = -68						; size = 4
__lpw$ = -64						; size = 4
__acp$ = -60						; size = 4
__convert$ = -56					; size = 4
_tmpSignedXML$ = -48					; size = 4
_charSignedHtmlXML$ = -40				; size = 4
_decodedDataPtr$ = -36					; size = 4
_dwBytesToWrite$ = -32					; size = 4
_encodedHTML$ = -28					; size = 4
_cur$ = -24						; size = 4
_root$ = -20						; size = 4
_doc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_signedHtmlXML$ = 12					; size = 4
_originalHTML$ = 16					; size = 4
?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::GetSignedHTML

; 4332 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4333 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 4334 : 	xmlNodePtr root=NULL, cur=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0

; 4335 : 	char *encodedHTML=NULL;

	mov	DWORD PTR _encodedHTML$[ebp], 0

; 4336 : 	DWORD  dwBytesToWrite;
; 4337 : 	char *decodedDataPtr=NULL;

	mov	DWORD PTR _decodedDataPtr$[ebp], 0

; 4338 : 	char *charSignedHtmlXML;
; 4339 : 	CComBSTR tmpSignedXML;

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4340 : 
; 4341 : 	EnterLog;
; 4342 : 	tmpSignedXML = signedHtmlXML;

	mov	eax, DWORD PTR _signedHtmlXML$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4343 : 	if (tmpSignedXML.Length() == 0)

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L207934

; 4344 : 	{
; 4345 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4346 : 		return S_FALSE;

	mov	DWORD PTR $T221210[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221210[ebp]
	jmp	$L207925
$L207934:

; 4347 : 	}
; 4348 : 
; 4349 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 4350 : 
; 4351 : 	charSignedHtmlXML = (char *)HeapW2A(signedHtmlXML);

	mov	eax, DWORD PTR _signedHtmlXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSignedHtmlXML$[ebp], eax

; 4352 : 	// parse main document
; 4353 : 	doc = xmlParseMemory((const char *)charSignedHtmlXML,strlen(charSignedHtmlXML));

	mov	ecx, DWORD PTR _charSignedHtmlXML$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _charSignedHtmlXML$[ebp]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 4354 : 	zFree(charSignedHtmlXML);

	mov	eax, DWORD PTR _charSignedHtmlXML$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4355 : 	if (!doc) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L207943

; 4356 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4357 : 		return S_FALSE;

	mov	DWORD PTR $T221211[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221211[ebp]
	jmp	$L207925
$L207943:

; 4358 : 	}
; 4359 : 	root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 4360 : 	cur = root->xmlChildrenNode;

	mov	ecx, DWORD PTR _root$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$L207947:

; 4361 : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L207948

; 4362 : 	{
; 4363 : 		if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedHTML"))) {

	push	OFFSET FLAT:$SG207951
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L207950

; 4364 : 			// content
; 4365 : 			encodedHTML = (char *)xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _encodedHTML$[ebp], eax

; 4366 : 			break;

	jmp	SHORT $L207948
$L207950:

; 4367 : 		}
; 4368 : 		cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 4369 : 	}

	jmp	SHORT $L207947
$L207948:

; 4370 : 	if (encodedHTML != NULL)

	cmp	DWORD PTR _encodedHTML$[ebp], 0
	je	$L207953

; 4371 : 	{
; 4372 : 		dwBytesToWrite = base64decodeSize((DWORD)strlen((const char *)encodedHTML));

	mov	ecx, DWORD PTR _encodedHTML$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 4373 : 		decodedDataPtr = (char *)zMalloc (dwBytesToWrite+1);

	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _decodedDataPtr$[ebp], eax

; 4374 : 		memset(decodedDataPtr,0,dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _decodedDataPtr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 4375 : 		dwBytesToWrite = base64decode((unsigned char *)encodedHTML,(unsigned char *)decodedDataPtr,dwBytesToWrite);

	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	push	edx
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encodedHTML$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 4376 : 		*originalHTML = A2WBSTR((LPCSTR)decodedDataPtr);

	push	-1
	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _originalHTML$[ebp]
	mov	DWORD PTR [ecx], eax

; 4377 : 		zFree(decodedDataPtr);

	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4378 : 		zFree(encodedHTML);

	mov	eax, DWORD PTR _encodedHTML$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L207953:

; 4379 : 	}
; 4380 : 	xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 4381 : 	ExitLog;
; 4382 : 	return S_OK;

	mov	DWORD PTR $T221212[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221212[ebp]
$L207925:

; 4383 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221219
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221219:
	DD	1
	DD	$L221218
$L221218:
	DD	-48					; ffffffd0H
	DD	4
	DD	$L221216
$L221216:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221213:
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221215
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::GetSignedHTML
PUBLIC	?SignFile@CSignature@@UAGJPAG0@Z		; CSignature::SignFile
EXTRN	_xmlNewValidCtxt:NEAR
EXTRN	_xmlFreeValidCtxt:NEAR
EXTRN	_xmlAddAttributeDecl:NEAR
EXTRN	_xmlNewDtd:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv277 = -300						; size = 4
_tmpEnvFlag$ = -296					; size = 2
_freeCharSigId$ = -292					; size = 4
__lpa$ = -288						; size = 4
__lpw$ = -284						; size = 4
__acp$ = -280						; size = 4
__convert$ = -276					; size = 4
_iSize$ = -268						; size = 4
_mem$ = -260						; size = 4
_curNs$ = -256						; size = 4
_signedInfoNode$ = -252					; size = 4
_sigNode$ = -248					; size = 4
_commNode$ = -244					; size = 4
_parent$ = -240						; size = 4
_rootNode$ = -236					; size = 4
_cur$ = -232						; size = 4
_doc$ = -228						; size = 4
_objectId$ = -220					; size = 50
_guidStr$ = -160					; size = 50
_sigGuid$ = -100					; size = 16
_dtd$ = -80						; size = 4
_ctxt$ = -76						; size = 4
_charSigId$ = -72					; size = 4
_bareFileName$ = -68					; size = 4
_writeResult$ = -64					; size = 4
_hFile$ = -60						; size = 4
_signedXML$ = -52					; size = 4
_binFileData$ = -40					; size = 4
_fileSize$ = -28					; size = 4
_crBlob$ = -16						; size = 8
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputFile$ = 12					; size = 4
_outputFile$ = 16					; size = 4
?SignFile@CSignature@@UAGJPAG0@Z PROC NEAR		; CSignature::SignFile

; 4386 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4387 : 	DS_DATA_BLOB crBlob;
; 4388 : 	DWORD fileSize=0;

	mov	DWORD PTR _fileSize$[ebp], 0

; 4389 : 	unsigned char *binFileData;
; 4390 : 	unsigned char *signedXML;
; 4391 : 	FILE *hFile;
; 4392 : 	unsigned int writeResult;
; 4393 : 	unsigned char *bareFileName=NULL;

	mov	DWORD PTR _bareFileName$[ebp], 0

; 4394 : 	char *charSigId;
; 4395 : 	xmlValidCtxtPtr ctxt;
; 4396 : 	xmlDtdPtr dtd =NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 4397 : #ifdef WIN32
; 4398 : 	GUID sigGuid;
; 4399 : #else
; 4400 : 	uuid_t sigGuid;
; 4401 : #endif
; 4402 : 	char guidStr[50];
; 4403 : 	char objectId[50];
; 4404 : 
; 4405 : 	EnterLog;
; 4406 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L207980

; 4407 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4408 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L207980:

; 4409 : 	}
; 4410 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L207982

; 4411 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 4412 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L207982:

; 4413 : 	}
; 4414 : 
; 4415 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L207984

; 4416 : 	{
; 4417 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L207985

; 4418 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L207985:

; 4419 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 4420 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L207984:

; 4421 : 	}
; 4422 : 
; 4423 : 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 4424 : 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 4425 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 4426 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 4427 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 4428 : 
; 4429 : 	crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 4430 : 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 4431 : 
; 4432 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 4433 : 
; 4434 : /* To be Added by Alex
; 4435 : <!DOCTYPE InfomosaicSecureXML [
; 4436 :   <!ATTLIST SignedHTML Id ID #IMPLIED>
; 4437 : ]>
; 4438 : 
; 4439 : */
; 4440 : 
; 4441 : //	charInputFile = (char *)HeapW2A(inputFile);
; 4442 : 	bareFileName = xsRemoveBstrPath(inputFile);

	mov	edx, DWORD PTR _inputFile$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z ; CSignature::xsRemoveBstrPath
	mov	DWORD PTR _bareFileName$[ebp], eax

; 4443 :  //	UTF16LEToUTF8(unsigned char* out, int *outlen,
; 4444 :  //           const unsigned char* inb, int *inlenb)
; 4445 : //	bareFileNameLen = SysStringByteLen(inputFile) - ((char *)bareFileName - (char *)inputFile);
; 4446 : 
; 4447 : 	if (ReadAllBin(inputFile, &binFileData, &fileSize) == S_FALSE)

	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputFile$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L208001

; 4448 : 	{
; 4449 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4450 : //		zFree(charInputFile);
; 4451 : 		return S_FALSE; // File does not exist just return

	mov	eax, 1
	jmp	$L207966
$L208001:

; 4452 : 	}
; 4453 : 	//File Exists so lets start the processing
; 4454 : 
; 4455 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG208004
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 4456 : 	// DTD
; 4457 :     dtd = xmlNewDtd(doc, BAD_CAST "SignatureEnvelope",NULL,NULL);

	push	0
	push	0
	push	OFFSET FLAT:$SG208006
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dtd$[ebp], eax

; 4458 : 	// create DTD validation context
; 4459 :     ctxt = xmlNewValidCtxt();

	call	_xmlNewValidCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 4460 : 	// add ATTLIST
; 4461 : 	xmlAddAttributeDecl(ctxt, dtd, BAD_CAST "infomosaic:SignedObject",
; 4462 :                     BAD_CAST "Id", NULL, 
; 4463 : 					XML_ATTRIBUTE_ID, XML_ATTRIBUTE_IMPLIED, 
; 4464 : 					NULL, NULL);		    

	push	0
	push	0
	push	3
	push	2
	push	0
	push	OFFSET FLAT:$SG208009
	push	OFFSET FLAT:$SG208010
	mov	eax, DWORD PTR _dtd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAddAttributeDecl
	add	esp, 36					; 00000024H

; 4465 : 	
; 4466 :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 4467 : 	xmlFreeValidCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeValidCtxt
	add	esp, 4

; 4468 : 
; 4469 : 	// document, namespace, element name, element content
; 4470 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"SignatureEnvelope",NULL);

	push	0
	push	OFFSET FLAT:$SG208014
	push	0
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 4471 : 
; 4472 : 	// if you want any namespace definition here
; 4473 : 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/SignData/DTD.htm",(const unsigned char *)"infomosaic");

	push	OFFSET FLAT:$SG208017
	push	OFFSET FLAT:$SG208018
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 4474 : 	xmlSetNs(cur,curNs);

	mov	ecx, DWORD PTR _curNs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlSetNs
	add	esp, 8

; 4475 : 
; 4476 : 	// add root element
; 4477 : 	xmlDocSetRootElement(doc,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocSetRootElement
	add	esp, 8

; 4478 : 	rootNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], edx

; 4479 : 
; 4480 : 	/*
; 4481 : 	 * SignedObject
; 4482 : 	*/
; 4483 : 
; 4484 : #ifdef WIN32
; 4485 : 	CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4486 : 	GuidToString(&sigGuid, &objectId[1]);

	lea	ecx, DWORD PTR _objectId$[ebp+1]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 4487 : #else
; 4488 : 	uuid_generate(sigGuid);
; 4489 : 	uuid_unparse(sigGuid, &objectId[1]);
; 4490 : #endif
; 4491 : 	objectId[0] = '#';

	mov	BYTE PTR _objectId$[ebp], 35		; 00000023H

; 4492 : 	
; 4493 : 	cur = xmlNewNode(curNs,(const unsigned char *)"SignedObject"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208020
	mov	eax, DWORD PTR _curNs$[ebp]
	push	eax
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4494 : 	cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4495 : 	xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG208023
	push	OFFSET FLAT:$SG208024
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4496 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)&objectId[1]);

	lea	ecx, DWORD PTR _objectId$[ebp+1]
	push	ecx
	push	OFFSET FLAT:$SG208027
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4497 : 	xmlNewProp(cur, (const unsigned char *)"FileName", (const unsigned char *)bareFileName);

	mov	eax, DWORD PTR _bareFileName$[ebp]
	push	eax
	push	OFFSET FLAT:$SG208030
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4498 : 	zFree(bareFileName);

	mov	edx, DWORD PTR _bareFileName$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4499 : 
; 4500 : //	zFree(charInputFile);
; 4501 : 	crBlob.cbData = base64encodeSize(fileSize);

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 4502 : 	// allocate memory
; 4503 : 	if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	ecx, DWORD PTR _crBlob$[ebp+4]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L208032

; 4504 : 	{
; 4505 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 4506 : 		zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4507 : 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 4508 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L208032:

; 4509 : 	}
; 4510 : 	if (base64encode((unsigned char *)binFileData,fileSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) 

	mov	eax, DWORD PTR _crBlob$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L208036

; 4511 : 	{
; 4512 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4513 : 		zFree(crBlob.pbData);

	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4514 : 		zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4515 : 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 4516 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L208036:

; 4517 : 	}
; 4518 : 	*(crBlob.pbData+crBlob.cbData)='\0';

	mov	eax, DWORD PTR _crBlob$[ebp]
	add	eax, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [eax], 0

; 4519 : 
; 4520 : 	zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4521 : 
; 4522 : 	xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 4523 : 
; 4524 : 	zFree(crBlob.pbData);

	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4525 : 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 4526 : 
; 4527 : 	/*
; 4528 : 	 * Signature
; 4529 : 	*/
; 4530 : 
; 4531 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 4532 : 	if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208040

; 4533 : 	{
; 4534 : #ifdef WIN32
; 4535 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4536 : 		GuidToString(&sigGuid, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 4537 : #else
; 4538 : 		uuid_generate(sigGuid);
; 4539 : 		uuid_unparse(sigGuid, guidStr);
; 4540 : #endif
; 4541 : 		charSigId = guidStr;

	lea	edx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], edx

; 4542 : 	}
; 4543 : 	else

	jmp	SHORT $L208041
$L208040:

; 4544 : 	{
; 4545 : 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 4546 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L208041:

; 4547 : 	}
; 4548 : 
; 4549 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208044
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4550 : 	sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 4551 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG208047
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4552 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4553 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG208050
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 4554 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 4555 : 
; 4556 : 	/*
; 4557 : 	 * SignedInfo
; 4558 : 	*/
; 4559 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208052
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4560 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 4561 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4562 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 4563 : 
; 4564 : 	/*
; 4565 : 	 * Canonicalization Method
; 4566 : 	*/
; 4567 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG208054
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4568 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv277[ebp], edx
	cmp	DWORD PTR tv277[ebp], 3
	ja	SHORT $L208079
	mov	eax, DWORD PTR tv277[ebp]
	jmp	DWORD PTR $L221234[eax*4]
$L208059:

; 4569 : 	{
; 4570 : 		case WITH_COMMENTS:
; 4571 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG208062
	push	OFFSET FLAT:$SG208063
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4572 : 			break;

	jmp	SHORT $L208056
$L208064:

; 4573 : 		case WITHOUT_COMMENTS:
; 4574 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG208067
	push	OFFSET FLAT:$SG208068
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4575 : 			break;

	jmp	SHORT $L208056
$L208069:

; 4576 : 		case EXC_WITH_COMMENTS:
; 4577 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG208072
	push	OFFSET FLAT:$SG208073
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4578 : 			break;

	jmp	SHORT $L208056
$L208074:

; 4579 : 		case EXC_WITHOUT_COMMENTS:
; 4580 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG208077
	push	OFFSET FLAT:$SG208078
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4581 : 			break;

	jmp	SHORT $L208056
$L208079:

; 4582 : 		default:
; 4583 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG208082
	push	OFFSET FLAT:$SG208083
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L208056:

; 4584 : 	}
; 4585 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4586 : 	/*
; 4587 : 	 * Reference
; 4588 : 	*/
; 4589 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208085
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4590 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4591 : 	xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)objectId);

	lea	ecx, DWORD PTR _objectId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG208088
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4592 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 4593 : 
; 4594 : 	/*
; 4595 : 	 * Transforms
; 4596 : 	 */
; 4597 : 	
; 4598 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG208090
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4599 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4600 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 4601 : 
; 4602 : 	/*
; 4603 : 	 * Transform
; 4604 : 	 */
; 4605 : 	
; 4606 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG208092
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4607 : 	xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG208095
	push	OFFSET FLAT:$SG208096
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 4608 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 4609 : 
; 4610 : #ifdef WIN32
; 4611 : 	if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L208097

; 4612 :         	AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L208097:

; 4613 : 
; 4614 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L208098

; 4615 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L208098:

; 4616 : #endif
; 4617 : 
; 4618 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 4619 : 	EnvelopingFlag = ENVELOPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+688], 2

; 4620 : 
; 4621 : 	if (!(CreateSigFromTmplBlob(doc, charSigId, &signedXML, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L208100

; 4622 : 	{
; 4623 : 		if (signedXML != NULL)

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L208101

; 4624 : 			xmlFree(signedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208101:

; 4625 : 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 4626 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L208102

; 4627 : 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L208102:

; 4628 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L208100:

; 4629 : 	}
; 4630 : 	EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 4631 : 
; 4632 : 	// open file in write mode 
; 4633 : //	charOutputFile = W2A(outputFile);
; 4634 : 
; 4635 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L208104

; 4636 : 		zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L208104:

; 4637 : 
; 4638 : #ifdef WIN32
; 4639 : 	if ((hFile = _wfopen(outputFile,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG208106
	mov	edx, DWORD PTR _outputFile$[ebp]
	push	edx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	SHORT $L208105

; 4640 : #elif LINUX
; 4641 : 	unsigned char *utf8File = HeapW2A(outputFile);
; 4642 : 	if ((hFile = fopen((const char *)utf8File, "wb")) == NULL) {
; 4643 : 		zFree(utf8File);
; 4644 : #endif
; 4645 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4646 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L207966
$L208105:

; 4647 : 	}
; 4648 : #ifdef LINUX
; 4649 : 	zFree(utf8File);
; 4650 : #endif
; 4651 : 
; 4652 : 	fileSize = iSize;

	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _fileSize$[ebp], edx

; 4653 : 
; 4654 : 	if ((writeResult = fwrite(signedXML, 1, fileSize, hFile)) == 0)

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _writeResult$[ebp], eax
	cmp	DWORD PTR _writeResult$[ebp], 0
	jne	SHORT $L208108

; 4655 : 	{
; 4656 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4657 : 		xmlFree(signedXML);

	mov	esi, esp
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4658 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207966
$L208108:

; 4659 : 	}
; 4660 : 	if (ferror(hFile))

	mov	eax, DWORD PTR _hFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 32					; 00000020H
	je	SHORT $L208110

; 4661 : 	{
; 4662 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 4663 : 		xmlFree(signedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4664 : 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L207966
$L208110:

; 4665 : 	}
; 4666 : 	fclose(hFile);

	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 4667 : 	if (Base64EncodeXML == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2180], 1
	jne	SHORT $L208112

; 4668 : 		zFree(signedXML);

	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4669 : 	else

	jmp	SHORT $L208113
$L208112:

; 4670 : 		xmlFree(signedXML);

	mov	esi, esp
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208113:

; 4671 : 	ExitLog;
; 4672 : 	return S_OK;

	xor	eax, eax
$L207966:

; 4673 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221233
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221233:
	DD	8
	DD	$L221232
$L221232:
	DD	-16					; fffffff0H
	DD	8
	DD	$L221223
	DD	-28					; ffffffe4H
	DD	4
	DD	$L221224
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221225
	DD	-52					; ffffffccH
	DD	4
	DD	$L221226
	DD	-100					; ffffff9cH
	DD	16					; 00000010H
	DD	$L221227
	DD	-160					; ffffff60H
	DD	50					; 00000032H
	DD	$L221228
	DD	-220					; ffffff24H
	DD	50					; 00000032H
	DD	$L221229
	DD	-268					; fffffef4H
	DD	4
	DD	$L221230
$L221230:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221229:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221228:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221227:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221226:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221225:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221224:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221223:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221234:
	DD	$L208064
	DD	$L208059
	DD	$L208074
	DD	$L208069
?SignFile@CSignature@@UAGJPAG0@Z ENDP			; CSignature::SignFile
_TEXT	ENDS
PUBLIC	?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::GetSignedFileObject
EXTRN	_wcscat:NEAR
EXTRN	_xmlGetProp:NEAR
EXTRN	__imp__GetTempPathW@8:NEAR
xdata$x	SEGMENT
$T221257 DD	0ffffffffH
	DD	FLAT:$L221247
$T221249 DD	019930520H
	DD	01H
	DD	FLAT:$T221257
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221246 = -200						; size = 4
$T221245 = -196						; size = 4
$T221244 = -192						; size = 4
$T221243 = -188						; size = 4
$T221242 = -184						; size = 4
$T221241 = -180						; size = 4
$T221240 = -176						; size = 4
$T221239 = -172						; size = 4
$T221238 = -168						; size = 4
$T221237 = -164						; size = 4
$T221236 = -160						; size = 4
_tmpFilePath$208213 = -152				; size = 4
_bstrSignedFileName$208188 = -144			; size = 4
_utf8ByteLen$208184 = -136				; size = 4
_utf16ByteLen$208183 = -124				; size = 4
_utf16CharStr$208182 = -116				; size = 4
__lpa$ = -112						; size = 4
__lpw$ = -108						; size = 4
__acp$ = -104						; size = 4
__convert$ = -100					; size = 4
_freeNewPtr$ = -96					; size = 4
_sizeM$ = -92						; size = 4
_szPtr$ = -88						; size = 4
_curPtr$ = -84						; size = 4
_newPtr$ = -80						; size = 4
_ptr$ = -76						; size = 4
_tmpSignedXML$ = -68					; size = 4
_charSaveDir$ = -60					; size = 4
_charSignedXML$ = -56					; size = 4
_writeResult$ = -52					; size = 4
_hFile$ = -48						; size = 4
_fullFilePath$ = -44					; size = 4
_decodedDataPtr$ = -40					; size = 4
_dwBytesToWrite$ = -36					; size = 4
_encodedFileData$ = -32					; size = 4
_signedFileName$ = -28					; size = 4
_cur$ = -24						; size = 4
_root$ = -20						; size = 4
_doc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_signedXML$ = 12					; size = 4
_saveDir$ = 16						; size = 4
_signedFilePath$ = 20					; size = 4
?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::GetSignedFileObject

; 4676 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 188				; 000000bcH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-200]
	mov	ecx, 47					; 0000002fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4677 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 4678 : 	xmlNodePtr root=NULL, cur=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0

; 4679 : 	char *signedFileName=NULL;

	mov	DWORD PTR _signedFileName$[ebp], 0

; 4680 : 	char *encodedFileData=NULL;

	mov	DWORD PTR _encodedFileData$[ebp], 0

; 4681 : 	DWORD  dwBytesToWrite;
; 4682 : 	char *decodedDataPtr=NULL;

	mov	DWORD PTR _decodedDataPtr$[ebp], 0

; 4683 : 	WCHAR *fullFilePath=NULL;

	mov	DWORD PTR _fullFilePath$[ebp], 0

; 4684 : 	FILE *hFile; 
; 4685 : 	BOOL writeResult;
; 4686 : 	char *charSignedXML=NULL;

	mov	DWORD PTR _charSignedXML$[ebp], 0

; 4687 : 	char *charSaveDir=NULL;

	mov	DWORD PTR _charSaveDir$[ebp], 0

; 4688 : 	CComBSTR tmpSignedXML;

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4689 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 4690 : 	unsigned int *szPtr;
; 4691 : 	unsigned int sizeM;
; 4692 : 	BOOL freeNewPtr = FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 4693 : 
; 4694 : 	EnterLog;
; 4695 : 	*signedFilePath = 	A2WBSTR((const char *) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedFilePath$[ebp]
	mov	DWORD PTR [ecx], eax

; 4696 : 
; 4697 : 	
; 4698 : 	tmpSignedXML = signedXML;

	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4699 : 	if (tmpSignedXML.Length() == 0)

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208141

; 4700 : 	{
; 4701 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4702 : 		return S_FALSE;

	mov	DWORD PTR $T221236[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221236[ebp]
	jmp	$L208120
$L208141:

; 4703 : 	}
; 4704 : 	if (Base64EncodeXML == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2180], 1
	jne	$L208144

; 4705 : 	{
; 4706 : 		ptr = HeapW2A(signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 4707 : 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 4708 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 4709 : 		if(!(newPtr = (BYTE *)zMalloc(sizeM+1)))

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax
	cmp	DWORD PTR _newPtr$[ebp], 0
	jne	SHORT $L208147

; 4710 : 		{
; 4711 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4712 : 			return S_FALSE;

	mov	DWORD PTR $T221237[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221237[ebp]
	jmp	$L208120
$L208147:

; 4713 : 		}
; 4714 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 4715 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L208150

; 4716 : 		{
; 4717 : 			zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4718 : 			zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4719 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4720 : 			return S_FALSE;

	mov	DWORD PTR $T221238[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221238[ebp]
	jmp	$L208120
$L208150:

; 4721 : 		}
; 4722 : 		zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4723 : 	}
; 4724 : 	else

	jmp	$L208153
$L208144:

; 4725 : 	{
; 4726 : 		ptr = (unsigned char *)signedXML;

	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 4727 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _szPtr$[ebp], edx

; 4728 : 		sizeM = (*szPtr);

	mov	eax, DWORD PTR _szPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sizeM$[ebp], ecx

; 4729 : 
; 4730 : 		if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 4731 : 			((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L208159
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 254				; 000000feH
	je	SHORT $L208158
$L208159:
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 254				; 000000feH
	jne	SHORT $L208157
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L208157
$L208158:

; 4732 : 		{
; 4733 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 4734 : 			newPtr = ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], ecx

; 4735 : 		}
; 4736 : 		else

	jmp	SHORT $L208153
$L208157:

; 4737 : 		{
; 4738 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 4739 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 4740 : 
; 4741 : 			FileEncoding(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 4742 : //			*newPtr = 0xFF;
; 4743 : //			*(newPtr + 1) = 0xFE;
; 4744 : 
; 4745 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	add	eax, 2
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 4746 : 			sizeM += 4;

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	mov	DWORD PTR _sizeM$[ebp], ecx
$L208153:

; 4747 : 		}
; 4748 : 	}
; 4749 : 
; 4750 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 4751 : 
; 4752 : 	// parse main document
; 4753 : 	doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 4754 : 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L208167

; 4755 : 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L208167:

; 4756 : 
; 4757 : 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L208168

; 4758 : 	{
; 4759 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 4760 : 		return S_FALSE;

	mov	DWORD PTR $T221239[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221239[ebp]
	jmp	$L208120
$L208168:

; 4761 : 	}
; 4762 : 	root = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 4763 : 	cur = root->xmlChildrenNode;

	mov	edx, DWORD PTR _root$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax
$L208172:

; 4764 : 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L208173

; 4765 : 	{
; 4766 : 		if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedObject"))) {

	push	OFFSET FLAT:$SG208176
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L208175

; 4767 : 			// content
; 4768 : 			signedFileName = (char *)xmlGetProp(cur, (const unsigned char *)"FileName");

	push	OFFSET FLAT:$SG208179
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _signedFileName$[ebp], eax

; 4769 : 			encodedFileData = (char *)xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _encodedFileData$[ebp], eax

; 4770 : 			break;

	jmp	SHORT $L208173
$L208175:

; 4771 : 		}
; 4772 : 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 4773 : 	}

	jmp	SHORT $L208172
$L208173:

; 4774 : 
; 4775 : 	if ((signedFileName != NULL) && (encodedFileData != NULL))

	cmp	DWORD PTR _signedFileName$[ebp], 0
	je	$L208181
	cmp	DWORD PTR _encodedFileData$[ebp], 0
	je	$L208181

; 4776 : 	{
; 4777 : 		unsigned char *utf16CharStr=NULL;

	mov	DWORD PTR _utf16CharStr$208182[ebp], 0

; 4778 : 		int utf16ByteLen=0, utf8ByteLen=0;

	mov	DWORD PTR _utf16ByteLen$208183[ebp], 0
	mov	DWORD PTR _utf8ByteLen$208184[ebp], 0

; 4779 : 		utf8ByteLen = strlen((const char *)signedFileName);

	mov	eax, DWORD PTR _signedFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _utf8ByteLen$208184[ebp], eax

; 4780 : 		utf16ByteLen = utf8ByteLen * 2;

	mov	ecx, DWORD PTR _utf8ByteLen$208184[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf16ByteLen$208183[ebp], ecx

; 4781 : 		utf16CharStr = (unsigned char *)zMalloc(utf16ByteLen);

	mov	edx, DWORD PTR _utf16ByteLen$208183[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf16CharStr$208182[ebp], eax

; 4782 : 		UTF8ToUTF16LE(utf16CharStr, &utf16ByteLen, (const unsigned char*)signedFileName, &utf8ByteLen);

	lea	eax, DWORD PTR _utf8ByteLen$208184[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _utf16ByteLen$208183[ebp]
	push	edx
	mov	eax, DWORD PTR _utf16CharStr$208182[ebp]
	push	eax
	call	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z		; UTF8ToUTF16LE
	add	esp, 16					; 00000010H

; 4783 : 		BSTR bstrSignedFileName = SysAllocStringByteLen((LPCSTR)utf16CharStr, utf16ByteLen);

	mov	esi, esp
	mov	ecx, DWORD PTR _utf16ByteLen$208183[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf16CharStr$208182[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrSignedFileName$208188[ebp], eax

; 4784 : 		zFree(utf16CharStr);

	mov	eax, DWORD PTR _utf16CharStr$208182[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4785 : 		xmlFree(signedFileName);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedFileName$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4786 : 
; 4787 : 		dwBytesToWrite = base64decodeSize((DWORD)strlen((const char *)encodedFileData));

	mov	edx, DWORD PTR _encodedFileData$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 4788 : 		decodedDataPtr = (char *) zMalloc (dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _decodedDataPtr$[ebp], eax

; 4789 : 		memset(decodedDataPtr,0,dwBytesToWrite+1);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	add	ecx, 1
	push	ecx
	push	0
	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 4790 : 		dwBytesToWrite = base64decode((unsigned char *)encodedFileData,(unsigned char *)decodedDataPtr,dwBytesToWrite);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _decodedDataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encodedFileData$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 4791 : 
; 4792 : 		fullFilePath = (WCHAR *)zMalloc(MAX_PATH * 2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _fullFilePath$[ebp], eax

; 4793 : 		memset(fullFilePath, 0, MAX_PATH * 2);

	push	520					; 00000208H
	push	0
	mov	eax, DWORD PTR _fullFilePath$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4794 : 
; 4795 : 		tmpSignedXML.Empty();

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 4796 : 		tmpSignedXML = saveDir;

	mov	ecx, DWORD PTR _saveDir$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4797 : 		if (tmpSignedXML.Length() == 0)

	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208196

; 4798 : 		{
; 4799 : 			GetTempPathW((DWORD)MAX_PATH, fullFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _fullFilePath$[ebp]
	push	edx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathW@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4800 : 		}
; 4801 : 		else

	jmp	SHORT $L208198
$L208196:

; 4802 : 		{
; 4803 : //			charSaveDir = W2A(saveDir);
; 4804 : 			wcscat(fullFilePath, saveDir);

	mov	eax, DWORD PTR _saveDir$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullFilePath$[ebp]
	push	ecx
	call	_wcscat
	add	esp, 8

; 4805 : 			wcscat(fullFilePath, (const WCHAR *)L"\\");

	push	OFFSET FLAT:$SG208200
	mov	edx, DWORD PTR _fullFilePath$[ebp]
	push	edx
	call	_wcscat
	add	esp, 8
$L208198:

; 4806 : 		}
; 4807 : 
; 4808 : 		wcscat(fullFilePath, (const WCHAR *)bstrSignedFileName);

	mov	eax, DWORD PTR _bstrSignedFileName$208188[ebp]
	push	eax
	mov	ecx, DWORD PTR _fullFilePath$[ebp]
	push	ecx
	call	_wcscat
	add	esp, 8

; 4809 : 		SysFreeString(bstrSignedFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrSignedFileName$208188[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4810 : 
; 4811 : 		// open file in write mode 
; 4812 : #ifdef WIN32
; 4813 : 		if ((hFile = _wfopen(fullFilePath,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG208203
	mov	eax, DWORD PTR _fullFilePath$[ebp]
	push	eax
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	SHORT $L208202

; 4814 : #elif LINUX
; 4815 : 		unsigned char *utf8FilePath = HeapWCHAR2A(fullFilePath);
; 4816 : 		if ((hFile = fopen((const char *)utf8FilePath, "wb")) == NULL) {
; 4817 : 			zFree(utf8FilePath);
; 4818 : #endif
; 4819 : 			
; 4820 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4821 : 			zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4822 : 			xmlFree(encodedFileData);

	mov	esi, esp
	mov	ecx, DWORD PTR _encodedFileData$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4823 : 			zFree(fullFilePath);

	mov	edx, DWORD PTR _fullFilePath$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4824 : 			xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 4825 : 			return S_FALSE;

	mov	DWORD PTR $T221240[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221240[ebp]
	jmp	$L208120
$L208202:

; 4826 : 		}
; 4827 : #ifdef LINUX
; 4828 : 		zFree(utf8FilePath);
; 4829 : #endif
; 4830 : 
; 4831 : 		if ((writeResult = fwrite(decodedDataPtr, 1, dwBytesToWrite, hFile)) == 0)

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwBytesToWrite$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _writeResult$[ebp], eax
	cmp	DWORD PTR _writeResult$[ebp], 0
	jne	SHORT $L208206

; 4832 : 		{
; 4833 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4834 : 			zFree(decodedDataPtr);

	mov	eax, DWORD PTR _decodedDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 4835 : 			xmlFree(encodedFileData);

	mov	esi, esp
	mov	ecx, DWORD PTR _encodedFileData$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4836 : 			zFree(fullFilePath);

	mov	edx, DWORD PTR _fullFilePath$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4837 : 			xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 4838 : 			return S_FALSE;

	mov	DWORD PTR $T221241[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221241[ebp]
	jmp	$L208120
$L208206:

; 4839 : 		}
; 4840 : 		if (ferror(hFile))

	mov	ecx, DWORD PTR _hFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 32					; 00000020H
	je	SHORT $L208209

; 4841 : 		{
; 4842 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 4843 : 			zFree(decodedDataPtr);

	mov	edx, DWORD PTR _decodedDataPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 4844 : 			xmlFree(encodedFileData);

	mov	esi, esp
	mov	eax, DWORD PTR _encodedFileData$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4845 : 			zFree(fullFilePath);

	mov	ecx, DWORD PTR _fullFilePath$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4846 : 			xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 4847 : 			return S_FALSE;

	mov	DWORD PTR $T221242[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221242[ebp]
	jmp	$L208120
$L208209:

; 4848 : 		}
; 4849 : 
; 4850 : 		fclose(hFile);

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 4851 : 		zFree(decodedDataPtr);

	mov	ecx, DWORD PTR _decodedDataPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4852 : 		xmlFree(encodedFileData);

	mov	esi, esp
	mov	edx, DWORD PTR _encodedFileData$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4853 : 		*signedFilePath = SysAllocString((const OLECHAR *)fullFilePath);

	mov	esi, esp
	mov	eax, DWORD PTR _fullFilePath$[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _signedFilePath$[ebp]
	mov	DWORD PTR [ecx], eax

; 4854 : 		TEMP_FILE_INFO *tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221243[ebp], eax
	mov	edx, DWORD PTR $T221243[ebp]
	mov	DWORD PTR _tmpFilePath$208213[ebp], edx

; 4855 : 		wcscpy((WCHAR *)tmpFilePath->fileName, fullFilePath);

	mov	eax, DWORD PTR _fullFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$208213[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 4856 : 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$208213[ebp]
	push	edx
	lea	eax, DWORD PTR $T221244[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T221245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 4857 : 		zFree(fullFilePath);

	mov	edx, DWORD PTR _fullFilePath$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L208181:

; 4858 : 	}
; 4859 : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 4860 : 	ExitLog;
; 4861 : 	return S_OK;

	mov	DWORD PTR $T221246[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221246[ebp]
$L208120:

; 4862 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221256
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221256:
	DD	4
	DD	$L221255
$L221255:
	DD	-68					; ffffffbcH
	DD	4
	DD	$L221250
	DD	-124					; ffffff84H
	DD	4
	DD	$L221251
	DD	-136					; ffffff78H
	DD	4
	DD	$L221252
	DD	-152					; ffffff68H
	DD	4
	DD	$L221253
$L221253:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221252:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221251:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221250:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221247:
	lea	ecx, DWORD PTR _tmpSignedXML$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221249
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::GetSignedFileObject
PUBLIC	?SetStoreName@CSignature@@UAGJPAG@Z		; CSignature::SetStoreName
xdata$x	SEGMENT
$T221279 DD	0ffffffffH
	DD	FLAT:$L221270
	DD	00H
	DD	FLAT:$L221271
$T221273 DD	019930520H
	DD	02H
	DD	FLAT:$T221279
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv318 = -148						; size = 4
tv148 = -144						; size = 4
$T221269 = -140						; size = 4
$T221266 = -136						; size = 4
$T221265 = -132						; size = 4
$T221264 = -128						; size = 16
$T221261 = -112						; size = 4
$T221260 = -108						; size = 4
$T221259 = -104						; size = 4
_i$208303 = -100					; size = 4
_j$208294 = -96						; size = 4
_certificateAllowed$208293 = -92			; size = 4
_i$208289 = -88						; size = 4
_j$208282 = -84						; size = 4
_i$208278 = -80						; size = 4
_allowedCertCount$208277 = -76				; size = 4
_indexArray$208274 = -72				; size = 4
_nsp$ = -68						; size = 4
__lpa$ = -64						; size = 4
__lpw$ = -60						; size = 4
__acp$ = -56						; size = 4
__convert$ = -52					; size = 4
_certPtr$ = -48						; size = 4
_numCerts$ = -40					; size = 4
_i$208233 = -32						; size = 4
_tmpCharPtr$ = -28					; size = 4
_tmpStoreName$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_storeName$ = 12					; size = 4
?SetStoreName@CSignature@@UAGJPAG@Z PROC NEAR		; CSignature::SetStoreName

; 4865 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetStoreName@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 136				; 00000088H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 4866 : 	CComBSTR tmpStoreName;

	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 4867 : 	unsigned char *tmpCharPtr;
; 4868 : 	EnterLog;
; 4869 : 	tmpStoreName = storeName;

	mov	eax, DWORD PTR _storeName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4870 : 	if (tmpStoreName.Length() == 0)

	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208227

; 4871 : 	{
; 4872 : 		setError(SigHandle, NO_CERT_STORE);

	push	19					; 00000013H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 4873 : 		return S_FALSE;

	mov	DWORD PTR $T221259[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221259[ebp]
	jmp	$L221258
$L208227:

; 4874 : 	}
; 4875 : 	//free cV and SigHandle
; 4876 : 	if ((UsingNetscape == FALSE) || (allowedCertIssuerCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3388], 0
	je	SHORT $L208231
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3332], 0
	je	$L208230
$L208231:

; 4877 : 		if (cV != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	$L208230

; 4878 : 		{
; 4879 : 			for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$208233[ebp], 0
	jmp	SHORT $L208234
$L208235:
	mov	eax, DWORD PTR _i$208233[ebp]
	add	eax, 1
	mov	DWORD PTR _i$208233[ebp], eax
$L208234:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$208233[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	SHORT $L208236

; 4880 : 			{
; 4881 : 				if (cV[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$208233[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L208237

; 4882 : 				{
; 4883 : 					if (cV[i]->certificate != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$208233[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+2048], 0
	je	SHORT $L208238

; 4884 : 						zFree(cV[i]->certificate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$208233[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	_rFree
	add	esp, 4
$L208238:

; 4885 : 					zFree(cV[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$208233[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L208237:

; 4886 : 				}
; 4887 : 			}

	jmp	SHORT $L208235
$L208236:

; 4888 : 			zFree(cV);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	call	_rFree
	add	esp, 4

; 4889 : 			cV = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0
$L208230:

; 4890 : 		}
; 4891 : #ifdef WIN32
; 4892 : 	//free showselect cert obj
; 4893 : 	if (CertificateCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	SHORT $L208239

; 4894 : 		if (dlg != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1808], 0
	je	SHORT $L208239

; 4895 : 			delete dlg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1808]
	mov	DWORD PTR $T221261[ebp], ecx
	mov	edx, DWORD PTR $T221261[ebp]
	mov	DWORD PTR $T221260[ebp], edx
	cmp	DWORD PTR $T221260[ebp], 0
	je	SHORT $L221262
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T221260[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T221260[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv148[ebp], eax
	jmp	SHORT $L208239
$L221262:
	mov	DWORD PTR tv148[ebp], 0
$L208239:

; 4896 : #endif
; 4897 : 
; 4898 : 	if (SigHandle != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+692], 0
	je	SHORT $L208243

; 4899 : 	{
; 4900 : 		axFree(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axFree
	add	esp, 4

; 4901 : 		SigHandle = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+692], 0
$L208243:

; 4902 : 	}
; 4903 : 
; 4904 : 	StoreName = storeName;

	mov	ecx, DWORD PTR _storeName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 4905 : 
; 4906 : 	//do all initialization
; 4907 : 	int numCerts;
; 4908 : 	PCERT_DESCR *certPtr;
; 4909 : 
; 4910 : 	sgArr=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 4911 : 	err=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 4912 : 	signum=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 4913 : 	uriArr=NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 4914 : 	failedUriArr=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 4915 : 	failedUriCount=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 4916 : 	totalUriCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+40], 0

; 4917 : 
; 4918 : 	CertificateCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 0

; 4919 : 	CurrentCertificate = NOT_INITIALIZED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], -1

; 4920 : 
; 4921 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 4922 : #ifdef NSS
; 4923 : 	unsigned char *nsp = (unsigned char *)HeapW2A(nsStorePassword);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3384]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _nsp$[ebp], eax

; 4924 : 	if (!nsp) {

	cmp	DWORD PTR _nsp$[ebp], 0
	jne	SHORT $L208252

; 4925 : 		nsp = (unsigned char *)zMalloc(sizeof(char));

	push	1
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _nsp$[ebp], eax

; 4926 : 		*nsp = '\0';

	mov	ecx, DWORD PTR _nsp$[ebp]
	mov	BYTE PTR [ecx], 0
$L208252:

; 4927 : 	}
; 4928 : 	SigHandle = axInit(nsp);

	mov	edx, DWORD PTR _nsp$[ebp]
	push	edx
	call	_axInit
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+692], eax

; 4929 : 	if (!SigHandle) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+692], 0
	jne	SHORT $L208255

; 4930 : 	   throw SigException("Library initialization failed");

	push	OFFSET FLAT:$SG208258
	lea	ecx, DWORD PTR $T221264[ebp]
	call	??0SigException@@QAE@PAD@Z		; SigException::SigException
	push	OFFSET FLAT:__TI2?AVSigException@@
	lea	eax, DWORD PTR $T221264[ebp]
	push	eax
	call	__CxxThrowException@8
$L208255:

; 4931 : 	}	
; 4932 : 
; 4933 : 	zFree((void *)nsp);

	mov	ecx, DWORD PTR _nsp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 4934 : #else
; 4935 : 	SigHandle = axInit();
; 4936 : #endif
; 4937 : 	SigHandle->useFastC14N=TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	DWORD PTR [eax+44], 1

; 4938 : 
; 4939 : 	tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 4940 : 
; 4941 : 	if (strcmp((const char *)tmpCharPtr, NETSCAPESTORE))

	push	OFFSET FLAT:$SG208262
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L208261

; 4942 : 	{
; 4943 : #ifdef WIN32
; 4944 : 		// Store name is not Netscape
; 4945 : 		if ((UsingNetscape == TRUE) && (nsCertStoreObj != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3388], 1
	jne	SHORT $L208263
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3380], 0
	je	SHORT $L208263

; 4946 : 		{
; 4947 : 			nsCertStoreObj->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3380]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3380]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4948 : 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208263:

; 4949 : 		}
; 4950 : #endif
; 4951 : 		UsingNetscape = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3388], 0

; 4952 : #ifdef NSS
; 4953 : 		if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts, SigHandle )) != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	lea	edx, DWORD PTR _numCerts$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_axGetCertificateList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _certPtr$[ebp], eax
	cmp	DWORD PTR _certPtr$[ebp], 0
	je	SHORT $L208264

; 4954 : #else
; 4955 : 		if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts )) != NULL)
; 4956 : #endif
; 4957 : 		{
; 4958 : 			CertificateCount = (long) numCerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [ecx+124], edx

; 4959 : 			if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L208266

; 4960 : 				cVSigner = certPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _certPtr$[ebp]
	mov	DWORD PTR [eax+108], ecx

; 4961 : 			else

	jmp	SHORT $L208264
$L208266:

; 4962 : 			{
; 4963 : 				cVSigner = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], 0
$L208264:

; 4964 : 				//return;
; 4965 : 			}
; 4966 : 		}
; 4967 : 	}
; 4968 : 	else // The store name is Netscape hence do the netscape cert processing

	jmp	SHORT $L208268
$L208261:

; 4969 : 	{
; 4970 : #ifdef NSS
; 4971 : 		UsingNetscape = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3388], 0

; 4972 : 		if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts, SigHandle )) != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	eax, DWORD PTR _numCerts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_axGetCertificateList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _certPtr$[ebp], eax
	cmp	DWORD PTR _certPtr$[ebp], 0
	je	SHORT $L208268

; 4973 : 		{
; 4974 : 			CertificateCount = (long) numCerts;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [edx+124], eax

; 4975 : 			if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L208271

; 4976 : 				cVSigner = certPtr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _certPtr$[ebp]
	mov	DWORD PTR [ecx+108], edx

; 4977 : 			else

	jmp	SHORT $L208268
$L208271:

; 4978 : 			{
; 4979 : 				cVSigner = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0
$L208268:

; 4980 : 			}
; 4981 : 		}
; 4982 : #else
; 4983 : 		IUnknown *pUnknown;
; 4984 : #ifdef WIN32
; 4985 : 		if ((UsingNetscape == TRUE) && (nsCertStoreObj != NULL))
; 4986 : 		{
; 4987 : 			nsCertStoreObj->Release();
; 4988 : 			CoUninitialize();
; 4989 : 		}
; 4990 : 
; 4991 : 		CoInitialize(NULL);
; 4992 : 		HRESULT hr = CoCreateInstance(__uuidof(CCertStore), NULL, CLSCTX_INPROC_SERVER, 
; 4993 : 							IID_IUnknown, (void **) &pUnknown);
; 4994 : 		if (FAILED(hr))
; 4995 : 		{
; 4996 : 			UsingNetscape = FALSE;
; 4997 : 			CoUninitialize();
; 4998 : 			return S_FALSE;
; 4999 : 		}
; 5000 : 
; 5001 : 		hr = pUnknown->QueryInterface(__uuidof(ICertStore), (void **) &nsCertStoreObj);
; 5002 : 		if (FAILED(hr))
; 5003 : 		{
; 5004 : 			pUnknown->Release();
; 5005 : 			UsingNetscape = FALSE;
; 5006 : 			CoUninitialize();
; 5007 : 			return S_FALSE;
; 5008 : 		}
; 5009 : 		pUnknown->Release();
; 5010 : 
; 5011 : 		nsCertStoreObj->NetscapeStorePassword = nsStorePassword;
; 5012 : 
; 5013 : 		char *certList = nsCertStoreObj->GetCertificateList((unsigned long *)&numCerts);
; 5014 : 		CertificateCount = (long) numCerts;
; 5015 : 		if (numCerts > 0)
; 5016 : 		{
; 5017 : 			UsingNetscape = TRUE;
; 5018 : 			cVSigner = (PCERT_DESCR *)certList;
; 5019 : 		}
; 5020 : 		else
; 5021 : 		{
; 5022 : 			UsingNetscape = FALSE;
; 5023 : 			cVSigner = NULL;
; 5024 : 			nsCertStoreObj->Release();
; 5025 : 			CoUninitialize();
; 5026 : 		}
; 5027 : #endif
; 5028 : #endif
; 5029 : 	}
; 5030 : 	if ((allowedCertIssuerCount != 0) && (CertificateCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3332], 0
	je	$L208273
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	$L208273

; 5031 : 	{
; 5032 : 		int *indexArray = (int *)zMalloc(sizeof(int) * CertificateCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _indexArray$208274[ebp], eax

; 5033 : 		int allowedCertCount = 0;

	mov	DWORD PTR _allowedCertCount$208277[ebp], 0

; 5034 : 
; 5035 : 		for (unsigned int i=0; i < allowedCertIssuerCount; i++)

	mov	DWORD PTR _i$208278[ebp], 0
	jmp	SHORT $L208279
$L208280:
	mov	edx, DWORD PTR _i$208278[ebp]
	add	edx, 1
	mov	DWORD PTR _i$208278[ebp], edx
$L208279:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$208278[ebp]
	cmp	ecx, DWORD PTR [eax+3332]
	jae	SHORT $L208281

; 5036 : 		{
; 5037 : 			for(int j=0; j < CertificateCount; j++)

	mov	DWORD PTR _j$208282[ebp], 0
	jmp	SHORT $L208283
$L208284:
	mov	edx, DWORD PTR _j$208282[ebp]
	add	edx, 1
	mov	DWORD PTR _j$208282[ebp], edx
$L208283:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$208282[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L208285

; 5038 : 			{
; 5039 : 				if (!strcmp((const char*)allowedCertIssuerNames[i], (const char *)cVSigner[j]->issuer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _j$208282[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 256				; 00000100H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3328]
	mov	edx, DWORD PTR _i$208278[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L208288

; 5040 : 				{
; 5041 : 					indexArray[allowedCertCount] = j;

	mov	ecx, DWORD PTR _allowedCertCount$208277[ebp]
	mov	edx, DWORD PTR _indexArray$208274[ebp]
	mov	eax, DWORD PTR _j$208282[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 5042 : 					allowedCertCount++;

	mov	ecx, DWORD PTR _allowedCertCount$208277[ebp]
	add	ecx, 1
	mov	DWORD PTR _allowedCertCount$208277[ebp], ecx
$L208288:

; 5043 : 				}
; 5044 : 			}

	jmp	SHORT $L208284
$L208285:

; 5045 : 		}

	jmp	SHORT $L208280
$L208281:

; 5046 : 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$208289[ebp], 0
	jmp	SHORT $L208290
$L208291:
	mov	edx, DWORD PTR _i$208289[ebp]
	add	edx, 1
	mov	DWORD PTR _i$208289[ebp], edx
$L208290:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$208289[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	$L208292

; 5047 : 		{
; 5048 : 			BOOL certificateAllowed = FALSE;

	mov	DWORD PTR _certificateAllowed$208293[ebp], 0

; 5049 : 			for (int j=0; j<allowedCertCount; j++)

	mov	DWORD PTR _j$208294[ebp], 0
	jmp	SHORT $L208295
$L208296:
	mov	edx, DWORD PTR _j$208294[ebp]
	add	edx, 1
	mov	DWORD PTR _j$208294[ebp], edx
$L208295:
	mov	eax, DWORD PTR _j$208294[ebp]
	cmp	eax, DWORD PTR _allowedCertCount$208277[ebp]
	jge	SHORT $L208297

; 5050 : 			{
; 5051 : 				if (indexArray[j] == i)

	mov	ecx, DWORD PTR _j$208294[ebp]
	mov	edx, DWORD PTR _indexArray$208274[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR _i$208289[ebp]
	jne	SHORT $L208298

; 5052 : 				{
; 5053 : 					certificateAllowed = TRUE;

	mov	DWORD PTR _certificateAllowed$208293[ebp], 1

; 5054 : 					break;

	jmp	SHORT $L208297
$L208298:

; 5055 : 				}
; 5056 : 			}

	jmp	SHORT $L208296
$L208297:

; 5057 : 			if ((certificateAllowed == FALSE) && (UsingNetscape == FALSE))

	cmp	DWORD PTR _certificateAllowed$208293[ebp], 0
	jne	SHORT $L208299
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3388], 0
	jne	SHORT $L208299

; 5058 : 			{
; 5059 : 				if (cVSigner[i]->certificate != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$208289[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L208300

; 5060 : 					zFree(cVSigner[i]->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _i$208289[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	_rFree
	add	esp, 4
$L208300:

; 5061 : 				zFree(cVSigner[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$208289[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L208299:

; 5062 : 			}
; 5063 : 		}

	jmp	$L208291
$L208292:

; 5064 : 		CertificateCount = allowedCertCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allowedCertCount$208277[ebp]
	mov	DWORD PTR [eax+124], ecx

; 5065 : 		cV = (PCERT_DESCR *)zMalloc(sizeof(PCERT_DESCR *) * CertificateCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 5066 : 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$208303[ebp], 0
	jmp	SHORT $L208304
$L208305:
	mov	edx, DWORD PTR _i$208303[ebp]
	add	edx, 1
	mov	DWORD PTR _i$208303[ebp], edx
$L208304:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$208303[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L208306

; 5067 : 			cV[i] = cVSigner[indexArray[i]];

	mov	edx, DWORD PTR _i$208303[ebp]
	mov	eax, DWORD PTR _indexArray$208274[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+104]
	mov	esi, DWORD PTR _i$208303[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+esi*4], eax
	jmp	SHORT $L208305
$L208306:

; 5068 : 		if (UsingNetscape == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3388], 0
	jne	SHORT $L208307

; 5069 : 			zFree(cVSigner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	_rFree
	add	esp, 4
$L208307:

; 5070 : 		zFree(indexArray);

	mov	ecx, DWORD PTR _indexArray$208274[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 5071 : 	}
; 5072 : 	else

	jmp	SHORT $L208308
$L208273:

; 5073 : 		cV = cVSigner;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR [edx+104], ecx
$L208308:

; 5074 : #ifdef WIN32
; 5075 : 	// initialise SelectCert
; 5076 : 	if (CertificateCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $L208309

; 5077 : 	{
; 5078 : 		dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV, CertificateCount);	

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221266[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T221266[ebp], 0
	je	SHORT $L221267
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T221266[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv318[ebp], eax
	jmp	SHORT $L221268
$L221267:
	mov	DWORD PTR tv318[ebp], 0
$L221268:
	mov	edx, DWORD PTR tv318[ebp]
	mov	DWORD PTR $T221265[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T221265[ebp]
	mov	DWORD PTR [eax+1808], ecx
$L208309:

; 5079 : //		dlg->Create(NULL);
; 5080 : 	}
; 5081 : #endif
; 5082 : 	zFree(tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5083 : 	ExitLog;
; 5084 : 	return S_OK;

	mov	DWORD PTR $T221269[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221269[ebp]
$L221258:

; 5085 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221278
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221278:
	DD	2
	DD	$L221277
$L221277:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221274
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221275
$L221275:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$L221274:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221270:
	lea	ecx, DWORD PTR _tmpStoreName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221271:
	mov	eax, DWORD PTR $T221266[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?SetStoreName@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T221273
	jmp	___CxxFrameHandler
text$x	ENDS
?SetStoreName@CSignature@@UAGJPAG@Z ENDP		; CSignature::SetStoreName
PUBLIC	?GetStoreName@CSignature@@UAGJPAPAG@Z		; CSignature::GetStoreName
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_storeName$ = 12					; size = 4
?GetStoreName@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::GetStoreName

; 5088 : {

	push	ebp
	mov	ebp, esp

; 5089 : 	EnterLog;
; 5090 : 	*storeName = StoreName.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 696				; 000002b8H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _storeName$[ebp]
	mov	DWORD PTR [ecx], eax

; 5091 : 	ExitLog;
; 5092 : 	return S_OK;

	xor	eax, eax

; 5093 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?GetStoreName@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::GetStoreName
_TEXT	ENDS
PUBLIC	?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z	; CSignature::SignXMLEnveloped
xdata$x	SEGMENT
$T221303 DD	0ffffffffH
	DD	FLAT:$L221289
$T221291 DD	019930520H
	DD	01H
	DD	FLAT:$T221303
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv258 = -288						; size = 4
$T221288 = -284						; size = 4
$T221287 = -280						; size = 4
$T221286 = -276						; size = 4
$T221285 = -272						; size = 4
$T221284 = -268						; size = 4
$T221283 = -264						; size = 4
_dataPtr$208496 = -260					; size = 4
_tmpEnvFlag$ = -256					; size = 2
_freeCharSigId$ = -252					; size = 4
_freeNewPtr$ = -248					; size = 4
_tmpInputXML$ = -240					; size = 4
__lpa$ = -232						; size = 4
__lpw$ = -228						; size = 4
__acp$ = -224						; size = 4
__convert$ = -220					; size = 4
_iSize$ = -212						; size = 4
_dtd$ = -204						; size = 4
_mem$ = -200						; size = 4
_curNs$ = -196						; size = 4
_signedInfoNode$ = -192					; size = 4
_sigNode$ = -188					; size = 4
_commNode$ = -184					; size = 4
_parent$ = -180						; size = 4
_rootNode$ = -176					; size = 4
_cur$ = -172						; size = 4
_doc$ = -168						; size = 4
_guidStr$ = -160					; size = 50
_sigGuid$ = -100					; size = 16
_sizeM$ = -80						; size = 4
_szPtr$ = -76						; size = 4
_curPtr$ = -72						; size = 4
_newPtr$ = -68						; size = 4
_ptr$ = -64						; size = 4
_charInputLength$ = -60					; size = 4
_charSigId$ = -56					; size = 4
_charSignedXML$ = -48					; size = 4
_ki$ = -40						; size = 4
_certData$ = -36					; size = 4
_crBlob$ = -28						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputXML$ = 12						; size = 4
_sigId$ = 16						; size = 4
_signedXML$ = 20					; size = 4
?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::SignXMLEnveloped

; 5097 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 276				; 00000114H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-288]
	mov	ecx, 69					; 00000045H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5098 : 	DS_DATA_BLOB crBlob;
; 5099 : 	unsigned char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 5100 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 5101 : 	unsigned char *charSignedXML;
; 5102 : 	char *charSigId;
; 5103 : 	int charInputLength;
; 5104 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 5105 : 	unsigned int *szPtr;
; 5106 : 	unsigned int sizeM;
; 5107 : #ifdef WIN32
; 5108 : 	GUID sigGuid;
; 5109 : #else
; 5110 : 	uuid_t sigGuid;
; 5111 : #endif
; 5112 : 	char guidStr[50];
; 5113 : 	
; 5114 : 	EnterLog;
; 5115 : 	//if (! LicObj.checkLicense()) {
; 5116 : 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 5117 : 	//	return S_FALSE;
; 5118 : 	//}
; 5119 : 	//if (!LicObj.getSignAllowed()) {
; 5120 : 	//	setError(SigHandle, NO_SIGNING_LIC);
; 5121 : 	//	return S_FALSE;
; 5122 : 	//}
; 5123 : 
; 5124 : 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L208340

; 5125 : 	{
; 5126 : 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L208341

; 5127 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L208341:

; 5128 : 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 5129 : 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L208340:

; 5130 : 	}
; 5131 : 
; 5132 : 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 5133 : 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 5134 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 5135 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 5136 : 	xmlDtdPtr dtd=NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 5137 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 5138 : 
; 5139 : 	crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 5140 : 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 5141 : 
; 5142 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 5143 : 
; 5144 : /* To be Added by Alex
; 5145 : <!DOCTYPE InfomosaicSecureXML [
; 5146 :   <!ATTLIST SignedHTML Id ID #IMPLIED>
; 5147 : ]>
; 5148 : 
; 5149 : */
; 5150 : 	CComBSTR tmpInputXML;

	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5151 : 
; 5152 : 	tmpInputXML = inputXML;

	mov	ecx, DWORD PTR _inputXML$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 5153 : 	charInputLength = tmpInputXML.Length();

	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	mov	DWORD PTR _charInputLength$[ebp], eax

; 5154 : 
; 5155 : 	if (charInputLength == 0)

	cmp	DWORD PTR _charInputLength$[ebp], 0
	jne	SHORT $L208358

; 5156 : 	{
; 5157 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 5158 : 		return S_FALSE;

	mov	DWORD PTR $T221283[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221283[ebp]
	jmp	$L208326
$L208358:

; 5159 : 	}
; 5160 : 
; 5161 : 	BOOL freeNewPtr = FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 5162 : 	if (Base64DecodeXML == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2184], 0
	jne	$L208362

; 5163 : 	{
; 5164 : 		ptr = (unsigned char *)inputXML;

	mov	edx, DWORD PTR _inputXML$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 5165 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _szPtr$[ebp], eax

; 5166 : 		sizeM = (*szPtr);

	mov	ecx, DWORD PTR _szPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _sizeM$[ebp], edx

; 5167 : 
; 5168 : 		if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 5169 : 			((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L208368
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L208367
$L208368:
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L208366
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L208366
$L208367:

; 5170 : 		{
; 5171 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 5172 : 			newPtr = ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], edx

; 5173 : 		}
; 5174 : 		else

	jmp	SHORT $L208369
$L208366:

; 5175 : 		{
; 5176 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 5177 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 5178 : 
; 5179 : 			FileEncoding(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 5180 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	add	ecx, 2
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5181 : 			sizeM += 4;

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	mov	DWORD PTR _sizeM$[ebp], edx
$L208369:

; 5182 : 		}
; 5183 : 	}
; 5184 : 	else

	jmp	$L208371
$L208362:

; 5185 : 	{
; 5186 : 		ptr = HeapW2A(inputXML);

	mov	eax, DWORD PTR _inputXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 5187 : 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 5188 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 5189 : 		newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 5190 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 5191 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L208374

; 5192 : 		{
; 5193 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 5194 : 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5195 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5196 : 			return S_FALSE;

	mov	DWORD PTR $T221284[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221284[ebp]
	jmp	$L208326
$L208374:

; 5197 : 		}
; 5198 : 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L208371:

; 5199 : 	}
; 5200 : 
; 5201 : 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L208377

; 5202 : 	{
; 5203 : 		if (!LicObj.getFormSignAllowed(newPtr, sizeM, SigHandle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	SHORT $L208377

; 5204 : 		{
; 5205 : 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5206 : 			return S_FALSE;

	mov	DWORD PTR $T221285[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221285[ebp]
	jmp	$L208326
$L208377:

; 5207 : 		}
; 5208 : 	}
; 5209 : 
; 5210 : 	doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 5211 : 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L208382

; 5212 : 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L208382:

; 5213 : 	if (!doc) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L208383

; 5214 : 		setError(SigHandle,XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5215 : 		return S_FALSE;

	mov	DWORD PTR $T221286[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221286[ebp]
	jmp	$L208326
$L208383:

; 5216 : 	}
; 5217 : 	rootNode = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _rootNode$[ebp], eax

; 5218 : 
; 5219 : 	/*
; 5220 : 	 * Signature
; 5221 : 	*/
; 5222 : 
; 5223 : 	tmpInputXML = sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 5224 : 
; 5225 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 5226 : 	if (tmpInputXML.Length() == 0)

	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208387

; 5227 : 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 5228 : 	else

	jmp	SHORT $L208388
$L208387:

; 5229 : 	{
; 5230 : 		charSigId = (char *)HeapW2A(sigId);

	mov	ecx, DWORD PTR _sigId$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 5231 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L208388:

; 5232 : 	}
; 5233 : 
; 5234 : 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L208390

; 5235 : 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208391

; 5236 : 		{
; 5237 : #ifdef WIN32
; 5238 : 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5239 : 			GuidToString(&sigGuid, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 5240 : #else
; 5241 : 			uuid_generate(sigGuid);
; 5242 : 			uuid_unparse(sigGuid, guidStr);
; 5243 : #endif
; 5244 : 			charSigId = guidStr;

	lea	edx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], edx

; 5245 : 		}
; 5246 : 		else

	jmp	SHORT $L208390
$L208391:

; 5247 : 		{
; 5248 : 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 5249 : 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L208390:

; 5250 : 		}
; 5251 : 
; 5252 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208395
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5253 : 	sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 5254 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG208398
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5255 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5256 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG208401
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 5257 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 5258 : 
; 5259 : 	/*
; 5260 : 	 * SignedInfo
; 5261 : 	*/
; 5262 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208403
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5263 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 5264 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5265 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 5266 : 
; 5267 : 	/*
; 5268 : 	 * Canonicalization Method
; 5269 : 	*/
; 5270 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG208405
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5271 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv258[ebp], edx
	cmp	DWORD PTR tv258[ebp], 3
	ja	SHORT $L208430
	mov	eax, DWORD PTR tv258[ebp]
	jmp	DWORD PTR $L221302[eax*4]
$L208410:

; 5272 : 	{
; 5273 : 		case WITH_COMMENTS:
; 5274 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG208413
	push	OFFSET FLAT:$SG208414
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5275 : 			break;

	jmp	SHORT $L208407
$L208415:

; 5276 : 		case WITHOUT_COMMENTS:
; 5277 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG208418
	push	OFFSET FLAT:$SG208419
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5278 : 			break;

	jmp	SHORT $L208407
$L208420:

; 5279 : 		case EXC_WITH_COMMENTS:
; 5280 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG208423
	push	OFFSET FLAT:$SG208424
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5281 : 			break;

	jmp	SHORT $L208407
$L208425:

; 5282 : 		case EXC_WITHOUT_COMMENTS:
; 5283 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG208428
	push	OFFSET FLAT:$SG208429
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5284 : 			break;

	jmp	SHORT $L208407
$L208430:

; 5285 : 		default:
; 5286 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG208433
	push	OFFSET FLAT:$SG208434
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L208407:

; 5287 : 	}
; 5288 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5289 : 	/*
; 5290 : 	 * Reference
; 5291 : 	*/
; 5292 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG208436
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5293 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5294 : 	xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG208439
	push	OFFSET FLAT:$SG208440
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5295 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 5296 : 
; 5297 : 	/*
; 5298 : 	 * Transforms
; 5299 : 	 */
; 5300 : 	
; 5301 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG208442
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5302 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5303 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 5304 : 
; 5305 : 	/*
; 5306 : 	 * Transform
; 5307 : 	 */
; 5308 : 	
; 5309 : 	if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 5310 : 		(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L208444
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L208443
$L208444:

; 5311 : 	{
; 5312 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG208446
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5313 : 		if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L208447

; 5314 : 		{
; 5315 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG208450
	push	OFFSET FLAT:$SG208451
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5316 : 		}
; 5317 : 		else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L208452
$L208447:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L208452

; 5318 : 		{
; 5319 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG208456
	push	OFFSET FLAT:$SG208457
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L208452:

; 5320 : 		}
; 5321 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5322 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 5323 : 		if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L208458

; 5324 : 		{
; 5325 : 			cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG208460
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5326 : 			xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG208463
	push	OFFSET FLAT:$SG208464
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 5327 : 			xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG208467
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5328 : 		}
; 5329 : 		else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L208468
$L208458:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L208468

; 5330 : 		{
; 5331 : 			cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG208471
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5332 : 			xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG208474
	push	OFFSET FLAT:$SG208475
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 5333 : 			xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG208478
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L208468:

; 5334 : 		}
; 5335 : 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5336 : 		parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx
$L208443:

; 5337 : 	}
; 5338 : 
; 5339 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG208480
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5340 : 	xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG208483
	push	OFFSET FLAT:$SG208484
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 5341 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 5342 : 
; 5343 : #ifdef WIN32
; 5344 : 	if (AddWindowImageFlag == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 1
	jne	SHORT $L208485

; 5345 : 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L208485:

; 5346 : 
; 5347 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $L208486

; 5348 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L208486:

; 5349 : #endif
; 5350 : 
; 5351 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], dx

; 5352 : 	EnvelopingFlag = ENVELOPED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+688], 2

; 5353 : 
; 5354 : 	if (!(CreateSigFromTmplBlob(doc, (char *)charSigId, &charSignedXML, &iSize)))

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _charSignedXML$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L208489

; 5355 : 	{
; 5356 : 		if (charSignedXML != NULL)

	cmp	DWORD PTR _charSignedXML$[ebp], 0
	je	SHORT $L208490

; 5357 : 			xmlFree(charSignedXML);

	mov	esi, esp
	mov	edx, DWORD PTR _charSignedXML$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208490:

; 5358 : 		EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 5359 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L208491

; 5360 : 			zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L208491:

; 5361 : 		return S_FALSE;

	mov	DWORD PTR $T221287[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221287[ebp]
	jmp	$L208326
$L208489:

; 5362 : 	}
; 5363 : 	else
; 5364 : 	{
; 5365 : 		if (charSignedXML != NULL)

	cmp	DWORD PTR _charSignedXML$[ebp], 0
	je	$L208494

; 5366 : 		{
; 5367 : 			unsigned char *dataPtr = charSignedXML;

	mov	eax, DWORD PTR _charSignedXML$[ebp]
	mov	DWORD PTR _dataPtr$208496[ebp], eax

; 5368 : 
; 5369 : 			if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) ||
; 5370 : 				((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff)))

	mov	ecx, DWORD PTR _dataPtr$208496[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L208499
	mov	eax, DWORD PTR _dataPtr$208496[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L208498
$L208499:
	mov	edx, DWORD PTR _dataPtr$208496[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L208497
	mov	ecx, DWORD PTR _dataPtr$208496[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L208497
$L208498:

; 5371 : 			{
; 5372 : 				// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 5373 : 				// Just allocate memory and copy data and put the size information in front
; 5374 : 				*signedXML = ::SysAllocStringByteLen((LPCSTR)dataPtr, (UINT)iSize);

	mov	esi, esp
	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$208496[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [edx], eax

; 5375 : 				xmlFree(dataPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _dataPtr$208496[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5376 : 			}
; 5377 : 			else

	jmp	SHORT $L208494
$L208497:

; 5378 : 			{
; 5379 : 				*signedXML = A2WBSTR((LPCSTR)dataPtr, iSize);

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$208496[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [ecx], eax

; 5380 : 				if (Base64EncodeXML == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2180], 1
	jne	SHORT $L208504

; 5381 : 					zFree(dataPtr);

	mov	eax, DWORD PTR _dataPtr$208496[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 5382 : 				else

	jmp	SHORT $L208494
$L208504:

; 5383 : 					xmlFree(dataPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _dataPtr$208496[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208494:

; 5384 : 			}
; 5385 : 		}
; 5386 : 	}
; 5387 : 	EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 5388 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L208506

; 5389 : 		zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L208506:

; 5390 : 	ExitLog;
; 5391 : 	return S_OK;

	mov	DWORD PTR $T221288[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221288[ebp]
$L208326:

; 5392 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221301
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221301:
	DD	6
	DD	$L221300
$L221300:
	DD	-28					; ffffffe4H
	DD	8
	DD	$L221292
	DD	-48					; ffffffd0H
	DD	4
	DD	$L221293
	DD	-100					; ffffff9cH
	DD	16					; 00000010H
	DD	$L221294
	DD	-160					; ffffff60H
	DD	50					; 00000032H
	DD	$L221295
	DD	-212					; ffffff2cH
	DD	4
	DD	$L221296
	DD	-240					; ffffff10H
	DD	4
	DD	$L221297
$L221297:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221296:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221295:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221294:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221293:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221292:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221302:
	DD	$L208415
	DD	$L208410
	DD	$L208425
	DD	$L208420
_TEXT	ENDS
text$x	SEGMENT
$L221289:
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221291
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::SignXMLEnveloped
PUBLIC	?GetVersion@CSignature@@UAGJPAPAG@Z		; CSignature::GetVersion
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_this$ = 8						; size = 4
_version$ = 12						; size = 4
?GetVersion@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::GetVersion

; 5395 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 5396 : // The commented code is to get the right CRC value which then needs to be put
; 5397 : // into the License.cpp verifyLicense() function to protect from dll tamperment
; 5398 : // Every time we choose a different X509 certificate to issue licenses, we need
; 5399 : // to uncomment this portion, change the X509 data, call GetVersion from a client, 
; 5400 : // get the CRC value. Then change License.cpp verifyLicense() function, comment 
; 5401 : // this code again and recompile.
; 5402 : 
; 5403 : /*
; 5404 : 	ULONG crcValue=0xff01ff01;
; 5405 : 	char charCRC[33];
; 5406 : */
; 5407 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 5408 : 	*version = ReleaseVersion.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 896				; 00000380H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _version$[ebp]
	mov	DWORD PTR [ecx], eax

; 5409 : /*
; 5410 : 	const string Cert1 = "MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCBvzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWwgU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxIzAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBTaWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlbnNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jACKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdBn2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A";
; 5411 : // Insert some junk data so that search for X509 cert match in the dll fails
; 5412 : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};
; 5413 : 	const string Cert2 = "aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTERMA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbWVudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArblPpz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl";
; 5414 : // Insert some junk data so that search for X509 cert match in the dll fails
; 5415 : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};
; 5416 : 
; 5417 : 	const string Cert3 = "cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBAKcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/sXMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzrrTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKmbpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=";	
; 5418 : 	string X509Cert = Cert1 + Cert2 + Cert3;
; 5419 : 
; 5420 : 	License::Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);
; 5421 : 	ltoa(crcValue, (char *)charCRC, 16);
; 5422 : 	*version = A2WBSTR((LPCSTR)charCRC);
; 5423 : */
; 5424 : 	return S_OK;

	xor	eax, eax

; 5425 : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetVersion@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::GetVersion
_TEXT	ENDS
PUBLIC	?getEncryptAllowed@CLicense@@QAEHXZ		; CLicense::getEncryptAllowed
PUBLIC	?getDecryptAllowed@CLicense@@QAEHXZ		; CLicense::getDecryptAllowed
PUBLIC	?getSecureSignAllowed@CLicense@@QAEHXZ		; CLicense::getSecureSignAllowed
PUBLIC	?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ ; CLicense::getSecureSignProfessionalAllowed
PUBLIC	?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ ; CLicense::getSecureSignEnterpriseAllowed
PUBLIC	?getSecureSignServerAllowed@CLicense@@QBEHXZ	; CLicense::getSecureSignServerAllowed
PUBLIC	?GetLicenseStatus@CSignature@@UAGJPAJ@Z		; CSignature::GetLicenseStatus
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_licenseValue$ = -4					; size = 4
_this$ = 8						; size = 4
_licStatus$ = 12					; size = 4
?GetLicenseStatus@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::GetLicenseStatus

; 5428 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 5429 : 	int licenseValue = 0;

	mov	DWORD PTR _licenseValue$[ebp], 0

; 5430 : 
; 5431 : 	if (LicObj.checkLicense())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	je	$L208523

; 5432 : 	{
; 5433 : 		if (LicObj.getSignAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	je	SHORT $L208524

; 5434 : 			licenseValue = licenseValue | SIGN_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	or	eax, 1
	mov	DWORD PTR _licenseValue$[ebp], eax

; 5435 : 		else

	jmp	SHORT $L208525
$L208524:

; 5436 : 			licenseValue &= ~SIGN_ALLOWED;

	mov	ecx, DWORD PTR _licenseValue$[ebp]
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR _licenseValue$[ebp], ecx
$L208525:

; 5437 : 		
; 5438 : 		if (LicObj.getVerifyAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getVerifyAllowed@CLicense@@QAEHXZ	; CLicense::getVerifyAllowed
	test	eax, eax
	je	SHORT $L208526

; 5439 : 			licenseValue = licenseValue | VERIFY_ALLOWED;

	mov	edx, DWORD PTR _licenseValue$[ebp]
	or	edx, 2
	mov	DWORD PTR _licenseValue$[ebp], edx

; 5440 : 		else

	jmp	SHORT $L208527
$L208526:

; 5441 : 			licenseValue &= ~VERIFY_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	and	eax, -3					; fffffffdH
	mov	DWORD PTR _licenseValue$[ebp], eax
$L208527:

; 5442 : 
; 5443 : 		if (LicObj.getEncryptAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getEncryptAllowed@CLicense@@QAEHXZ	; CLicense::getEncryptAllowed
	test	eax, eax
	je	SHORT $L208528

; 5444 : 			licenseValue = licenseValue | ENCRYPT_ALLOWED;

	mov	ecx, DWORD PTR _licenseValue$[ebp]
	or	ecx, 4
	mov	DWORD PTR _licenseValue$[ebp], ecx

; 5445 : 		else

	jmp	SHORT $L208529
$L208528:

; 5446 : 			licenseValue &= ~ENCRYPT_ALLOWED;

	mov	edx, DWORD PTR _licenseValue$[ebp]
	and	edx, -5					; fffffffbH
	mov	DWORD PTR _licenseValue$[ebp], edx
$L208529:

; 5447 : 		
; 5448 : 		if (LicObj.getDecryptAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getDecryptAllowed@CLicense@@QAEHXZ	; CLicense::getDecryptAllowed
	test	eax, eax
	je	SHORT $L208530

; 5449 : 			licenseValue = licenseValue | DECRYPT_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	or	eax, 8
	mov	DWORD PTR _licenseValue$[ebp], eax

; 5450 : 		else

	jmp	SHORT $L208531
$L208530:

; 5451 : 			licenseValue &= ~DECRYPT_ALLOWED;

	mov	ecx, DWORD PTR _licenseValue$[ebp]
	and	ecx, -9					; fffffff7H
	mov	DWORD PTR _licenseValue$[ebp], ecx
$L208531:

; 5452 : 		
; 5453 : 		if (LicObj.getSecureSignAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSecureSignAllowed@CLicense@@QAEHXZ	; CLicense::getSecureSignAllowed
	test	eax, eax
	je	SHORT $L208532

; 5454 : 			licenseValue = licenseValue | SECURESIGN_ALLOWED;

	mov	edx, DWORD PTR _licenseValue$[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR _licenseValue$[ebp], edx

; 5455 : 		else

	jmp	SHORT $L208533
$L208532:

; 5456 : 			licenseValue &= ~SECURESIGN_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	and	eax, -17				; ffffffefH
	mov	DWORD PTR _licenseValue$[ebp], eax
$L208533:

; 5457 : 
; 5458 : 		if (LicObj.getSecureSignProfessionalAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ ; CLicense::getSecureSignProfessionalAllowed
	test	eax, eax
	je	SHORT $L208534

; 5459 : 			licenseValue = licenseValue | SECURESIGN_PROF_ALLOWED;

	mov	ecx, DWORD PTR _licenseValue$[ebp]
	or	ecx, 32					; 00000020H
	mov	DWORD PTR _licenseValue$[ebp], ecx

; 5460 : 		else

	jmp	SHORT $L208535
$L208534:

; 5461 : 			licenseValue &= ~SECURESIGN_PROF_ALLOWED;

	mov	edx, DWORD PTR _licenseValue$[ebp]
	and	edx, -33				; ffffffdfH
	mov	DWORD PTR _licenseValue$[ebp], edx
$L208535:

; 5462 : 
; 5463 : 		if (LicObj.getSecureSignEnterpriseAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ ; CLicense::getSecureSignEnterpriseAllowed
	test	eax, eax
	je	SHORT $L208536

; 5464 : 			licenseValue = licenseValue | SECURESIGN_ENTR_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	or	eax, 64					; 00000040H
	mov	DWORD PTR _licenseValue$[ebp], eax

; 5465 : 		else

	jmp	SHORT $L208537
$L208536:

; 5466 : 			licenseValue &= ~SECURESIGN_ENTR_ALLOWED;

	mov	ecx, DWORD PTR _licenseValue$[ebp]
	and	ecx, -65				; ffffffbfH
	mov	DWORD PTR _licenseValue$[ebp], ecx
$L208537:

; 5467 : 
; 5468 : 		if (LicObj.getSecureSignServerAllowed())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSecureSignServerAllowed@CLicense@@QBEHXZ ; CLicense::getSecureSignServerAllowed
	test	eax, eax
	je	SHORT $L208538

; 5469 : 			licenseValue = licenseValue | SECURESIGN_SERVER_ALLOWED;

	mov	edx, DWORD PTR _licenseValue$[ebp]
	or	edx, 128				; 00000080H
	mov	DWORD PTR _licenseValue$[ebp], edx

; 5470 : 		else

	jmp	SHORT $L208523
$L208538:

; 5471 : 			licenseValue &= ~SECURESIGN_SERVER_ALLOWED;

	mov	eax, DWORD PTR _licenseValue$[ebp]
	and	eax, -129				; ffffff7fH
	mov	DWORD PTR _licenseValue$[ebp], eax
$L208523:

; 5472 : 	}
; 5473 : 	*licStatus = licenseValue;

	mov	ecx, DWORD PTR _licStatus$[ebp]
	mov	edx, DWORD PTR _licenseValue$[ebp]
	mov	DWORD PTR [ecx], edx

; 5474 : 
; 5475 : 	return S_OK;

	xor	eax, eax

; 5476 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetLicenseStatus@CSignature@@UAGJPAJ@Z ENDP		; CSignature::GetLicenseStatus
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
_TEXT	ENDS
;	COMDAT ?getEncryptAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getEncryptAllowed@CLicense@@QAEHXZ PROC NEAR		; CLicense::getEncryptAllowed, COMDAT
; _this$ = ecx

; 67   : 	BOOL getEncryptAllowed() {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 		if (isEncryptAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $L197872

; 69   : 			return isEncryptAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+72]
	jmp	SHORT $L197871
$L197872:

; 70   : 		else
; 71   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197871:

; 72   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getEncryptAllowed@CLicense@@QAEHXZ ENDP		; CLicense::getEncryptAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getDecryptAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDecryptAllowed@CLicense@@QAEHXZ PROC NEAR		; CLicense::getDecryptAllowed, COMDAT
; _this$ = ecx

; 73   : 	BOOL getDecryptAllowed(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 		if (isDecryptAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+76], 0
	je	SHORT $L197876

; 75   : 			return isDecryptAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+76]
	jmp	SHORT $L197875
$L197876:

; 76   : 		else
; 77   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197875:

; 78   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getDecryptAllowed@CLicense@@QAEHXZ ENDP		; CLicense::getDecryptAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getSecureSignAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSecureSignAllowed@CLicense@@QAEHXZ PROC NEAR	; CLicense::getSecureSignAllowed, COMDAT
; _this$ = ecx

; 79   : 	BOOL getSecureSignAllowed(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		if (isSecureSignAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $L197880

; 81   : 			return isSecureSignAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+80]
	jmp	SHORT $L197879
$L197880:

; 82   : 		else
; 83   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197879:

; 84   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getSecureSignAllowed@CLicense@@QAEHXZ ENDP		; CLicense::getSecureSignAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ PROC NEAR ; CLicense::getSecureSignProfessionalAllowed, COMDAT
; _this$ = ecx

; 86   : 	BOOL getSecureSignProfessionalAllowed(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		if (isSecureSignProfessionalAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+84], 0
	je	SHORT $L197884

; 88   : 			return isSecureSignProfessionalAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+84]
	jmp	SHORT $L197883
$L197884:

; 89   : 		else
; 90   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197883:

; 91   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getSecureSignProfessionalAllowed@CLicense@@QAEHXZ ENDP	; CLicense::getSecureSignProfessionalAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ PROC NEAR ; CLicense::getSecureSignEnterpriseAllowed, COMDAT
; _this$ = ecx

; 93   : 	BOOL getSecureSignEnterpriseAllowed(){

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 		if (isSecureSignEnterpriseAllowed)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L197888

; 95   : 			return isSecureSignEnterpriseAllowed;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+88]
	jmp	SHORT $L197887
$L197888:

; 96   : 		else
; 97   : 			return floatingLicenseStatus();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?floatingLicenseStatus@CLicense@@QAEHXZ	; CLicense::floatingLicenseStatus
$L197887:

; 98   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?getSecureSignEnterpriseAllowed@CLicense@@QAEHXZ ENDP	; CLicense::getSecureSignEnterpriseAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getSecureSignServerAllowed@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSecureSignServerAllowed@CLicense@@QBEHXZ PROC NEAR	; CLicense::getSecureSignServerAllowed, COMDAT
; _this$ = ecx

; 100  : 	BOOL getSecureSignServerAllowed() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		return isSecureSignServerAllowed;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+92]

; 102  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSecureSignServerAllowed@CLicense@@QBEHXZ ENDP	; CLicense::getSecureSignServerAllowed
_TEXT	ENDS
PUBLIC	?GetPropertyCount@CSignature@@UAGJJPAJ@Z	; CSignature::GetPropertyCount
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_propCount$ = 16					; size = 4
?GetPropertyCount@CSignature@@UAGJJPAJ@Z PROC NEAR	; CSignature::GetPropertyCount

; 5479 : {

	push	ebp
	mov	ebp, esp

; 5480 : 	EnterLog;
; 5481 : 	if ((sigIndex < signum) && (signum != 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $L208546
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $L208546

; 5482 : 		*propCount = sgArr[sigIndex]->propNumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _propCount$[ebp]
	mov	edx, DWORD PTR [eax+32]
	mov	DWORD PTR [ecx], edx

; 5483 : 	else

	jmp	SHORT $L208547
$L208546:

; 5484 : 		*propCount = 0;

	mov	eax, DWORD PTR _propCount$[ebp]
	mov	DWORD PTR [eax], 0
$L208547:

; 5485 : 	ExitLog;
; 5486 : 	return S_OK;

	xor	eax, eax

; 5487 : }

	pop	ebp
	ret	12					; 0000000cH
?GetPropertyCount@CSignature@@UAGJJPAJ@Z ENDP		; CSignature::GetPropertyCount
_TEXT	ENDS
PUBLIC	?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z ; CSignature::QueryStatus
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$208559 = -8						; size = 4
_hr$ = -4						; size = 4
_this$ = 8						; size = 4
_pguidCmdGroup$ = 12					; size = 4
_cCmds$ = 16						; size = 4
_prgCmds$ = 20						; size = 4
_pCmdText$ = 24						; size = 4
?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z PROC NEAR ; CSignature::QueryStatus

; 5495 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 5496 : 	HRESULT hr = E_POINTER;

	mov	DWORD PTR _hr$[ebp], -2147467261	; 80004003H

; 5497 : 	if (prgCmds != NULL) {

	cmp	DWORD PTR _prgCmds$[ebp], 0
	je	SHORT $L208558

; 5498 : 
; 5499 : 		for (ULONG i = 0; i < cCmds; i++)

	mov	DWORD PTR _i$208559[ebp], 0
	jmp	SHORT $L208560
$L208561:
	mov	eax, DWORD PTR _i$208559[ebp]
	add	eax, 1
	mov	DWORD PTR _i$208559[ebp], eax
$L208560:
	mov	ecx, DWORD PTR _i$208559[ebp]
	cmp	ecx, DWORD PTR _cCmds$[ebp]
	jae	SHORT $L208562

; 5500 : 			prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

	mov	edx, DWORD PTR _i$208559[ebp]
	mov	eax, DWORD PTR _prgCmds$[ebp]
	mov	DWORD PTR [eax+edx*8+4], 3
	jmp	SHORT $L208561
$L208562:

; 5501 : 
; 5502 : 		hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0
$L208558:

; 5503 : 	}
; 5504 : 
; 5505 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 5506 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z ENDP ; CSignature::QueryStatus
_TEXT	ENDS
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z ; CSignature::Exec
PUBLIC	??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ ; ATL::CComPtrBase<IHTMLDocument2>::operator&
PUBLIC	??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ ; ATL::CComPtrBase<IHTMLDocument2>::operator->
PUBLIC	??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ	; ATL::CComPtr<IHTMLDocument2>::CComPtr<IHTMLDocument2>
PUBLIC	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ	; ATL::CComPtr<IHTMLDocument2>::~CComPtr<IHTMLDocument2>
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
EXTRN	__imp__GetProcAddress@8:NEAR
EXTRN	_IID_IShellBrowser:BYTE
EXTRN	__imp__CoInitialize@4:NEAR
EXTRN	__imp__SendMessageTimeoutA@28:NEAR
EXTRN	__imp__LoadLibraryA@4:NEAR
EXTRN	__imp__FindWindowExA@16:NEAR
EXTRN	__imp__GetClassNameA@12:NEAR
EXTRN	_IID_IHTMLDocument2:BYTE
EXTRN	__imp__RegisterWindowMessageA@4:NEAR
xdata$x	SEGMENT
$T221354 DD	0ffffffffH
	DD	FLAT:$L221332
	DD	00H
	DD	FLAT:$L221333
	DD	01H
	DD	FLAT:$L221334
	DD	02H
	DD	FLAT:$L221335
$T221337 DD	019930520H
	DD	04H
	DD	FLAT:$T221354
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv171 = -640						; size = 4
$T221331 = -636						; size = 4
$T221330 = -632						; size = 4
$T221329 = -628						; size = 4
$T221328 = -624						; size = 4
$T221327 = -620						; size = 4
$T221326 = -616						; size = 4
$T221325 = -612						; size = 4
$T221324 = -608						; size = 4
$T221323 = -604						; size = 4
$T221322 = -600						; size = 4
_oFile$ = -592						; size = 148
_origHTML$ = -436					; size = 4
_sFile$ = -424						; size = 148
_buff$ = -272						; size = 4
_signedHTML$ = -264					; size = 4
_spDisp$ = -252						; size = 4
_spElem$ = -240						; size = 4
_pfObjectFromLresult$ = -232				; size = 4
_nMsg$ = -228						; size = 4
_lRes$ = -220						; size = 4
_spDoc$ = -208						; size = 4
_hInst$ = -200						; size = 4
_hwndchild$ = -196					; size = 4
_str$ = -188						; size = 28
_winclass$ = -152					; size = 100
_hwnd$ = -44						; size = 4
_hres$ = -36						; size = 4
_iShBro$ = -28						; size = 4
_hr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_pguidCmdGroup$ = 12					; size = 4
_nCmdID$ = 16						; size = 4
_nCmdExecOpt$ = 20					; size = 4
_pvaIn$ = 24						; size = 4
_pvaOut$ = 28						; size = 4
?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z PROC NEAR ; CSignature::Exec

; 5514 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 628				; 00000274H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-640]
	mov	ecx, 157				; 0000009dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5515 : 
; 5516 : 	HRESULT hr = E_FAIL;

	mov	DWORD PTR _hr$[ebp], -2147467259	; 80004005H

; 5517 : 
; 5518 : 	// Return error messages if proper parameters are not passed.
; 5519 : 	if (pguidCmdGroup != NULL)

	cmp	DWORD PTR _pguidCmdGroup$[ebp], 0
	je	SHORT $L208574

; 5520 : 		return OLECMDERR_E_UNKNOWNGROUP;

	mov	eax, -2147221244			; 80040104H
	jmp	$L208571
$L208574:

; 5521 : 	if (nCmdID != 0)

	cmp	DWORD PTR _nCmdID$[ebp], 0
	je	SHORT $L208576

; 5522 : 		return OLECMDERR_E_NOTSUPPORTED;

	mov	eax, -2147221248			; 80040100H
	jmp	$L208571
$L208576:

; 5523 : 	if (nCmdExecOpt == OLECMDEXECOPT_SHOWHELP)

	cmp	DWORD PTR _nCmdExecOpt$[ebp], 3
	jne	SHORT $L208578

; 5524 : 		return OLECMDERR_E_NOHELP;

	mov	eax, -2147221246			; 80040102H
	jmp	$L208571
$L208578:

; 5525 : 
; 5526 : 	// Get a reference to the IShellBrowser from GetSite
; 5527 : 	IShellBrowser *iShBro;
; 5528 : 	HRESULT hres = GetSite(IID_IShellBrowser, (void **)&iShBro);

	mov	esi, esp
	lea	eax, DWORD PTR _iShBro$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IShellBrowser
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	ecx
	call	DWORD PTR [eax+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5529 : 	if (FAILED(hres))

	cmp	DWORD PTR _hres$[ebp], 0
	jge	SHORT $L208584

; 5530 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L208571
$L208584:

; 5531 : 
; 5532 : 	// Get the HWND object from the IShellBrowser
; 5533 : 	HWND hwnd;
; 5534 : 	hres = iShBro->GetWindow(&hwnd);

	mov	esi, esp
	lea	ecx, DWORD PTR _hwnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iShBro$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _iShBro$[ebp]
	push	ecx
	call	DWORD PTR [eax+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5535 : 	if (FAILED(hres))

	cmp	DWORD PTR _hres$[ebp], 0
	jge	SHORT $L208587

; 5536 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L208571
$L208587:

; 5537 : 
; 5538 : 	// Find out the class name of the HWND object
; 5539 : 	char winclass[100];
; 5540 : 	if (GetClassName(hwnd, winclass, 100) == 0)

	mov	esi, esp
	push	100					; 00000064H
	lea	edx, DWORD PTR _winclass$[ebp]
	push	edx
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetClassNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L208589

; 5541 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L208571
$L208589:

; 5542 : 
; 5543 : 	string str(winclass);

	lea	ecx, DWORD PTR _winclass$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _str$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5544 : 	// If the name is not "IEFrame", it is an error
; 5545 : 	if (str.compare("IEFrame"))

	push	OFFSET FLAT:$SG208592
	lea	ecx, DWORD PTR _str$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
	test	eax, eax
	je	SHORT $L208591

; 5546 : 		return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221322[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221322[ebp]
	jmp	$L208571
$L208591:

; 5547 : 
; 5548 : 	// Get the Shell DocObject View and then the Internet Explorer_Server
; 5549 : 	// These are child windows of the HWND object we have
; 5550 : 	HWND hwndchild = FindWindowEx(hwnd, NULL, "Shell DocObject View", NULL);

	mov	esi, esp
	push	0
	push	OFFSET FLAT:$SG208595
	push	0
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	call	DWORD PTR __imp__FindWindowExA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hwndchild$[ebp], eax

; 5551 : 	if (hwndchild == NULL)

	cmp	DWORD PTR _hwndchild$[ebp], 0
	jne	SHORT $L208596

; 5552 : 		return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221323[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221323[ebp]
	jmp	$L208571
$L208596:

; 5553 : 	hwndchild = FindWindowEx(hwndchild, NULL, "Internet Explorer_Server", NULL);

	mov	esi, esp
	push	0
	push	OFFSET FLAT:$SG208598
	push	0
	mov	edx, DWORD PTR _hwndchild$[ebp]
	push	edx
	call	DWORD PTR __imp__FindWindowExA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hwndchild$[ebp], eax

; 5554 : 	if (hwndchild == NULL)

	cmp	DWORD PTR _hwndchild$[ebp], 0
	jne	SHORT $L208599

; 5555 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221324[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221324[ebp]
	jmp	$L208571
$L208599:

; 5556 : 	
; 5557 : 	// Need to load the OLEACC library to be able to get IHTMLDocument2 from the window
; 5558 : 	CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5559 : 	HINSTANCE hInst = ::LoadLibrary( _T("OLEACC.DLL") );

	mov	esi, esp
	push	OFFSET FLAT:$SG208602
	call	DWORD PTR __imp__LoadLibraryA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hInst$[ebp], eax

; 5560 : 	CComPtr<IHTMLDocument2> spDoc;

	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ ; ATL::CComPtr<IHTMLDocument2>::CComPtr<IHTMLDocument2>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5561 : 	LRESULT lRes;
; 5562 : 
; 5563 : 	UINT nMsg = ::RegisterWindowMessage( _T("WM_HTML_GETOBJECT") );

	mov	esi, esp
	push	OFFSET FLAT:$SG208680
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nMsg$[ebp], eax

; 5564 : 	::SendMessageTimeout(hwndchild, nMsg, 0L, 0L, SMTO_ABORTIFHUNG, 1000, (DWORD*)&lRes);

	mov	esi, esp
	lea	ecx, DWORD PTR _lRes$[ebp]
	push	ecx
	push	1000					; 000003e8H
	push	2
	push	0
	push	0
	mov	edx, DWORD PTR _nMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hwndchild$[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageTimeoutA@28
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5565 : 
; 5566 : 	LPFNOBJECTFROMLRESULT pfObjectFromLresult = (LPFNOBJECTFROMLRESULT)::GetProcAddress(hInst, _T("ObjectFromLresult") );

	mov	esi, esp
	push	OFFSET FLAT:$SG208684
	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pfObjectFromLresult$[ebp], eax

; 5567 : 	if (pfObjectFromLresult == NULL)

	cmp	DWORD PTR _pfObjectFromLresult$[ebp], 0
	jne	SHORT $L208685

; 5568 : 		return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221325[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221325[ebp]
	jmp	$L208571
$L208685:

; 5569 : 
; 5570 : 	// Get a reference to the IHTMLDocument2 window
; 5571 : 	hres = (*pfObjectFromLresult)(lRes, IID_IHTMLDocument2, 0, (void**)&spDoc);

	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ ; ATL::CComPtrBase<IHTMLDocument2>::operator&
	mov	esi, esp
	push	eax
	push	0
	push	OFFSET FLAT:_IID_IHTMLDocument2
	mov	eax, DWORD PTR _lRes$[ebp]
	push	eax
	call	DWORD PTR _pfObjectFromLresult$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5572 : 	if (FAILED(hres))

	cmp	DWORD PTR _hres$[ebp], 0
	jge	SHORT $L208689

; 5573 : 		return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221326[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221326[ebp]
	jmp	$L208571
$L208689:

; 5574 : 
; 5575 : 	// Get the body and then the document of the HTMLDocument
; 5576 : 	IHTMLElement *spElem;
; 5577 : 	hres = spDoc->get_body(&spElem);

	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ ; ATL::CComPtrBase<IHTMLDocument2>::operator->
	mov	DWORD PTR tv171[ebp], eax
	mov	esi, esp
	lea	edx, DWORD PTR _spElem$[ebp]
	push	edx
	mov	eax, DWORD PTR tv171[ebp]
	push	eax
	mov	ecx, DWORD PTR tv171[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+36]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5578 : 	if (FAILED(hres))

	cmp	DWORD PTR _hres$[ebp], 0
	jge	SHORT $L208704

; 5579 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221327[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221327[ebp]
	jmp	$L208571
$L208704:

; 5580 : 
; 5581 : 	IDispatch *spDisp;
; 5582 : 	hres = spElem->get_document(&spDisp);

	mov	esi, esp
	lea	ecx, DWORD PTR _spDisp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _spElem$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _spElem$[ebp]
	push	ecx
	call	DWORD PTR [eax+156]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5583 : 	if (FAILED(hres))

	cmp	DWORD PTR _hres$[ebp], 0
	jge	SHORT $L208708

; 5584 : 		return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221328[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221328[ebp]
	jmp	$L208571
$L208708:

; 5585 : 
; 5586 : 	// Call the SignHTML function which signs the object and gives the XML.
; 5587 : 	BSTR signedHTML;
; 5588 : 	hres = SignHTML(spDisp, &signedHTML);

	mov	esi, esp
	lea	eax, DWORD PTR _signedHTML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _spDisp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	push	edx
	call	DWORD PTR [ecx+244]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5589 : 	if (hres == S_FALSE) {

	cmp	DWORD PTR _hres$[ebp], 1
	jne	SHORT $L208712

; 5590 : 		// SysFreeString(signedHTML);
; 5591 : 		return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221329[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221329[ebp]
	jmp	$L208571
$L208712:

; 5592 : 	}
; 5593 : 
; 5594 : 	unsigned char *buff = HeapW2A(signedHTML);

	mov	eax, DWORD PTR _signedHTML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _buff$[ebp], eax

; 5595 : 	ofstream sFile("C:\\Tmp\\SecureXMLsignedHTML.xml");

	push	1
	push	438					; 000001b6H
	push	2
	push	OFFSET FLAT:$SG208821
	lea	ecx, DWORD PTR _sFile$[ebp]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 5596 : 	sFile << buff << endl;

	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	mov	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sFile$[ebp]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 5597 : 	sFile.close();

	lea	ecx, DWORD PTR _sFile$[ebp]
	call	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close

; 5598 : 	zFree(buff);

	mov	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 5599 : 
; 5600 : 	// Get the original HTML signed by using the GetSignedHTML function.
; 5601 : 	BSTR origHTML;
; 5602 : 	hres = GetSignedHTML(signedHTML, &origHTML);

	mov	esi, esp
	lea	ecx, DWORD PTR _origHTML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedHTML$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	eax
	call	DWORD PTR [edx+256]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hres$[ebp], eax

; 5603 : 	if (hres == S_FALSE) {

	cmp	DWORD PTR _hres$[ebp], 1
	jne	SHORT $L208868

; 5604 : 		SysFreeString(signedHTML);

	mov	esi, esp
	mov	eax, DWORD PTR _signedHTML$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5605 : 		// SysFreeString(origHTML);
; 5606 : 		return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T221330[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sFile$[ebp]
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221330[ebp]
	jmp	$L208571
$L208868:

; 5607 : 	}
; 5608 : 
; 5609 : 	buff = HeapW2A(origHTML);

	mov	edx, DWORD PTR _origHTML$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _buff$[ebp], eax

; 5610 : 	ofstream oFile("C:\\Tmp\\SecureXMLorigHTML.html");

	push	1
	push	438					; 000001b6H
	push	2
	push	OFFSET FLAT:$SG208871
	lea	ecx, DWORD PTR _oFile$[ebp]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 5611 : 	oFile << buff << endl;

	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	mov	eax, DWORD PTR _buff$[ebp]
	push	eax
	lea	ecx, DWORD PTR _oFile$[ebp]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 5612 : 	oFile.close(); zFree(buff);

	lea	ecx, DWORD PTR _oFile$[ebp]
	call	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close
	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5613 : 
; 5614 : 	SysFreeString(signedHTML);

	mov	esi, esp
	mov	eax, DWORD PTR _signedHTML$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5615 : 	SysFreeString(origHTML);

	mov	esi, esp
	mov	ecx, DWORD PTR _origHTML$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5616 : 	return S_OK;

	mov	DWORD PTR $T221331[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _oFile$[ebp]
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _sFile$[ebp]
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spDoc$[ebp]
	call	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _str$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T221331[ebp]
$L208571:

; 5617 : 
; 5618 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221353
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 640				; 00000280H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L221353:
	DD	12					; 0000000cH
	DD	$L221352
$L221352:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L221338
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221339
	DD	-152					; ffffff68H
	DD	100					; 00000064H
	DD	$L221340
	DD	-188					; ffffff44H
	DD	28					; 0000001cH
	DD	$L221341
	DD	-208					; ffffff30H
	DD	4
	DD	$L221342
	DD	-220					; ffffff24H
	DD	4
	DD	$L221343
	DD	-240					; ffffff10H
	DD	4
	DD	$L221344
	DD	-252					; ffffff04H
	DD	4
	DD	$L221345
	DD	-264					; fffffef8H
	DD	4
	DD	$L221346
	DD	-424					; fffffe58H
	DD	148					; 00000094H
	DD	$L221347
	DD	-436					; fffffe4cH
	DD	4
	DD	$L221348
	DD	-592					; fffffdb0H
	DD	148					; 00000094H
	DD	$L221349
$L221349:
	DB	111					; 0000006fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L221348:
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	72					; 00000048H
	DB	84					; 00000054H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221347:
	DB	115					; 00000073H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L221346:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	72					; 00000048H
	DB	84					; 00000054H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L221345:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	0
$L221344:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	0
$L221343:
	DB	108					; 0000006cH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$L221342:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	0
$L221341:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221340:
	DB	119					; 00000077H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	0
$L221339:
	DB	104					; 00000068H
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$L221338:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	104					; 00000068H
	DB	66					; 00000042H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221332:
	lea	ecx, DWORD PTR _str$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L221333:
	lea	ecx, DWORD PTR _spDoc$[ebp]
	jmp	??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
$L221334:
	lea	ecx, DWORD PTR _sFile$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L221335:
	lea	ecx, DWORD PTR _oFile$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z:
	mov	eax, OFFSET FLAT:$T221337
	jmp	___CxxFrameHandler
text$x	ENDS
?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z ENDP ; CSignature::Exec
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z PROC NEAR ; std::endl, COMDAT

; 921  : 	{	// insert newline and flush byte stream

	push	ebp
	mov	ebp, esp

; 922  : 	_Ostr.put('\n');

	push	10					; 0000000aH
	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 923  : 	_Ostr.flush();

	mov	ecx, DWORD PTR __Ostr$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 924  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 925  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ENDP ; std::endl
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ	; ATL::CComPtrBase<IHTMLDocument2>::~CComPtrBase<IHTMLDocument2>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<IHTMLDocument2>::~CComPtr<IHTMLDocument2>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ ; ATL::CComPtrBase<IHTMLDocument2>::~CComPtrBase<IHTMLDocument2>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IHTMLDocument2>::~CComPtr<IHTMLDocument2>
_TEXT	ENDS
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	?SetSite@CSignature@@UAGJPAUIUnknown@@@Z	; CSignature::SetSite
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
xdata$x	SEGMENT
$T221370 DD	0ffffffffH
	DD	FLAT:$L221363
$T221365 DD	019930520H
	DD	01H
	DD	FLAT:$T221370
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T221362 = -176						; size = 4
_ofile$ = -168						; size = 148
_hr$208885 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pUnkSite$ = 12						; size = 4
?SetSite@CSignature@@UAGJPAUIUnknown@@@Z PROC NEAR	; CSignature::SetSite

; 5621 : STDMETHODIMP CSignature::SetSite(IUnknown* pUnkSite) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetSite@CSignature@@UAGJPAUIUnknown@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 164				; 000000a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-176]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5622 : 
; 5623 : 	if (pUnkSite)

	cmp	DWORD PTR _pUnkSite$[ebp], 0
	je	SHORT $L208884

; 5624 : 		HRESULT hr = pUnkSite->QueryInterface(IID_IShellBrowser, (LPVOID *)&pSite);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H
	mov	esi, esp
	push	eax
	push	OFFSET FLAT:_IID_IShellBrowser
	mov	ecx, DWORD PTR _pUnkSite$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pUnkSite$[ebp]
	push	eax
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$208885[ebp], eax
$L208884:

; 5625 : 
; 5626 : 	ofstream ofile;

	push	1
	lea	ecx, DWORD PTR _ofile$[ebp]
	call	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5627 : 	ofile.open("C:\\Tmp\\setsiteinv.txt", ios_base::app);

	push	438					; 000001b6H
	push	8
	push	OFFSET FLAT:$SG208889
	lea	ecx, DWORD PTR _ofile$[ebp]
	call	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open

; 5628 : 	ofile << "We are in Setsite" << endl;

	push	OFFSET FLAT:?endl@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@AAV21@@Z ; std::endl
	push	OFFSET FLAT:$SG208901
	lea	ecx, DWORD PTR _ofile$[ebp]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 5629 : 	ofile.close();

	lea	ecx, DWORD PTR _ofile$[ebp]
	call	?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ofstream<char,std::char_traits<char> >::close

; 5630 : 
; 5631 : 	return S_OK;

	mov	DWORD PTR $T221362[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ofile$[ebp]
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR $T221362[ebp]

; 5632 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221369
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 176				; 000000b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221369:
	DD	1
	DD	$L221368
$L221368:
	DD	-168					; ffffff58H
	DD	148					; 00000094H
	DD	$L221366
$L221366:
	DB	111					; 0000006fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221363:
	lea	ecx, DWORD PTR _ofile$[ebp]
	jmp	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
__ehhandler$?SetSite@CSignature@@UAGJPAUIUnknown@@@Z:
	mov	eax, OFFSET FLAT:$T221365
	jmp	___CxxFrameHandler
text$x	ENDS
?SetSite@CSignature@@UAGJPAUIUnknown@@@Z ENDP		; CSignature::SetSite
PUBLIC	?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z	; CSignature::GetSite
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvSite$ = 16						; size = 4
?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z PROC NEAR	; CSignature::GetSite

; 5634 : STDMETHODIMP CSignature::GetSite(REFIID riid, void **ppvSite) {

	push	ebp
	mov	ebp, esp
	push	esi

; 5635 : 
; 5636 : 	if (pSite)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $L208909

; 5637 : 		return pSite->QueryInterface(riid, ppvSite);

	mov	esi, esp
	mov	ecx, DWORD PTR _ppvSite$[ebp]
	push	ecx
	mov	edx, DWORD PTR _riid$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L208908
$L208909:

; 5638 : 
; 5639 : 	return E_FAIL;

	mov	eax, -2147467259			; 80004005H
$L208908:

; 5640 : 
; 5641 : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z ENDP		; CSignature::GetSite
_TEXT	ENDS
PUBLIC	?ViewAnyCertificate@CSignature@@UAGJPAG@Z	; CSignature::ViewAnyCertificate
xdata$x	SEGMENT
$T221382 DD	0ffffffffH
	DD	FLAT:$L221375
$T221377 DD	019930520H
	DD	01H
	DD	FLAT:$T221382
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221374 = -36						; size = 4
$T221373 = -32						; size = 4
_tmpCcBstr$ = -24					; size = 4
_charX509Data$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_inputX509Data$ = 12					; size = 4
?ViewAnyCertificate@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::ViewAnyCertificate

; 5645 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ViewAnyCertificate@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax

; 5646 : 	unsigned char *charX509Data;
; 5647 : 	CComBSTR	tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5648 : 	EnterLog;
; 5649 : 	tmpCcBstr = inputX509Data;

	mov	eax, DWORD PTR _inputX509Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 5650 : 	if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208917

; 5651 : 	{
; 5652 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5653 : 		return(S_FALSE);

	mov	DWORD PTR $T221373[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221373[ebp]
	jmp	SHORT $L208914
$L208917:

; 5654 : 	}
; 5655 : 	charX509Data = HeapW2A(inputX509Data);

	mov	eax, DWORD PTR _inputX509Data$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charX509Data$[ebp], eax

; 5656 : 	axViewAnyCertificate(charX509Data);

	mov	ecx, DWORD PTR _charX509Data$[ebp]
	push	ecx
	call	_axViewAnyCertificate
	add	esp, 4

; 5657 : 	zFree(charX509Data);

	mov	edx, DWORD PTR _charX509Data$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5658 : 	ExitLog;
; 5659 : 	return S_OK;

	mov	DWORD PTR $T221374[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221374[ebp]
$L208914:

; 5660 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221381
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221381:
	DD	1
	DD	$L221380
$L221380:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221378
$L221378:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221375:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?ViewAnyCertificate@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T221377
	jmp	___CxxFrameHandler
text$x	ENDS
?ViewAnyCertificate@CSignature@@UAGJPAG@Z ENDP		; CSignature::ViewAnyCertificate
PUBLIC	?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z ; CSignature::SelectActiveCertificate
PUBLIC	?selectCertificate@CShowSelectCert@@QAEPADXZ	; CShowSelectCert::selectCertificate
PUBLIC	??0_bstr_t@@QAE@PBG@Z				; _bstr_t::_bstr_t
PUBLIC	??0CComBSTR@ATL@@QAE@PBD@Z			; ATL::CComBSTR::CComBSTR
xdata$x	SEGMENT
$T221396 DD	0ffffffffH
	DD	FLAT:$L221385
	DD	00H
	DD	FLAT:$L221387
$T221389 DD	019930520H
	DD	02H
	DD	FLAT:$T221396
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv203 = -88						; size = 4
tv202 = -84						; size = 4
$T221384 = -80						; size = 4
_pfxFilePath$208955 = -72				; size = 4
_certSerialNumber$208953 = -60				; size = 4
_pfxX509Cert$208952 = -48				; size = 4
_i$208934 = -40						; size = 4
__lpa$ = -36						; size = 4
__lpw$ = -32						; size = 4
__acp$ = -28						; size = 4
__convert$ = -24					; size = 4
_plainTextHex$ = -20					; size = 4
_certData$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::SelectActiveCertificate

; 5663 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5664 : 	char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 5665 : 	unsigned char *plainTextHex = NULL;

	mov	DWORD PTR _plainTextHex$[ebp], 0

; 5666 : 
; 5667 : 	*certID = NULL;

	mov	eax, DWORD PTR _certID$[ebp]
	mov	DWORD PTR [eax], 0

; 5668 : 	EnterLog;
; 5669 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 5670 : //DebugBreak();
; 5671 : #ifdef WIN32
; 5672 : 	if (CertificateCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	SHORT $L208932

; 5673 : 	{
; 5674 :         certData = dlg->selectCertificate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1808]
	call	?selectCertificate@CShowSelectCert@@QAEPADXZ ; CShowSelectCert::selectCertificate
	mov	DWORD PTR _certData$[ebp], eax
$L208932:

; 5675 : 	}
; 5676 : #endif
; 5677 : 	if (certData != NULL)

	cmp	DWORD PTR _certData$[ebp], 0
	je	$L208933

; 5678 : 	{
; 5679 : 		int i = 0;

	mov	DWORD PTR _i$208934[ebp], 0

; 5680 : 		for (i = 0; i < CertificateCount; i++)

	mov	DWORD PTR _i$208934[ebp], 0
	jmp	SHORT $L208935
$L208936:
	mov	eax, DWORD PTR _i$208934[ebp]
	add	eax, 1
	mov	DWORD PTR _i$208934[ebp], eax
$L208935:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$208934[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	$L208937

; 5681 : 		{
; 5682 : 			if (!(StrCmp((const char *)cV[i]->certificate, (const char *)certData)))

	mov	esi, esp
	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$208934[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L208940

; 5683 : 			{
; 5684 : 				CurrentCertificate = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$208934[ebp]
	mov	DWORD PTR [eax+120], ecx

; 5685 : 				if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3324], 1
	jne	SHORT $L208941

; 5686 : 				{
; 5687 : 					plainTextHex = Base64BinToPlainHex(cV[i]->serialNumber);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$208934[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainTextHex$[ebp], eax

; 5688 : 					*certID = A2WBSTR((LPCSTR)plainTextHex);

	push	-1
	mov	ecx, DWORD PTR _plainTextHex$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _certID$[ebp]
	mov	DWORD PTR [edx], eax

; 5689 : 					zFree(plainTextHex);

	mov	eax, DWORD PTR _plainTextHex$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 5690 : 				}
; 5691 : 				else

	jmp	SHORT $L208943
$L208941:

; 5692 : 					*certID = A2WBSTR((LPCSTR)cV[i]->serialNumber);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$208934[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _certID$[ebp]
	mov	DWORD PTR [edx], eax
$L208943:

; 5693 : 				break;

	jmp	SHORT $L208937
$L208940:

; 5694 : 			}
; 5695 : 		}

	jmp	$L208936
$L208937:

; 5696 : 		if ((i==CertificateCount) && (*certID == NULL))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$208934[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jne	SHORT $L208945
	mov	edx, DWORD PTR _certID$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L208945

; 5697 : 		{
; 5698 : 			setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5699 : 			CurrentCertificate = NOT_INITIALIZED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 5700 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L208925
$L208945:

; 5701 : 		}
; 5702 : 	}
; 5703 : 	else

	jmp	SHORT $L208947
$L208933:

; 5704 : 	{
; 5705 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5706 : 		CurrentCertificate = NOT_INITIALIZED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 5707 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L208925
$L208947:

; 5708 : 	}
; 5709 : 	if (PfxCertInfo != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $L208949

; 5710 : 	{
; 5711 : 		if (PfxCertInfo->certificate != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L208950

; 5712 : 			zFree(PfxCertInfo->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	_rFree
	add	esp, 4
$L208950:

; 5713 : 		zFree(PfxCertInfo);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	call	_rFree
	add	esp, 4

; 5714 : 		PfxCertInfo = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+932], 0
$L208949:

; 5715 : 	}
; 5716 : #ifdef WIN32
; 5717 : 	if ((UsingNetscape) && (nsCertStoreObj != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3388], 0
	je	$L208951
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3380], 0
	je	$L208951

; 5718 : 	{
; 5719 : 		BSTR pfxX509Cert;
; 5720 : 		CComBSTR certSerialNumber = (char *)cV[CurrentCertificate]->serialNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	push	eax
	lea	ecx, DWORD PTR _certSerialNumber$208953[ebp]
	call	??0CComBSTR@ATL@@QAE@PBD@Z		; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5721 : 		_bstr_t pfxFilePath = nsCertStoreObj->ExportNetscapeCert(certSerialNumber.m_str);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T221384[ebp], esp
	mov	edx, DWORD PTR _certSerialNumber$208953[ebp]
	push	edx
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv202[ebp], eax
	lea	eax, DWORD PTR _pfxFilePath$208955[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3380]
	call	?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ; NetscapeCert::ICertStore::ExportNetscapeCert
	mov	DWORD PTR tv203[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 5722 : 		SetActivePFXFileCert(pfxFilePath, nsStorePassword, &pfxX509Cert);

	mov	esi, esp
	lea	edx, DWORD PTR _pfxX509Cert$208952[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3384]
	push	ecx
	lea	ecx, DWORD PTR _pfxFilePath$208955[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+304]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5723 : 		DeleteFile((LPCTSTR)(char *)pfxFilePath);

	lea	ecx, DWORD PTR _pfxFilePath$208955[ebp]
	call	??B_bstr_t@@QBEPADXZ			; _bstr_t::operator char *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5724 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pfxFilePath$208955[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _certSerialNumber$208953[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L208951:

; 5725 : #endif
; 5726 : 	ExitLog;
; 5727 : 	return S_OK;

	xor	eax, eax
$L208925:

; 5728 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221395
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221395:
	DD	3
	DD	$L221394
$L221394:
	DD	-48					; ffffffd0H
	DD	4
	DD	$L221390
	DD	-60					; ffffffc4H
	DD	4
	DD	$L221391
	DD	-72					; ffffffb8H
	DD	4
	DD	$L221392
$L221392:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221391:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L221390:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221385:
	lea	ecx, DWORD PTR _certSerialNumber$208953[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221387:
	lea	ecx, DWORD PTR _pfxFilePath$208955[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221389
	jmp	___CxxFrameHandler
text$x	ENDS
?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::SelectActiveCertificate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComBSTR@ATL@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
??0CComBSTR@ATL@@QAE@PBD@Z PROC NEAR			; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 978  : 	CComBSTR(LPCSTR pSrc)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 979  : 	{
; 980  : 		if (pSrc != NULL)

	cmp	DWORD PTR _pSrc$[ebp], 0
	je	SHORT $L81982

; 981  : 		{
; 982  : 			m_str = A2WBSTR(pSrc);

	push	-1
	mov	eax, DWORD PTR _pSrc$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 983  : 			if (m_str == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L81983

; 984  : 				AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L81983:

; 985  : 		}
; 986  : 		else

	jmp	SHORT $L81981
$L81982:

; 987  : 			m_str = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L81981:

; 988  : 	}

	mov	eax, DWORD PTR _this$[ebp]
$L221397:
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0CComBSTR@ATL@@QAE@PBD@Z ENDP				; ATL::CComBSTR::CComBSTR
_TEXT	ENDS
PUBLIC	?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z ; ATL::CAxDialogImpl<CShowSelectCert,ATL::CWindow>::DoModal
PUBLIC	??BCComBSTR@ATL@@QBEPAGXZ			; ATL::CComBSTR::operator unsigned short *
PUBLIC	?LoadStringA@CComBSTR@ATL@@QAE_NI@Z		; ATL::CComBSTR::LoadStringA
PUBLIC	?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z		; ATL::CWindow::MessageBoxA
EXTRN	__imp__GetActiveWindow@0:NEAR
EXTRN	?getCertificateData@CShowSelectCert@@QAEPADH@Z:NEAR ; CShowSelectCert::getCertificateData
;	COMDAT xdata$x
; File c:\activex\xmlsign\showselectcert.h
xdata$x	SEGMENT
$T221409 DD	0ffffffffH
	DD	FLAT:$L221402
$T221404 DD	019930520H
	DD	01H
	DD	FLAT:$T221409
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?selectCertificate@CShowSelectCert@@QAEPADXZ
_TEXT	SEGMENT
$T221401 = -44						; size = 4
$T221400 = -40						; size = 4
_msg2$ = -36						; size = 4
_msg1$ = -32						; size = 4
_cstr$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?selectCertificate@CShowSelectCert@@QAEPADXZ PROC NEAR	; CShowSelectCert::selectCertificate, COMDAT
; _this$ = ecx

; 193  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?selectCertificate@CShowSelectCert@@QAEPADXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 194  : //		DebugBreak();
; 195  : 		CComBSTR cstr;

	lea	ecx, DWORD PTR _cstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 196  : 		BYTE *msg1=NULL, *msg2=NULL;

	mov	DWORD PTR _msg1$[ebp], 0
	mov	DWORD PTR _msg2$[ebp], 0

; 197  : 
; 198  : 		cstr.LoadString(IDS_MSGINSTALL);

	push	107					; 0000006bH
	lea	ecx, DWORD PTR _cstr$[ebp]
	call	?LoadStringA@CComBSTR@ATL@@QAE_NI@Z	; ATL::CComBSTR::LoadStringA

; 199  : 		msg1 = HeapW2A(cstr);

	lea	ecx, DWORD PTR _cstr$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _msg1$[ebp], eax

; 200  : 		cstr.LoadString(IDS_MSGNOCERT);

	push	108					; 0000006cH
	lea	ecx, DWORD PTR _cstr$[ebp]
	call	?LoadStringA@CComBSTR@ATL@@QAE_NI@Z	; ATL::CComBSTR::LoadStringA

; 201  : 		msg2 = HeapW2A(cstr);

	lea	ecx, DWORD PTR _cstr$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _msg2$[ebp], eax

; 202  : 		if (count != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $L198164

; 203  : 			DoModal();

	push	0
	mov	esi, esp
	call	DWORD PTR __imp__GetActiveWindow@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z ; ATL::CAxDialogImpl<CShowSelectCert,ATL::CWindow>::DoModal

; 204  : 		else

	jmp	SHORT $L198165
$L198164:

; 205  : 			MessageBox((LPCTSTR) msg1, (LPCTSTR) msg2, MB_OK);

	push	0
	mov	ecx, DWORD PTR _msg2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _msg1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z	; ATL::CWindow::MessageBoxA
$L198165:

; 206  : 
; 207  : 		zFree(msg1);

	mov	eax, DWORD PTR _msg1$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 208  : 		zFree(msg2);

	mov	ecx, DWORD PTR _msg2$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 209  : 
; 210  : 		if(certSelected)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $L198168

; 211  : 			return getCertificateData(nCurrentRow);

	mov	eax, DWORD PTR _this$[ebp]
	movsx	ecx, WORD PTR [eax+68]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCertificateData@CShowSelectCert@@QAEPADH@Z ; CShowSelectCert::getCertificateData
	mov	DWORD PTR $T221400[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221400[ebp]
	jmp	SHORT $L198160
$L198168:

; 212  : 		else 
; 213  : 			return NULL;

	mov	DWORD PTR $T221401[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221401[ebp]
$L198160:

; 214  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221408
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L221408:
	DD	1
	DD	$L221407
$L221407:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221405
$L221405:
	DB	99					; 00000063H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L221402:
	lea	ecx, DWORD PTR _cstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?selectCertificate@CShowSelectCert@@QAEPADXZ:
	mov	eax, OFFSET FLAT:$T221404
	jmp	___CxxFrameHandler
text$x	ENDS
?selectCertificate@CShowSelectCert@@QAEPADXZ ENDP	; CShowSelectCert::selectCertificate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??BCComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCComBSTR@ATL@@QBEPAGXZ PROC NEAR			; ATL::CComBSTR::operator unsigned short *, COMDAT
; _this$ = ecx

; 640  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return m_str;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 642  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BCComBSTR@ATL@@QBEPAGXZ ENDP				; ATL::CComBSTR::operator unsigned short *
_TEXT	ENDS
PUBLIC	?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z	; ATL::CComBSTR::LoadStringResource
; Function compile flags: /Odt /RTCsu
;	COMDAT ?LoadStringA@CComBSTR@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nID$ = 8						; size = 4
?LoadStringA@CComBSTR@ATL@@QAE_NI@Z PROC NEAR		; ATL::CComBSTR::LoadStringA, COMDAT
; _this$ = ecx

; 890  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 891  : 		::SysFreeString(m_str);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 892  : 		m_str = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 893  : 		return LoadStringResource(nID, m_str);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nID$[ebp]
	push	ecx
	call	?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z ; ATL::CComBSTR::LoadStringResource
	add	esp, 8

; 894  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?LoadStringA@CComBSTR@ATL@@QAE_NI@Z ENDP		; ATL::CComBSTR::LoadStringA
_TEXT	ENDS
PUBLIC	??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z ; ATL::AtlGetStringResourceImage
;	COMDAT ??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@ DB 'bstrText == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lcomcli.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z
_TEXT	SEGMENT
_pImage$ = -4						; size = 4
_uID$ = 8						; size = 4
_bstrText$ = 12						; size = 4
?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z PROC NEAR ; ATL::CComBSTR::LoadStringResource, COMDAT

; 1106 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1107 : 		const ATLSTRINGRESOURCEIMAGE* pImage;
; 1108 : 
; 1109 : 		ATLASSERT(bstrText == NULL);

	mov	eax, DWORD PTR _bstrText$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L221418
	push	OFFSET FLAT:??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@
	push	0
	push	1109					; 00000455H
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L221418
	int	3
$L221418:

; 1110 : 
; 1111 : 		pImage = AtlGetStringResourceImage(uID);

	mov	edx, DWORD PTR _uID$[ebp]
	push	edx
	call	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z ; ATL::AtlGetStringResourceImage
	add	esp, 4
	mov	DWORD PTR _pImage$[ebp], eax

; 1112 : 		if (pImage != NULL)

	cmp	DWORD PTR _pImage$[ebp], 0
	je	SHORT $L82068

; 1113 : 		{
; 1114 : 			bstrText = ::SysAllocStringLen(pImage->achString, pImage->nLength);

	mov	eax, DWORD PTR _pImage$[ebp]
	movzx	ecx, WORD PTR [eax]
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pImage$[ebp]
	add	edx, 2
	push	edx
	call	DWORD PTR __imp__SysAllocStringLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _bstrText$[ebp]
	mov	DWORD PTR [ecx], eax
$L82068:

; 1115 : 		}
; 1116 : 
; 1117 : 		return (bstrText != NULL) ? true : false;

	mov	edx, DWORD PTR _bstrText$[ebp]
	cmp	DWORD PTR [edx], 0
	setne	al

; 1118 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z ENDP	; ATL::CComBSTR::LoadStringResource
_TEXT	ENDS
PUBLIC	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
EXTRN	?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z:NEAR ; ATL::CAtlBaseModule::GetHInstanceAt
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z
_TEXT	SEGMENT
tv70 = -16						; size = 4
_i$77536 = -12						; size = 4
_hInst$ = -8						; size = 4
_p$ = -4						; size = 4
_id$ = 8						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 307  : 	const ATLSTRINGRESOURCEIMAGE* p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 308  : 	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	push	0
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z ; ATL::CAtlBaseModule::GetHInstanceAt
	mov	DWORD PTR _hInst$[ebp], eax

; 309  : 
; 310  : 	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))

	mov	DWORD PTR _i$77536[ebp], 1
	jmp	SHORT $L77537
$L77538:
	mov	eax, DWORD PTR _i$77536[ebp]
	mov	DWORD PTR tv70[ebp], eax
	mov	ecx, DWORD PTR _i$77536[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$77536[ebp], ecx
	mov	edx, DWORD PTR tv70[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetHInstanceAt@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@H@Z ; ATL::CAtlBaseModule::GetHInstanceAt
	mov	DWORD PTR _hInst$[ebp], eax
$L77537:
	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $L77539
	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L77539

; 311  : 	{
; 312  : 		p = AtlGetStringResourceImage(hInst, id);

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ; ATL::AtlGetStringResourceImage
	add	esp, 8
	mov	DWORD PTR _p$[ebp], eax

; 313  : 	}

	jmp	SHORT $L77538
$L77539:

; 314  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]

; 315  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
PUBLIC	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
EXTRN	__imp__FindResourceA@12:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT
_hResource$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_id$ = 12						; size = 4
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z PROC NEAR ; ATL::AtlGetStringResourceImage, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 281  : 	HRSRC hResource;
; 282  : 
; 283  : 	hResource = ::FindResource( hInstance, MAKEINTRESOURCE( ((id>>4)+1) ), RT_STRING );

	mov	esi, esp
	push	6
	mov	eax, DWORD PTR _id$[ebp]
	shr	eax, 4
	add	eax, 1
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	DWORD PTR __imp__FindResourceA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResource$[ebp], eax

; 284  : 	if( hResource == NULL )

	cmp	DWORD PTR _hResource$[ebp], 0
	jne	SHORT $L77515

; 285  : 	{
; 286  : 		return( NULL );

	xor	eax, eax
	jmp	SHORT $L77507
$L77515:

; 287  : 	}
; 288  : 
; 289  : 	return _AtlGetStringResourceImage( hInstance, hResource, id );

	mov	eax, DWORD PTR _id$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hResource$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ; ATL::_AtlGetStringResourceImage
	add	esp, 12					; 0000000cH
$L77507:

; 290  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z ENDP ; ATL::AtlGetStringResourceImage
_TEXT	ENDS
EXTRN	__imp__LockResource@4:NEAR
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT
_iIndex$ = -20						; size = 4
_hGlobal$ = -16						; size = 4
_nResourceSize$ = -12					; size = 4
_pImageEnd$ = -8					; size = 4
_pImage$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_hResource$ = 12					; size = 4
_id$ = 16						; size = 4
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z PROC NEAR ; ATL::_AtlGetStringResourceImage, COMDAT

; 239  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 240  : 	const ATLSTRINGRESOURCEIMAGE* pImage;
; 241  : 	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
; 242  : 	ULONG nResourceSize;
; 243  : 	HGLOBAL hGlobal;
; 244  : 	UINT iIndex;
; 245  : 
; 246  : 	hGlobal = ::LoadResource( hInstance, hResource );

	mov	esi, esp
	mov	eax, DWORD PTR _hResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadResource@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hGlobal$[ebp], eax

; 247  : 	if( hGlobal == NULL )

	cmp	DWORD PTR _hGlobal$[ebp], 0
	jne	SHORT $L77492

; 248  : 	{
; 249  : 		return( NULL );

	xor	eax, eax
	jmp	$L77486
$L77492:

; 250  : 	}
; 251  : 
; 252  : 	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );

	mov	esi, esp
	mov	edx, DWORD PTR _hGlobal$[ebp]
	push	edx
	call	DWORD PTR __imp__LockResource@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pImage$[ebp], eax

; 253  : 	if( pImage == NULL )

	cmp	DWORD PTR _pImage$[ebp], 0
	jne	SHORT $L77494

; 254  : 	{
; 255  : 		return( NULL );

	xor	eax, eax
	jmp	SHORT $L77486
$L77494:

; 256  : 	}
; 257  : 
; 258  : 	nResourceSize = ::SizeofResource( hInstance, hResource );

	mov	esi, esp
	mov	eax, DWORD PTR _hResource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__SizeofResource@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nResourceSize$[ebp], eax

; 259  : 	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);

	mov	edx, DWORD PTR _pImage$[ebp]
	add	edx, DWORD PTR _nResourceSize$[ebp]
	mov	DWORD PTR _pImageEnd$[ebp], edx

; 260  : 	iIndex = id&0x000f;

	mov	eax, DWORD PTR _id$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _iIndex$[ebp], eax
$L77497:

; 261  : 
; 262  : 	while( (iIndex > 0) && (pImage < pImageEnd) )

	cmp	DWORD PTR _iIndex$[ebp], 0
	jbe	SHORT $L77498
	mov	ecx, DWORD PTR _pImage$[ebp]
	cmp	ecx, DWORD PTR _pImageEnd$[ebp]
	jae	SHORT $L77498

; 263  : 	{
; 264  : 		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));

	mov	edx, DWORD PTR _pImage$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _pImage$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2+2]
	mov	DWORD PTR _pImage$[ebp], edx

; 265  : 		iIndex--;

	mov	eax, DWORD PTR _iIndex$[ebp]
	sub	eax, 1
	mov	DWORD PTR _iIndex$[ebp], eax

; 266  : 	}

	jmp	SHORT $L77497
$L77498:

; 267  : 	if( pImage >= pImageEnd )

	mov	ecx, DWORD PTR _pImage$[ebp]
	cmp	ecx, DWORD PTR _pImageEnd$[ebp]
	jb	SHORT $L77502

; 268  : 	{
; 269  : 		return( NULL );

	xor	eax, eax
	jmp	SHORT $L77486
$L77502:

; 270  : 	}
; 271  : 	if( pImage->nLength == 0 )

	mov	edx, DWORD PTR _pImage$[ebp]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	jne	SHORT $L77503

; 272  : 	{
; 273  : 		return( NULL );

	xor	eax, eax
	jmp	SHORT $L77486
$L77503:

; 274  : 	}
; 275  : 
; 276  : 	return( pImage );

	mov	eax, DWORD PTR _pImage$[ebp]
$L77486:

; 277  : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z ENDP ; ATL::_AtlGetStringResourceImage
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\comutil.h
xdata$x	SEGMENT
$T221435 DD	0ffffffffH
	DD	FLAT:$L221431
$T221433 DD	019930520H
	DD	01H
	DD	FLAT:$T221435
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT
tv72 = -28						; size = 4
$T221428 = -24						; size = 4
$T221427 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_s$ = 8							; size = 4
??0_bstr_t@@QAE@PBG@Z PROC NEAR				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 261  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0_bstr_t@@QAE@PBG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	push	12					; 0000000cH
	call	??2Data_t@_bstr_t@@SAPAXI@Z		; _bstr_t::Data_t::operator new
	add	esp, 4
	mov	DWORD PTR $T221428[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T221428[ebp], 0
	je	SHORT $L221429
	mov	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T221428[ebp]
	call	??0Data_t@_bstr_t@@QAE@PBG@Z		; _bstr_t::Data_t::Data_t
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $L221430
$L221429:
	mov	DWORD PTR tv72[ebp], 0
$L221430:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	DWORD PTR $T221427[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T221427[ebp]
	mov	DWORD PTR [edx], eax

; 262  :     if (m_Data == NULL) {

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L198346

; 263  :         _com_issue_error(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?_com_issue_error@@YGXJ@Z		; _com_issue_error
$L198346:

; 264  :     }
; 265  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L221431:
	mov	eax, DWORD PTR $T221428[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0_bstr_t@@QAE@PBG@Z:
	mov	eax, OFFSET FLAT:$T221433
	jmp	___CxxFrameHandler
text$x	ENDS
??0_bstr_t@@QAE@PBG@Z ENDP				; _bstr_t::_bstr_t
PUBLIC	??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
EXTRN	__imp__MessageBoxA@16:NEAR
EXTRN	__imp__IsWindow@4:NEAR
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlwin.h
CONST	SEGMENT
??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@ DB '::IsWindow(m_hWnd)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lwin.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpszText$ = 8						; size = 4
_lpszCaption$ = 12					; size = 4
_nType$ = 16						; size = 4
?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z PROC NEAR		; ATL::CWindow::MessageBoxA, COMDAT
; _this$ = ecx

; 1482 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1483 : 		ATLASSERT(::IsWindow(m_hWnd));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__IsWindow@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L221440
	push	OFFSET FLAT:??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
	push	0
	push	1483					; 000005cbH
	push	OFFSET FLAT:??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L221440
	int	3
$L221440:

; 1484 : 		return ::MessageBox(m_hWnd, lpszText, lpszCaption, nType);

	mov	esi, esp
	mov	eax, DWORD PTR _nType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszCaption$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszText$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1485 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z ENDP		; ATL::CWindow::MessageBoxA
_TEXT	ENDS
PUBLIC	?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z		; CSignature::VerifyXMLStr
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_i$209010 = -44						; size = 4
_freeNewPtr$ = -40					; size = 4
_sizeM$ = -36						; size = 4
_szPtr$ = -32						; size = 4
_curPtr$ = -28						; size = 4
_newPtr$ = -24						; size = 4
_ptr$ = -20						; size = 4
_certStatus$ = -12					; size = 4
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_signedXML$ = 12					; size = 4
_sigStatus$ = 16					; size = 4
?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z PROC NEAR	; CSignature::VerifyXMLStr

; 5731 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5732 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 5733 : 	long certStatus=FALSE;

	mov	DWORD PTR _certStatus$[ebp], 0

; 5734 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 5735 : 	unsigned int *szPtr;
; 5736 : 	unsigned int sizeM;
; 5737 : 	BOOL freeNewPtr=FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 5738 : 	
; 5739 : 	EnterLog;
; 5740 : 
; 5741 : 
; 5742 : 	*sigStatus = FALSE;

	mov	eax, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [eax], 0

; 5743 : 	if (!LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L208975

; 5744 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5745 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L208965
$L208975:

; 5746 : 	}
; 5747 : 	if (!LicObj.getVerifyAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getVerifyAllowed@CLicense@@QAEHXZ	; CLicense::getVerifyAllowed
	test	eax, eax
	jne	SHORT $L208977

; 5748 : 		setError(SigHandle, NO_VERIFICATION_LIC);

	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5749 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L208965
$L208977:

; 5750 : 	}
; 5751 : 
; 5752 : 	if ((signedXML == NULL) || (SysStringByteLen(signedXML) == 0))

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L208980
	mov	esi, esp
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L208979
$L208980:

; 5753 : 	{
; 5754 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5755 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L208965
$L208979:

; 5756 : 	}
; 5757 : 
; 5758 : 	if (Base64EncodeXML == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2180], 1
	jne	$L208982

; 5759 : 	{
; 5760 : 		ptr = HeapW2A(signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 5761 : 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 5762 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 5763 : 		if(!(newPtr = (BYTE *)zMalloc(sizeM+1)))

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax
	cmp	DWORD PTR _newPtr$[ebp], 0
	jne	SHORT $L208985

; 5764 : 		{
; 5765 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 5766 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 5767 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L208965
$L208985:

; 5768 : 		}
; 5769 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 5770 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L208987

; 5771 : 		{
; 5772 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 5773 : 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5774 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5775 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L208965
$L208987:

; 5776 : 		}
; 5777 : 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 5778 : 	}
; 5779 : 	else

	jmp	$L208989
$L208982:

; 5780 : 	{
; 5781 : 		ptr = (unsigned char *)signedXML;

	mov	eax, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 5782 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 5783 : 		sizeM = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sizeM$[ebp], eax

; 5784 : 
; 5785 : 		if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 5786 : 			((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L208995
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L208994
$L208995:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L208993
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L208993
$L208994:

; 5787 : 		{
; 5788 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 5789 : 			newPtr = ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], eax

; 5790 : 		}
; 5791 : 		else

	jmp	SHORT $L208989
$L208993:

; 5792 : 		{
; 5793 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 5794 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 5795 : 
; 5796 : 			FileEncoding(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 5797 : //			*newPtr = 0xFF;
; 5798 : //			*(newPtr + 1) = 0xFE;
; 5799 : 
; 5800 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	add	edx, 2
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5801 : 			sizeM += 4;

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	mov	DWORD PTR _sizeM$[ebp], eax
$L208989:

; 5802 : 		}
; 5803 : 	}
; 5804 : 
; 5805 : 	*sigStatus = TRUE;

	mov	ecx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [ecx], 1

; 5806 : 	if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L208998

; 5807 : 	{
; 5808 : 		SigHandle->locArray = uriArr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+12], eax

; 5809 : 		SigHandle->locNumber = totalUriCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+16], ecx
$L208998:

; 5810 : 	}
; 5811 : 
; 5812 : 	if (HMACKey.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L208999

; 5813 : 		*sigStatus = (BOOL) axVerify((const unsigned char *)newPtr, sizeM, NULL, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3424]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3420]
	push	eax
	push	0
	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [ecx], eax

; 5814 : 	else

	jmp	SHORT $L209002
$L208999:

; 5815 : 	{
; 5816 : 		/*
; 5817 : 		 * This might not work on Windows 95/98
; 5818 : 		 */
; 5819 : 		xsCoreSetCSP((unsigned char *)"Microsoft Enhanced Cryptographic Provider v1.0",SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	push	OFFSET FLAT:$SG209004
	call	_xsCoreSetCSP
	add	esp, 8

; 5820 : 		*sigStatus = (BOOL) axVerify((const unsigned char *)newPtr, sizeM, &HMACPassword, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3424]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3420]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 908				; 0000038cH
	push	eax
	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [ecx], eax
$L209002:

; 5821 : 	}
; 5822 : 
; 5823 : 	if (sgArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $L209007

; 5824 : 	{
; 5825 : 		if (uriArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L209008

; 5826 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L209008:

; 5827 : 		sgArr = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 5828 : 		signum = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
$L209007:

; 5829 : 	}
; 5830 : 
; 5831 : 	//if (DetailedVerificationReportFlag)
; 5832 : 	//	FetchSignatureStatus(*sigStatus);
; 5833 : 	//else
; 5834 : 	//	sgArr = axGetSignature(&signum, SigHandle); // Get the full signature stats
; 5835 : 	FetchSignatureStatus(*sigStatus, DetailedVerificationReportFlag);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	push	ecx
	mov	edx, DWORD PTR _sigStatus$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FetchSignatureStatus@CSignature@@QAEXHH@Z ; CSignature::FetchSignatureStatus

; 5836 : 
; 5837 : 	if ((*sigStatus != FALSE) && (CertVerifyParams.verificationOptions))

	mov	ecx, DWORD PTR _sigStatus$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$L209009
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1856], 0
	je	SHORT $L209009

; 5838 : 	{
; 5839 : 		for (int i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$209010[ebp], 0
	jmp	SHORT $L209011
$L209012:
	mov	eax, DWORD PTR _i$209010[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209010[ebp], eax
$L209011:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$209010[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L209009

; 5840 : 		{
; 5841 : 			// certificate is present in the signature, validate it
; 5842 : 			if (sgArr[i]->certificatesCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$209010[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L209014

; 5843 : 			{
; 5844 : 				get_SigCertStatus(i, NULL, 0, &certStatus);

	mov	esi, esp
	lea	ecx, DWORD PTR _certStatus$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _i$209010[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+344]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5845 : 				if (certStatus != 0)

	cmp	DWORD PTR _certStatus$[ebp], 0
	je	SHORT $L209014

; 5846 : 				{
; 5847 : 					// Add signature status value of failed
; 5848 : 					*sigStatus = FALSE;

	mov	eax, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [eax], 0

; 5849 : 					sgArr[i]->status = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$209010[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx+8], 0

; 5850 : 					break;

	jmp	SHORT $L209009
$L209014:

; 5851 : 				}
; 5852 : 			}
; 5853 : 		}

	jmp	SHORT $L209012
$L209009:

; 5854 : 	}
; 5855 : 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L209016

; 5856 : 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209016:

; 5857 : 	ExitLog;
; 5858 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L208965:

; 5859 : 
; 5860 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221445
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221445:
	DD	1
	DD	$L221444
$L221444:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221443
$L221443:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z ENDP		; CSignature::VerifyXMLStr
_TEXT	ENDS
PUBLIC	?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::SetActivePFXFileCert
PUBLIC	?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z ; CSignature::SwapUnicodeBytes
EXTRN	_crPFX2X509:NEAR
xdata$x	SEGMENT
$T221462 DD	0ffffffffH
	DD	FLAT:$L221452
$T221454 DD	019930520H
	DD	01H
	DD	FLAT:$T221462
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221451 = -124						; size = 4
$T221450 = -120						; size = 4
$T221449 = -116						; size = 4
$T221448 = -112						; size = 4
$T221447 = -108						; size = 4
_spwd$ = -100						; size = 12
_tmpCcBstr$ = -80					; size = 4
__lpa$ = -72						; size = 4
__lpw$ = -68						; size = 4
__acp$ = -64						; size = 4
__convert$ = -60					; size = 4
_sizeM$ = -56						; size = 4
_szPtr$ = -52						; size = 4
_ptr$ = -48						; size = 4
_binFileData$ = -40					; size = 4
_certData$ = -32					; size = 4
_dwBytesToWrite$ = -28					; size = 4
_fileSize$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pfxFileName$ = 12					; size = 4
_pfxPassword$ = 16					; size = 4
_pfxX509Cert$ = 20					; size = 4
?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::SetActivePFXFileCert

; 5863 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 112				; 00000070H
	push	edi
	lea	edi, DWORD PTR [ebp-124]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5864 : 	DWORD fileSize,dwBytesToWrite;
; 5865 : 	char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 5866 : 	unsigned char *binFileData=NULL;

	mov	DWORD PTR _binFileData$[ebp], 0

; 5867 : //	unsigned char *charPfxFileName;
; 5868 : 	unsigned char *ptr;
; 5869 : 	unsigned int *szPtr;
; 5870 : 	unsigned int sizeM;
; 5871 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 5872 : 	EnterLog;
; 5873 : 	CComBSTR	tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5874 : 
; 5875 : 	tmpCcBstr = pfxFileName;

	mov	eax, DWORD PTR _pfxFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 5876 : 	if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209035

; 5877 : 	{
; 5878 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5879 : 		return S_FALSE;

	mov	DWORD PTR $T221447[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221447[ebp]
	jmp	$L209022
$L209035:

; 5880 : 	}
; 5881 : //	charPfxFileName = HeapW2A(pfxFileName);
; 5882 : 	
; 5883 : 	if (ReadAllBin(pfxFileName, &binFileData, &fileSize) == S_FALSE)

	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfxFileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L209039

; 5884 : 	{
; 5885 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5886 : //		zFree(charPfxFileName);
; 5887 : 		return S_FALSE;

	mov	DWORD PTR $T221448[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221448[ebp]
	jmp	$L209022
$L209039:

; 5888 : 	}
; 5889 : 
; 5890 : 	if (PfxPassword.pbData != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+900], 0
	je	SHORT $L209042

; 5891 : 	{
; 5892 : 		zFree(PfxPassword.pbData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	call	_rFree
	add	esp, 4

; 5893 : 		PfxPassword.pbData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+900], 0
$L209042:

; 5894 : 	}
; 5895 : 
; 5896 : 	ptr = (unsigned char *)pfxPassword;

	mov	eax, DWORD PTR _pfxPassword$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 5897 : 
; 5898 : 	if (ptr != NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $L209044

; 5899 : 	{
; 5900 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 5901 : 		sizeM = *szPtr;

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sizeM$[ebp], eax

; 5902 : 
; 5903 : 		if (sizeM == 0) {

	cmp	DWORD PTR _sizeM$[ebp], 0
	jne	SHORT $L209047

; 5904 : 			PfxPassword.pbData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+900], 0

; 5905 : 			PfxPassword.cbData = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+904], 0

; 5906 : 		}
; 5907 : 		else

	jmp	SHORT $L209044
$L209047:

; 5908 : 		{
; 5909 : 			sizeM += 2; // BSTR size does not include the terminating null so add 2 to the size

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 2
	mov	DWORD PTR _sizeM$[ebp], eax

; 5910 : 			PfxPassword.pbData		= (unsigned char *) zMalloc(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+900], eax

; 5911 : 			memcpy(PfxPassword.pbData, ptr, sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+900]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5912 : 			PfxPassword.cbData = sizeM;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sizeM$[ebp]
	mov	DWORD PTR [ecx+904], edx
$L209044:

; 5913 : 		}
; 5914 : 	}
; 5915 : 
; 5916 : 	dwBytesToWrite	= base64encodeSize(fileSize);

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 5917 : 	
; 5918 : 	if (B64PfxDataPtr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+920], 0
	je	SHORT $L209050

; 5919 : 		zFree(B64PfxDataPtr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	push	eax
	call	_rFree
	add	esp, 4
$L209050:

; 5920 : 
; 5921 : 	B64PfxDataPtr = (unsigned char *)zMalloc (dwBytesToWrite+1);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+920], eax

; 5922 : 	
; 5923 : 	memset(B64PfxDataPtr,0,dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 5924 : 	dwBytesToWrite = base64encode(binFileData,fileSize, B64PfxDataPtr,dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+920]
	push	edx
	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 5925 : 
; 5926 : 	PfxCertDataBlob.cbData = fileSize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR [edx+928], eax

; 5927 : 	
; 5928 : 	if (PfxCertDataBlob.pbData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+924], 0
	je	SHORT $L209052

; 5929 : 		zFree(PfxCertDataBlob.pbData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+924]
	push	eax
	call	_rFree
	add	esp, 4
$L209052:

; 5930 : 	
; 5931 : 	PfxCertDataBlob.pbData = binFileData; // Remember to free this memory in Empty()

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _binFileData$[ebp]
	mov	DWORD PTR [ecx+924], edx

; 5932 : 
; 5933 : 	if (PfxX509Cert != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+916], 0
	je	SHORT $L209053

; 5934 : 		zFree(PfxX509Cert);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+916]
	push	edx
	call	_rFree
	add	esp, 4
$L209053:

; 5935 : 
; 5936 : 	if (PfxCertInfo != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+932], 0
	je	SHORT $L209054

; 5937 : 	{
; 5938 : 		// Since PfxX509Cert and PfxCertInfo->certificate point to the same memory location
; 5939 : 		// and we just freed PfxX509Cert above, we can't free PfxCertInfo->certificate as well
; 5940 : 		zFree(PfxCertInfo);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+932]
	push	edx
	call	_rFree
	add	esp, 4

; 5941 : 		PfxCertInfo = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+932], 0
$L209054:

; 5942 : 	}
; 5943 : #ifdef NSS
; 5944 : 	SECItem spwd;
; 5945 : 	spwd.data = PfxPassword.pbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	mov	DWORD PTR _spwd$[ebp+4], edx

; 5946 : 	spwd.len  = PfxPassword.cbData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+904]
	mov	DWORD PTR _spwd$[ebp+8], ecx

; 5947 : 	if (SwapUnicodeBytes(&spwd)!=0) {

	lea	edx, DWORD PTR _spwd$[ebp]
	push	edx
	call	?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z ; CSignature::SwapUnicodeBytes
	add	esp, 4
	test	eax, eax
	je	SHORT $L209056

; 5948 : 		ExitLog;
; 5949 : 		setError(SigHandle, PFX_BAD_PASSWORD);

	push	57					; 00000039H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 5950 : 		return S_FALSE;

	mov	DWORD PTR $T221449[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221449[ebp]
	jmp	$L209022
$L209056:

; 5951 : 	}
; 5952 : 
; 5953 : 	PfxX509Cert	= crPFX2X509(&PfxCertDataBlob, &spwd, &PfxCertInfo, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 932				; 000003a4H
	push	ecx
	lea	edx, DWORD PTR _spwd$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 924				; 0000039cH
	push	eax
	call	_crPFX2X509
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], eax

; 5954 : #else
; 5955 : 	PfxX509Cert	= crPFX2X509(&PfxCertDataBlob, (LPCWSTR) PfxPassword.pbData, &PfxCertInfo, SigHandle);
; 5956 : #endif
; 5957 : 
; 5958 : 	if (PfxX509Cert != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+916], 0
	je	SHORT $L209059

; 5959 : 	{
; 5960 : 		*pfxX509Cert	= A2WBSTR((LPCSTR) PfxX509Cert);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pfxX509Cert$[ebp]
	mov	DWORD PTR [edx], eax

; 5961 : 		CurrentCertificate = USE_PFX_CERT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -2			; fffffffeH

; 5962 : 	}
; 5963 : 	else

	jmp	SHORT $L209061
$L209059:

; 5964 : 	{
; 5965 : 		ExitLog;
; 5966 : 		setError(SigHandle, PFX_BAD_PASSWORD);

	push	57					; 00000039H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5967 : 		return S_FALSE;

	mov	DWORD PTR $T221450[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221450[ebp]
	jmp	SHORT $L209022
$L209061:

; 5968 : 	}
; 5969 : 
; 5970 : //	zFree(charPfxFileName);
; 5971 : 	ExitLog;
; 5972 : 	return S_OK;

	mov	DWORD PTR $T221451[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221451[ebp]
$L209022:

; 5973 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221461
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 124				; 0000007cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221461:
	DD	4
	DD	$L221460
$L221460:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221455
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221456
	DD	-80					; ffffffb0H
	DD	4
	DD	$L221457
	DD	-100					; ffffff9cH
	DD	12					; 0000000cH
	DD	$L221458
$L221458:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	0
$L221457:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221456:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221455:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221452:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221454
	jmp	___CxxFrameHandler
text$x	ENDS
?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::SetActivePFXFileCert
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.h
;	COMDAT ?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z
_TEXT	SEGMENT
_a$ = -5						; size = 1
_i$ = -4						; size = 4
_uniItem$ = 8						; size = 4
?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z PROC NEAR ; CSignature::SwapUnicodeBytes, COMDAT

; 411  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 412  : 		unsigned int i;
; 413  : 		unsigned char a;
; 414  : 		if((uniItem == NULL) || (uniItem->len % 2)) {

	cmp	DWORD PTR _uniItem$[ebp], 0
	je	SHORT $L203892
	mov	eax, DWORD PTR _uniItem$[ebp]
	mov	eax, DWORD PTR [eax+8]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $L203891
$L203892:

; 415  : 			return -1;

	or	eax, -1
	jmp	SHORT $L203888
$L203891:

; 416  : 		}
; 417  : 		for(i = 0; i < uniItem->len; i += 2) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L203893
$L203894:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 2
	mov	DWORD PTR _i$[ebp], edx
$L203893:
	mov	eax, DWORD PTR _uniItem$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $L203895

; 418  : 			a = uniItem->data[i];

	mov	edx, DWORD PTR _uniItem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _a$[ebp], dl

; 419  : 			uniItem->data[i] = uniItem->data[i+1];

	mov	eax, DWORD PTR _uniItem$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _uniItem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _i$[ebp]
	mov	esi, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [esi+ecx+1]
	mov	BYTE PTR [eax+edx], cl

; 420  : 			uniItem->data[i+1] = a;

	mov	edx, DWORD PTR _uniItem$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	dl, BYTE PTR _a$[ebp]
	mov	BYTE PTR [ecx+eax+1], dl

; 421  : 		}

	jmp	SHORT $L203894
$L203895:

; 422  : 		return 0;

	xor	eax, eax
$L203888:

; 423  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z ENDP	; CSignature::SwapUnicodeBytes
_TEXT	ENDS
PUBLIC	?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::PFXExportCertificate
EXTRN	_axExportCertificate:NEAR
xdata$x	SEGMENT
$T221486 DD	0ffffffffH
	DD	FLAT:$L221474
$T221476 DD	019930520H
	DD	01H
	DD	FLAT:$T221486
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T221473 = -664						; size = 4
$T221472 = -660						; size = 4
$T221471 = -656						; size = 4
$T221470 = -652						; size = 4
$T221469 = -648						; size = 4
$T221468 = -644						; size = 4
$T221467 = -640						; size = 4
_tmpFilePath$209112 = -632				; size = 4
_tmpCcBstr$ = -620					; size = 4
__lpa$ = -612						; size = 4
__lpw$ = -608						; size = 4
__acp$ = -604						; size = 4
__convert$ = -600					; size = 4
_pfxPassword$ = -596					; size = 4
_sizeM$ = -592						; size = 4
_szPtr$ = -588						; size = 4
_ptr$ = -584						; size = 4
_dwBytesWritten$ = -576					; size = 4
_hTempFile$ = -568					; size = 4
_TempName$ = -560					; size = 260
_TempPath$ = -292					; size = 260
_pPFXDataBlob$ = -28					; size = 4
_charStoreName$ = -24					; size = 4
_charCertId$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
_password$ = 16						; size = 4
_pfxFilePath$ = 20					; size = 4
?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::PFXExportCertificate

; 5976 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 652				; 0000028cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-664]
	mov	ecx, 163				; 000000a3H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5977 : 	unsigned char *charCertId, *charStoreName;
; 5978 : 	PDS_DATA_BLOB pPFXDataBlob;
; 5979 : 	char TempPath[MAX_PATH], TempName[MAX_PATH];
; 5980 : #ifdef WIN32
; 5981 : 	HANDLE hTempFile;
; 5982 : #else
; 5983 : 	FILE *hTempFile;
; 5984 : #endif
; 5985 : 	DWORD dwBytesWritten;
; 5986 : 	unsigned char *ptr;
; 5987 : 	unsigned int *szPtr;
; 5988 : 	unsigned int sizeM;
; 5989 : 	LPCWSTR pfxPassword=NULL;

	mov	DWORD PTR _pfxPassword$[ebp], 0

; 5990 : 
; 5991 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 5992 : 
; 5993 : 	CComBSTR	tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 5994 : 	EnterLog;
; 5995 : 	tmpCcBstr = certID;

	mov	eax, DWORD PTR _certID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 5996 : 	if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209088

; 5997 : 	{
; 5998 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 5999 : 		return S_FALSE;

	mov	DWORD PTR $T221467[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221467[ebp]
	jmp	$L209071
$L209088:

; 6000 : 	}
; 6001 : 	
; 6002 : 	charCertId = (unsigned char *)HeapW2A(certID);

	mov	eax, DWORD PTR _certID$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charCertId$[ebp], eax

; 6003 : 	charStoreName = (unsigned char *)HeapW2A(StoreName.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+696]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charStoreName$[ebp], eax

; 6004 : 
; 6005 : 	ptr = (unsigned char *)password;

	mov	eax, DWORD PTR _password$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 6006 : 
; 6007 : 	if (ptr != NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $L209094

; 6008 : 	{
; 6009 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 6010 : 		sizeM = *szPtr;

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sizeM$[ebp], eax

; 6011 : 
; 6012 : 		if (sizeM == 0)

	cmp	DWORD PTR _sizeM$[ebp], 0
	jne	SHORT $L209097

; 6013 : 			pfxPassword = NULL;

	mov	DWORD PTR _pfxPassword$[ebp], 0

; 6014 : 		else

	jmp	SHORT $L209094
$L209097:

; 6015 : 		{
; 6016 : 			sizeM += 2; // BSTR size does not include the terminating null so add 2 to the size

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 2
	mov	DWORD PTR _sizeM$[ebp], ecx

; 6017 : 			pfxPassword		= (LPCWSTR) zMalloc(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pfxPassword$[ebp], eax

; 6018 : 			memcpy((void *)pfxPassword, ptr, sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfxPassword$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L209094:

; 6019 : 		}
; 6020 : 	}
; 6021 : 
; 6022 : 
; 6023 : 	pPFXDataBlob = axExportCertificate(charStoreName, charCertId, pfxPassword, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _pfxPassword$[ebp]
	push	edx
	mov	eax, DWORD PTR _charCertId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charStoreName$[ebp]
	push	ecx
	call	_axExportCertificate
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pPFXDataBlob$[ebp], eax

; 6024 : 	
; 6025 : 	if (pfxPassword != NULL)

	cmp	DWORD PTR _pfxPassword$[ebp], 0
	je	SHORT $L209101

; 6026 : 		zFree((void *)pfxPassword);

	mov	edx, DWORD PTR _pfxPassword$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209101:

; 6027 : 	zFree(charCertId);

	mov	eax, DWORD PTR _charCertId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6028 : 	zFree(charStoreName);

	mov	ecx, DWORD PTR _charStoreName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6029 : 
; 6030 : 	if (pPFXDataBlob != NULL)

	cmp	DWORD PTR _pPFXDataBlob$[ebp], 0
	je	$L209103

; 6031 : 	{
; 6032 : 		// Create a temporary file. 
; 6033 : 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	edx, DWORD PTR _TempPath$[ebp]
	push	edx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6034 : 		GetTempFileName(TempPath, // dir. for temp. files 
; 6035 : 			"INFM",                // temp. file name prefix 
; 6036 : 			0,                    // create unique name 
; 6037 : 			TempName);          // buffer for name 

	mov	esi, esp
	lea	eax, DWORD PTR _TempName$[ebp]
	push	eax
	push	0
	push	OFFSET FLAT:$SG209105
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6038 : #ifdef WIN32
; 6039 : 		hTempFile = CreateFile((LPCSTR) TempName,  // file name 
; 6040 : 			GENERIC_READ | GENERIC_WRITE, // open for read/write 
; 6041 : 			0,                            // do not share 
; 6042 : 			NULL,                         // no security 
; 6043 : 			CREATE_ALWAYS,                // overwrite existing file
; 6044 : 			FILE_ATTRIBUTE_NORMAL,        // normal file 
; 6045 : 			NULL);                        // no attr. template 

	mov	esi, esp
	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	-1073741824				; c0000000H
	lea	edx, DWORD PTR _TempName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hTempFile$[ebp], eax

; 6046 : 		if (hTempFile == INVALID_HANDLE_VALUE) 

	cmp	DWORD PTR _hTempFile$[ebp], -1
	jne	SHORT $L209109

; 6047 : #else
; 6048 : 		hTempFile = fopen(TempName, "w+");
; 6049 : 		if (!hTempFile)
; 6050 : #endif
; 6051 : 		{ 
; 6052 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6053 : 			zFree(pPFXDataBlob->pbData);

	mov	edx, DWORD PTR _pPFXDataBlob$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4

; 6054 : 			zFree(pPFXDataBlob);

	mov	ecx, DWORD PTR _pPFXDataBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6055 : 			return S_FALSE;

	mov	DWORD PTR $T221468[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221468[ebp]
	jmp	$L209071
$L209109:

; 6056 : 		}
; 6057 :  
; 6058 : 		// Write the signature buffer to the temporary file. 
; 6059 : #ifdef WIN32
; 6060 : 		WriteFile(hTempFile, pPFXDataBlob->pbData, pPFXDataBlob->cbData, 
; 6061 : 				&dwBytesWritten, NULL);

	mov	esi, esp
	push	0
	lea	edx, DWORD PTR _dwBytesWritten$[ebp]
	push	edx
	mov	eax, DWORD PTR _pPFXDataBlob$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pPFXDataBlob$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _hTempFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6062 : 		// Close file. 
; 6063 :  		CloseHandle(hTempFile);

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6064 : #else
; 6065 : 		fwrite(pPFXDataBlob->pbData, 1, pPFXDataBlob->cbData, hTempFile);
; 6066 : 		fclose(hTempFile);
; 6067 : #endif
; 6068 : 		zFree(pPFXDataBlob->pbData);

	mov	eax, DWORD PTR _pPFXDataBlob$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4

; 6069 : 		zFree(pPFXDataBlob);

	mov	edx, DWORD PTR _pPFXDataBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6070 : 
; 6071 : 		*pfxFilePath = A2WBSTR(TempName);

	push	-1
	lea	eax, DWORD PTR _TempName$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pfxFilePath$[ebp]
	mov	DWORD PTR [ecx], eax

; 6072 : 
; 6073 : 		TEMP_FILE_INFO *tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221469[ebp], eax
	mov	edx, DWORD PTR $T221469[ebp]
	mov	DWORD PTR _tmpFilePath$209112[ebp], edx

; 6074 : 		strcpy((char *)tmpFilePath->fileName, TempName);

	lea	eax, DWORD PTR _TempName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$209112[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6075 : 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$209112[ebp]
	push	edx
	lea	eax, DWORD PTR $T221470[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T221471[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 6076 : 		ExitLog;
; 6077 : 		return S_OK;

	mov	DWORD PTR $T221472[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221472[ebp]
	jmp	SHORT $L209071
$L209103:

; 6078 : 	}
; 6079 : 	else
; 6080 : 		return S_FALSE;

	mov	DWORD PTR $T221473[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221473[ebp]
$L209071:

; 6081 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221485
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 664				; 00000298H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221485:
	DD	5
	DD	$L221484
$L221484:
	DD	-292					; fffffedcH
	DD	260					; 00000104H
	DD	$L221477
	DD	-560					; fffffdd0H
	DD	260					; 00000104H
	DD	$L221478
	DD	-576					; fffffdc0H
	DD	4
	DD	$L221479
	DD	-620					; fffffd94H
	DD	4
	DD	$L221480
	DD	-632					; fffffd88H
	DD	4
	DD	$L221481
$L221481:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221480:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221479:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	87					; 00000057H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221478:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221477:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221474:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221476
	jmp	___CxxFrameHandler
text$x	ENDS
?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::PFXExportCertificate
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
PUBLIC	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
PUBLIC	??0NtpServerResponse@@QAE@XZ			; NtpServerResponse::NtpServerResponse
PUBLIC	?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z	; CSignature::getSignerCertChain
EXTRN	_crComputeHash:NEAR
EXTRN	_crGetSignerCertChain:NEAR
EXTRN	_rfcTimeToSystem:NEAR
EXTRN	_systemTimeToJsUtcTime:NEAR
EXTRN	_systemTimeToVbNowTime:NEAR
EXTRN	_systemTimeToRfcTime:NEAR
EXTRN	_getSystemTimeAsRfcTime:NEAR
EXTRN	_xsCoreGenerateXMLSec:NEAR
EXTRN	_xsGenerateReference:NEAR
EXTRN	_xsGenerateObject:NEAR
EXTRN	_xsGenerateTransform:NEAR
EXTRN	_xsInitSignature:NEAR
EXTRN	_xsCoreAddX509Data:NEAR
EXTRN	_xsGetSignedInfo:NEAR
EXTRN	_xsSign:NEAR
EXTRN	_xsRemovePath:NEAR
EXTRN	_xsCoreSetSignatureMethod:NEAR
EXTRN	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z:NEAR ; crVerifyCertificate
EXTRN	_xsCoreAddKeyInfo:NEAR
EXTRN	_xsCoreAddX509Group:NEAR
EXTRN	_xsCoreSetX509Group:NEAR
EXTRN	__imp__WSAStartup@8:NEAR
EXTRN	__imp__WSACleanup@0:NEAR
EXTRN	??HCNtpTime@@QBE?AV0@ABN@Z:NEAR			; CNtpTime::operator+
EXTRN	??BCNtpTime@@QBE?AU_SYSTEMTIME@@XZ:NEAR		; CNtpTime::operator _SYSTEMTIME
EXTRN	?GetTickCount@CNtpTime@@SA?AV1@XZ:NEAR		; CNtpTime::GetTickCount
EXTRN	??0CSNTPClient@@QAE@XZ:NEAR			; CSNTPClient::CSNTPClient
EXTRN	?GetServerTime@CSNTPClient@@QAEHPBDAAUNtpServerResponse@@H@Z:NEAR ; CSNTPClient::GetServerTime
EXTRN	__imp__GetSystemTime@4:NEAR
xdata$x	SEGMENT
$T221531 DD	0ffffffffH
	DD	FLAT:$L221492
	DD	00H
	DD	FLAT:$L221494
	DD	0ffffffffH
	DD	FLAT:$L221495
	DD	02H
	DD	FLAT:$L221496
	DD	03H
	DD	FLAT:$L221497
	DD	0ffffffffH
	DD	FLAT:$L221498
	DD	0ffffffffH
	DD	FLAT:$L221499
$T221501 DD	019930520H
	DD	07H
	DD	FLAT:$T221531
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv1032 = -1240						; size = 4
tv988 = -1236						; size = 4
tv901 = -1232						; size = 4
tv820 = -1228						; size = 4
tv1862 = -1224						; size = 4
tv1861 = -1220						; size = 4
$T221491 = -1216					; size = 16
$T221490 = -1200					; size = 8
$T221489 = -1192					; size = 4
_pbData$209664 = -1188					; size = 4
_cbData$209663 = -1184					; size = 4
_srcSize$209662 = -1180					; size = 4
_sigalgtype$209616 = -1176				; size = 4
_dwKeyLen$209615 = -1172				; size = 4
_pbPublicKey$209614 = -1168				; size = 4
_dwSigLen$209613 = -1164				; size = 4
_pbSignature$209612 = -1160				; size = 4
_dwHashLen$209611 = -1152				; size = 4
_pbHash$209610 = -1144					; size = 4
_pcrBlob$209609 = -1140					; size = 4
_tmp$209588 = -1136					; size = 4
_cbDigest$209559 = -1128				; size = 4
_pbDigest$209558 = -1120				; size = 4
_objectBlob$209557 = -1112				; size = 8
_bstrCapturedSignatureFileName$209553 = -1100		; size = 4
_addComma$209520 = -1096				; size = 4
_verOptions$209516 = -1088				; size = 28
_propNameStr$209449 = -1052				; size = 28
_systemTime$209435 = -1020				; size = 4
_timeBuffer$209434 = -1016				; size = 4
_p$209423 = -1012					; size = 4
_index$209422 = -1008					; size = 4
_len$209420 = -1004					; size = 4
_tsSize$209415 = -996					; size = 4
_buf$209414 = -988					; size = 4
_freeTsUrl$209413 = -984				; size = 4
_tsUrl$209412 = -980					; size = 4
_propNameStr$209379 = -972				; size = 28
_timeBuffer$209366 = -940				; size = 4
_sntpTime$209363 = -932					; size = 16
_newTime$209362 = -908					; size = 8
_month$209359 = -892					; size = 28
_day$209358 = -856					; size = 28
_hostUrl$209355 = -824					; size = 4
_response$209354 = -816					; size = 56
_sntp$209353 = -752					; size = 28
_wVersionRequested$209345 = -720			; size = 2
_wsMinorVersion$209344 = -714				; size = 1
_wsMajorVersion$209343 = -713				; size = 1
_wsaData$209342 = -708					; size = 400
_bareFileName$209251 = -304				; size = 4
_wDocURI$209245 = -300					; size = 4
_crlData$209231 = -296					; size = 4
_crlData$209222 = -292					; size = 4
_s$209211 = -284					; size = 12
_tsSysTime$209204 = -264				; size = 16
_i$209197 = -244					; size = 4
_siPwd$209190 = -236					; size = 12
_pfxFilePath$209177 = -216				; size = 4
_certSerialNumber$209175 = -204				; size = 4
_pfxX509Cert$209174 = -192				; size = 4
_i$209166 = -184					; size = 4
_trAlgorithm$ = -180					; size = 4
_ptrs$ = -176						; size = 4
__lpa$ = -172						; size = 4
__lpw$ = -168						; size = 4
__acp$ = -164						; size = 4
__convert$ = -160					; size = 4
_bstrPropValue$ = -156					; size = 4
_bstrPropName$ = -152					; size = 4
_freeSigningCert$ = -148				; size = 4
_result$ = -144						; size = 4
_pref$ = -140						; size = 4
_varprop$ = -132					; size = 4
_cbDocument$ = -120					; size = 4
_pbDocument$ = -112					; size = 4
_cbData$ = -108						; size = 4
_pbData$ = -104						; size = 4
_iSigMethod$ = -100					; size = 4
_tmpUriPath$ = -96					; size = 4
_tmpUriArr$ = -92					; size = 4
_j$ = -88						; size = 4
_i$ = -84						; size = 4
_certificateListCount$ = -76				; size = 4
_certificateList$ = -68					; size = 4
_charInputFile$ = -64					; size = 4
_binFileData$ = -56					; size = 4
_fileSize$ = -44					; size = 4
_curX509Group$ = -36					; size = 4
_curX509Data$ = -32					; size = 4
_ki$ = -28						; size = 4
_signingCert$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_doc$ = 8						; size = 4
_sigId$ = 12						; size = 4
_signedXML$ = 16					; size = 4
_signedXmlSize$ = 20					; size = 4
?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z PROC NEAR ; CSignature::CreateSigFromTmplBlob
; _this$ = ecx

; 6097 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 1228				; 000004ccH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1240]
	mov	ecx, 307				; 00000133H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 6098 : 	unsigned char *signingCert=NULL;

	mov	DWORD PTR _signingCert$[ebp], 0

; 6099 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 6100 : 	x509data *curX509Data=NULL;

	mov	DWORD PTR _curX509Data$[ebp], 0

; 6101 : 	x509group *curX509Group=NULL;

	mov	DWORD PTR _curX509Group$[ebp], 0

; 6102 : 	DWORD fileSize;
; 6103 : 	unsigned char *binFileData=NULL;

	mov	DWORD PTR _binFileData$[ebp], 0

; 6104 : 	char *charInputFile=NULL;

	mov	DWORD PTR _charInputFile$[ebp], 0

; 6105 : 	BYTE **certificateList=NULL;

	mov	DWORD PTR _certificateList$[ebp], 0

; 6106 : 	UINT certificateListCount=0;

	mov	DWORD PTR _certificateListCount$[ebp], 0

; 6107 : 	UINT i,j;
; 6108 : 	PURI_PATH *tmpUriArr=NULL;

	mov	DWORD PTR _tmpUriArr$[ebp], 0

; 6109 : 	PURI_PATH tmpUriPath=NULL;

	mov	DWORD PTR _tmpUriPath$[ebp], 0

; 6110 : 	int iSigMethod=0;

	mov	DWORD PTR _iSigMethod$[ebp], 0

; 6111 : 
; 6112 : 	BYTE **pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 6113 : 	DWORD cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 6114 : 	BYTE *pbDocument=NULL;		// Object BLOB to sign

	mov	DWORD PTR _pbDocument$[ebp], 0

; 6115 : 	DWORD cbDocument=0;

	mov	DWORD PTR _cbDocument$[ebp], 0

; 6116 : 	char *varprop[1];
; 6117 : 	reference *pref=NULL;

	mov	DWORD PTR _pref$[ebp], 0

; 6118 : 	BOOL result;
; 6119 : 	BOOL freeSigningCert=FALSE;

	mov	DWORD PTR _freeSigningCert$[ebp], 0

; 6120 : 	BSTR bstrPropName, bstrPropValue;
; 6121 : 
; 6122 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 6123 : 	EnterLog;
; 6124 : 	memset(pout,0,MAX_PATH*2);

	push	520					; 00000208H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2284				; 000008ecH
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 6125 : 	memset(pout2,0,MAX_PATH*2);

	push	520					; 00000208H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6126 : 	st_transform *ptrs=NULL;

	mov	DWORD PTR _ptrs$[ebp], 0

; 6127 : 	XS_ALGORITHM trAlgorithm=0;

	mov	DWORD PTR _trAlgorithm$[ebp], 0

; 6128 : 
; 6129 : 	*signedXML = NULL;

	mov	edx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [edx], 0

; 6130 : 	/*
; 6131 : 	 * init Signature. crBlob contains XML - envelope document
; 6132 : 	 */
; 6133 : 
; 6134 : 	if (xsInitSignature(sigId, doc, SigHandle)!=TRUE) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	call	_xsInitSignature
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $L209160

; 6135 : 	{
; 6136 : 		return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209160:

; 6137 : 	}
; 6138 : //	DebugBreak();
; 6139 : 	if (UseHMAC != TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 1
	je	$L209161

; 6140 : 	{
; 6141 : 		if (calculateDigestOnly == FALSE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3408], 0
	jne	$L209162

; 6142 : 		{
; 6143 : 			if ((CurrentCertificate == NOT_INITIALIZED)	&& (CertificateCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], -1
	jne	$L209163
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	$L209163

; 6144 : 			{
; 6145 : #ifdef WIN32
; 6146 : 				signingCert = (unsigned char *)dlg->selectCertificate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1808]
	call	?selectCertificate@CShowSelectCert@@QAEPADXZ ; CShowSelectCert::selectCertificate
	mov	DWORD PTR _signingCert$[ebp], eax

; 6147 : #endif
; 6148 : 				if (signingCert != NULL)

	cmp	DWORD PTR _signingCert$[ebp], 0
	je	$L209165

; 6149 : 				{
; 6150 : 					for (int i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$209166[ebp], 0
	jmp	SHORT $L209167
$L209168:
	mov	eax, DWORD PTR _i$209166[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209166[ebp], eax
$L209167:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$209166[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	SHORT $L209169

; 6151 : 					{
; 6152 : 						if (!(StrCmp((const char *)cV[i]->certificate, (const char *)signingCert)))

	mov	esi, esp
	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$209166[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L209172

; 6153 : 						{
; 6154 : 							CurrentCertificate = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$209166[ebp]
	mov	DWORD PTR [eax+120], ecx

; 6155 : 							break;

	jmp	SHORT $L209169
$L209172:

; 6156 : 						}
; 6157 : 					}

	jmp	SHORT $L209168
$L209169:

; 6158 : #ifdef WIN32
; 6159 : 					if ((UsingNetscape) && (nsCertStoreObj != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 0
	je	$L209165
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3380], 0
	je	$L209165

; 6160 : 					{
; 6161 : //						DebugBreak();
; 6162 : 						BSTR pfxX509Cert;
; 6163 : 						CComBSTR certSerialNumber = (char *)cV[CurrentCertificate]->serialNumber;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [ecx+edx*4]
	push	edx
	lea	ecx, DWORD PTR _certSerialNumber$209175[ebp]
	call	??0CComBSTR@ATL@@QAE@PBD@Z		; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 6164 : 						_bstr_t pfxFilePath = nsCertStoreObj->ExportNetscapeCert(certSerialNumber.m_str);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T221489[ebp], esp
	mov	eax, DWORD PTR _certSerialNumber$209175[ebp]
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv1861[ebp], eax
	lea	ecx, DWORD PTR _pfxFilePath$209177[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3380]
	call	?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ; NetscapeCert::ICertStore::ExportNetscapeCert
	mov	DWORD PTR tv1862[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 6165 : 						SetActivePFXFileCert(pfxFilePath, nsStorePassword, &pfxX509Cert);

	mov	esi, esp
	lea	eax, DWORD PTR _pfxX509Cert$209174[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3384]
	push	edx
	lea	ecx, DWORD PTR _pfxFilePath$209177[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+304]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6166 : 						signingCert = B64PfxDataPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+920]
	mov	DWORD PTR _signingCert$[ebp], ecx

; 6167 : 						DeleteFile((LPCTSTR)(char *)pfxFilePath);

	lea	ecx, DWORD PTR _pfxFilePath$209177[ebp]
	call	??B_bstr_t@@QBEPADXZ			; _bstr_t::operator char *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6168 : 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pfxFilePath$209177[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _certSerialNumber$209175[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L209165:

; 6169 : #endif
; 6170 : 				}
; 6171 : 			}
; 6172 : 			else

	jmp	SHORT $L209182
$L209163:

; 6173 : 				if (CurrentCertificate == USE_PFX_CERT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -2			; fffffffeH
	jne	SHORT $L209183

; 6174 : 					signingCert = B64PfxDataPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+920]
	mov	DWORD PTR _signingCert$[ebp], ecx

; 6175 : 				else

	jmp	SHORT $L209182
$L209183:

; 6176 : 					if (CurrentCertificate == USE_BASE64_CERT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -3			; fffffffdH
	jne	SHORT $L209185

; 6177 : 					{
; 6178 : 						freeSigningCert = TRUE;

	mov	DWORD PTR _freeSigningCert$[ebp], 1

; 6179 : 						signingCert = (unsigned char *)HeapW2A(SignerCertificate.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _signingCert$[ebp], eax

; 6180 : 					}
; 6181 : 					else

	jmp	SHORT $L209182
$L209185:

; 6182 : 						if ((CurrentCertificate >= 0) && (cV != NULL) && (cV[CurrentCertificate] != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], 0
	jl	SHORT $L209182
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L209182
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L209182

; 6183 : 							signingCert = cV[CurrentCertificate]->certificate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+2048]
	mov	DWORD PTR _signingCert$[ebp], ecx
$L209182:

; 6184 : 
; 6185 : 			if (signingCert == NULL)

	cmp	DWORD PTR _signingCert$[ebp], 0
	jne	SHORT $L209189

; 6186 : 			{
; 6187 : 				setError(SigHandle, NO_CERTIFICATE);

	push	13					; 0000000dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 6188 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209189:

; 6189 : 			}
; 6190 : 			// We don't need the whole certificate chain if any of the following is true
; 6191 : 			// 1. Cam is being used and ExcludeSignerCertificate != 0
; 6192 : 			// 2. No certificate verification options other than VERIFY_CRL_REC are enabled and 
; 6193 : 			// ExcludeSignerCertificate != 0
; 6194 : 			//if (!(((useCam) && (ExcludeSignerCertificateFlag != 0)) ||
; 6195 : 			//	(!(CertVerifyParams.verificationOptions &= (~VERIFY_CRL_REC)) && (ExcludeSignerCertificateFlag != 0))))
; 6196 : 			//{
; 6197 : #ifdef NSS
; 6198 : 				SECItem siPwd;
; 6199 : 				siPwd.data = PfxPassword.pbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	mov	DWORD PTR _siPwd$209190[ebp+4], edx

; 6200 : 				siPwd.len  = PfxPassword.cbData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+904]
	mov	DWORD PTR _siPwd$209190[ebp+8], ecx

; 6201 : 
; 6202 : 				certificateList = crGetSignerCertChain(	signingCert,
; 6203 : 													&siPwd,
; 6204 : 													&certificateListCount,
; 6205 : 													SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _certificateListCount$[ebp]
	push	ecx
	lea	edx, DWORD PTR _siPwd$209190[ebp]
	push	edx
	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_crGetSignerCertChain
	add	esp, 16					; 00000010H
	mov	DWORD PTR _certificateList$[ebp], eax

; 6206 : #else
; 6207 : 				certificateList = crGetSignerCertChain(	signingCert,
; 6208 : 													(LPWSTR)PfxPassword.pbData,
; 6209 : 													&certificateListCount,
; 6210 : 													SigHandle);
; 6211 : #endif
; 6212 : 			//}
; 6213 : 			//else
; 6214 : 			//{
; 6215 : 			//	certificateList = (BYTE **)zMalloc(sizeof (BYTE *) * 1);
; 6216 : 			//	certificateList[0] = (BYTE *)zMalloc(strlen((const char *)signingCert) + 1);
; 6217 : 			//	strcpy((char *)certificateList[0], (const char *)signingCert);
; 6218 : 			//	certificateListCount = 1;
; 6219 : 			//}
; 6220 : 
; 6221 : 			if (certificateList == NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	jne	SHORT $L209191

; 6222 : 			{
; 6223 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209192

; 6224 : 					zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209192:

; 6225 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209191:

; 6226 : 			}
; 6227 : 		}
; 6228 : 		else

	jmp	SHORT $L209193
$L209162:

; 6229 : 		{// use the signer certificate chain set by a previous call to SetSignerCertChain method
; 6230 : 			certificateList = getSignerCertChain(&certificateListCount);

	lea	edx, DWORD PTR _certificateListCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z ; CSignature::getSignerCertChain
	mov	DWORD PTR _certificateList$[ebp], eax

; 6231 : 			if (certificateList != NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L209193

; 6232 : 				signingCert = certificateList[0];

	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _signingCert$[ebp], ecx
$L209193:

; 6233 : 		}
; 6234 : //DebugBreak();
; 6235 : 		if (certificateList != NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L209161

; 6236 : 		{
; 6237 : 			if ((CertVerifyParams.usedCrlCount != 0) &&
; 6238 : 				(CertVerifyParams.usedCrlList != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	$L209196
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1892], 0
	je	$L209196

; 6239 : 			{
; 6240 : 				for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$209197[ebp], 0
	jmp	SHORT $L209198
$L209199:
	mov	ecx, DWORD PTR _i$209197[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$209197[ebp], ecx
$L209198:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$209197[ebp]
	cmp	eax, DWORD PTR [edx+1888]
	jae	SHORT $L209200

; 6241 : 				{
; 6242 : 					if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$209197[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L209201

; 6243 : 						zFree(CertVerifyParams.usedCrlList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$209197[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L209201:

; 6244 : 				}

	jmp	SHORT $L209199
$L209200:

; 6245 : 				zFree(CertVerifyParams.usedCrlList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	push	eax
	call	_rFree
	add	esp, 4

; 6246 : 				CertVerifyParams.usedCrlList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1892], 0

; 6247 : 				CertVerifyParams.usedCrlCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1888], 0
$L209196:

; 6248 : 			}
; 6249 : 
; 6250 : 			if (((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) || (useCam) || (useOcsp)) &&
; 6251 : 				(certificateList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	jne	SHORT $L209203
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	jne	SHORT $L209203
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 0
	je	$L209202
$L209203:
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L209202

; 6252 : 			{
; 6253 : 				SYSTEMTIME	tsSysTime;
; 6254 : #ifdef WIN32
; 6255 : 				GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	ecx, DWORD PTR _tsSysTime$209204[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6256 : #else
; 6257 : 				GetSystemTimeLinux(&tsSysTime);
; 6258 : #endif
; 6259 : 				if (useCam)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	SHORT $L209205

; 6260 : 					result = crVerifyCertificateUsingCam(certificateList,
; 6261 : 										certificateListCount,
; 6262 : 										&tsSysTime, 
; 6263 : 										(LPWSTR)PfxPassword.pbData, 
; 6264 : 										&CertVerifyParams,
; 6265 : 										SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$209204[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 6266 : 				else

	jmp	$L209207
$L209205:

; 6267 : 					if (useOcsp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	je	SHORT $L209208

; 6268 : 						result = crVerifyCertificateUsingOcsp(certificateList,
; 6269 : 											certificateListCount,
; 6270 : 											&tsSysTime, 
; 6271 : 											(LPWSTR)PfxPassword.pbData, 
; 6272 : 											&CertVerifyParams,
; 6273 : 											SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$209204[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 6274 : 					else {

	jmp	SHORT $L209207
$L209208:

; 6275 : #ifdef NSS
; 6276 : 						SECItem s;
; 6277 : 						s.data = PfxPassword.pbData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+900]
	mov	DWORD PTR _s$209211[ebp+4], eax

; 6278 : 						s.len  = PfxPassword.cbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	DWORD PTR _s$209211[ebp+8], edx

; 6279 : 						result = crVerifyCertificate(certificateList,
; 6280 : 											certificateListCount,
; 6281 : 											&tsSysTime, 
; 6282 : 											&s, 
; 6283 : 											&CertVerifyParams,
; 6284 : 											SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	lea	eax, DWORD PTR _s$209211[ebp]
	push	eax
	lea	ecx, DWORD PTR _tsSysTime$209204[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateListCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L209207:

; 6285 : #else
; 6286 : 						result = crVerifyCertificate(certificateList,
; 6287 : 											certificateListCount,
; 6288 : 											&tsSysTime, 
; 6289 : 											(LPWSTR)PfxPassword.pbData, 
; 6290 : 											&CertVerifyParams,
; 6291 : 											SigHandle);
; 6292 : #endif
; 6293 : 					}
; 6294 : 				if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L209202

; 6295 : 				{
; 6296 : 					for (i=0; i < certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209213
$L209214:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L209213:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209215

; 6297 : 					{
; 6298 : 						zFree(certificateList[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 6299 : 					}

	jmp	SHORT $L209214
$L209215:

; 6300 : 					zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6301 : 					if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209216

; 6302 : 						zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209216:

; 6303 : 					return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209202:

; 6304 : 				}
; 6305 : 			}
; 6306 : 
; 6307 : 			/*
; 6308 : 			* set <X509Data> certificate
; 6309 : 			*/
; 6310 : 			if (ExcludeSignerCertificateFlag != 1)// Either include the whole chain or just the end certificate

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1820], 1
	je	$L209161

; 6311 : 			{
; 6312 : 
; 6313 : 				ki = xsCoreAddKeyInfo(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_xsCoreAddKeyInfo
	add	esp, 4
	mov	DWORD PTR _ki$[ebp], eax

; 6314 : 				curX509Data = xsCoreAddX509Data(ki, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _ki$[ebp]
	push	ecx
	call	_xsCoreAddX509Data
	add	esp, 8
	mov	DWORD PTR _curX509Data$[ebp], eax

; 6315 : 
; 6316 : 				if (ExcludeSignerCertificateFlag == 0)// Include the whole chain of certificates

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1820], 0
	jne	$L209218

; 6317 : 				{
; 6318 : 					for (i=0; i < certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209219
$L209220:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L209219:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	$L209218

; 6319 : 					{
; 6320 : 						char *crlData = NULL;

	mov	DWORD PTR _crlData$209222[ebp], 0

; 6321 : 
; 6322 : 						curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _curX509Data$[ebp]
	push	ecx
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 6323 : 						if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2192], 1
	jne	SHORT $L209223
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1888], 0
	je	SHORT $L209223

; 6324 : 						{
; 6325 : 							crlData = CertVerifyParams.usedCrlList[i];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _crlData$209222[ebp], ecx
$L209223:

; 6326 : 						}
; 6327 : 
; 6328 : 						if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[i],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _crlData$209222[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _curX509Group$[ebp]
	push	edx
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	SHORT $L209225

; 6329 : 						{
; 6330 : 							for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209226
$L209227:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209226:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209228

; 6331 : 							{
; 6332 : 								zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 6333 : 							}

	jmp	SHORT $L209227
$L209228:

; 6334 : 							zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6335 : 							if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209229

; 6336 : 								zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209229:

; 6337 : 							return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209225:

; 6338 : 						}
; 6339 : 					}

	jmp	$L209220
$L209218:

; 6340 : 				}
; 6341 : 				if (ExcludeSignerCertificateFlag == 2) //Just include the signer end certificate

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1820], 2
	jne	$L209161

; 6342 : 				{
; 6343 : 					char *crlData = NULL;

	mov	DWORD PTR _crlData$209231[ebp], 0

; 6344 : 					curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _curX509Data$[ebp]
	push	ecx
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 6345 : 					if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2192], 1
	jne	SHORT $L209232
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1888], 0
	je	SHORT $L209232

; 6346 : 					{
; 6347 : 						crlData = CertVerifyParams.usedCrlList[0];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _crlData$209231[ebp], eax
$L209232:

; 6348 : 					}
; 6349 : 					if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[0],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _crlData$209231[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _curX509Group$[ebp]
	push	eax
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	SHORT $L209161

; 6350 : 					{
; 6351 : 						for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209235
$L209236:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L209235:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209237

; 6352 : 						{
; 6353 : 							zFree(certificateList[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 6354 : 						}

	jmp	SHORT $L209236
$L209237:

; 6355 : 						zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6356 : 						if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209238

; 6357 : 							zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209238:

; 6358 : 						return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209161:

; 6359 : 					}
; 6360 : 				}
; 6361 : 			} // ExcludeSignerCertificateFlag != 1
; 6362 : 		}
; 6363 : 	}
; 6364 : 
; 6365 : 	if (EnvelopingFlag == DETACHED) {

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+688]
	test	eax, eax
	jne	$L209239

; 6366 : 		// prepare URI array, one element
; 6367 : 		tmpUriArr = (PURI_PATH *)zMalloc(sizeof(PURI_PATH));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmpUriArr$[ebp], eax

; 6368 : 		tmpUriPath = (PURI_PATH) zMalloc(sizeof(URI_PATH));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmpUriPath$[ebp], eax

; 6369 : 		tmpUriPath->fullPath = (unsigned char *)zMalloc(MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 6370 : 		char *wDocURI = (char *)HeapW2A(DocumentURI.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+680]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wDocURI$209245[ebp], eax

; 6371 : 		strcpy((char *)tmpUriPath->fullPath, wDocURI);

	mov	ecx, DWORD PTR _wDocURI$209245[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpUriPath$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcpy
	add	esp, 8

; 6372 : 		zFree(wDocURI);

	mov	ecx, DWORD PTR _wDocURI$209245[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6373 : 		tmpUriPath->sigId = (unsigned char *)zMalloc(MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [edx], eax

; 6374 : 		strcpy((char *)tmpUriPath->sigId,sigId);

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 6375 : 		tmpUriPath->URI = (unsigned char *)zMalloc (MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 6376 : 		unsigned char *bareFileName = xsRemoveBstrPath(DocumentURI.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+680]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z ; CSignature::xsRemoveBstrPath
	mov	DWORD PTR _bareFileName$209251[ebp], eax

; 6377 : 		strcpy((char *)tmpUriPath->URI,(const char *)bareFileName);

	mov	ecx, DWORD PTR _bareFileName$209251[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpUriPath$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8

; 6378 : 		tmpUriArr[0] = tmpUriPath;

	mov	ecx, DWORD PTR _tmpUriArr$[ebp]
	mov	edx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [ecx], edx

; 6379 : 
; 6380 : 		// set global structures
; 6381 : 		SigHandle->locArray = tmpUriArr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR _tmpUriArr$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 6382 : 		SigHandle->locNumber = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	DWORD PTR [ecx+16], 1

; 6383 : 		sprintf (pout,"REF_Detached_%s",SigHandle->sig->param_id);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 2048				; 00000800H
	push	ecx
	push	OFFSET FLAT:$SG209254
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2284				; 000008ecH
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 6384 : 		if ((xsGenerateReference(pout,IFM_SHA1,NULL, (const char *)bareFileName,SigHandle))==NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _bareFileName$209251[ebp]
	push	edx
	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2284				; 000008ecH
	push	eax
	call	_xsGenerateReference
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L209256

; 6385 : 		{ 
; 6386 : 			for (i=0; i < certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209257
$L209258:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L209257:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209259

; 6387 : 			{
; 6388 : 				zFree(certificateList[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 6389 : 			}

	jmp	SHORT $L209258
$L209259:

; 6390 : 			zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6391 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209260

; 6392 : 				zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209260:

; 6393 : 			zFree(bareFileName);

	mov	edx, DWORD PTR _bareFileName$209251[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6394 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209256:

; 6395 : 		}
; 6396 : 		zFree(bareFileName);

	mov	eax, DWORD PTR _bareFileName$209251[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209239:

; 6397 : }
; 6398 : 	if (DetachedObjectCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	$L209261

; 6399 : 	{
; 6400 : 		// prepare URI array, DetachedObjectCount elements
; 6401 : 		tmpUriArr = (PURI_PATH *)zMalloc(sizeof(PURI_PATH) * DetachedObjectCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+72]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmpUriArr$[ebp], eax

; 6402 : 
; 6403 : 		for (i=0; i < DetachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209264
$L209265:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L209264:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jae	$L209266

; 6404 : 		{
; 6405 : 			tmpUriPath = (PURI_PATH) zMalloc(sizeof(URI_PATH));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmpUriPath$[ebp], eax

; 6406 : 			tmpUriPath->fullPath = (unsigned char *)zMalloc(MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 6407 : 			strcpy((char *)tmpUriPath->fullPath,(const char *)DetachedObjectList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _tmpUriPath$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6408 : 			tmpUriPath->sigId = (unsigned char *) zMalloc(MAX_PATH);

	push	260					; 00000104H
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [edx], eax

; 6409 : 			strcpy((char *)tmpUriPath->sigId,sigId);

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 6410 : 			tmpUriPath->URI = (unsigned char *) zMalloc (MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 6411 : 			strcpy((char *)tmpUriPath->URI,xsRemovePath((const char *)DetachedObjectList[i]));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xsRemovePath
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _tmpUriPath$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6412 : 			tmpUriArr[i] = tmpUriPath;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _tmpUriArr$[ebp]
	mov	ecx, DWORD PTR _tmpUriPath$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 6413 : 		}

	jmp	$L209265
$L209266:

; 6414 : 		// set global structures
; 6415 : 		SigHandle->locArray = tmpUriArr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _tmpUriArr$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6416 : 		SigHandle->locNumber = DetachedObjectCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+16], edx

; 6417 : 		for (i=0; i < DetachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209277
$L209278:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L209277:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+72]
	jae	$L209261

; 6418 : 		{
; 6419 : 			sprintf (pout,"REF_Detached_%s_%d",SigHandle->sig->param_id, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 2048				; 00000800H
	push	eax
	push	OFFSET FLAT:$SG209280
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6420 : 			if ((xsGenerateReference(pout,IFM_SHA1,NULL, xsRemovePath((const char *)DetachedObjectList[i]),SigHandle))==NULL) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_xsRemovePath
	add	esp, 4
	push	eax
	push	0
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2284				; 000008ecH
	push	edx
	call	_xsGenerateReference
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L209282

; 6421 : 			{ 
; 6422 : 				for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209283
$L209284:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209283:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209285

; 6423 : 				{
; 6424 : 					zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 6425 : 				}

	jmp	SHORT $L209284
$L209285:

; 6426 : 				zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6427 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209286

; 6428 : 					zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209286:

; 6429 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209282:

; 6430 : 			}
; 6431 : 		}

	jmp	$L209278
$L209261:

; 6432 : 	}
; 6433 : 	if (AttachedObjectCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	$L209287

; 6434 : 	{
; 6435 : 		pbData = (BYTE **)zMalloc(sizeof(BYTE *) * AttachedObjectCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax

; 6436 : 		if (pbData == NULL)

	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L209290

; 6437 : 		{
; 6438 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 6439 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209291
$L209292:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209291:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209293

; 6440 : 			{
; 6441 : 				zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 6442 : 			}

	jmp	SHORT $L209292
$L209293:

; 6443 : 			zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6444 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209294

; 6445 : 				zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209294:

; 6446 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209290:

; 6447 : 		}
; 6448 : 		memset(pbData, 0, sizeof(BYTE *) * AttachedObjectCount);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$L209287:

; 6449 : 	}
; 6450 : 	for (i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209296
$L209297:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L209296:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+80]
	jae	$L209298

; 6451 : 	{
; 6452 : 		if ((pbDocument = xsDereferenceBstrURI(
; 6453 : 			AttachedObjectList[i],
; 6454 : 			&cbDocument))==NULL) {		// (in/out) size of data

	lea	ecx, DWORD PTR _cbDocument$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	DWORD PTR _pbDocument$[ebp], eax
	cmp	DWORD PTR _pbDocument$[ebp], 0
	jne	SHORT $L209299

; 6455 : 				setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6456 : 				for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209300
$L209301:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209300:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209302

; 6457 : 				{
; 6458 : 					zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6459 : 				}

	jmp	SHORT $L209301
$L209302:

; 6460 : 				zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6461 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209303

; 6462 : 					zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209303:

; 6463 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209299:

; 6464 : 			}
; 6465 : 		// Base64 encode
; 6466 : 		cbData = base64encodeSize(cbDocument);

	mov	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 6467 : 		// allocate memory
; 6468 : 		if (pbData[i]) zFree (pbData[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L209304
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4
$L209304:

; 6469 : 		pbData[i] = NULL;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbData$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 6470 : 		if(!(pbData[i] = (BYTE *)zMalloc(cbData+1)))

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbData$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L209306

; 6471 : 		{
; 6472 : 			zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6473 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6474 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209307
$L209308:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209307:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209309

; 6475 : 			{
; 6476 : 				zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6477 : 			}

	jmp	SHORT $L209308
$L209309:

; 6478 : 			zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6479 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209310

; 6480 : 				zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209310:

; 6481 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209306:

; 6482 : 		}
; 6483 : 		if (base64encode(pbDocument,cbDocument,(unsigned char*)pbData[i],cbData)==-1) 

	mov	eax, DWORD PTR _cbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _cbDocument$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	$L209312

; 6484 : 		{
; 6485 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6486 : 			zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6487 : 			zFree(pbData[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pbData$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 6488 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209313
$L209314:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209313:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209315

; 6489 : 			{
; 6490 : 				zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 6491 : 			}

	jmp	SHORT $L209314
$L209315:

; 6492 : 			zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6493 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209316

; 6494 : 				zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209316:

; 6495 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209312:

; 6496 : 		}
; 6497 : 		*(pbData[i]+cbData)='\0';

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 6498 : 		zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6499 : 		sprintf (	pout2,
; 6500 : 					"OBJECT_%s_%d",
; 6501 : 					SigHandle->sig->param_id, 
; 6502 : 					i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 2048				; 00000800H
	push	eax
	push	OFFSET FLAT:$SG209317
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6503 : 		varprop[0] = NULL;

	mov	DWORD PTR _varprop$[ebp], 0

; 6504 : 		varprop[0] = (char *)zMalloc(MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _varprop$[ebp], eax

; 6505 : 		memset(varprop[0],0,MAX_PATH*2);

	push	520					; 00000208H
	push	0
	mov	edx, DWORD PTR _varprop$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 6506 : //		sprintf(varprop[0],"URI_%s=%s",pout2,xsRemovePath((const char *)AttachedObjectList[i]));
; 6507 : 		sprintf(varprop[0], "URI_%s",pout2);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2804				; 00000af4H
	push	eax
	push	OFFSET FLAT:$SG209319
	mov	ecx, DWORD PTR _varprop$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 6508 : 		bstrPropName = A2WBSTR((LPCSTR)varprop[0]);

	push	-1
	mov	edx, DWORD PTR _varprop$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6509 : 		bstrPropValue = A2WBSTR((LPCSTR)xsRemovePath((const char *)AttachedObjectList[i]));

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_xsRemovePath
	add	esp, 4
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6510 : 		ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6511 : 		SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6512 : 		SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6513 : //		if ((xsGenerateObject(pout2,(const char *)pbData[i],(const char**)varprop,1,SigHandle))==NULL)
; 6514 : 		if ((xsGenerateObject(pout2,(const char *)pbData[i],(const char**)NULL,0,SigHandle))==NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_xsGenerateObject
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$L209325

; 6515 : 		{
; 6516 : 			if (varprop[0]) zFree(varprop[0]);

	cmp	DWORD PTR _varprop$[ebp], 0
	je	SHORT $L209326
	mov	edx, DWORD PTR _varprop$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209326:

; 6517 : 			setError(SigHandle, XMLSIGLIB_ERROR);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6518 : 			zFree(pbData[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbData$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 6519 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209327
$L209328:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209327:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209329

; 6520 : 			{
; 6521 : 				zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6522 : 			}

	jmp	SHORT $L209328
$L209329:

; 6523 : 			zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6524 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209330

; 6525 : 				zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209330:

; 6526 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209325:

; 6527 : 		}
; 6528 : 		if (varprop[0]) zFree(varprop[0]);

	cmp	DWORD PTR _varprop$[ebp], 0
	je	SHORT $L209331
	mov	eax, DWORD PTR _varprop$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209331:

; 6529 : 		varprop[0] = NULL;

	mov	DWORD PTR _varprop$[ebp], 0

; 6530 : 		sprintf (pout,"REF_Attached_%s_%d",SigHandle->sig->param_id, i);

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 2048				; 00000800H
	push	ecx
	push	OFFSET FLAT:$SG209332
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2284				; 000008ecH
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6531 : 		sprintf (pout2,"#OBJECT_%s_%d",SigHandle->sig->param_id, i);

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 2048				; 00000800H
	push	eax
	push	OFFSET FLAT:$SG209333
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6532 : 		if ((pref = xsGenerateReference(pout,IFM_SHA1,NULL,pout2, SigHandle))==NULL) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	push	0
	push	1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2284				; 000008ecH
	push	edx
	call	_xsGenerateReference
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pref$[ebp], eax
	cmp	DWORD PTR _pref$[ebp], 0
	jne	SHORT $L209334

; 6533 : 		{
; 6534 : 			setError(SigHandle, XMLSIGLIB_ERROR);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6535 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209335
$L209336:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209335:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209337

; 6536 : 			{
; 6537 : 				zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6538 : 			}

	jmp	SHORT $L209336
$L209337:

; 6539 : 			zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6540 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209338

; 6541 : 				zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209338:

; 6542 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209334:

; 6543 : 		}
; 6544 : 		if (xsGenerateTransform(BASE64,pref, SigHandle)==NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _pref$[ebp]
	push	edx
	push	2
	call	_xsGenerateTransform
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L209339

; 6545 : 		{
; 6546 : 			setError(SigHandle, XMLSIGLIB_ERROR);

	push	5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6547 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209339:

; 6548 : 		}
; 6549 : 	}

	jmp	$L209297
$L209298:

; 6550 : 
; 6551 : 	if (TimeStampOption)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+940], 0
	je	$L209340

; 6552 : 	{
; 6553 : 		if (TimeStampOption == TIME_SNTP_RFC_1305_SRVR)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+940], 2
	jne	$L209341

; 6554 : 		{
; 6555 : 			DebugLog("TimeStampOption == TIME_SNTP_RFC_1305_SRVR");
; 6556 : 			//Initialise the winsock stack
; 6557 : 			WSADATA wsaData;
; 6558 : 			BYTE wsMajorVersion = 1;

	mov	BYTE PTR _wsMajorVersion$209343[ebp], 1

; 6559 : 			BYTE wsMinorVersion = 1;

	mov	BYTE PTR _wsMinorVersion$209344[ebp], 1

; 6560 : 			WORD wVersionRequested = MAKEWORD(wsMinorVersion, wsMajorVersion);   

	movzx	ecx, BYTE PTR _wsMinorVersion$209344[ebp]
	and	ecx, 255				; 000000ffH
	movzx	edx, cl
	movzx	eax, BYTE PTR _wsMajorVersion$209343[ebp]
	and	eax, 255				; 000000ffH
	movzx	ecx, al
	shl	ecx, 8
	or	edx, ecx
	mov	WORD PTR _wVersionRequested$209345[ebp], dx

; 6561 : 			if (WSAStartup(wVersionRequested, &wsaData) == 0) 

	mov	esi, esp
	lea	edx, DWORD PTR _wsaData$209342[ebp]
	push	edx
	mov	ax, WORD PTR _wVersionRequested$209345[ebp]
	push	eax
	call	DWORD PTR __imp__WSAStartup@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L209352

; 6562 : 			{
; 6563 : 				DebugLog("WSAStartup successful. Initializing CSNTPClient object");
; 6564 : 				//Do the actual NTP Query
; 6565 : 				CSNTPClient sntp;

	lea	ecx, DWORD PTR _sntp$209353[ebp]
	call	??0CSNTPClient@@QAE@XZ			; CSNTPClient::CSNTPClient

; 6566 : 				NtpServerResponse response;

	lea	ecx, DWORD PTR _response$209354[ebp]
	call	??0NtpServerResponse@@QAE@XZ

; 6567 : 				unsigned char *hostUrl = HeapW2A(TimeStampURL.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+936]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _hostUrl$209355[ebp], eax

; 6568 : 				if (sntp.GetServerTime((LPCTSTR)hostUrl, response))

	push	123					; 0000007bH
	lea	eax, DWORD PTR _response$209354[ebp]
	push	eax
	mov	ecx, DWORD PTR _hostUrl$209355[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sntp$209353[ebp]
	call	?GetServerTime@CSNTPClient@@QAEHPBDAAUNtpServerResponse@@H@Z ; CSNTPClient::GetServerTime
	test	eax, eax
	je	$L209357

; 6569 : 				{
; 6570 : 					DebugLog("sntp.GetServerTime() returned non-zero response");
; 6571 : 					string day, month;

	lea	ecx, DWORD PTR _day$209358[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _month$209359[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 6572 : 					CNtpTime newTime(CNtpTime::GetCurrentTime() + response.m_LocalClockOffset);

	lea	edx, DWORD PTR _response$209354[ebp+48]
	push	edx
	lea	eax, DWORD PTR _newTime$209362[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221490[ebp]
	push	ecx
	call	?GetTickCount@CNtpTime@@SA?AV1@XZ	; CNtpTime::GetTickCount
	add	esp, 4
	mov	ecx, eax
	call	??HCNtpTime@@QBE?AV0@ABN@Z		; CNtpTime::operator+

; 6573 : 					SYSTEMTIME sntpTime = newTime;

	lea	edx, DWORD PTR $T221491[ebp]
	push	edx
	lea	ecx, DWORD PTR _newTime$209362[ebp]
	call	??BCNtpTime@@QBE?AU_SYSTEMTIME@@XZ	; CNtpTime::operator _SYSTEMTIME
	mov	eax, DWORD PTR $T221491[ebp]
	mov	DWORD PTR _sntpTime$209363[ebp], eax
	mov	ecx, DWORD PTR $T221491[ebp+4]
	mov	DWORD PTR _sntpTime$209363[ebp+4], ecx
	mov	edx, DWORD PTR $T221491[ebp+8]
	mov	DWORD PTR _sntpTime$209363[ebp+8], edx
	mov	eax, DWORD PTR $T221491[ebp+12]
	mov	DWORD PTR _sntpTime$209363[ebp+12], eax

; 6574 : 					char *timeBuffer=NULL;

	mov	DWORD PTR _timeBuffer$209366[ebp], 0

; 6575 : 					switch (TimeStampFormat)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+944]
	mov	DWORD PTR tv820[ebp], edx
	cmp	DWORD PTR tv820[ebp], 0
	je	SHORT $L209371
	cmp	DWORD PTR tv820[ebp], 1
	je	SHORT $L209373
	cmp	DWORD PTR tv820[ebp], 2
	je	$L209375
	jmp	$L209377
$L209371:

; 6576 : 					{
; 6577 : 						case TIME_RFC:
; 6578 : 							timeBuffer = systemTimeToRfcTime(sntpTime);

	lea	eax, DWORD PTR _sntpTime$209363[ebp]
	push	eax
	call	_systemTimeToRfcTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209366[ebp], eax

; 6579 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	ecx, DWORD PTR _timeBuffer$209366[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6580 : 							zFree(timeBuffer);

	mov	edx, DWORD PTR _timeBuffer$209366[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6581 : 							break;

	jmp	$L209368
$L209373:

; 6582 : 						case TIME_VB_NOW:
; 6583 : 							timeBuffer = systemTimeToVbNowTime(sntpTime);

	lea	eax, DWORD PTR _sntpTime$209363[ebp]
	push	eax
	call	_systemTimeToVbNowTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209366[ebp], eax

; 6584 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	ecx, DWORD PTR _timeBuffer$209366[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6585 : 							zFree(timeBuffer);

	mov	edx, DWORD PTR _timeBuffer$209366[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6586 : 							break;

	jmp	SHORT $L209368
$L209375:

; 6587 : 						case TIME_JS_UTC:
; 6588 : //							showSystemTime(&sntpTime);
; 6589 : 							timeBuffer = systemTimeToJsUtcTime(sntpTime);

	lea	eax, DWORD PTR _sntpTime$209363[ebp]
	push	eax
	call	_systemTimeToJsUtcTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209366[ebp], eax

; 6590 : //							MessageBox(NULL, (LPCTSTR)timeBuffer, "CreateSigFromTmplBlob", MB_OK);
; 6591 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	ecx, DWORD PTR _timeBuffer$209366[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6592 : 							zFree(timeBuffer);

	mov	edx, DWORD PTR _timeBuffer$209366[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6593 : 							break;

	jmp	SHORT $L209368
$L209377:

; 6594 : 						default:
; 6595 : 							timeBuffer = systemTimeToRfcTime(sntpTime);

	lea	eax, DWORD PTR _sntpTime$209363[ebp]
	push	eax
	call	_systemTimeToRfcTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209366[ebp], eax

; 6596 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	ecx, DWORD PTR _timeBuffer$209366[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6597 : 							zFree(timeBuffer);

	mov	edx, DWORD PTR _timeBuffer$209366[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209368:

; 6598 : 					}
; 6599 : 					string propNameStr = TIME_STAMP_PREFIX;

	push	OFFSET FLAT:$SG209380
	lea	ecx, DWORD PTR _propNameStr$209379[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 6600 : 					propNameStr += sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _propNameStr$209379[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6601 : 					bstrPropName = A2WBSTR((LPCSTR)propNameStr.c_str());

	push	-1
	lea	ecx, DWORD PTR _propNameStr$209379[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6602 : 					DebugLog(propNameStr.c_str());
; 6603 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6604 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6605 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6606 : 					//Don't forget to release out use of the winsock stack
; 6607 : 					WSACleanup();

	mov	esi, esp
	call	DWORD PTR __imp__WSACleanup@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6608 : 					bstrPropName = SysAllocString((const OLECHAR *)TIME_STAMP_FORMAT);

	mov	esi, esp
	push	OFFSET FLAT:$SG209383
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6609 : 					switch (TimeStampFormat)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	mov	DWORD PTR tv901[ebp], eax
	cmp	DWORD PTR tv901[ebp], 0
	je	SHORT $L209388
	cmp	DWORD PTR tv901[ebp], 1
	je	SHORT $L209390
	cmp	DWORD PTR tv901[ebp], 2
	je	SHORT $L209392
	jmp	SHORT $L209394
$L209388:

; 6610 : 					{
; 6611 : 						case TIME_RFC:
; 6612 : 							bstrPropValue = SysAllocString(L"0");

	mov	esi, esp
	push	OFFSET FLAT:$SG209389
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6613 : 							break;

	jmp	SHORT $L209385
$L209390:

; 6614 : 						case TIME_VB_NOW:
; 6615 : 							bstrPropValue = SysAllocString(L"1");

	mov	esi, esp
	push	OFFSET FLAT:$SG209391
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6616 : 							break;

	jmp	SHORT $L209385
$L209392:

; 6617 : 						case TIME_JS_UTC:
; 6618 : 							bstrPropValue = SysAllocString(L"2");

	mov	esi, esp
	push	OFFSET FLAT:$SG209393
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6619 : 							break;

	jmp	SHORT $L209385
$L209394:

; 6620 : 						default:
; 6621 : 							bstrPropValue = SysAllocString(L"0");

	mov	esi, esp
	push	OFFSET FLAT:$SG209395
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax
$L209385:

; 6622 : 					}
; 6623 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6624 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6625 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6626 : 					bstrPropName = A2WBSTR((LPCSTR)"TimeStampURL");

	push	-1
	push	OFFSET FLAT:$SG209397
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6627 : 					bstrPropValue = TimeStampURL.m_str;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6628 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6629 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6630 : 					bstrPropName = SysAllocString((const OLECHAR *)TIME_STAMP_PROTOCOL);

	mov	esi, esp
	push	OFFSET FLAT:$SG209399
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6631 : 					bstrPropValue = SysAllocString((const OLECHAR *)TIME_SNTP_RFC_1305_PROTOCOL);

	mov	esi, esp
	push	OFFSET FLAT:$SG209401
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6632 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6633 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6634 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6635 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _propNameStr$209379[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _month$209359[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _day$209358[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 6636 : 				else

	jmp	$L209402
$L209357:

; 6637 : 				{
; 6638 : 					DebugLog("sntp.GetServerTime() failed. Returned zero as response.");
; 6639 : 					//Don't forget to release out use of the winsock stack
; 6640 : 					WSACleanup();

	mov	esi, esp
	call	DWORD PTR __imp__WSACleanup@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6641 : 					setError(SigHandle, TIME_STAMP_FAILED);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 6642 : 					if (TimeStampCritical == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 1
	jne	SHORT $L209402

; 6643 : 					{
; 6644 : 						for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209404
$L209405:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209404:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209406

; 6645 : 						{
; 6646 : 							zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6647 : 						}

	jmp	SHORT $L209405
$L209406:

; 6648 : 						zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6649 : 						if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209407

; 6650 : 							zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209407:

; 6651 : 						if (hostUrl != NULL)

	cmp	DWORD PTR _hostUrl$209355[ebp], 0
	je	SHORT $L209408

; 6652 : 							zFree(hostUrl);

	mov	eax, DWORD PTR _hostUrl$209355[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209408:

; 6653 : 						return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209402:

; 6654 : 					}
; 6655 : 				}
; 6656 : 				if (hostUrl != NULL)

	cmp	DWORD PTR _hostUrl$209355[ebp], 0
	je	SHORT $L209352

; 6657 : 					zFree(hostUrl);

	mov	ecx, DWORD PTR _hostUrl$209355[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209352:

; 6658 : 			}
; 6659 : 		}
; 6660 : 		else

	jmp	$L209340
$L209341:

; 6661 : 		{
; 6662 : 			if (TimeStampOption == TIME_RFC_867_SRVR)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+940], 1
	jne	$L209340

; 6663 : 			{
; 6664 : 				unsigned char *tsUrl=NULL;

	mov	DWORD PTR _tsUrl$209412[ebp], 0

; 6665 : 				BOOL freeTsUrl = FALSE;

	mov	DWORD PTR _freeTsUrl$209413[ebp], 0

; 6666 : 				unsigned char *buf=NULL;

	mov	DWORD PTR _buf$209414[ebp], 0

; 6667 : 				DWORD tsSize=0;

	mov	DWORD PTR _tsSize$209415[ebp], 0

; 6668 : 
; 6669 : 				if (TimeStampURL.Length() == 0) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209416

; 6670 : 				{
; 6671 : 					tsUrl = (unsigned char *)defaultTimeServiceUrl;

	mov	DWORD PTR _tsUrl$209412[ebp], OFFSET FLAT:$SG209418

; 6672 : 				}
; 6673 : 				else

	jmp	SHORT $L209419
$L209416:

; 6674 : 				{
; 6675 : 					tsUrl = HeapW2A(TimeStampURL.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+936]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tsUrl$209412[ebp], eax

; 6676 : 					freeTsUrl = TRUE;

	mov	DWORD PTR _freeTsUrl$209413[ebp], 1
$L209419:

; 6677 : 				}
; 6678 : 				DebugLog((const char *)tsUrl);
; 6679 : 				int len =strlen((const char *)tsUrl);

	mov	edx, DWORD PTR _tsUrl$209412[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$209420[ebp], eax

; 6680 : 				int index =0;

	mov	DWORD PTR _index$209422[ebp], 0

; 6681 : 				char *p = (char *)tsUrl;

	mov	eax, DWORD PTR _tsUrl$209412[ebp]
	mov	DWORD PTR _p$209423[ebp], eax

; 6682 : 				if (!(strcmp((const char *)tsUrl, "SystemTime")))

	push	OFFSET FLAT:$SG209427
	mov	ecx, DWORD PTR _tsUrl$209412[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L209426

; 6683 : 				{
; 6684 : 					buf = getSystemTimeAsRfcTime();

	call	_getSystemTimeAsRfcTime
	mov	DWORD PTR _buf$209414[ebp], eax

; 6685 : 					tsSize = strlen((const char *)buf);

	mov	edx, DWORD PTR _buf$209414[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _tsSize$209415[ebp], eax

; 6686 : 				}
; 6687 : 				else

	jmp	SHORT $L209429
$L209426:

; 6688 : 					buf = xsHTTPFetch((const char *)tsUrl, (int *) &tsSize);

	lea	eax, DWORD PTR _tsSize$209415[ebp]
	push	eax
	mov	ecx, DWORD PTR _tsUrl$209412[ebp]
	push	ecx
	call	_xsHTTPFetch
	add	esp, 8
	mov	DWORD PTR _buf$209414[ebp], eax
$L209429:

; 6689 : 				if (freeTsUrl)

	cmp	DWORD PTR _freeTsUrl$209413[ebp], 0
	je	SHORT $L209432

; 6690 : 					zFree(tsUrl);

	mov	edx, DWORD PTR _tsUrl$209412[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209432:

; 6691 : 
; 6692 : 				if ((buf != NULL) && (tsSize != 0))

	cmp	DWORD PTR _buf$209414[ebp], 0
	je	$L209433
	cmp	DWORD PTR _tsSize$209415[ebp], 0
	je	$L209433

; 6693 : 				{
; 6694 : 					char *timeBuffer=NULL;

	mov	DWORD PTR _timeBuffer$209434[ebp], 0

; 6695 : 					LPSYSTEMTIME systemTime = rfcTimeToSystem((BYTE *)buf);

	mov	eax, DWORD PTR _buf$209414[ebp]
	push	eax
	call	_rfcTimeToSystem
	add	esp, 4
	mov	DWORD PTR _systemTime$209435[ebp], eax

; 6696 : 
; 6697 : 					switch (TimeStampFormat)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+944]
	mov	DWORD PTR tv988[ebp], edx
	cmp	DWORD PTR tv988[ebp], 0
	je	SHORT $L209441
	cmp	DWORD PTR tv988[ebp], 1
	je	SHORT $L209443
	cmp	DWORD PTR tv988[ebp], 2
	je	SHORT $L209445
	jmp	$L209447
$L209441:

; 6698 : 					{
; 6699 : 						case TIME_RFC:
; 6700 : 							bstrPropValue = A2WBSTR((LPCSTR)buf);

	push	-1
	mov	eax, DWORD PTR _buf$209414[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6701 : 							break;

	jmp	$L209438
$L209443:

; 6702 : 						case TIME_VB_NOW:
; 6703 : 							timeBuffer = systemTimeToVbNowTime(*systemTime);

	mov	ecx, DWORD PTR _systemTime$209435[ebp]
	push	ecx
	call	_systemTimeToVbNowTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209434[ebp], eax

; 6704 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	edx, DWORD PTR _timeBuffer$209434[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6705 : 							zFree(timeBuffer);

	mov	eax, DWORD PTR _timeBuffer$209434[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6706 : 							break;

	jmp	SHORT $L209438
$L209445:

; 6707 : 						case TIME_JS_UTC:
; 6708 : 							timeBuffer = systemTimeToJsUtcTime(*systemTime);

	mov	ecx, DWORD PTR _systemTime$209435[ebp]
	push	ecx
	call	_systemTimeToJsUtcTime
	add	esp, 4
	mov	DWORD PTR _timeBuffer$209434[ebp], eax

; 6709 : 							bstrPropValue = A2WBSTR((LPCSTR)timeBuffer);

	push	-1
	mov	edx, DWORD PTR _timeBuffer$209434[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6710 : 							zFree(timeBuffer);

	mov	eax, DWORD PTR _timeBuffer$209434[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6711 : 							break;

	jmp	SHORT $L209438
$L209447:

; 6712 : 						default:
; 6713 : 							bstrPropValue = A2WBSTR((LPCSTR)buf);

	push	-1
	mov	ecx, DWORD PTR _buf$209414[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax
$L209438:

; 6714 : 					}
; 6715 : 					zFree(systemTime);

	mov	edx, DWORD PTR _systemTime$209435[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 6716 : 					string propNameStr = TIME_STAMP_PREFIX;

	push	OFFSET FLAT:$SG209450
	lea	ecx, DWORD PTR _propNameStr$209449[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 6717 : 					propNameStr += sigId;

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	lea	ecx, DWORD PTR _propNameStr$209449[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6718 : 					bstrPropName = A2WBSTR((LPCSTR)propNameStr.c_str());

	push	-1
	lea	ecx, DWORD PTR _propNameStr$209449[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6719 : 					DebugLog(propNameStr.c_str());
; 6720 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6721 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6722 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6723 : 
; 6724 : 					bstrPropName = SysAllocString((const OLECHAR *)TIME_STAMP_FORMAT);

	mov	esi, esp
	push	OFFSET FLAT:$SG209453
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6725 : 					switch (TimeStampFormat)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+944]
	mov	DWORD PTR tv1032[ebp], eax
	cmp	DWORD PTR tv1032[ebp], 0
	je	SHORT $L209458
	cmp	DWORD PTR tv1032[ebp], 1
	je	SHORT $L209460
	cmp	DWORD PTR tv1032[ebp], 2
	je	SHORT $L209462
	jmp	SHORT $L209464
$L209458:

; 6726 : 					{
; 6727 : 						case TIME_RFC:
; 6728 : 							bstrPropValue = SysAllocString(L"0");

	mov	esi, esp
	push	OFFSET FLAT:$SG209459
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6729 : 							break;

	jmp	SHORT $L209455
$L209460:

; 6730 : 						case TIME_VB_NOW:
; 6731 : 							bstrPropValue = SysAllocString(L"1");

	mov	esi, esp
	push	OFFSET FLAT:$SG209461
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6732 : 							break;

	jmp	SHORT $L209455
$L209462:

; 6733 : 						case TIME_JS_UTC:
; 6734 : 							bstrPropValue = SysAllocString(L"2");

	mov	esi, esp
	push	OFFSET FLAT:$SG209463
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6735 : 							break;

	jmp	SHORT $L209455
$L209464:

; 6736 : 						default:
; 6737 : 							bstrPropValue = SysAllocString(L"0");

	mov	esi, esp
	push	OFFSET FLAT:$SG209465
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax
$L209455:

; 6738 : 					}
; 6739 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6740 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6741 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6742 : 					bstrPropName = A2WBSTR((LPCSTR)"TimeStampURL");

	push	-1
	push	OFFSET FLAT:$SG209467
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6743 : 					bstrPropValue = TimeStampURL.m_str;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+936]
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6744 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6745 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6746 : 					bstrPropName = SysAllocString((const OLECHAR *)TIME_STAMP_PROTOCOL);

	mov	esi, esp
	push	OFFSET FLAT:$SG209469
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6747 : 					bstrPropValue = SysAllocString((const OLECHAR *)TIME_RFC_867_PROTOCOL);

	mov	esi, esp
	push	OFFSET FLAT:$SG209471
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6748 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6749 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6750 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6751 : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _propNameStr$209449[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 6752 : 				else

	jmp	SHORT $L209340
$L209433:

; 6753 : 				{
; 6754 : 					DebugLog("RFC-867 Time stamp failed. Returned null as response.");
; 6755 : 					setError(SigHandle, TIME_STAMP_FAILED);

	push	128					; 00000080H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 6756 : 					if (TimeStampCritical == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+948], 1
	jne	SHORT $L209340

; 6757 : 					{
; 6758 : 						for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209474
$L209475:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209474:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209476

; 6759 : 						{
; 6760 : 							zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 6761 : 						}

	jmp	SHORT $L209475
$L209476:

; 6762 : 						zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6763 : 						if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209477

; 6764 : 							zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209477:

; 6765 : 						return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209340:

; 6766 : 					}
; 6767 : 				}
; 6768 : 			}
; 6769 : 		}
; 6770 : 	}
; 6771 : 
; 6772 : 	if (UseHMAC != TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 1
	je	$L209478

; 6773 : 	{
; 6774 : 		if (((CertVerifyParams.verificationOptions & VERIFY_CRL) || (useCam) || (useOcsp)) &&
; 6775 : 				(certificateList != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, 1
	jne	SHORT $L209480
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1908], 0
	jne	SHORT $L209480
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1912], 0
	je	$L209479
$L209480:
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L209479

; 6776 : 		{
; 6777 : 			bstrPropName = A2WBSTR((LPCSTR)"CertificateValidationMethod");

	push	-1
	push	OFFSET FLAT:$SG209482
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6778 : 			if (useCam)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	$L209483

; 6779 : 			{
; 6780 : 				bstrPropValue = A2WBSTR((LPCSTR)"CAM");

	push	-1
	push	OFFSET FLAT:$SG209485
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6781 : 				ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6782 : 				SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6783 : 				SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6784 : 				bstrPropName = A2WBSTR((LPCSTR)"CamServerHost");

	push	-1
	push	OFFSET FLAT:$SG209487
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6785 : 				bstrPropValue = A2WBSTR((LPCSTR)camServerHost);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1896]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6786 : 				ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6787 : 				SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6788 : 				SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6789 : 				if (CamResponseTransactionId != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2212], 0
	je	$L209489

; 6790 : 				{
; 6791 : 					bstrPropName = A2WBSTR((LPCSTR)"CamTransactionId");

	push	-1
	push	OFFSET FLAT:$SG209491
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6792 : 					bstrPropValue = A2WBSTR((LPCSTR)CamResponseTransactionId);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2212]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6793 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6794 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6795 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209489:

; 6796 : 				}
; 6797 : 
; 6798 : 				if (IncludeCamResponse)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2188], 0
	je	$L209493

; 6799 : 				{
; 6800 : 					bstrPropName = A2WBSTR((LPCSTR)"CamValidationResponse");

	push	-1
	push	OFFSET FLAT:$SG209495
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6801 : 					bstrPropValue = A2WBSTR((LPCSTR)CamResponseCaSignedMsg, CamResponseCaSignedMsgSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2208]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+2200]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6802 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6803 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6804 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209493:

; 6805 : 				}
; 6806 : 			}
; 6807 : 			else 			

	jmp	$L209479
$L209483:

; 6808 : 				if (useOcsp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	je	$L209498

; 6809 : 				{
; 6810 : 					bstrPropValue = A2WBSTR((LPCSTR)"OCSP");

	push	-1
	push	OFFSET FLAT:$SG209500
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6811 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6812 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6813 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6814 : 					bstrPropName = A2WBSTR((LPCSTR)"OcspResponderURL");

	push	-1
	push	OFFSET FLAT:$SG209502
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6815 : 					bstrPropValue = ocspResponderUrl;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6816 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6817 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6818 : 					if (ocspOutputNonce.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L209503

; 6819 : 					{
; 6820 : 						bstrPropName = A2WBSTR((LPCSTR)"OcspNonce");

	push	-1
	push	OFFSET FLAT:$SG209505
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6821 : 						bstrPropValue = ocspOutputNonce;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6822 : 						ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6823 : 						SysFreeString(bstrPropName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209503:

; 6824 : 					}
; 6825 : 
; 6826 : 					if (IncludeOcspResponse & INCLUDE_TEXT_RESPONSE)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2264]
	and	edx, 1
	je	SHORT $L209506

; 6827 : 					{
; 6828 : 						bstrPropName = A2WBSTR((LPCSTR)"OcspTextResponse");

	push	-1
	push	OFFSET FLAT:$SG209508
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6829 : 						bstrPropValue = ocspTextResponse;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6830 : 						ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6831 : 						SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209506:

; 6832 : 					}
; 6833 : 					if (IncludeOcspResponse & INCLUDE_BIN_RESPONSE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2264]
	and	ecx, 2
	je	SHORT $L209509

; 6834 : 					{
; 6835 : 						bstrPropName = A2WBSTR((LPCSTR)"OcspBinaryResponse");

	push	-1
	push	OFFSET FLAT:$SG209511
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6836 : 						bstrPropValue = ocspB64Response;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6837 : 						ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6838 : 						SysFreeString(bstrPropName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209509:

; 6839 : 					}
; 6840 : 				}
; 6841 : 				else

	jmp	SHORT $L209479
$L209498:

; 6842 : 				{
; 6843 : 					bstrPropValue = A2WBSTR((LPCSTR)"CRL");

	push	-1
	push	OFFSET FLAT:$SG209514
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6844 : 					ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6845 : 					SysFreeString(bstrPropName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6846 : 					SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropValue$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209479:

; 6847 : 				}
; 6848 : 		}
; 6849 : 
; 6850 : 		if (((CertVerifyParams.verificationOptions &= (~VERIFY_CRL_REC)) && !useCam &&!useOcsp) &&
; 6851 : 				(certificateList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1856], 0
	je	$L209478
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1908], 0
	jne	$L209478
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	jne	$L209478
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L209478

; 6852 : 		{
; 6853 : 				string verOptions = "";

	push	OFFSET FLAT:$SG209517
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 6854 : 				bstrPropName = A2WBSTR((LPCSTR)"CertificateVerificationOptions");

	push	-1
	push	OFFSET FLAT:$SG209519
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6855 : 				BOOL addComma = FALSE;

	mov	DWORD PTR _addComma$209520[ebp], 0

; 6856 : 				if (CertVerifyParams.verificationOptions & VERIFY_CRL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, 1
	je	SHORT $L209521

; 6857 : 				{
; 6858 : 					verOptions += "VERIFY_CRL";

	push	OFFSET FLAT:$SG209522
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6859 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209521:

; 6860 : 				}
; 6861 : 				if (CertVerifyParams.verificationOptions & VERIFY_CHAIN)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, 4
	je	SHORT $L209523

; 6862 : 				{
; 6863 : 					if (addComma)

	cmp	DWORD PTR _addComma$209520[ebp], 0
	je	SHORT $L209524

; 6864 : 						verOptions += ", ";

	push	OFFSET FLAT:$SG209525
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$L209524:

; 6865 : 					verOptions += "VERIFY_CHAIN";

	push	OFFSET FLAT:$SG209526
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6866 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209523:

; 6867 : 				}
; 6868 : 				if (CertVerifyParams.verificationOptions & VERIFY_PATH_LENGTH)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, 8
	je	SHORT $L209527

; 6869 : 				{
; 6870 : 					if (addComma)

	cmp	DWORD PTR _addComma$209520[ebp], 0
	je	SHORT $L209528

; 6871 : 						verOptions += ", ";

	push	OFFSET FLAT:$SG209529
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$L209528:

; 6872 : 					verOptions += "VERIFY_PATH_LENGTH";

	push	OFFSET FLAT:$SG209530
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6873 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209527:

; 6874 : 				}
; 6875 : 				if (CertVerifyParams.verificationOptions & VERIFY_POLICY)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, 2
	je	SHORT $L209531

; 6876 : 				{
; 6877 : 					if (addComma)

	cmp	DWORD PTR _addComma$209520[ebp], 0
	je	SHORT $L209532

; 6878 : 						verOptions += ", ";

	push	OFFSET FLAT:$SG209533
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$L209532:

; 6879 : 					verOptions += "VERIFY_POLICY";

	push	OFFSET FLAT:$SG209534
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6880 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209531:

; 6881 : 				}
; 6882 : 				if (CertVerifyParams.verificationOptions & POLICY_EXPLICIT)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, 16					; 00000010H
	je	SHORT $L209535

; 6883 : 				{
; 6884 : 					if (addComma)

	cmp	DWORD PTR _addComma$209520[ebp], 0
	je	SHORT $L209536

; 6885 : 						verOptions += ", ";

	push	OFFSET FLAT:$SG209537
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$L209536:

; 6886 : 					verOptions += "POLICY_EXPLICIT";

	push	OFFSET FLAT:$SG209538
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6887 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209535:

; 6888 : 				}
; 6889 : 				if (CertVerifyParams.verificationOptions & EXPLICIT_TRUST)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, 32					; 00000020H
	je	SHORT $L209539

; 6890 : 				{
; 6891 : 					if (addComma)

	cmp	DWORD PTR _addComma$209520[ebp], 0
	je	SHORT $L209540

; 6892 : 						verOptions += ", ";

	push	OFFSET FLAT:$SG209541
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$L209540:

; 6893 : 					verOptions += "EXPLICIT_TRUST";

	push	OFFSET FLAT:$SG209542
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 6894 : 					addComma = TRUE;

	mov	DWORD PTR _addComma$209520[ebp], 1
$L209539:

; 6895 : 				}
; 6896 : 
; 6897 : 				bstrPropValue = A2WBSTR((LPCSTR)verOptions.c_str());

	push	-1
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6898 : 				ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6899 : 				SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6900 : 				SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6901 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L209478:

; 6902 : 	}
; 6903 : 
; 6904 : 	// if hmac true && PhysicalSigUsage == NO_PHYSICAL_SIG set error return
; 6905 : 
; 6906 : 	if ((PhysicalSigUsage == NO_PHYSICAL_SIG) && (UseHMAC == TRUE) && (HMACKey.Length() == 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+956], 0
	jne	SHORT $L209544
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1800], 1
	jne	SHORT $L209544
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209544

; 6907 : 	{
; 6908 : 		setError(SigHandle, NO_HMAC_PASSWORD);

	push	67					; 00000043H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6909 : 		return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209544:

; 6910 : 	}
; 6911 : 
; 6912 : 
; 6913 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	$L209545

; 6914 : 	{
; 6915 : 		if (SigImageGuid.length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	test	eax, eax
	je	$L209546

; 6916 : 		{
; 6917 : 			bstrPropName = A2WBSTR((LPCSTR)"SignatureImageId");

	push	-1
	push	OFFSET FLAT:$SG209548
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 6918 : 			bstrPropValue = A2WBSTR((LPCSTR)SigImageGuid.c_str());

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 6919 : 
; 6920 : 			ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6921 : 			SysFreeString(bstrPropName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6922 : 			SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropValue$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209546:

; 6923 : 		}
; 6924 : 		if(UseHMAC == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1800], 1
	jne	$L209545

; 6925 : 		{
; 6926 : 			if (HMACKey.Length() == 0) // No password provided, use sig image hash as password

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	$L209545

; 6927 : 			{
; 6928 : 				// call function to get sig file and create hash and return value in 
; 6929 : 				// pfxpassword & set HMAC as signature method
; 6930 : 				charInputFile = (char *)CapturedSignatureFileName;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	mov	DWORD PTR _charInputFile$[ebp], edx

; 6931 : 				BSTR bstrCapturedSignatureFileName = A2WBSTR((LPCSTR)CapturedSignatureFileName);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrCapturedSignatureFileName$209553[ebp], eax

; 6932 : 				if (ReadAllBin(bstrCapturedSignatureFileName, &binFileData, &fileSize) == S_FALSE)

	lea	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrCapturedSignatureFileName$209553[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L209556

; 6933 : 				{
; 6934 : 					setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 6935 : 					zFree(charInputFile);

	mov	eax, DWORD PTR _charInputFile$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 6936 : 					SysFreeString(bstrCapturedSignatureFileName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrCapturedSignatureFileName$209553[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6937 : 					return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209556:

; 6938 : 				}
; 6939 : 				SysFreeString(bstrCapturedSignatureFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrCapturedSignatureFileName$209553[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6940 : //				zFree(charInputFile);
; 6941 : 				
; 6942 : 				
; 6943 : 				DS_DATA_BLOB objectBlob;				
; 6944 : 				
; 6945 : 				BYTE *pbDigest=NULL;

	mov	DWORD PTR _pbDigest$209558[ebp], 0

; 6946 : 
; 6947 : 				DWORD cbDigest=0;

	mov	DWORD PTR _cbDigest$209559[ebp], 0

; 6948 : 
; 6949 : 				objectBlob.cbData = fileSize;	

	mov	eax, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR _objectBlob$209557[ebp+4], eax

; 6950 : 				objectBlob.pbData = NULL;

	mov	DWORD PTR _objectBlob$209557[ebp], 0

; 6951 : 				if(!(objectBlob.pbData = (unsigned char*)zMalloc(objectBlob.cbData+1)))

	mov	ecx, DWORD PTR _objectBlob$209557[ebp+4]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _objectBlob$209557[ebp], eax
	cmp	DWORD PTR _objectBlob$209557[ebp], 0
	jne	SHORT $L209561

; 6952 : 				{
; 6953 : 					SigImageGuid = "";

	push	OFFSET FLAT:$SG209562
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 6954 : 					setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 6955 : 					zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 6956 : 					return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209561:

; 6957 : 				}
; 6958 : 				memcpy(objectBlob.pbData,binFileData,fileSize);

	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _objectBlob$209557[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6959 : 				
; 6960 : 				if (!crComputeHash(
; 6961 : 					CALG_SHA1,
; 6962 : 					NULL,
; 6963 : 					&objectBlob,			// (in) Object data
; 6964 : 					NULL,				// (in/out) digest: pointer 
; 6965 : 					&cbDigest,
; 6966 : 					SigHandle)) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _cbDigest$209559[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _objectBlob$209557[ebp]
	push	edx
	push	0
	push	32772					; 00008004H
	call	_crComputeHash
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $L209563

; 6967 : 					setError(SigHandle, DIGEST_ERROR);

	push	22					; 00000016H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 6968 : 					err=TRUE; 

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 1
$L209563:

; 6969 : 
; 6970 : 				}	//&pKey			
; 6971 : 				
; 6972 : 				if (pbDigest) zFree (pbDigest);

	cmp	DWORD PTR _pbDigest$209558[ebp], 0
	je	SHORT $L209564
	mov	eax, DWORD PTR _pbDigest$209558[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209564:

; 6973 : 				pbDigest = NULL;

	mov	DWORD PTR _pbDigest$209558[ebp], 0

; 6974 : 				if(!(pbDigest = (BYTE*)zMalloc(cbDigest+1)))	{

	mov	ecx, DWORD PTR _cbDigest$209559[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbDigest$209558[ebp], eax
	cmp	DWORD PTR _pbDigest$209558[ebp], 0
	jne	SHORT $L209566

; 6975 : 					setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 6976 : 					err=TRUE; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 1
$L209566:

; 6977 : 				}
; 6978 : 				if (!crComputeHash(
; 6979 : 					CALG_SHA1,
; 6980 : 					NULL,
; 6981 : 					&objectBlob,			// (in) Object data
; 6982 : 					pbDigest,				// (in/out) digest: pointer 
; 6983 : 					&cbDigest,
; 6984 : 					SigHandle)) {			// (in/out) digest: size 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _cbDigest$209559[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbDigest$209558[ebp]
	push	edx
	lea	eax, DWORD PTR _objectBlob$209557[ebp]
	push	eax
	push	0
	push	32772					; 00008004H
	call	_crComputeHash
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $L209567

; 6985 : 					setError(SigHandle, DIGEST_ERROR);

	push	22					; 00000016H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 6986 : 					err=TRUE; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 1
$L209567:

; 6987 : 				}	//&pKey	
; 6988 : 				
; 6989 : 				// allocate memory				
; 6990 : 				if (HMACPassword.pbData) zFree (HMACPassword.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+908], 0
	je	SHORT $L209568
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+908]
	push	eax
	call	_rFree
	add	esp, 4
$L209568:

; 6991 : 				HMACPassword.pbData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], 0

; 6992 : 				HMACPassword.cbData = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+912], 0

; 6993 : 				cbDigest = cbDigest-18;

	mov	eax, DWORD PTR _cbDigest$209559[ebp]
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _cbDigest$209559[ebp], eax

; 6994 : 				// encode digest value
; 6995 : 				HMACPassword.cbData = base64encodeSize(cbDigest);

	mov	ecx, DWORD PTR _cbDigest$209559[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+912], eax

; 6996 : 				if(!(HMACPassword.pbData = (BYTE*)zMalloc(HMACPassword.cbData+1))) {

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], eax
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+908], 0
	jne	SHORT $L209570

; 6997 : 					setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 6998 : 					err=TRUE; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 1
$L209570:

; 6999 : 				}
; 7000 : 				memset (HMACPassword.pbData,0,HMACPassword.cbData+1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+912]
	add	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+908]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 7001 : 				if (base64encode(pbDigest,cbDigest,HMACPassword.pbData,HMACPassword.cbData)==-1) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	push	edx
	mov	eax, DWORD PTR _cbDigest$209559[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbDigest$209558[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L209571

; 7002 : 					setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 7003 : 					err=TRUE; 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 1
$L209571:

; 7004 : 				}
; 7005 : 				if (objectBlob.pbData) zFree (objectBlob.pbData);

	cmp	DWORD PTR _objectBlob$209557[ebp], 0
	je	SHORT $L209572
	mov	edx, DWORD PTR _objectBlob$209557[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209572:

; 7006 : 				objectBlob.pbData = NULL;

	mov	DWORD PTR _objectBlob$209557[ebp], 0

; 7007 : 				objectBlob.cbData = 0;				

	mov	DWORD PTR _objectBlob$209557[ebp+4], 0
$L209545:

; 7008 : 				
; 7009 : 			}
; 7010 : 		}
; 7011 : 	}
; 7012 : 
; 7013 : 	//if (LicObj.isLicenseDemo())
; 7014 : 	//{
; 7015 : 	//	bstrPropName = A2WBSTR((LPCSTR)"SecureXMLLicenseUsed");;
; 7016 : 	//	bstrPropValue = A2WBSTR((LPCSTR)"Non Production Demo License");
; 7017 : 	//	ChangeOrAddProperty(bstrPropName, bstrPropValue);
; 7018 : 	//	SysFreeString(bstrPropName);
; 7019 : 	//	SysFreeString(bstrPropValue);
; 7020 : 	//}
; 7021 : 
; 7022 : 	//if (LicObj.isLicenseDevelopment())
; 7023 : 	//{
; 7024 : 	//	bstrPropName = A2WBSTR((LPCSTR)"SecureXMLLicenseUsed");;
; 7025 : 	//	bstrPropValue = A2WBSTR((LPCSTR)"Non Production Development License");
; 7026 : 	//	ChangeOrAddProperty(bstrPropName, bstrPropValue);
; 7027 : 	//	SysFreeString(bstrPropName);
; 7028 : 	//	SysFreeString(bstrPropValue);
; 7029 : 	//}
; 7030 : 
; 7031 : 	// create <Object ID="Properties">
; 7032 : 	if (PropertyCount>0) {

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	jle	$L209573

; 7033 : 	// create <Reference> for PROPERTIES
; 7034 : 		sprintf (pout,"REF_Properties_%s",SigHandle->sig->param_id);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 2048				; 00000800H
	push	eax
	push	OFFSET FLAT:$SG209574
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2284				; 000008ecH
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7035 : 		sprintf (pout2,"#PROPERTIES_%s",SigHandle->sig->param_id);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 2048				; 00000800H
	push	ecx
	push	OFFSET FLAT:$SG209575
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2804				; 00000af4H
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7036 : 		if ((pref = xsGenerateReference(pout,IFM_SHA1,NULL,pout2, SigHandle))==NULL) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2804				; 00000af4H
	push	edx
	push	0
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2284				; 000008ecH
	push	eax
	call	_xsGenerateReference
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pref$[ebp], eax
	cmp	DWORD PTR _pref$[ebp], 0
	jne	SHORT $L209576

; 7037 : 		{
; 7038 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209577
$L209578:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L209577:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209579

; 7039 : 			{
; 7040 : 				zFree(certificateList[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 7041 : 			}

	jmp	SHORT $L209578
$L209579:

; 7042 : 			zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 7043 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209580

; 7044 : 				zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209580:

; 7045 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L209129
$L209576:

; 7046 : 		}
; 7047 : 		if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L209582

; 7048 : 		{
; 7049 : 			trAlgorithm = CANON_EXC_NO_COMM;

	mov	DWORD PTR _trAlgorithm$[ebp], 65	; 00000041H

; 7050 : 		}
; 7051 : 		else if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	jmp	SHORT $L209583
$L209582:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L209583

; 7052 : 		{
; 7053 : 			trAlgorithm = CANON_EXC_WITH_COMM;

	mov	DWORD PTR _trAlgorithm$[ebp], 33	; 00000021H
$L209583:

; 7054 : 		}
; 7055 : 		if (trAlgorithm)

	cmp	DWORD PTR _trAlgorithm$[ebp], 0
	je	$L209585

; 7056 : 			if ((ptrs = xsGenerateTransform(trAlgorithm,pref,SigHandle))!=NULL) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _pref$[ebp]
	push	eax
	mov	ecx, DWORD PTR _trAlgorithm$[ebp]
	push	ecx
	call	_xsGenerateTransform
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ptrs$[ebp], eax
	cmp	DWORD PTR _ptrs$[ebp], 0
	je	SHORT $L209585

; 7057 : 			{
; 7058 : 				if (InclusiveNamespaceList != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+96], 0
	je	SHORT $L209585

; 7059 : 				{
; 7060 : 					unsigned char *tmp = (unsigned char *)zMalloc(strlen(InclusiveNamespaceList) + 1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmp$209588[ebp], eax

; 7061 : 					strcpy((char *)tmp, InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	mov	ecx, DWORD PTR _tmp$209588[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7062 : 					ptrs->prefixList = (unsigned char *)tmp;

	mov	edx, DWORD PTR _ptrs$[ebp]
	mov	eax, DWORD PTR _tmp$209588[ebp]
	mov	DWORD PTR [edx+6160], eax
$L209585:

; 7063 : 				}
; 7064 : 			}
; 7065 : 
; 7066 : 
; 7067 : 		sprintf (pout2,"PROPERTIES_%s",SigHandle->sig->param_id);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 2048				; 00000800H
	push	eax
	push	OFFSET FLAT:$SG209592
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7068 : 		if ((xsGenerateObject(pout2,NULL,(const char**)Properties,PropertyCount,SigHandle))==NULL) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_xsGenerateObject
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L209573

; 7069 : 		{
; 7070 : 			for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209595
$L209596:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$L209595:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209597

; 7071 : 			{
; 7072 : 				zFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 7073 : 			}

	jmp	SHORT $L209596
$L209597:

; 7074 : 			zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7075 : 			if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209598

; 7076 : 				zFree(signingCert);

	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209598:

; 7077 : 			return S_FALSE;

	mov	eax, 1
	jmp	$L209129
$L209573:

; 7078 : 		}
; 7079 : 	}
; 7080 : 
; 7081 : 	//if (TimeStampOption == TIME_RFC_867_SRVR)
; 7082 : 	//{
; 7083 : 	//	unsigned char *wTimeStampURL = HeapW2A(TimeStampURL.m_str);
; 7084 : 	//	xsCoreAddTimestamp(SigHandle, wTimeStampURL);
; 7085 : 	//	zFree(wTimeStampURL);
; 7086 : 	//}
; 7087 : 
; 7088 : 	/* 
; 7089 : 	 * sign it and generate other XML sections
; 7090 : 	 */
; 7091 : 
; 7092 : 	if(UseHMAC != TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1800], 1
	je	$L209600

; 7093 : 	{
; 7094 : 		if (calculateDigestOnly == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3408], 0
	jne	$L209601

; 7095 : 		{
; 7096 : 			if (!xsSign(
; 7097 : 				(const char *)signingCert,	// base64 encoded certificate with public key, or base64 encoded pfx data
; 7098 : 				&PfxPassword,		// if signingCert is NULL, it is HMAC key, if certData is Pfx it is the password
; 7099 : 									// ignored otherwise
; 7100 : 				SigHandle
; 7101 :  				)) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 900				; 00000384H
	push	ecx
	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_xsSign
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L209603

; 7102 : 			{
; 7103 : 				for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209604
$L209605:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209604:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209606

; 7104 : 				{
; 7105 : 					zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 7106 : 				}

	jmp	SHORT $L209605
$L209606:

; 7107 : 				zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 7108 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209607

; 7109 : 					zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209607:

; 7110 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209603:

; 7111 : 			}
; 7112 : 			*signedXML = xsCoreGenerateXMLSec(SigHandle, signedXmlSize);

	mov	ecx, DWORD PTR _signedXmlSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_xsCoreGenerateXMLSec
	add	esp, 8
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [ecx], eax

; 7113 : 		}
; 7114 : 		else // Calculate digest only. Signature value will be calculated on the client computer

	jmp	$L209608
$L209601:

; 7115 : 		{
; 7116 : 			/*
; 7117 : 			* Get signed info
; 7118 : 			*/
; 7119 : 			PDS_DATA_BLOB pcrBlob=NULL;	// <SignedInfo> data

	mov	DWORD PTR _pcrBlob$209609[ebp], 0

; 7120 : 			BYTE *pbHash;			// SHA1 hash
; 7121 : 			DWORD dwHashLen=20;			// 

	mov	DWORD PTR _dwHashLen$209611[ebp], 20	; 00000014H

; 7122 : 			PBYTE pbSignature=NULL;		// signature BLOB

	mov	DWORD PTR _pbSignature$209612[ebp], 0

; 7123 : 			DWORD dwSigLen=0;			// signature BLOB

	mov	DWORD PTR _dwSigLen$209613[ebp], 0

; 7124 : 			PBYTE pbPublicKey=NULL;		// (out) pub key BLOB

	mov	DWORD PTR _pbPublicKey$209614[ebp], 0

; 7125 : 			DWORD dwKeyLen=0;			// (out) pub key BLOB

	mov	DWORD PTR _dwKeyLen$209615[ebp], 0

; 7126 : 			DWORD sigalgtype=0;

	mov	DWORD PTR _sigalgtype$209616[ebp], 0

; 7127 : 			if (signingCert == NULL)

	cmp	DWORD PTR _signingCert$[ebp], 0
	jne	SHORT $L209617

; 7128 : 			{
; 7129 : 				PfxPassword.cbData = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+904], 0

; 7130 : 				if (PfxPassword.pbData != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+900], 0
	je	SHORT $L209618

; 7131 : 					zFree(PfxPassword.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	push	edx
	call	_rFree
	add	esp, 4
$L209618:

; 7132 : 				PfxPassword.pbData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+900], 0
$L209617:

; 7133 : 			}
; 7134 : 
; 7135 : 			pbHash = (BYTE *)zMalloc(dwHashLen);

	mov	ecx, DWORD PTR _dwHashLen$209611[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbHash$209610[ebp], eax

; 7136 : 
; 7137 : 			if ((pcrBlob = xsGetSignedInfo(
; 7138 : 				(const char *)signingCert,
; 7139 : 				&PfxPassword,		// if signingCert is NULL, it is HMAC key, if certData is Pfx it is the password
; 7140 : 				SigHandle))==NULL) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 900				; 00000384H
	push	ecx
	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	call	_xsGetSignedInfo
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pcrBlob$209609[ebp], eax
	cmp	DWORD PTR _pcrBlob$209609[ebp], 0
	jne	SHORT $L209621

; 7141 : 			{
; 7142 : 				for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209622
$L209623:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209622:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209624

; 7143 : 				{
; 7144 : 					zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 7145 : 				}

	jmp	SHORT $L209623
$L209624:

; 7146 : 				zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 7147 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209625

; 7148 : 					zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209625:

; 7149 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209621:

; 7150 : 			}
; 7151 : 
; 7152 : 			/*
; 7153 : 			* Get SHA1 digest of it
; 7154 : 			*/
; 7155 : 			if (!crComputeHash(
; 7156 : 				CALG_SHA1,
; 7157 : 				NULL,		// HMAC key, not used
; 7158 : 				pcrBlob,	// (in) Object data
; 7159 : 				pbHash,		// (in/out) digest: pointer 
; 7160 : 				&dwHashLen,	// (in/out) 20 for SHA1
; 7161 : 				SigHandle)) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	eax, DWORD PTR _dwHashLen$209611[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbHash$209610[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcrBlob$209609[ebp]
	push	edx
	push	0
	push	32772					; 00008004H
	call	_crComputeHash
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	$L209626

; 7162 : 			{	
; 7163 : 				for (j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L209627
$L209628:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L209627:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209629

; 7164 : 				{
; 7165 : 					zFree(certificateList[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 7166 : 				}

	jmp	SHORT $L209628
$L209629:

; 7167 : 				zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 7168 : 				if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209630

; 7169 : 					zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209630:

; 7170 : 				if (pcrBlob != NULL)

	cmp	DWORD PTR _pcrBlob$209609[ebp], 0
	je	SHORT $L209631

; 7171 : 				{
; 7172 : 					if (pcrBlob->pbData != NULL)

	mov	ecx, DWORD PTR _pcrBlob$209609[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L209632

; 7173 : 						zFree(pcrBlob->pbData);

	mov	edx, DWORD PTR _pcrBlob$209609[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4
$L209632:

; 7174 : 					zFree(pcrBlob);

	mov	ecx, DWORD PTR _pcrBlob$209609[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209631:

; 7175 : 				}
; 7176 : 				xmlFree(pcrBlob->pbData);

	mov	esi, esp
	mov	edx, DWORD PTR _pcrBlob$209609[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7177 : 				zFree(pcrBlob);

	mov	ecx, DWORD PTR _pcrBlob$209609[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7178 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209626:

; 7179 : 			}
; 7180 : 			*signedXML = pbHash;

	mov	edx, DWORD PTR _signedXML$[ebp]
	mov	eax, DWORD PTR _pbHash$209610[ebp]
	mov	DWORD PTR [edx], eax

; 7181 : 			*signedXmlSize = dwHashLen;

	mov	ecx, DWORD PTR _signedXmlSize$[ebp]
	mov	edx, DWORD PTR _dwHashLen$209611[ebp]
	mov	DWORD PTR [ecx], edx

; 7182 : 			xmlFree(pcrBlob->pbData);

	mov	esi, esp
	mov	eax, DWORD PTR _pcrBlob$209609[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7183 : 			zFree(pcrBlob);

	mov	edx, DWORD PTR _pcrBlob$209609[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209608:

; 7184 : 		}
; 7185 : 	}
; 7186 : 	else 

	jmp	$L209633
$L209600:

; 7187 : 	{
; 7188 : 		/*
; 7189 : 		 * HMAC as signature method 
; 7190 : 		 */ 
; 7191 : 		if (xsCoreSetSignatureMethod(NULL,ALG_HMACSHA1,0,NULL, SigHandle)!=TRUE) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	0
	push	0
	push	OFFSET FLAT:$SG209635
	push	0
	call	_xsCoreSetSignatureMethod
	add	esp, 20					; 00000014H
	cmp	eax, 1
	je	SHORT $L209634

; 7192 : 		{
; 7193 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209634:

; 7194 : 		}
; 7195 : 
; 7196 : 		/*
; 7197 : 		 * This might not work on Windows 95/98
; 7198 : 		 */
; 7199 : 		xsCoreSetCSP((unsigned char *)"Microsoft Enhanced Cryptographic Provider v1.0",SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	push	OFFSET FLAT:$SG209637
	call	_xsCoreSetCSP
	add	esp, 8

; 7200 : 
; 7201 : 		if (!xsSign(
; 7202 : 				NULL,	// base64 encoded certificate with public key, or base64 encoded pfx data
; 7203 : 				&HMACPassword,	// if signingCert is NULL, it is HMAC key, if certData is Pfx it is the password
; 7204 : 									// ignored otherwise
; 7205 : 				SigHandle
; 7206 :  				)) 

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 908				; 0000038cH
	push	eax
	push	0
	call	_xsSign
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L209638

; 7207 : 			{
; 7208 : 				return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209638:

; 7209 : 			}
; 7210 : 		*signedXML = xsCoreGenerateXMLSec(SigHandle, signedXmlSize);

	mov	ecx, DWORD PTR _signedXmlSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_xsCoreGenerateXMLSec
	add	esp, 8
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [ecx], eax
$L209633:

; 7211 : 	}
; 7212 : 	
; 7213 : 	/*
; 7214 : 	 * get result XML as string and save it
; 7215 : 	 */
; 7216 : //	xmlDocPtr tmpDocPtr = NULL;
; 7217 : 
; 7218 : 
; 7219 : 	if (UseHMAC == FALSE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1800], 0
	jne	SHORT $L209639

; 7220 : 	{
; 7221 : 		if ((certificateListCount != 0) && (certificateList != NULL))

	cmp	DWORD PTR _certificateListCount$[ebp], 0
	je	SHORT $L209640
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L209640

; 7222 : 		{
; 7223 : 			for (i=0; i < certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209641
$L209642:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L209641:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L209643

; 7224 : 			{
; 7225 : 				zFree(certificateList[i]);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 7226 : 			}

	jmp	SHORT $L209642
$L209643:

; 7227 : 			zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209640:

; 7228 : 		}
; 7229 : 		if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L209639

; 7230 : 			zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209639:

; 7231 : 	}
; 7232 : 	if (AttachedObjectCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $L209645

; 7233 : 	{
; 7234 : 		for (i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209646
$L209647:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L209646:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jae	SHORT $L209648

; 7235 : 			if (pbData[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pbData$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L209649

; 7236 : 				zFree(pbData[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pbData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L209649:

; 7237 : 		zFree(pbData);

	jmp	SHORT $L209647
$L209648:
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209645:

; 7238 : 	}
; 7239 : 
; 7240 : 	if ((EnvelopingFlag == DETACHED) ||
; 7241 : 		(DetachedObjectCount != 0))

	mov	edx, DWORD PTR _this$[ebp]
	movsx	eax, WORD PTR [edx+688]
	test	eax, eax
	je	SHORT $L209651
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	$L209650
$L209651:

; 7242 : 	{
; 7243 : 		if (SigHandle->locNumber != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	cmp	DWORD PTR [eax+16], 0
	je	$L209650

; 7244 : 		{
; 7245 : 			for (i=0; i < (UINT)SigHandle->locNumber; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L209654
$L209655:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L209654:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	$L209656

; 7246 : 			{
; 7247 : 				if (SigHandle->locArray[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	$L209657

; 7248 : 				{
; 7249 : 					if (SigHandle->locArray[i]->fullPath != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $L209658

; 7250 : 					{
; 7251 : 						zFree(SigHandle->locArray[i]->fullPath);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_rFree
	add	esp, 4

; 7252 : 						SigHandle->locArray[i]->fullPath = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [eax+8], 0
$L209658:

; 7253 : 					}
; 7254 : 					if (SigHandle->locArray[i]->sigId != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L209659

; 7255 : 					{
; 7256 : 						zFree(SigHandle->locArray[i]->sigId);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_rFree
	add	esp, 4

; 7257 : 						SigHandle->locArray[i]->sigId = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [ecx], 0
$L209659:

; 7258 : 					}
; 7259 : 					if (SigHandle->locArray[i]->URI != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L209660

; 7260 : 					{
; 7261 : 						zFree(SigHandle->locArray[i]->URI);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_rFree
	add	esp, 4

; 7262 : 						SigHandle->locArray[i]->URI = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+4], 0
$L209660:

; 7263 : 					}
; 7264 : 					zFree(SigHandle->locArray[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 7265 : 					SigHandle->locArray[i] = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L209657:

; 7266 : 				}
; 7267 : 			}

	jmp	$L209655
$L209656:

; 7268 : 			zFree(SigHandle->locArray);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_rFree
	add	esp, 4

; 7269 : 			SigHandle->locArray = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	DWORD PTR [ecx+12], 0

; 7270 : 			SigHandle->locNumber = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	DWORD PTR [eax+16], 0
$L209650:

; 7271 : 		}
; 7272 : 	}
; 7273 : 	if ((Base64EncodeXML == TRUE) && (calculateDigestOnly == FALSE))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 1
	jne	$L209661
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3408], 0
	jne	$L209661

; 7274 : 	{
; 7275 : 	// Base64 encode
; 7276 : 		int srcSize;
; 7277 : 		unsigned int cbData;
; 7278 : 		unsigned char *pbData;
; 7279 : 		srcSize = *signedXmlSize;

	mov	eax, DWORD PTR _signedXmlSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _srcSize$209662[ebp], ecx

; 7280 : 		cbData = base64encodeSize(srcSize);

	mov	edx, DWORD PTR _srcSize$209662[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$209663[ebp], eax

; 7281 : 
; 7282 : 		if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	eax, DWORD PTR _cbData$209663[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$209664[ebp], eax
	cmp	DWORD PTR _pbData$209664[ebp], 0
	jne	SHORT $L209666

; 7283 : 		{
; 7284 : 			zFree(*signedXML);

	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_rFree
	add	esp, 4

; 7285 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 7286 : 			return FALSE;

	xor	eax, eax
	jmp	$L209129
$L209666:

; 7287 : 		}
; 7288 : 		if ((cbData  = base64encode(*signedXML,srcSize,(unsigned char*)pbData,cbData+1))==-1) 

	mov	edx, DWORD PTR _cbData$209663[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbData$209664[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcSize$209662[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedXML$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$209663[ebp], eax
	cmp	DWORD PTR _cbData$209663[ebp], -1
	jne	SHORT $L209668

; 7289 : 		{
; 7290 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 7291 : 			zFree(*signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4

; 7292 : 			zFree(pbData);

	mov	edx, DWORD PTR _pbData$209664[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 7293 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L209129
$L209668:

; 7294 : 		}
; 7295 : 		*(pbData+cbData)='\0';

	mov	eax, DWORD PTR _pbData$209664[ebp]
	add	eax, DWORD PTR _cbData$209663[ebp]
	mov	BYTE PTR [eax], 0

; 7296 : 		xmlFree(*signedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7297 : 		*signedXML = pbData;

	mov	eax, DWORD PTR _signedXML$[ebp]
	mov	ecx, DWORD PTR _pbData$209664[ebp]
	mov	DWORD PTR [eax], ecx

; 7298 : 		*signedXmlSize = cbData;

	mov	edx, DWORD PTR _signedXmlSize$[ebp]
	mov	eax, DWORD PTR _cbData$209663[ebp]
	mov	DWORD PTR [edx], eax
$L209661:

; 7299 : 	}
; 7300 : 	ExitLog;	 
; 7301 : 	return TRUE;

	mov	eax, 1
$L209129:

; 7302 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221530
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 1240				; 000004d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221530:
	DD	25					; 00000019H
	DD	$L221529
$L221529:
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221502
	DD	-56					; ffffffc8H
	DD	4
	DD	$L221503
	DD	-76					; ffffffb4H
	DD	4
	DD	$L221504
	DD	-120					; ffffff88H
	DD	4
	DD	$L221505
	DD	-132					; ffffff7cH
	DD	4
	DD	$L221506
	DD	-192					; ffffff40H
	DD	4
	DD	$L221507
	DD	-204					; ffffff34H
	DD	4
	DD	$L221508
	DD	-216					; ffffff28H
	DD	4
	DD	$L221509
	DD	-236					; ffffff14H
	DD	12					; 0000000cH
	DD	$L221510
	DD	-264					; fffffef8H
	DD	16					; 00000010H
	DD	$L221511
	DD	-284					; fffffee4H
	DD	12					; 0000000cH
	DD	$L221512
	DD	-708					; fffffd3cH
	DD	400					; 00000190H
	DD	$L221513
	DD	-752					; fffffd10H
	DD	28					; 0000001cH
	DD	$L221514
	DD	-816					; fffffcd0H
	DD	56					; 00000038H
	DD	$L221515
	DD	-856					; fffffca8H
	DD	28					; 0000001cH
	DD	$L221516
	DD	-892					; fffffc84H
	DD	28					; 0000001cH
	DD	$L221517
	DD	-908					; fffffc74H
	DD	8
	DD	$L221518
	DD	-932					; fffffc5cH
	DD	16					; 00000010H
	DD	$L221519
	DD	-972					; fffffc34H
	DD	28					; 0000001cH
	DD	$L221520
	DD	-996					; fffffc1cH
	DD	4
	DD	$L221521
	DD	-1052					; fffffbe4H
	DD	28					; 0000001cH
	DD	$L221522
	DD	-1088					; fffffbc0H
	DD	28					; 0000001cH
	DD	$L221523
	DD	-1112					; fffffba8H
	DD	8
	DD	$L221524
	DD	-1128					; fffffb98H
	DD	4
	DD	$L221525
	DD	-1152					; fffffb80H
	DD	4
	DD	$L221526
$L221526:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	72					; 00000048H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	104					; 00000068H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221525:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L221524:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221523:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	79					; 0000004fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	0
$L221522:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221521:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221520:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221519:
	DB	115					; 00000073H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221518:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221517:
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221516:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	0
$L221515:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	0
$L221514:
	DB	115					; 00000073H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	0
$L221513:
	DB	119					; 00000077H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221512:
	DB	115					; 00000073H
	DB	0
$L221511:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221510:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	80					; 00000050H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	0
$L221509:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221508:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	78					; 0000004eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L221507:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L221506:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	0
$L221505:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221504:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221503:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221502:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221492:
	lea	ecx, DWORD PTR _certSerialNumber$209175[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221494:
	lea	ecx, DWORD PTR _pfxFilePath$209177[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L221495:
	lea	ecx, DWORD PTR _day$209358[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L221496:
	lea	ecx, DWORD PTR _month$209359[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L221497:
	lea	ecx, DWORD PTR _propNameStr$209379[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L221498:
	lea	ecx, DWORD PTR _propNameStr$209449[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L221499:
	lea	ecx, DWORD PTR _verOptions$209516[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z:
	mov	eax, OFFSET FLAT:$T221501
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ENDP ; CSignature::CreateSigFromTmplBlob
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0IObjectWithSite@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IObjectWithSite@@QAE@XZ PROC NEAR			; IObjectWithSite::IObjectWithSite, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0IObjectWithSite@@QAE@XZ ENDP				; IObjectWithSite::IObjectWithSite
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0IDispatch@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IDispatch@@QAE@XZ PROC NEAR				; IDispatch::IDispatch, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0IDispatch@@QAE@XZ ENDP				; IDispatch::IDispatch
_TEXT	ENDS
EXTRN	??0CNtpTime@@QAE@XZ:NEAR			; CNtpTime::CNtpTime
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0NtpServerResponse@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0NtpServerResponse@@QAE@XZ PROC NEAR			; NtpServerResponse::NtpServerResponse, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0CNtpTime@@QAE@XZ			; CNtpTime::CNtpTime
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0CNtpTime@@QAE@XZ			; CNtpTime::CNtpTime
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0CNtpTime@@QAE@XZ			; CNtpTime::CNtpTime
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0CNtpTime@@QAE@XZ			; CNtpTime::CNtpTime
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0NtpServerResponse@@QAE@XZ ENDP			; NtpServerResponse::NtpServerResponse
_TEXT	ENDS
PUBLIC	?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z ; CSignature::PFXExportActiveCertificate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_certId$ = -4						; size = 4
_this$ = 8						; size = 4
_password$ = 12						; size = 4
_pfxFilePath$ = 16					; size = 4
?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::PFXExportActiveCertificate

; 7305 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 7306 : 	BSTR certId;
; 7307 : 	EnterLog;
; 7308 : 	if ((CurrentCertificate != NOT_INITIALIZED) && (CurrentCertificate != USE_PFX_CERT) && (CurrentCertificate != USE_BASE64_CERT))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], -1
	je	SHORT $L209677
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+120], -2			; fffffffeH
	je	SHORT $L209677
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -3			; fffffffdH
	je	SHORT $L209677

; 7309 : 	{
; 7310 : 		certId = A2WBSTR((LPCSTR)cV[CurrentCertificate]->serialNumber);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+120]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [eax+ecx*4]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _certId$[ebp], eax

; 7311 : 		PFXExportCertificate(certId, password, pfxFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _pfxFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _password$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+152]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7312 : 		SysFreeString(certId);

	mov	esi, esp
	mov	edx, DWORD PTR _certId$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L209677:

; 7313 : 	}
; 7314 : 	ExitLog;
; 7315 : 	return S_OK;

	xor	eax, eax

; 7316 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z ENDP ; CSignature::PFXExportActiveCertificate
_TEXT	ENDS
PUBLIC	?get_HostName@CSignature@@UAGJPAPAG@Z		; CSignature::get_HostName
EXTRN	__imp__GetComputerNameA@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -300						; size = 4
__lpw$ = -296						; size = 4
__acp$ = -292						; size = 4
__convert$ = -288					; size = 4
_lpnSize$ = -280					; size = 4
_lpBuffer$ = -268					; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_HostName@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::get_HostName

; 7319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 75					; 0000004bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7320 : 	char lpBuffer[MAX_PATH];
; 7321 : 	unsigned long lpnSize=MAX_PATH;

	mov	DWORD PTR _lpnSize$[ebp], 260		; 00000104H

; 7322 : 
; 7323 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 7324 : 	EnterLog;
; 7325 : #ifdef WIN32
; 7326 : 	GetComputerName(lpBuffer,           // name buffer
; 7327 : 				&lpnSize                // size of name buffer
; 7328 : 				);

	mov	esi, esp
	lea	eax, DWORD PTR _lpnSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpBuffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetComputerNameA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7329 : #else
; 7330 : 	gethostname(lpBuffer, MAX_PATH);
; 7331 : #endif
; 7332 : 	*pVal = A2WBSTR((LPCSTR)lpBuffer);

	push	-1
	lea	edx, DWORD PTR _lpBuffer$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7333 : 	ExitLog;
; 7334 : 	return S_OK;

	xor	eax, eax

; 7335 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221545
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221545:
	DD	2
	DD	$L221544
$L221544:
	DD	-268					; fffffef4H
	DD	260					; 00000104H
	DD	$L221541
	DD	-280					; fffffee8H
	DD	4
	DD	$L221542
$L221542:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221541:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?get_HostName@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_HostName
_TEXT	ENDS
PUBLIC	?get_TimeStampURL@CSignature@@UAGJPAPAG@Z	; CSignature::get_TimeStampURL
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_TimeStampURL@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_TimeStampURL

; 7338 : {

	push	ebp
	mov	ebp, esp

; 7339 : 	EnterLog;
; 7340 : 	*pVal = TimeStampURL.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7341 : 	ExitLog;
; 7342 : 	return S_OK;

	xor	eax, eax

; 7343 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_TimeStampURL@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_TimeStampURL
_TEXT	ENDS
PUBLIC	?put_TimeStampURL@CSignature@@UAGJPAG@Z		; CSignature::put_TimeStampURL
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_TimeStampURL@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_TimeStampURL

; 7346 : {

	push	ebp
	mov	ebp, esp

; 7347 : 	EnterLog;
; 7348 : 	TimeStampURL.Empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 7349 : 	TimeStampURL = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7350 : 	ExitLog;
; 7351 : 	return S_OK;

	xor	eax, eax

; 7352 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_TimeStampURL@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_TimeStampURL
_TEXT	ENDS
PUBLIC	?get_TimeStamping@CSignature@@UAGJPAH@Z		; CSignature::get_TimeStamping
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_TimeStamping@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_TimeStamping

; 7356 : {

	push	ebp
	mov	ebp, esp

; 7357 : 	EnterLog;
; 7358 : 	*pVal = TimeStampOption;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+940]
	mov	DWORD PTR [eax], edx

; 7359 : 	ExitLog;
; 7360 : 	return S_OK;

	xor	eax, eax

; 7361 : }

	pop	ebp
	ret	8
?get_TimeStamping@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_TimeStamping
_TEXT	ENDS
PUBLIC	?put_TimeStamping@CSignature@@UAGJH@Z		; CSignature::put_TimeStamping
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_TimeStamping@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_TimeStamping

; 7364 : {

	push	ebp
	mov	ebp, esp

; 7365 : 	EnterLog;
; 7366 : 	TimeStampOption = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+940], ecx

; 7367 : 	if (TimeStampURL.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209711

; 7368 : 	{
; 7369 : 		TimeStampURL = A2WBSTR((LPCSTR) defaultTimeServiceUrl);

	push	-1
	push	OFFSET FLAT:$SG209713
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 936				; 000003a8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
$L209711:

; 7370 : 	}
; 7371 : 	ExitLog;
; 7372 : 	return S_OK;

	xor	eax, eax

; 7373 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_TimeStamping@CSignature@@UAGJH@Z ENDP		; CSignature::put_TimeStamping
_TEXT	ENDS
PUBLIC	?get_HostOsType@CSignature@@UAGJPAJ@Z		; CSignature::get_HostOsType
EXTRN	?getHostOsType@CLicense@@SAJXZ:NEAR		; CLicense::getHostOsType
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_HostOsType@CSignature@@UAGJPAJ@Z PROC NEAR		; CSignature::get_HostOsType

; 7376 : {

	push	ebp
	mov	ebp, esp

; 7377 : 	EnterLog;
; 7378 : #ifdef WIN32
; 7379 : 	*pVal = CLicense::getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7380 : #endif
; 7381 : 	ExitLog;
; 7382 : 	return S_OK;

	xor	eax, eax

; 7383 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_HostOsType@CSignature@@UAGJPAJ@Z ENDP		; CSignature::get_HostOsType
_TEXT	ENDS
PUBLIC	?get_CrlChecking@CSignature@@UAGJPAH@Z		; CSignature::get_CrlChecking
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CrlChecking@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_CrlChecking

; 7386 : {

	push	ebp
	mov	ebp, esp

; 7387 : 	EnterLog;
; 7388 : 	*pVal = CertVerifyParams.verificationOptions & VERIFY_CRL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, 1
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], ecx

; 7389 : 	ExitLog;
; 7390 : 	return S_OK;

	xor	eax, eax

; 7391 : }

	pop	ebp
	ret	8
?get_CrlChecking@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_CrlChecking
_TEXT	ENDS
PUBLIC	?put_CrlChecking@CSignature@@UAGJH@Z		; CSignature::put_CrlChecking
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CrlChecking@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_CrlChecking

; 7394 : {

	push	ebp
	mov	ebp, esp

; 7395 : 	EnterLog;
; 7396 : 	if (DoDCompliance == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jne	SHORT $L209729

; 7397 : 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L209730

; 7398 : 			CertVerifyParams.verificationOptions |= VERIFY_CRL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 7399 : 		else

	jmp	SHORT $L209729
$L209730:

; 7400 : 			CertVerifyParams.verificationOptions &= (~VERIFY_CRL);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx
$L209729:

; 7401 : 	ExitLog;
; 7402 : 	return S_OK;

	xor	eax, eax

; 7403 : }

	pop	ebp
	ret	8
?put_CrlChecking@CSignature@@UAGJH@Z ENDP		; CSignature::put_CrlChecking
_TEXT	ENDS
PUBLIC	_localTimeToUtcTime
PUBLIC	?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z	; CSignature::get_SigCertStatus
EXTRN	_jsUtcTimeToSystem:NEAR
EXTRN	_wcscmp:NEAR
xdata$x	SEGMENT
$T221579 DD	0ffffffffH
	DD	FLAT:$L221557
	DD	00H
	DD	FLAT:$L221558
$T221560 DD	019930520H
	DD	02H
	DD	FLAT:$T221579
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv351 = -144						; size = 4
tv211 = -140						; size = 4
$T221561 = -133						; size = 1
$T221556 = -132						; size = 4
$T221555 = -128						; size = 4
$T221554 = -124						; size = 4
_propName$209770 = -116					; size = 4
_tsProp$209769 = -104					; size = 4
_i$209763 = -96						; size = 4
__lpa$ = -92						; size = 4
__lpw$ = -88						; size = 4
__acp$ = -84						; size = 4
__convert$ = -80					; size = 4
_timeStampFormat$ = -76					; size = 4
_result$ = -72						; size = 4
_charLocAtTime$ = -68					; size = 4
_ptsSysTime$ = -64					; size = 4
_tsSysTime$ = -56					; size = 16
_localAtTime$ = -32					; size = 4
_tsData$ = -24						; size = 4
_tsAttrText$ = -20					; size = 4
_hResult$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_atTime$ = 16						; size = 4
_timeFormat$ = 20					; size = 4
_pVal$ = 24						; size = 4
?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z PROC NEAR	; CSignature::get_SigCertStatus

; 7406 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 132				; 00000084H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 33					; 00000021H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T221561[ebp], 0

; 7407 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 7408 : 	*pVal = FALSE;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 7409 : 	char *tsAttrText, *tsData;
; 7410 : 	CComBSTR localAtTime;

	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 7411 : 	SYSTEMTIME tsSysTime;
; 7412 : 	LPSYSTEMTIME ptsSysTime;
; 7413 : 	char *charLocAtTime;
; 7414 : 	BOOL result;
; 7415 : 	int timeStampFormat=0;

	mov	DWORD PTR _timeStampFormat$[ebp], 0

; 7416 : 
; 7417 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 7418 : 	//DebugBreak();
; 7419 : 	EnterLog;
; 7420 : 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L209754

; 7421 : 	{
; 7422 : 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 7423 : 		return S_FALSE;

	mov	DWORD PTR $T221554[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221554[ebp]
	jmp	$L209739
$L209754:

; 7424 : 	}
; 7425 : 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L209758
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L209757
$L209758:

; 7426 : 	{
; 7427 : 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 7428 : 		return S_FALSE;

	mov	DWORD PTR $T221555[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221555[ebp]
	jmp	$L209739
$L209757:

; 7429 : 	}
; 7430 : 
; 7431 : 	localAtTime = atTime;

	mov	edx, DWORD PTR _atTime$[ebp]
	push	edx
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7432 : 	CertVerifyParams.recCrlCount = sgArr[sigIndex]->crlDataCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx+1844], edx

; 7433 : 	CertVerifyParams.recCrlList  = (LPSTR *)sgArr[sigIndex]->crlDataList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	mov	DWORD PTR [ecx+1840], edx

; 7434 : 
; 7435 : 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 7436 : 		(CertVerifyParams.usedCrlList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1888], 0
	je	$L209762
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1892], 0
	je	SHORT $L209762

; 7437 : 	{
; 7438 : 		for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$209763[ebp], 0
	jmp	SHORT $L209764
$L209765:
	mov	edx, DWORD PTR _i$209763[ebp]
	add	edx, 1
	mov	DWORD PTR _i$209763[ebp], edx
$L209764:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$209763[ebp]
	cmp	ecx, DWORD PTR [eax+1888]
	jae	SHORT $L209766

; 7439 : 		{
; 7440 : 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$209763[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L209767

; 7441 : 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$209763[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L209767:

; 7442 : 		}

	jmp	SHORT $L209765
$L209766:

; 7443 : 		zFree(CertVerifyParams.usedCrlList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	push	ecx
	call	_rFree
	add	esp, 4

; 7444 : 		CertVerifyParams.usedCrlList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1892], 0

; 7445 : 		CertVerifyParams.usedCrlCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1888], 0
$L209762:

; 7446 : 	}
; 7447 : 
; 7448 : 	if (sgArr[sigIndex]->certificatesCount != 0) // There is a certificate available

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	$L209768

; 7449 : 	{
; 7450 : 		BSTR tsProp=NULL;

	mov	DWORD PTR _tsProp$209769[ebp], 0

; 7451 : 		CComBSTR propName;

	lea	ecx, DWORD PTR _propName$209770[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 7452 : 		// Check to see if signature time stamp is provided
; 7453 : 
; 7454 : 		if (localAtTime.Length() == 0) // No time is provided

	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	$L209771

; 7455 : 		{
; 7456 : 			tsAttrText = (char *)zMalloc(MAX_TS_PROP_ATTR);

	push	1024					; 00000400H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tsAttrText$[ebp], eax

; 7457 : 			memset(tsAttrText,0,MAX_TS_PROP_ATTR);

	push	1024					; 00000400H
	push	0
	mov	edx, DWORD PTR _tsAttrText$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 7458 : 
; 7459 : 			strcat(tsAttrText, (const char *)TIME_STAMP_PREFIX);

	push	OFFSET FLAT:$SG209774
	mov	eax, DWORD PTR _tsAttrText$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7460 : 			if (sgArr[sigIndex]->sigId != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L209775

; 7461 : 			{
; 7462 : 				strcat(tsAttrText, (const char *)sgArr[sigIndex]->sigId);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _tsAttrText$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L209775:

; 7463 : 			}
; 7464 : 
; 7465 : 			propName = tsAttrText;

	mov	edx, DWORD PTR _tsAttrText$[ebp]
	push	edx
	lea	ecx, DWORD PTR _propName$209770[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 7466 : 
; 7467 : 			GetSigPropValueByName(sigIndex, propName.m_str, &tsProp);

	mov	esi, esp
	lea	eax, DWORD PTR _tsProp$209769[ebp]
	push	eax
	mov	ecx, DWORD PTR _propName$209770[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+560]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7468 : 			if (tsProp != NULL)

	cmp	DWORD PTR _tsProp$209769[ebp], 0
	je	$L209777

; 7469 : 			{
; 7470 : 				tsData = (char *)HeapW2A(tsProp);

	mov	eax, DWORD PTR _tsProp$209769[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tsData$[ebp], eax

; 7471 : 				zFree(tsAttrText);

	mov	ecx, DWORD PTR _tsAttrText$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7472 : 				SysFreeString(tsProp);

	mov	esi, esp
	mov	edx, DWORD PTR _tsProp$209769[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7473 : 				tsProp = NULL;

	mov	DWORD PTR _tsProp$209769[ebp], 0

; 7474 : 				//Time stamp string has been found. Now lets find out what format it is in
; 7475 : 				propName = TIME_STAMP_FORMAT;

	push	OFFSET FLAT:$SG209779
	lea	ecx, DWORD PTR _propName$209770[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7476 : 				GetSigPropValueByName(sigIndex, propName.m_str, &tsProp);

	mov	esi, esp
	lea	eax, DWORD PTR _tsProp$209769[ebp]
	push	eax
	mov	ecx, DWORD PTR _propName$209770[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigIndex$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+560]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7477 : 				if (tsProp == NULL)

	cmp	DWORD PTR _tsProp$209769[ebp], 0
	jne	SHORT $L209780

; 7478 : 				{
; 7479 : 					timeStampFormat = TIME_RFC;

	mov	DWORD PTR _timeStampFormat$[ebp], 0

; 7480 : 				}
; 7481 : 				else

	jmp	SHORT $L209781
$L209780:

; 7482 : 				{
; 7483 : 					if (!(wcscmp((const WCHAR *)L"1",tsProp)))

	mov	eax, DWORD PTR _tsProp$209769[ebp]
	push	eax
	push	OFFSET FLAT:$SG209784
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L209783

; 7484 : 					{
; 7485 : 						timeStampFormat = TIME_VB_NOW;

	mov	DWORD PTR _timeStampFormat$[ebp], 1

; 7486 : 					}
; 7487 : 					else

	jmp	SHORT $L209781
$L209783:

; 7488 : 						if (!(wcscmp((const WCHAR *)L"2", tsProp)))

	mov	ecx, DWORD PTR _tsProp$209769[ebp]
	push	ecx
	push	OFFSET FLAT:$SG209788
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L209787

; 7489 : 						{
; 7490 : 							timeStampFormat = TIME_JS_UTC;

	mov	DWORD PTR _timeStampFormat$[ebp], 2

; 7491 : 						}
; 7492 : 						else

	jmp	SHORT $L209781
$L209787:

; 7493 : 						{
; 7494 : 							timeStampFormat = TIME_RFC;

	mov	DWORD PTR _timeStampFormat$[ebp], 0
$L209781:

; 7495 : 						}
; 7496 : 				}
; 7497 : 				// Now covert this time to SYSTEMTIME and call crVerifyCertificate
; 7498 : 				switch (timeStampFormat)

	mov	edx, DWORD PTR _timeStampFormat$[ebp]
	mov	DWORD PTR tv211[ebp], edx
	cmp	DWORD PTR tv211[ebp], 0
	je	SHORT $L209794
	cmp	DWORD PTR tv211[ebp], 1
	je	SHORT $L209796
	cmp	DWORD PTR tv211[ebp], 2
	je	SHORT $L209798
	jmp	SHORT $L209800
$L209794:

; 7499 : 				{
; 7500 : 					case TIME_RFC:		ptsSysTime = rfcTimeToSystem((unsigned char *)tsData);

	mov	eax, DWORD PTR _tsData$[ebp]
	push	eax
	call	_rfcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7501 : 										break;

	jmp	SHORT $L209791
$L209796:

; 7502 : 					case TIME_VB_NOW:	ptsSysTime = vbNowTimeToSystem((unsigned char *)tsData);

	mov	ecx, DWORD PTR _tsData$[ebp]
	push	ecx
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7503 : 										break;

	jmp	SHORT $L209791
$L209798:

; 7504 : 					case TIME_JS_UTC:	ptsSysTime = jsUtcTimeToSystem((BYTE *)tsData);

	mov	edx, DWORD PTR _tsData$[ebp]
	push	edx
	call	_jsUtcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7505 : 										break;

	jmp	SHORT $L209791
$L209800:

; 7506 : 					default:			ptsSysTime = rfcTimeToSystem((unsigned char *)tsData);

	mov	eax, DWORD PTR _tsData$[ebp]
	push	eax
	call	_rfcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax
$L209791:

; 7507 : 				}
; 7508 : 				zFree(tsData);

	mov	ecx, DWORD PTR _tsData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7509 : 				if (useCam)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	SHORT $L209802

; 7510 : 					result = crVerifyCertificateUsingCam(sgArr[sigIndex]->certificates,
; 7511 : 										sgArr[sigIndex]->certificatesCount,
; 7512 : 										ptsSysTime, 
; 7513 : 										NULL, 
; 7514 : 										&CertVerifyParams,
; 7515 : 										SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221562
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221562:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	push	0
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 7516 : 				else

	jmp	$L209803
$L209802:

; 7517 : 					if (useOcsp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	je	SHORT $L209804

; 7518 : 						result = crVerifyCertificateUsingOcsp(sgArr[sigIndex]->certificates,
; 7519 : 											sgArr[sigIndex]->certificatesCount,
; 7520 : 											ptsSysTime, 
; 7521 : 											NULL, 
; 7522 : 											&CertVerifyParams,
; 7523 : 											SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221564
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221564:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	push	0
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 7524 : 					else

	jmp	SHORT $L209803
$L209804:

; 7525 : 						result = crVerifyCertificate(sgArr[sigIndex]->certificates,
; 7526 : 											sgArr[sigIndex]->certificatesCount,
; 7527 : 											ptsSysTime, 
; 7528 : 											NULL, 
; 7529 : 											&CertVerifyParams,
; 7530 : 											SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221565
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221565:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	push	0
	mov	edx, DWORD PTR _ptsSysTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L209803:

; 7531 : 
; 7532 : 				if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L209806

; 7533 : 				{
; 7534 : 					*pVal = axGetLastError(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetLastError
	add	esp, 4
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7535 : 				}
; 7536 : 				else

	jmp	SHORT $L209807
$L209806:

; 7537 : 					*pVal = 0;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 0
$L209807:

; 7538 : 				zFree(ptsSysTime);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221566
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221566:
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 7539 : 				SysFreeString(tsProp);

	mov	esi, esp
	mov	ecx, DWORD PTR _tsProp$209769[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7540 : 			}
; 7541 : 			else // TimeStamp Not Found so use current system time

	jmp	$L209808
$L209777:

; 7542 : 			{
; 7543 : #ifdef WIN32
; 7544 : 				GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	edx, DWORD PTR _tsSysTime$[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7545 : #else
; 7546 : 				GetSystemTimeLinux(&tsSysTime);
; 7547 : #endif
; 7548 : 				if (useCam)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1908], 0
	je	SHORT $L209809

; 7549 : 					result = crVerifyCertificateUsingCam(sgArr[sigIndex]->certificates,
; 7550 : 										sgArr[sigIndex]->certificatesCount,
; 7551 : 										&tsSysTime, 
; 7552 : 										NULL, 
; 7553 : 										&CertVerifyParams,
; 7554 : 										SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1828				; 00000724H
	push	eax
	push	0
	lea	ecx, DWORD PTR _tsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 7555 : 				else

	jmp	$L209810
$L209809:

; 7556 : 					if (useOcsp)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 0
	je	SHORT $L209811

; 7557 : 						result = crVerifyCertificateUsingOcsp(sgArr[sigIndex]->certificates,
; 7558 : 											sgArr[sigIndex]->certificatesCount,
; 7559 : 											&tsSysTime, 
; 7560 : 											NULL, 
; 7561 : 											&CertVerifyParams,
; 7562 : 											SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1828				; 00000724H
	push	eax
	push	0
	lea	ecx, DWORD PTR _tsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 7563 : 					else

	jmp	SHORT $L209810
$L209811:

; 7564 : 						result = crVerifyCertificate(sgArr[sigIndex]->certificates,
; 7565 : 											sgArr[sigIndex]->certificatesCount,
; 7566 : 											&tsSysTime, 
; 7567 : 											NULL, 
; 7568 : 											&CertVerifyParams,
; 7569 : 											SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	push	0
	lea	eax, DWORD PTR _tsSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L209810:

; 7570 : 
; 7571 : 				if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L209813

; 7572 : 				{
; 7573 : 					*pVal = axGetLastError(SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_axGetLastError
	add	esp, 4
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7574 : 				}
; 7575 : 				else

	jmp	SHORT $L209808
$L209813:

; 7576 : 					*pVal = 0;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 0
$L209808:

; 7577 : 			}
; 7578 : 		} // No Time Provided
; 7579 : 		else

	jmp	$L209815
$L209771:

; 7580 : 		{ // Time was provided
; 7581 : 
; 7582 : 			charLocAtTime = (char *)HeapW2A(atTime);

	mov	eax, DWORD PTR _atTime$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charLocAtTime$[ebp], eax

; 7583 : 			// Now covert this time to SYSTEMTIME and call crVerifyCertificate
; 7584 : 
; 7585 : 			switch(timeFormat)

	mov	ecx, DWORD PTR _timeFormat$[ebp]
	mov	DWORD PTR tv351[ebp], ecx
	cmp	DWORD PTR tv351[ebp], 0
	je	SHORT $L209821
	cmp	DWORD PTR tv351[ebp], 1
	je	SHORT $L209823
	cmp	DWORD PTR tv351[ebp], 2
	je	SHORT $L209825
	jmp	SHORT $L209818
$L209821:

; 7586 : 			{
; 7587 : 				case TIME_RFC:
; 7588 : 						ptsSysTime = rfcTimeToSystem((unsigned char *)charLocAtTime);

	mov	edx, DWORD PTR _charLocAtTime$[ebp]
	push	edx
	call	_rfcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7589 : 						break;

	jmp	SHORT $L209818
$L209823:

; 7590 : 				case TIME_VB_NOW:
; 7591 : 						ptsSysTime = vbNowTimeToSystem((unsigned char *)charLocAtTime);

	mov	eax, DWORD PTR _charLocAtTime$[ebp]
	push	eax
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7592 : 						localTimeToUtcTime(ptsSysTime);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221567
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221567:
	mov	ecx, DWORD PTR _ptsSysTime$[ebp]
	push	ecx
	call	_localTimeToUtcTime
	add	esp, 4

; 7593 : 						break;

	jmp	SHORT $L209818
$L209825:

; 7594 : 				case TIME_JS_UTC:
; 7595 : 						ptsSysTime = jsUtcTimeToSystem((unsigned char *)charLocAtTime);

	mov	edx, DWORD PTR _charLocAtTime$[ebp]
	push	edx
	call	_jsUtcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221561[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax
$L209818:

; 7596 : 						break;
; 7597 : 				default:
; 7598 : 					break;
; 7599 : 			}
; 7600 : 			zFree(charLocAtTime);

	mov	eax, DWORD PTR _charLocAtTime$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 7601 : 
; 7602 : 			if (useCam)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1908], 0
	je	SHORT $L209828

; 7603 : 				result = crVerifyCertificateUsingCam(sgArr[sigIndex]->certificates,
; 7604 : 									sgArr[sigIndex]->certificatesCount,
; 7605 : 									ptsSysTime, 
; 7606 : 									NULL, 
; 7607 : 									&CertVerifyParams,
; 7608 : 									SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221568
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221568:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	push	0
	mov	edx, DWORD PTR _ptsSysTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 7609 : 			else

	jmp	$L209829
$L209828:

; 7610 : 				if (useOcsp)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1912], 0
	je	SHORT $L209830

; 7611 : 					result = crVerifyCertificateUsingOcsp(sgArr[sigIndex]->certificates,
; 7612 : 										sgArr[sigIndex]->certificatesCount,
; 7613 : 										ptsSysTime, 
; 7614 : 										NULL, 
; 7615 : 										&CertVerifyParams,
; 7616 : 										SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221569
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221569:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	push	0
	mov	edx, DWORD PTR _ptsSysTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 7617 : 				else

	jmp	SHORT $L209829
$L209830:

; 7618 : 					result = crVerifyCertificate(sgArr[sigIndex]->certificates,
; 7619 : 										sgArr[sigIndex]->certificatesCount,
; 7620 : 										ptsSysTime, 
; 7621 : 										NULL, 
; 7622 : 										&CertVerifyParams,
; 7623 : 										SigHandle);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221570
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221570:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1828				; 00000724H
	push	eax
	push	0
	mov	ecx, DWORD PTR _ptsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L209829:

; 7624 : 			if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L209832

; 7625 : 			{
; 7626 : 				*pVal = axGetLastError(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_axGetLastError
	add	esp, 4
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 7627 : 			}
; 7628 : 			else

	jmp	SHORT $L209833
$L209832:

; 7629 : 				*pVal = 0;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0
$L209833:

; 7630 : 			zFree(ptsSysTime);

	cmp	BYTE PTR $T221561[ebp], 0
	jne	SHORT $L221571
	push	OFFSET FLAT:$L221563
	call	__RTC_UninitUse
	add	esp, 4
$L221571:
	mov	ecx, DWORD PTR _ptsSysTime$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209815:

; 7631 : 
; 7632 : 		}
; 7633 : 	} // There is a certificate available

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _propName$209770[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR

; 7634 : 	else

	jmp	SHORT $L209834
$L209768:

; 7635 : 		*pVal = CERT_NOT_FOUND;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 28			; 0000001cH
$L209834:

; 7636 : 	ExitLog;
; 7637 : 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
	mov	DWORD PTR $T221556[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221556[ebp]
$L209739:

; 7638 : 
; 7639 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221578
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 144				; 00000090H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221578:
	DD	4
	DD	$L221577
$L221577:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221572
	DD	-56					; ffffffc8H
	DD	16					; 00000010H
	DD	$L221573
	DD	-104					; ffffff98H
	DD	4
	DD	$L221574
	DD	-116					; ffffff8cH
	DD	4
	DD	$L221575
$L221575:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221574:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	0
$L221573:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221572:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221563:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221557:
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221558:
	lea	ecx, DWORD PTR _propName$209770[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z:
	mov	eax, OFFSET FLAT:$T221560
	jmp	___CxxFrameHandler
text$x	ENDS
?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z ENDP	; CSignature::get_SigCertStatus
PUBLIC	?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z	; CSignature::VerifyX509CertCRL
PUBLIC	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
xdata$x	SEGMENT
$T221599 DD	0ffffffffH
	DD	FLAT:$L221582
	DD	00H
	DD	FLAT:$L221583
	DD	01H
	DD	FLAT:$L221584
$T221586 DD	019930520H
	DD	03H
	DD	FLAT:$T221599
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv157 = -116						; size = 4
$T221587 = -109						; size = 1
$T221581 = -108						; size = 4
_i$209855 = -104					; size = 4
__lpa$ = -100						; size = 4
__lpw$ = -96						; size = 4
__acp$ = -92						; size = 4
__convert$ = -88					; size = 4
_charLocAtTime$ = -84					; size = 4
_ptsSysTime$ = -80					; size = 4
_localAtTime$ = -72					; size = 4
_tsSysTime$ = -60					; size = 16
_charCertData$ = -40					; size = 4
_locAtTime$ = -32					; size = 4
_locCertData$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_certData$ = 12						; size = 4
_atTime$ = 16						; size = 4
_timeFormat$ = 20					; size = 4
_pVal$ = 24						; size = 4
?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z PROC NEAR	; CSignature::VerifyX509CertCRL

; 7642 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T221587[ebp], 0

; 7643 : 	CComBSTR locCertData, locAtTime;

	lea	ecx, DWORD PTR _locCertData$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 7644 : 	unsigned char *charCertData;
; 7645 : 	SYSTEMTIME	tsSysTime;
; 7646 : 	CComBSTR localAtTime;

	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 7647 : 	LPSYSTEMTIME ptsSysTime;
; 7648 : 	char *charLocAtTime;
; 7649 : 
; 7650 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 7651 : 
; 7652 : 	EnterLog;
; 7653 : 
; 7654 : 	locCertData = certData;

	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _locCertData$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7655 : 	locAtTime	= atTime;

	mov	ecx, DWORD PTR _atTime$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7656 : 
; 7657 : 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 7658 : 		(CertVerifyParams.usedCrlList != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	$L209854
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1892], 0
	je	SHORT $L209854

; 7659 : 	{
; 7660 : 		for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$209855[ebp], 0
	jmp	SHORT $L209856
$L209857:
	mov	ecx, DWORD PTR _i$209855[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$209855[ebp], ecx
$L209856:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$209855[ebp]
	cmp	eax, DWORD PTR [edx+1888]
	jae	SHORT $L209858

; 7661 : 		{
; 7662 : 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$209855[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L209859

; 7663 : 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$209855[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L209859:

; 7664 : 		}

	jmp	SHORT $L209857
$L209858:

; 7665 : 		zFree(CertVerifyParams.usedCrlList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	push	eax
	call	_rFree
	add	esp, 4

; 7666 : 		CertVerifyParams.usedCrlList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1892], 0

; 7667 : 		CertVerifyParams.usedCrlCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1888], 0
$L209854:

; 7668 : 	}
; 7669 : 
; 7670 : 	if (locCertData.Length() != 0) // Certificate data present

	lea	ecx, DWORD PTR _locCertData$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L209860

; 7671 : 	{
; 7672 : 		charCertData = HeapW2A(certData);

	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charCertData$[ebp], eax

; 7673 : 
; 7674 : 		if (locAtTime.Length() == 0) // Use system time

	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209861

; 7675 : 		{
; 7676 : #ifdef WIN32
; 7677 : 			GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	ecx, DWORD PTR _tsSysTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7678 : #else
; 7679 : 			GetSystemTimeLinux(&tsSysTime);
; 7680 : #endif
; 7681 : 			*pVal = CheckCertificateValidity(charCertData, 
; 7682 : 										&tsSysTime, 
; 7683 : 										NULL, 
; 7684 : 										&CertVerifyParams,
; 7685 : 										SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	push	0
	lea	edx, DWORD PTR _tsSysTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _charCertData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7686 : 		}
; 7687 : 		else

	jmp	$L209862
$L209861:

; 7688 : 		{ 
; 7689 : 			charLocAtTime = (char *)HeapW2A(atTime);

	mov	edx, DWORD PTR _atTime$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charLocAtTime$[ebp], eax

; 7690 : 			// Now covert this time to SYSTEMTIME and call CheckCertificateValidity
; 7691 : 
; 7692 : 			switch(timeFormat)

	mov	eax, DWORD PTR _timeFormat$[ebp]
	mov	DWORD PTR tv157[ebp], eax
	cmp	DWORD PTR tv157[ebp], 0
	je	SHORT $L209868
	cmp	DWORD PTR tv157[ebp], 1
	je	SHORT $L209870
	cmp	DWORD PTR tv157[ebp], 2
	je	SHORT $L209872
	jmp	SHORT $L209865
$L209868:

; 7693 : 			{
; 7694 : 				case TIME_RFC:
; 7695 : 					ptsSysTime = rfcTimeToSystem((unsigned char *)charLocAtTime);

	mov	ecx, DWORD PTR _charLocAtTime$[ebp]
	push	ecx
	call	_rfcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221587[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7696 : 					break;

	jmp	SHORT $L209865
$L209870:

; 7697 : 			case TIME_VB_NOW:
; 7698 : 					ptsSysTime = vbNowTimeToSystem((unsigned char *)charLocAtTime);

	mov	edx, DWORD PTR _charLocAtTime$[ebp]
	push	edx
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221587[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7699 : 					localTimeToUtcTime(ptsSysTime);

	cmp	BYTE PTR $T221587[ebp], 0
	jne	SHORT $L221588
	push	OFFSET FLAT:$L221589
	call	__RTC_UninitUse
	add	esp, 4
$L221588:
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	call	_localTimeToUtcTime
	add	esp, 4

; 7700 : 					break;

	jmp	SHORT $L209865
$L209872:

; 7701 : 			case TIME_JS_UTC:
; 7702 : 					ptsSysTime = jsUtcTimeToSystem((unsigned char *)charLocAtTime);

	mov	ecx, DWORD PTR _charLocAtTime$[ebp]
	push	ecx
	call	_jsUtcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221587[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax
$L209865:

; 7703 : 					break;
; 7704 : 			default:
; 7705 : 					break;
; 7706 : 			}
; 7707 : 			charLocAtTime = (char *)HeapW2A(atTime);

	mov	edx, DWORD PTR _atTime$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charLocAtTime$[ebp], eax

; 7708 : 
; 7709 : 			*pVal = CheckCertificateValidity(charCertData, 
; 7710 : 										ptsSysTime, 
; 7711 : 										NULL, 
; 7712 : 										&CertVerifyParams,
; 7713 : 										SigHandle);

	cmp	BYTE PTR $T221587[ebp], 0
	jne	SHORT $L221590
	push	OFFSET FLAT:$L221589
	call	__RTC_UninitUse
	add	esp, 4
$L221590:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	push	0
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charCertData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 7714 : 			zFree(ptsSysTime);

	cmp	BYTE PTR $T221587[ebp], 0
	jne	SHORT $L221591
	push	OFFSET FLAT:$L221589
	call	__RTC_UninitUse
	add	esp, 4
$L221591:
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L209862:

; 7715 : 		}
; 7716 : 		zFree(charCertData);

	mov	ecx, DWORD PTR _charCertData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7717 : 
; 7718 : 	}
; 7719 : 	else

	jmp	SHORT $L209876
$L209860:

; 7720 : 	{
; 7721 : 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 7722 : 		*pVal = FALSE;

	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], 0
$L209876:

; 7723 : 	}
; 7724 : 	ExitLog;
; 7725 : 	return S_OK;

	mov	DWORD PTR $T221581[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locCertData$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221581[ebp]

; 7726 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221598
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221598:
	DD	4
	DD	$L221597
$L221597:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221592
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221593
	DD	-60					; ffffffc4H
	DD	16					; 00000010H
	DD	$L221594
	DD	-72					; ffffffb8H
	DD	4
	DD	$L221595
$L221595:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221594:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221593:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221592:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221589:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221582:
	lea	ecx, DWORD PTR _locCertData$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221583:
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221584:
	lea	ecx, DWORD PTR _localAtTime$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z:
	mov	eax, OFFSET FLAT:$T221586
	jmp	___CxxFrameHandler
text$x	ENDS
?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z ENDP	; CSignature::VerifyX509CertCRL
PUBLIC	?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z	; CSignature::VerifyPFXCertCRL
xdata$x	SEGMENT
$T221623 DD	0ffffffffH
	DD	FLAT:$L221604
	DD	00H
	DD	FLAT:$L221605
$T221607 DD	019930520H
	DD	02H
	DD	FLAT:$T221623
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv190 = -192						; size = 4
$T221608 = -185						; size = 1
$T221603 = -184						; size = 4
$T221602 = -180						; size = 4
$T221601 = -176						; size = 4
_s$209925 = -168					; size = 12
_i$209909 = -152					; size = 4
_tmpCcBstr$ = -144					; size = 4
__lpa$ = -136						; size = 4
__lpw$ = -132						; size = 4
__acp$ = -128						; size = 4
__convert$ = -124					; size = 4
_charLocAtTime$ = -120					; size = 4
_ptsSysTime$ = -116					; size = 4
_tsSysTime$ = -108					; size = 16
_locAtTime$ = -84					; size = 4
_blobPfxPassword$ = -72					; size = 8
_sizeM$ = -60						; size = 4
_szPtr$ = -56						; size = 4
_ptr$ = -52						; size = 4
_b64PfxDataPtr$ = -48					; size = 4
_binFileData$ = -40					; size = 4
_certData$ = -32					; size = 4
_dwBytesToWrite$ = -28					; size = 4
_fileSize$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pfxFileName$ = 12					; size = 4
_pfxPassword$ = 16					; size = 4
_atTime$ = 20						; size = 4
_timeFormat$ = 24					; size = 4
_pVal$ = 28						; size = 4
?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z PROC NEAR	; CSignature::VerifyPFXCertCRL

; 7729 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 180				; 000000b4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 45					; 0000002dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T221608[ebp], 0

; 7730 : 	DWORD fileSize,dwBytesToWrite;
; 7731 : 	char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 7732 : 	unsigned char *binFileData=NULL;

	mov	DWORD PTR _binFileData$[ebp], 0

; 7733 : //	unsigned char *charPfxFileName;
; 7734 : 	unsigned char *b64PfxDataPtr;
; 7735 : 
; 7736 : 	unsigned char *ptr;
; 7737 : 	unsigned int *szPtr;
; 7738 : 	unsigned int sizeM;
; 7739 : 	DS_DATA_BLOB blobPfxPassword;
; 7740 : 	CComBSTR locAtTime;

	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 7741 : 	SYSTEMTIME tsSysTime;
; 7742 : 	LPSYSTEMTIME ptsSysTime;
; 7743 : 	char *charLocAtTime;
; 7744 : 
; 7745 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 7746 : // DebugBreak();
; 7747 : 	CComBSTR	tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 7748 : 
; 7749 : 	EnterLog;
; 7750 : 	tmpCcBstr = pfxFileName;

	mov	eax, DWORD PTR _pfxFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7751 : 	if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209905

; 7752 : 	{
; 7753 : 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 7754 : 		return S_FALSE;

	mov	DWORD PTR $T221601[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221601[ebp]
	jmp	$L209886
$L209905:

; 7755 : 	}
; 7756 : 
; 7757 : 	blobPfxPassword.cbData =0;

	mov	DWORD PTR _blobPfxPassword$[ebp+4], 0

; 7758 : 	locAtTime = atTime;

	mov	eax, DWORD PTR _atTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 7759 : 
; 7760 : 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 7761 : 		(CertVerifyParams.usedCrlList != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1888], 0
	je	$L209908
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1892], 0
	je	$L209908

; 7762 : 	{
; 7763 : 		for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$209909[ebp], 0
	jmp	SHORT $L209910
$L209911:
	mov	eax, DWORD PTR _i$209909[ebp]
	add	eax, 1
	mov	DWORD PTR _i$209909[ebp], eax
$L209910:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$209909[ebp]
	cmp	edx, DWORD PTR [ecx+1888]
	jae	SHORT $L209912

; 7764 : 		{
; 7765 : 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$209909[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L209913

; 7766 : 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$209909[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L209913:

; 7767 : 		}

	jmp	SHORT $L209911
$L209912:

; 7768 : 		zFree(CertVerifyParams.usedCrlList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	push	edx
	call	_rFree
	add	esp, 4

; 7769 : 		CertVerifyParams.usedCrlList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1892], 0

; 7770 : 		CertVerifyParams.usedCrlCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1888], 0
$L209908:

; 7771 : 	}
; 7772 : 
; 7773 : //	charPfxFileName = HeapW2A(pfxFileName);
; 7774 : 	
; 7775 : 	if (ReadAllBin(pfxFileName, &binFileData, &fileSize) == S_FALSE)

	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfxFileName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L209915

; 7776 : 	{
; 7777 : 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 7778 : //		zFree(charPfxFileName);
; 7779 : 		return S_FALSE;

	mov	DWORD PTR $T221602[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221602[ebp]
	jmp	$L209886
$L209915:

; 7780 : 	}
; 7781 : 
; 7782 : 	ptr = (unsigned char *)pfxPassword;

	mov	ecx, DWORD PTR _pfxPassword$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 7783 : 
; 7784 : 	if (ptr != NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $L209919

; 7785 : 	{
; 7786 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _szPtr$[ebp], edx

; 7787 : 		sizeM = *szPtr;

	mov	eax, DWORD PTR _szPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sizeM$[ebp], ecx

; 7788 : 
; 7789 : 		if (sizeM == 0)

	cmp	DWORD PTR _sizeM$[ebp], 0
	jne	SHORT $L209922

; 7790 : 			blobPfxPassword.pbData = NULL;

	mov	DWORD PTR _blobPfxPassword$[ebp], 0

; 7791 : 		else

	jmp	SHORT $L209923
$L209922:

; 7792 : 		{
; 7793 : 			sizeM += 2; // BSTR size does not include the terminating null so add 2 to the size

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 2
	mov	DWORD PTR _sizeM$[ebp], edx

; 7794 : 			blobPfxPassword.pbData		= (unsigned char *) zMalloc(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _blobPfxPassword$[ebp], eax

; 7795 : 			blobPfxPassword.cbData = sizeM;

	mov	ecx, DWORD PTR _sizeM$[ebp]
	mov	DWORD PTR _blobPfxPassword$[ebp+4], ecx

; 7796 : 			memcpy(blobPfxPassword.pbData, ptr, sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blobPfxPassword$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7797 : #ifdef NSS
; 7798 : 			SECItem s;
; 7799 : 			s.data = blobPfxPassword.pbData;

	mov	edx, DWORD PTR _blobPfxPassword$[ebp]
	mov	DWORD PTR _s$209925[ebp+4], edx

; 7800 : 			s.len  = blobPfxPassword.cbData;

	mov	eax, DWORD PTR _blobPfxPassword$[ebp+4]
	mov	DWORD PTR _s$209925[ebp+8], eax

; 7801 : 			SwapUnicodeBytes(&s);

	lea	ecx, DWORD PTR _s$209925[ebp]
	push	ecx
	call	?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z ; CSignature::SwapUnicodeBytes
	add	esp, 4
$L209923:

; 7802 : #endif
; 7803 : 		}
; 7804 : 	}
; 7805 : 	else {

	jmp	SHORT $L209926
$L209919:

; 7806 : 		blobPfxPassword.pbData = NULL;

	mov	DWORD PTR _blobPfxPassword$[ebp], 0

; 7807 : 		blobPfxPassword.cbData = 0;

	mov	DWORD PTR _blobPfxPassword$[ebp+4], 0
$L209926:

; 7808 : 	}
; 7809 : 
; 7810 : 	dwBytesToWrite	= base64encodeSize(fileSize);

	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 7811 : 	
; 7812 : 	b64PfxDataPtr = (unsigned char *) zMalloc (dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _b64PfxDataPtr$[ebp], eax

; 7813 : 	
; 7814 : 	memset(b64PfxDataPtr,0,dwBytesToWrite+1);

	mov	ecx, DWORD PTR _dwBytesToWrite$[ebp]
	add	ecx, 1
	push	ecx
	push	0
	mov	edx, DWORD PTR _b64PfxDataPtr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 7815 : 	dwBytesToWrite = base64encode(binFileData,fileSize, b64PfxDataPtr,dwBytesToWrite+1);

	mov	eax, DWORD PTR _dwBytesToWrite$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _b64PfxDataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dwBytesToWrite$[ebp], eax

; 7816 : 	zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 7817 : 
; 7818 : 	if (locAtTime.Length() == 0) // Use system time

	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L209928

; 7819 : 	{
; 7820 : #ifdef WIN32
; 7821 : 		GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	edx, DWORD PTR _tsSysTime$[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7822 : #else
; 7823 : 		GetSystemTimeLinux(&tsSysTime);
; 7824 : #endif
; 7825 : 
; 7826 : 		*pVal = CheckCertificateValidity(b64PfxDataPtr, 
; 7827 : 									&tsSysTime, 
; 7828 : 									&blobPfxPassword, 
; 7829 : 									&CertVerifyParams,
; 7830 : 									SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	lea	eax, DWORD PTR _blobPfxPassword$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b64PfxDataPtr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7831 : 	}
; 7832 : 	else

	jmp	$L209929
$L209928:

; 7833 : 	{ 
; 7834 : 		charLocAtTime = (char *)HeapW2A(atTime);

	mov	edx, DWORD PTR _atTime$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charLocAtTime$[ebp], eax

; 7835 : 		// Now covert this time to SYSTEMTIME and call CheckCertificateValidity
; 7836 : 		switch(timeFormat)

	mov	eax, DWORD PTR _timeFormat$[ebp]
	mov	DWORD PTR tv190[ebp], eax
	cmp	DWORD PTR tv190[ebp], 0
	je	SHORT $L209935
	cmp	DWORD PTR tv190[ebp], 1
	je	SHORT $L209937
	cmp	DWORD PTR tv190[ebp], 2
	je	SHORT $L209939
	jmp	SHORT $L209932
$L209935:

; 7837 : 		{
; 7838 : 			case TIME_RFC:
; 7839 : 				ptsSysTime = rfcTimeToSystem((unsigned char *)charLocAtTime);

	mov	ecx, DWORD PTR _charLocAtTime$[ebp]
	push	ecx
	call	_rfcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221608[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7840 : 				break;

	jmp	SHORT $L209932
$L209937:

; 7841 : 			case TIME_VB_NOW:
; 7842 : 				ptsSysTime = vbNowTimeToSystem((unsigned char *)charLocAtTime);

	mov	edx, DWORD PTR _charLocAtTime$[ebp]
	push	edx
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221608[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax

; 7843 : 				localTimeToUtcTime(ptsSysTime);

	cmp	BYTE PTR $T221608[ebp], 0
	jne	SHORT $L221609
	push	OFFSET FLAT:$L221610
	call	__RTC_UninitUse
	add	esp, 4
$L221609:
	mov	eax, DWORD PTR _ptsSysTime$[ebp]
	push	eax
	call	_localTimeToUtcTime
	add	esp, 4

; 7844 : 				break;

	jmp	SHORT $L209932
$L209939:

; 7845 : 			case TIME_JS_UTC:
; 7846 : 				ptsSysTime = jsUtcTimeToSystem((unsigned char *)charLocAtTime);

	mov	ecx, DWORD PTR _charLocAtTime$[ebp]
	push	ecx
	call	_jsUtcTimeToSystem
	add	esp, 4
	mov	BYTE PTR $T221608[ebp], 1
	mov	DWORD PTR _ptsSysTime$[ebp], eax
$L209932:

; 7847 : 				break;
; 7848 : 			default:
; 7849 : 				break;
; 7850 : 		}
; 7851 : 		zFree(charLocAtTime);

	mov	edx, DWORD PTR _charLocAtTime$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 7852 : 
; 7853 : 		*pVal = CheckCertificateValidity(b64PfxDataPtr, 
; 7854 : 									ptsSysTime, 
; 7855 : 									&blobPfxPassword, 
; 7856 : 									&CertVerifyParams,
; 7857 : 									SigHandle);

	cmp	BYTE PTR $T221608[ebp], 0
	jne	SHORT $L221611
	push	OFFSET FLAT:$L221610
	call	__RTC_UninitUse
	add	esp, 4
$L221611:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	lea	eax, DWORD PTR _blobPfxPassword$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b64PfxDataPtr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 7858 : 		zFree(ptsSysTime);

	cmp	BYTE PTR $T221608[ebp], 0
	jne	SHORT $L221612
	push	OFFSET FLAT:$L221610
	call	__RTC_UninitUse
	add	esp, 4
$L221612:
	mov	edx, DWORD PTR _ptsSysTime$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L209929:

; 7859 : 	}
; 7860 : //	zFree(charPfxFileName);
; 7861 : 	zFree(b64PfxDataPtr);

	mov	eax, DWORD PTR _b64PfxDataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 7862 : 	if (blobPfxPassword.cbData!=0)

	cmp	DWORD PTR _blobPfxPassword$[ebp+4], 0
	je	SHORT $L209942

; 7863 : 		zFree(blobPfxPassword.pbData);

	mov	ecx, DWORD PTR _blobPfxPassword$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L209942:

; 7864 : 
; 7865 : 	ExitLog;
; 7866 : 	return S_OK;

	mov	DWORD PTR $T221603[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221603[ebp]
$L209886:

; 7867 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221622
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L221622:
	DD	7
	DD	$L221621
$L221621:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221613
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221614
	DD	-72					; ffffffb8H
	DD	8
	DD	$L221615
	DD	-84					; ffffffacH
	DD	4
	DD	$L221616
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$L221617
	DD	-144					; ffffff70H
	DD	4
	DD	$L221618
	DD	-168					; ffffff58H
	DD	12					; 0000000cH
	DD	$L221619
$L221619:
	DB	115					; 00000073H
	DB	0
$L221618:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221617:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221616:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L221615:
	DB	98					; 00000062H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	80					; 00000050H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	115					; 00000073H
	DB	119					; 00000077H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	0
$L221614:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221613:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221610:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221604:
	lea	ecx, DWORD PTR _locAtTime$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221605:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z:
	mov	eax, OFFSET FLAT:$T221607
	jmp	___CxxFrameHandler
text$x	ENDS
?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z ENDP	; CSignature::VerifyPFXCertCRL
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_data8$ = -32						; size = 2
_data7$ = -28						; size = 2
_data6$ = -24						; size = 2
_data5$ = -20						; size = 2
_data4$ = -16						; size = 2
_data3$ = -12						; size = 2
_data2$ = -8						; size = 2
_data1$ = -4						; size = 2
_guid$ = 8						; size = 4
_guidStr$ = 12						; size = 4
?GuidToString@@YAXPAU_GUID@@PAD@Z PROC NEAR		; GuidToString

; 7879 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 7880 : 	unsigned short data1, data2, data3, data4, data5, data6, data7, data8;
; 7881 : 	data1 = *(unsigned char *)&guid->Data4[0];

	mov	eax, DWORD PTR _guid$[ebp]
	movzx	cx, BYTE PTR [eax+8]
	mov	WORD PTR _data1$[ebp], cx

; 7882 : 	data2 = *(unsigned char *)&guid->Data4[1];

	mov	edx, DWORD PTR _guid$[ebp]
	movzx	ax, BYTE PTR [edx+9]
	mov	WORD PTR _data2$[ebp], ax

; 7883 : 	data3 = *(unsigned char *)&guid->Data4[2];

	mov	ecx, DWORD PTR _guid$[ebp]
	movzx	dx, BYTE PTR [ecx+10]
	mov	WORD PTR _data3$[ebp], dx

; 7884 : 	data4 = *(unsigned char *)&guid->Data4[3];

	mov	eax, DWORD PTR _guid$[ebp]
	movzx	cx, BYTE PTR [eax+11]
	mov	WORD PTR _data4$[ebp], cx

; 7885 : 	data5 = *(unsigned char *)&guid->Data4[4];

	mov	edx, DWORD PTR _guid$[ebp]
	movzx	ax, BYTE PTR [edx+12]
	mov	WORD PTR _data5$[ebp], ax

; 7886 : 	data6 = *(unsigned char *)&guid->Data4[5];

	mov	ecx, DWORD PTR _guid$[ebp]
	movzx	dx, BYTE PTR [ecx+13]
	mov	WORD PTR _data6$[ebp], dx

; 7887 : 	data7 = *(unsigned char *)&guid->Data4[6];

	mov	eax, DWORD PTR _guid$[ebp]
	movzx	cx, BYTE PTR [eax+14]
	mov	WORD PTR _data7$[ebp], cx

; 7888 : 	data8 = *(unsigned char *)&guid->Data4[7];

	mov	edx, DWORD PTR _guid$[ebp]
	movzx	ax, BYTE PTR [edx+15]
	mov	WORD PTR _data8$[ebp], ax

; 7889 : 
; 7890 : 	sprintf(guidStr, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x", 
; 7891 : 			guid->Data1, 
; 7892 : 			guid->Data2,
; 7893 : 			guid->Data3,
; 7894 : 			data1, data2, data3, data4,
; 7895 : 			data5, data6, data7, data8);

	movzx	ecx, WORD PTR _data8$[ebp]
	push	ecx
	movzx	edx, WORD PTR _data7$[ebp]
	push	edx
	movzx	eax, WORD PTR _data6$[ebp]
	push	eax
	movzx	ecx, WORD PTR _data5$[ebp]
	push	ecx
	movzx	edx, WORD PTR _data4$[ebp]
	push	edx
	movzx	eax, WORD PTR _data3$[ebp]
	push	eax
	movzx	ecx, WORD PTR _data2$[ebp]
	push	ecx
	movzx	edx, WORD PTR _data1$[ebp]
	push	edx
	mov	eax, DWORD PTR _guid$[ebp]
	movzx	ecx, WORD PTR [eax+6]
	push	ecx
	mov	edx, DWORD PTR _guid$[ebp]
	movzx	eax, WORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _guid$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:$SG209965
	mov	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	call	_sprintf
	add	esp, 52					; 00000034H

; 7896 : 
; 7897 : }

	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GuidToString@@YAXPAU_GUID@@PAD@Z ENDP			; GuidToString
_TEXT	ENDS
PUBLIC	?GetPhysicalSignatureFromMouse@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromMouse
PUBLIC	?GetPhysicalSignatureFromTablet@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromTablet
PUBLIC	?ShowFileSignature@CSignature@@QAEJPAD0HPAUtagRECT@@0@Z ; CSignature::ShowFileSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv82 = -740						; size = 4
$T221632 = -736						; size = 4
$T221631 = -732						; size = 4
$T221630 = -728						; size = 4
$T221629 = -724						; size = 4
$T221628 = -720						; size = 4
$T221627 = -716						; size = 4
_bstrCapturedSigFileName$ = -712			; size = 4
_tmpFilePath$ = -704					; size = 4
_sigIdLength$ = -696					; size = 4
_uriPath$ = -688					; size = 261
_objectId$ = -416					; size = 260
_parent$ = -152						; size = 4
_cur$ = -148						; size = 4
_fHandle$ = -144					; size = 4
_guidStr$ = -136					; size = 50
_sigGuid$ = -76						; size = 16
_charInputFile$ = -56					; size = 4
_captureResult$ = -52					; size = 4
_binFileData$ = -44					; size = 4
_fileSize$ = -32					; size = 4
_crBlob$ = -20						; size = 8
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_sigNode$ = 8						; size = 4
_signedInfoNode$ = 12					; size = 4
_charSigId$ = 16					; size = 4
?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z PROC NEAR ; CSignature::AddPhysicalSignature
; _this$ = ecx

; 7918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 740				; 000002e4H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-740]
	mov	ecx, 185				; 000000b9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 7919 : 	DS_DATA_BLOB crBlob;
; 7920 : 	DWORD fileSize;
; 7921 : 	unsigned char *binFileData;
; 7922 : 	BOOL captureResult=FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 7923 : 	char *charInputFile;
; 7924 : #ifdef WIN32
; 7925 : 	GUID sigGuid;
; 7926 : #else
; 7927 : 	uuid_t sigGuid;
; 7928 : #endif
; 7929 : 	char guidStr[50];
; 7930 : 	FILE *fHandle;
; 7931 : 	xmlNodePtr cur=NULL, parent=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 7932 : 	unsigned char objectId[MAX_PATH];
; 7933 : 	unsigned char uriPath[MAX_PATH + 1];
; 7934 : 	int sigIdLength=0;

	mov	DWORD PTR _sigIdLength$[ebp], 0

; 7935 : 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 7936 : 	BSTR bstrCapturedSigFileName = NULL;

	mov	DWORD PTR _bstrCapturedSigFileName$[ebp], 0

; 7937 : 	EnterLog;
; 7938 : 
; 7939 : 	if ((sigNode == NULL) || (signedInfoNode == NULL) || (charSigId == NULL))

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L209988
	cmp	DWORD PTR _signedInfoNode$[ebp], 0
	je	SHORT $L209988
	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L209987
$L209988:

; 7940 : 		return; // Do Nothing

	jmp	$L209971
$L209987:

; 7941 : 
; 7942 : 	sigIdLength = strlen(SIG_IMAGE_OBJECT_ID_PREFIX) + strlen(charSigId);

	push	OFFSET FLAT:$SG209989
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _sigIdLength$[ebp], esi

; 7943 : 
; 7944 : 	if (sigIdLength >= MAX_PATH)

	cmp	DWORD PTR _sigIdLength$[ebp], 260	; 00000104H
	jl	SHORT $L209990

; 7945 : 		return;

	jmp	$L209971
$L209990:

; 7946 : 
; 7947 : 	strcpy((char *)objectId, SIG_IMAGE_OBJECT_ID_PREFIX);

	push	OFFSET FLAT:$SG209992
	lea	ecx, DWORD PTR _objectId$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7948 : 	strcat((char *)objectId, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	lea	eax, DWORD PTR _objectId$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7949 : 
; 7950 : 	strcpy((char *)uriPath, "#");

	push	OFFSET FLAT:$SG209995
	lea	ecx, DWORD PTR _uriPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7951 : 	strcat((char *)uriPath, (const char *)objectId);

	lea	edx, DWORD PTR _objectId$[ebp]
	push	edx
	lea	eax, DWORD PTR _uriPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7952 : 
; 7953 : 	// First decide where to get the signature image from
; 7954 : 
; 7955 : 	switch (PhysicalSigUsage)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+956]
	mov	DWORD PTR tv82[ebp], edx
	cmp	DWORD PTR tv82[ebp], 1
	je	SHORT $L210002
	cmp	DWORD PTR tv82[ebp], 2
	je	$L210055
	cmp	DWORD PTR tv82[ebp], 3
	je	$L210104
	jmp	$L209971
$L210002:

; 7956 : 	{
; 7957 : 		case	FILE_PHYSICAL_SIG:	
; 7958 : 									charInputFile = (char *)PhysicalSignatureFileName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 968				; 000003c8H
	mov	DWORD PTR _charInputFile$[ebp], eax

; 7959 : 									if (strlen((const char *)charInputFile) == 0)

	mov	ecx, DWORD PTR _charInputFile$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L210005

; 7960 : 									{
; 7961 : 										break;

	jmp	$L209971
$L210005:

; 7962 : 									}
; 7963 : 									else
; 7964 : 									{
; 7965 : 										if ((fHandle = fopen(charInputFile, "r")) == NULL)

	push	OFFSET FLAT:$SG210008
	mov	edx, DWORD PTR _charInputFile$[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fHandle$[ebp], eax
	cmp	DWORD PTR _fHandle$[ebp], 0
	jne	SHORT $L210007

; 7966 : 											break;

	jmp	$L209971
$L210007:

; 7967 : 										else
; 7968 : 											fclose(fHandle);

	mov	eax, DWORD PTR _fHandle$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 7969 : 									}
; 7970 : #ifdef WIN32
; 7971 : 									CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7972 : 									GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 7973 : #else
; 7974 : 									uuid_generate(sigGuid);
; 7975 : 									uuid_unparse(sigGuid, guidStr);
; 7976 : #endif
; 7977 : 									SigImageGuid = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 7978 : 
; 7979 : 									memset((void *)CapturedSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 7980 : 									ShowFileSignature(charInputFile, (char *)CapturedSignatureFileName, SignatureCaptured, &SignatureCaptureWindowDim, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1752				; 000006d8H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+964]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	mov	edx, DWORD PTR _charInputFile$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowFileSignature@CSignature@@QAEJPAD0HPAUtagRECT@@0@Z ; CSignature::ShowFileSignature

; 7981 : 									if (strlen((const char *)CapturedSignatureFileName) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L210013

; 7982 : 									{
; 7983 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210014
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 7984 : 										SignatureCaptured = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+964], 0

; 7985 : 										break;

	jmp	$L209971
$L210013:

; 7986 : 									}
; 7987 : 									tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221627[ebp], eax
	mov	edx, DWORD PTR $T221627[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], edx

; 7988 : 									strcpy((char *)tmpFilePath->fileName, (const char *)CapturedSignatureFileName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7989 : 									tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T221628[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T221629[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 7990 : 									SignatureCaptured = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], 1

; 7991 : 
; 7992 : 									bstrCapturedSigFileName = A2WBSTR((LPCSTR)CapturedSignatureFileName);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrCapturedSigFileName$[ebp], eax

; 7993 : 									if (ReadAllBin(bstrCapturedSigFileName, &binFileData, &fileSize) == S_FALSE)

	lea	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L210023

; 7994 : 									{
; 7995 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210024
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 7996 : 										setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 7997 : 										zFree(charInputFile);

	mov	eax, DWORD PTR _charInputFile$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 7998 : 										SysFreeString(bstrCapturedSigFileName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 7999 : 										return;

	jmp	$L209971
$L210023:

; 8000 : 									}
; 8001 : 									SysFreeString(bstrCapturedSigFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8002 : 									crBlob.cbData = base64encodeSize(fileSize);

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 8003 : 									// allocate memory
; 8004 : 									crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 8005 : 									if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	ecx, DWORD PTR _crBlob$[ebp+4]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L210026

; 8006 : 									{
; 8007 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210027
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8008 : 										setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 8009 : 										zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8010 : 										return;

	jmp	$L209971
$L210026:

; 8011 : 									}
; 8012 : 									if (base64encode((unsigned char *)binFileData,fileSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) 

	mov	edx, DWORD PTR _crBlob$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L210030

; 8013 : 									{
; 8014 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210031
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8015 : 										setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8016 : 										zFree(crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8017 : 										zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8018 : 										return;

	jmp	$L209971
$L210030:

; 8019 : 									}
; 8020 : 									*(crBlob.pbData+crBlob.cbData)='\0';

	mov	ecx, DWORD PTR _crBlob$[ebp]
	add	ecx, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [ecx], 0

; 8021 : 
; 8022 : 									zFree(binFileData);

	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8023 : 
; 8024 : 									// Add Object element to the Signature node
; 8025 : 
; 8026 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Object");

	push	OFFSET FLAT:$SG210033
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8027 : 									xmlAddChild(sigNode, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 8028 : 									xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)objectId);

	lea	edx, DWORD PTR _objectId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG210036
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8029 : 									xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210039
	push	OFFSET FLAT:$SG210040
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8030 : 									xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 8031 : 									zFree(crBlob.pbData);

	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8032 : 
; 8033 : 									// Now add the reference element to the SignedInfo node
; 8034 : 
; 8035 : 									/*
; 8036 : 									 * Reference
; 8037 : 									*/
; 8038 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210043
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8039 : 									cur = xmlAddChild(signedInfoNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8040 : 									xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)uriPath);

	lea	ecx, DWORD PTR _uriPath$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG210046
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8041 : 									parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 8042 : 
; 8043 : 									/*
; 8044 : 									 * Transforms
; 8045 : 									 */
; 8046 : 	
; 8047 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210048
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8048 : 									cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8049 : 									parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 8050 : 
; 8051 : 									/*
; 8052 : 									 * Transform
; 8053 : 									 */
; 8054 : 	
; 8055 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210050
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8056 : 									xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210053
	push	OFFSET FLAT:$SG210054
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8057 : 									cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8058 : 
; 8059 : 
; 8060 : 									break;

	jmp	$L209971
$L210055:

; 8061 : 
; 8062 : 		case	CAPTURE_PHYSICAL_SIG:
; 8063 : #ifdef WIN32
; 8064 : 									CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8065 : 									GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 8066 : #else
; 8067 : 									uuid_generate(sigGuid);
; 8068 : 									uuid_unparse(sigGuid, guidStr);
; 8069 : #endif
; 8070 : 									SigImageGuid = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8071 : 				
; 8072 : 									memset((void *)CapturedSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 8073 : 									captureResult = GetPhysicalSignatureFromTablet((char *)CapturedSignatureFileName, MAX_PATH, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	push	260					; 00000104H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPhysicalSignatureFromTablet@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromTablet
	mov	DWORD PTR _captureResult$[ebp], eax

; 8074 : 									
; 8075 : 									if (captureResult)

	cmp	DWORD PTR _captureResult$[ebp], 0
	je	SHORT $L210058

; 8076 : 									{
; 8077 : 										SignatureCaptured = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], 1

; 8078 : 										
; 8079 : 									}
; 8080 : 									else

	jmp	SHORT $L210059
$L210058:

; 8081 : 									{	
; 8082 : 										captureResult = GetPhysicalSignatureFromMouse((char *)CapturedSignatureFileName, MAX_PATH, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	push	260					; 00000104H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPhysicalSignatureFromMouse@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromMouse
	mov	DWORD PTR _captureResult$[ebp], eax

; 8083 : 										
; 8084 : 										if (captureResult)

	cmp	DWORD PTR _captureResult$[ebp], 0
	je	SHORT $L210061

; 8085 : 										{
; 8086 : 											SignatureCaptured = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+964], 1

; 8087 : 										}
; 8088 : 										else

	jmp	SHORT $L210059
$L210061:

; 8089 : 										{
; 8090 : 											SigImageGuid = "";

	push	OFFSET FLAT:$SG210063
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8091 : 											SignatureCaptured = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+964], 0

; 8092 : 											return;

	jmp	$L209971
$L210059:

; 8093 : 										}
; 8094 : 									}
; 8095 : 									tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221630[ebp], eax
	mov	ecx, DWORD PTR $T221630[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 8096 : 									strcpy((char *)tmpFilePath->fileName, (const char *)CapturedSignatureFileName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 8097 : 									tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T221631[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T221632[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 8098 : 
; 8099 : //									charInputFile = (char *)CapturedSignatureFileName;
; 8100 : 									bstrCapturedSigFileName = A2WBSTR((LPCSTR)CapturedSignatureFileName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrCapturedSigFileName$[ebp], eax

; 8101 : 									if (ReadAllBin(bstrCapturedSigFileName, &binFileData, &fileSize) == S_FALSE)

	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L210072

; 8102 : 									{
; 8103 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210073
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8104 : 										setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 8105 : //										zFree(charInputFile);
; 8106 : 										SysFreeString(bstrCapturedSigFileName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8107 : 										return;

	jmp	$L209971
$L210072:

; 8108 : 									}
; 8109 : 									SysFreeString(bstrCapturedSigFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrCapturedSigFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8110 : 									crBlob.cbData = base64encodeSize(fileSize);

	mov	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 8111 : 									// allocate memory
; 8112 : 									crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 8113 : 									if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	ecx, DWORD PTR _crBlob$[ebp+4]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L210075

; 8114 : 									{
; 8115 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210076
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8116 : 										setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 8117 : 										zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8118 : 										return;

	jmp	$L209971
$L210075:

; 8119 : 									}
; 8120 : 									if (base64encode((unsigned char *)binFileData,fileSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) 

	mov	edx, DWORD PTR _crBlob$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L210079

; 8121 : 									{
; 8122 : 										SigImageGuid = "";

	push	OFFSET FLAT:$SG210080
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 8123 : 										setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8124 : 										zFree(crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8125 : 										zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8126 : 										return;

	jmp	$L209971
$L210079:

; 8127 : 									}
; 8128 : 									*(crBlob.pbData+crBlob.cbData)='\0';

	mov	ecx, DWORD PTR _crBlob$[ebp]
	add	ecx, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [ecx], 0

; 8129 : 
; 8130 : 									zFree(binFileData);

	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8131 : 
; 8132 : 									// Add Object element to the Signature node
; 8133 : 
; 8134 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Object");

	push	OFFSET FLAT:$SG210082
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8135 : 									xmlAddChild(sigNode, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 8136 : 									xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)objectId);

	lea	edx, DWORD PTR _objectId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG210085
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8137 : 									xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210088
	push	OFFSET FLAT:$SG210089
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8138 : 									xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 8139 : 									zFree(crBlob.pbData);

	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8140 : 
; 8141 : 									// Now add the reference element to the SignedInfo node
; 8142 : 
; 8143 : 									/*
; 8144 : 									 * Reference
; 8145 : 									*/
; 8146 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210092
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8147 : 									cur = xmlAddChild(signedInfoNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8148 : 									xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)uriPath);

	lea	ecx, DWORD PTR _uriPath$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG210095
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8149 : 									parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 8150 : 
; 8151 : 									/*
; 8152 : 									 * Transforms
; 8153 : 									 */
; 8154 : 	
; 8155 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210097
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8156 : 									cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8157 : 									parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 8158 : 
; 8159 : 									/*
; 8160 : 									 * Transform
; 8161 : 									 */
; 8162 : 	
; 8163 : 									cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210099
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8164 : 									xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210102
	push	OFFSET FLAT:$SG210103
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8165 : 									cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8166 : 
; 8167 : 									break;

	jmp	$L209971
$L210104:

; 8168 : 		case	BUF_PHYSICAL_SIG:
; 8169 : 									if (PhysicalSignatureB64Str != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3404], 0
	je	$L209971

; 8170 : 									{
; 8171 : 										// Add Object element to the Signature node
; 8172 : 
; 8173 : 										cur = xmlNewNode(NULL,(const unsigned char *)"Object");

	push	OFFSET FLAT:$SG210107
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8174 : 										xmlAddChild(sigNode, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 8175 : 										xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)objectId);

	lea	ecx, DWORD PTR _objectId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG210110
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8176 : 										xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210113
	push	OFFSET FLAT:$SG210114
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8177 : 										xmlNodeSetContent(cur,(const unsigned char *)PhysicalSignatureB64Str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3404]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 8178 : 
; 8179 : 										// Now add the reference element to the SignedInfo node
; 8180 : 										/*
; 8181 : 										* Reference
; 8182 : 										*/
; 8183 : 										cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210117
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8184 : 										cur = xmlAddChild(signedInfoNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8185 : 										xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)uriPath);

	lea	eax, DWORD PTR _uriPath$[ebp]
	push	eax
	push	OFFSET FLAT:$SG210120
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8186 : 										parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8187 : 
; 8188 : 										/*
; 8189 : 										* Transforms
; 8190 : 										*/
; 8191 : 										cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210122
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8192 : 										cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8193 : 										parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8194 : 
; 8195 : 										/*
; 8196 : 										* Transform
; 8197 : 										*/
; 8198 : 										cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210124
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8199 : 										xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210127
	push	OFFSET FLAT:$SG210128
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8200 : 										cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L209971:

; 8201 : 									}
; 8202 : 									break;
; 8203 : 		case	NO_PHYSICAL_SIG:	
; 8204 : 
; 8205 : 									break;
; 8206 : 		default:
; 8207 : 									break;
; 8208 : 	}
; 8209 : 	ExitLog;
; 8210 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221643
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 740				; 000002e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221643:
	DD	8
	DD	$L221642
$L221642:
	DD	-20					; ffffffecH
	DD	8
	DD	$L221633
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221634
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221635
	DD	-76					; ffffffb4H
	DD	16					; 00000010H
	DD	$L221636
	DD	-136					; ffffff78H
	DD	50					; 00000032H
	DD	$L221637
	DD	-416					; fffffe60H
	DD	260					; 00000104H
	DD	$L221638
	DD	-688					; fffffd50H
	DD	261					; 00000105H
	DD	$L221639
	DD	-704					; fffffd40H
	DD	4
	DD	$L221640
$L221640:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221639:
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221638:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221637:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221636:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221635:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221634:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221633:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ENDP ; CSignature::AddPhysicalSignature
_TEXT	ENDS
EXTRN	_IID_IUnknown:BYTE
EXTRN	__imp__CoCreateInstance@20:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -68						; size = 4
__lpw$ = -64						; size = 4
__acp$ = -60						; size = 4
__convert$ = -56					; size = 4
_bstrGuidStr$ = -52					; size = 4
_charFilePath$ = -48					; size = 4
_bstrFilePath$ = -40					; size = 4
_pEPad$ = -28						; size = 4
_pUnknown$ = -16					; size = 4
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_filePathBuf$ = 8					; size = 4
_bufSize$ = 12						; size = 4
_guidStr$ = 16						; size = 4
?GetPhysicalSignatureFromTablet@CSignature@@QAEHPADH0@Z PROC NEAR ; CSignature::GetPhysicalSignatureFromTablet
; _this$ = ecx

; 8213 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8214 : 	HRESULT hr;
; 8215 : 	IUnknown *pUnknown;
; 8216 : 	IePad *pEPad;
; 8217 : 	BSTR bstrFilePath;
; 8218 : 	char *charFilePath;
; 8219 : 	BSTR bstrGuidStr;
; 8220 : 
; 8221 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 8222 : 	EnterLog;
; 8223 : 	hr = CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8224 : 
; 8225 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210148

; 8226 : 	{
; 8227 : 		return FALSE;

	xor	eax, eax
	jmp	$L210136
$L210148:

; 8228 : 	}
; 8229 : 	hr = CoCreateInstance(CLSID_ePad, NULL, CLSCTX_INPROC_SERVER, 
; 8230 : 						  IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:_CLSID_ePad
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8231 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210151

; 8232 : 	{
; 8233 : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8234 : 		return FALSE;

	xor	eax, eax
	jmp	$L210136
$L210151:

; 8235 : 	}
; 8236 : 	hr = pUnknown->QueryInterface(IID_IePad, (void **) &pEPad);

	mov	esi, esp
	lea	ecx, DWORD PTR _pEPad$[ebp]
	push	ecx
	push	OFFSET FLAT:_IID_IePad
	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8237 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210154

; 8238 : 	{
; 8239 : 		pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8240 : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8241 : 		return FALSE;

	xor	eax, eax
	jmp	$L210136
$L210154:

; 8242 : 	}
; 8243 : 	pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8244 : 	pEPad->put_UpperX(SignatureCaptureWindowDim.left);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1752]
	push	eax
	mov	ecx, DWORD PTR _pEPad$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pEPad$[ebp]
	push	eax
	call	DWORD PTR [edx+40]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8245 : 	pEPad->put_UpperY(SignatureCaptureWindowDim.top);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1756]
	push	edx
	mov	eax, DWORD PTR _pEPad$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pEPad$[ebp]
	push	edx
	call	DWORD PTR [ecx+48]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8246 : 	pEPad->put_Width(SignatureCaptureWindowDim.right);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1760]
	push	ecx
	mov	edx, DWORD PTR _pEPad$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pEPad$[ebp]
	push	ecx
	call	DWORD PTR [eax+56]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8247 : 	pEPad->put_Height(SignatureCaptureWindowDim.bottom);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	push	eax
	mov	ecx, DWORD PTR _pEPad$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pEPad$[ebp]
	push	eax
	call	DWORD PTR [edx+64]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8248 : 	bstrGuidStr = A2WBSTR(guidStr);

	push	-1
	mov	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrGuidStr$[ebp], eax

; 8249 : 	hr = pEPad->GetPhysicalSignature(bstrGuidStr, &bstrFilePath);

	mov	esi, esp
	lea	edx, DWORD PTR _bstrFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrGuidStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEPad$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pEPad$[ebp]
	push	eax
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8250 : 	SysFreeString(bstrGuidStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrGuidStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8251 : 
; 8252 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210156

; 8253 : 	{
; 8254 : 		pEPad->Release();

	mov	edx, DWORD PTR _pEPad$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pEPad$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8255 : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8256 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L210136
$L210156:

; 8257 : 	}
; 8258 : 	charFilePath = (char *)HeapW2A(bstrFilePath);

	mov	edx, DWORD PTR _bstrFilePath$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charFilePath$[ebp], eax

; 8259 : 	strcpy(filePathBuf, charFilePath);

	mov	eax, DWORD PTR _charFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filePathBuf$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8260 : 	zFree(charFilePath);

	mov	edx, DWORD PTR _charFilePath$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8261 : 	pEPad->Release();

	mov	eax, DWORD PTR _pEPad$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pEPad$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8262 : 	CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8263 : 	ExitLog;
; 8264 : 	return TRUE;

	mov	eax, 1
$L210136:

; 8265 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221649
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221649:
	DD	3
	DD	$L221648
$L221648:
	DD	-16					; fffffff0H
	DD	4
	DD	$L221645
	DD	-28					; ffffffe4H
	DD	4
	DD	$L221646
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221647
$L221647:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221646:
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	0
$L221645:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
?GetPhysicalSignatureFromTablet@CSignature@@QAEHPADH0@Z ENDP ; CSignature::GetPhysicalSignatureFromTablet
_TEXT	ENDS
PUBLIC	__GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
PUBLIC	__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
PUBLIC	?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ; SigWinImage::ICaptureImage::CaptureMouseSignature
;	COMDAT __GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
CONST	SEGMENT
__GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31 DD 0f18805ccH
	DW	05075H
	DW	04d36H
	DB	0bbH
	DB	01H
	DB	076H
	DB	0a4H
	DB	0caH
	DB	0f6H
	DB	0eeH
	DB	031H
CONST	ENDS
;	COMDAT __GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
CONST	SEGMENT
__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf DD 0674a7d1H
	DW	0a9cH
	DW	04fe4H
	DB	0b9H
	DB	014H
	DB	096H
	DB	0bcH
	DB	0c6H
	DB	0edH
	DB	0c4H
	DB	0cfH
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv152 = -80						; size = 4
tv150 = -76						; size = 4
tv149 = -72						; size = 4
$T221652 = -68						; size = 4
$T221651 = -64						; size = 4
_hr$ = -60						; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_result$ = -40						; size = 4
_charFilePath$ = -36					; size = 4
_bstrFilePath$ = -32					; size = 4
_captureImageObject$ = -24				; size = 4
_pUnknown$ = -12					; size = 4
_this$ = -4						; size = 4
_filePathBuf$ = 8					; size = 4
_bufSize$ = 12						; size = 4
_guidStr$ = 16						; size = 4
?GetPhysicalSignatureFromMouse@CSignature@@QAEHPADH0@Z PROC NEAR ; CSignature::GetPhysicalSignatureFromMouse
; _this$ = ecx

; 8268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 8269 : 	IUnknown *pUnknown;
; 8270 : 	ICaptureImage *captureImageObject;
; 8271 : 	BSTR bstrFilePath;
; 8272 : 	char *charFilePath;
; 8273 : 	BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 8274 : 
; 8275 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 8276 : 	EnterLog;
; 8277 : #ifdef WIN32
; 8278 : 	CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8279 : 	HRESULT hr = CoCreateInstance(__uuidof(CCaptureImage), NULL, CLSCTX_INPROC_SERVER, 
; 8280 : 						IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8281 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210177

; 8282 : 	{
; 8283 : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8284 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L210163
$L210177:

; 8285 : 	}
; 8286 : 
; 8287 : 	hr = pUnknown->QueryInterface(__uuidof(ICaptureImage), (void **) &captureImageObject);

	mov	esi, esp
	lea	ecx, DWORD PTR _captureImageObject$[ebp]
	push	ecx
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 8288 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L210181

; 8289 : 	{
; 8290 : 		pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8291 : 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8292 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L210163
$L210181:

; 8293 : 	}
; 8294 : 	pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8295 : 
; 8296 : 	bstrFilePath = captureImageObject->CaptureMouseSignature(_bstr_t(guidStr));

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T221651[ebp], esp
	mov	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv149[ebp], eax
	lea	eax, DWORD PTR $T221652[ebp]
	push	eax
	mov	ecx, DWORD PTR _captureImageObject$[ebp]
	call	?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ; SigWinImage::ICaptureImage::CaptureMouseSignature
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv152[ebp], ecx
	mov	ecx, DWORD PTR tv152[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	DWORD PTR _bstrFilePath$[ebp], eax
	lea	ecx, DWORD PTR $T221652[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 8297 : 	captureImageObject->Release();

	mov	edx, DWORD PTR _captureImageObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _captureImageObject$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8298 : 	CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8299 : 	if (bstrFilePath != NULL)

	cmp	DWORD PTR _bstrFilePath$[ebp], 0
	je	SHORT $L210186

; 8300 : 	{
; 8301 : 		result = TRUE;

	mov	DWORD PTR _result$[ebp], 1

; 8302 : 		charFilePath = (char *)HeapW2A(bstrFilePath);

	mov	edx, DWORD PTR _bstrFilePath$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charFilePath$[ebp], eax

; 8303 : 		strcpy(filePathBuf, charFilePath);

	mov	eax, DWORD PTR _charFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _filePathBuf$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8304 : 		zFree(charFilePath);

	mov	edx, DWORD PTR _charFilePath$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210186:

; 8305 : 	}
; 8306 : #endif
; 8307 : 	ExitLog;
; 8308 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L210163:

; 8309 : 
; 8310 : //	return CaptureMouseSignature(filePathBuf, SignatureCaptured, &SignatureCaptureWindowDim, guidStr);
; 8311 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221658
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221658:
	DD	2
	DD	$L221657
$L221657:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221655
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221656
$L221656:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$L221655:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
?GetPhysicalSignatureFromMouse@CSignature@@QAEHPADH0@Z ENDP ; CSignature::GetPhysicalSignatureFromMouse
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\activex\xmlsign\nssdebug\sigwinimage.tli
xdata$x	SEGMENT
$T221670 DD	0ffffffffH
	DD	FLAT:$L221660
$T221665 DD	019930520H
	DD	01H
	DD	FLAT:$T221670
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT
$T221662 = -36						; size = 4
__hr$ = -32						; size = 4
__result$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_guidStr$ = 12						; size = 4
?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z PROC NEAR ; SigWinImage::ICaptureImage::CaptureMouseSignature, COMDAT
; _this$ = ecx

; 53   : inline _bstr_t ICaptureImage::CaptureMouseSignature ( _bstr_t guidStr ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T221662[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 54   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 55   :     HRESULT _hr = raw_CaptureMouseSignature(guidStr, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	lea	ecx, DWORD PTR _guidStr$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+56]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 56   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L204873
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L204873:

; 57   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T221662[ebp]
	or	ecx, 1
	mov	DWORD PTR $T221662[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _guidStr$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 58   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221669
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221669:
	DD	1
	DD	$L221668
$L221668:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221666
$L221666:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L221660:
	lea	ecx, DWORD PTR _guidStr$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z:
	mov	eax, OFFSET FLAT:$T221665
	jmp	___CxxFrameHandler
text$x	ENDS
?CaptureMouseSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ENDP ; SigWinImage::ICaptureImage::CaptureMouseSignature
PUBLIC	?CaptureCurrentWindowImage@CSignature@@QAEHPAD0@Z ; CSignature::CaptureCurrentWindowImage
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_bstrCapturedWinFileName$210216 = -612			; size = 4
_sigIdLength$ = -608					; size = 4
_uriPath$ = -600					; size = 261
_objectId$ = -328					; size = 261
_parent$ = -60						; size = 4
_cur$ = -56						; size = 4
_captureResult$ = -52					; size = 4
_binFileData$ = -44					; size = 4
_fileSize$ = -32					; size = 4
_crBlob$ = -20						; size = 8
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_sigNode$ = 8						; size = 4
_signedInfoNode$ = 12					; size = 4
_charSigId$ = 16					; size = 4
?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z PROC NEAR ; CSignature::AddWindowImage
; _this$ = ecx

; 8314 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 612				; 00000264H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-612]
	mov	ecx, 153				; 00000099H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 8315 : 	DS_DATA_BLOB crBlob;
; 8316 : 	DWORD fileSize;
; 8317 : 	unsigned char *binFileData;
; 8318 : 	BOOL captureResult=FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 8319 : 	xmlNodePtr cur=NULL, parent=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 8320 : 	unsigned char objectId[MAX_PATH+1];
; 8321 : 	unsigned char uriPath[MAX_PATH + 1];
; 8322 : 	int sigIdLength=0;

	mov	DWORD PTR _sigIdLength$[ebp], 0

; 8323 : 
; 8324 : 	EnterLog;
; 8325 : 	if ((sigNode == NULL) || (signedInfoNode == NULL) || (charSigId == NULL))

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L210204
	cmp	DWORD PTR _signedInfoNode$[ebp], 0
	je	SHORT $L210204
	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L210203
$L210204:

; 8326 : 		return; // Do Nothing

	jmp	$L210193
$L210203:

; 8327 : 
; 8328 : 	sigIdLength = strlen(WINDOW_IMAGE_OBJECT_ID_PREFIX) + strlen(charSigId);

	push	OFFSET FLAT:$SG210205
	call	_strlen
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _sigIdLength$[ebp], esi

; 8329 : 
; 8330 : 	if (sigIdLength >= MAX_PATH)

	cmp	DWORD PTR _sigIdLength$[ebp], 260	; 00000104H
	jl	SHORT $L210206

; 8331 : 		return;

	jmp	$L210193
$L210206:

; 8332 : 
; 8333 : 	strcpy((char *)objectId, WINDOW_IMAGE_OBJECT_ID_PREFIX);

	push	OFFSET FLAT:$SG210208
	lea	ecx, DWORD PTR _objectId$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8334 : 	strcat((char *)objectId, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	lea	eax, DWORD PTR _objectId$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 8335 : 	strcpy((char *)uriPath, "#");

	push	OFFSET FLAT:$SG210211
	lea	ecx, DWORD PTR _uriPath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8336 : 	strcat((char *)uriPath, (const char *)objectId);

	lea	edx, DWORD PTR _objectId$[ebp]
	push	edx
	lea	eax, DWORD PTR _uriPath$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 8337 : 
; 8338 : 	captureResult = CaptureCurrentWindowImage ((char *)WindowImageFileName, NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1490				; 000005d2H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CaptureCurrentWindowImage@CSignature@@QAEHPAD0@Z ; CSignature::CaptureCurrentWindowImage
	mov	DWORD PTR _captureResult$[ebp], eax

; 8339 : 	if (captureResult)

	cmp	DWORD PTR _captureResult$[ebp], 0
	je	$L210193

; 8340 : 	{
; 8341 : 		BSTR bstrCapturedWinFileName = A2WBSTR((LPCSTR)WindowImageFileName);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1490				; 000005d2H
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrCapturedWinFileName$210216[ebp], eax

; 8342 : 		if (ReadAllBin(bstrCapturedWinFileName, &binFileData, &fileSize) == S_FALSE)

	lea	eax, DWORD PTR _fileSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrCapturedWinFileName$210216[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L210219

; 8343 : 		{
; 8344 : 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8345 : 			SysFreeString(bstrCapturedWinFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrCapturedWinFileName$210216[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8346 : 			return;

	jmp	$L210193
$L210219:

; 8347 : 		}
; 8348 : 		SysFreeString(bstrCapturedWinFileName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrCapturedWinFileName$210216[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8349 : 		crBlob.cbData = base64encodeSize(fileSize);

	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 8350 : 		// allocate memory
; 8351 : 		crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 8352 : 		if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	edx, DWORD PTR _crBlob$[ebp+4]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L210221

; 8353 : 		{
; 8354 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8355 : 			zFree(binFileData);

	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8356 : 			return;

	jmp	$L210193
$L210221:

; 8357 : 		}
; 8358 : 		if (base64encode((unsigned char *)binFileData,fileSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) 

	mov	eax, DWORD PTR _crBlob$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L210224

; 8359 : 		{
; 8360 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 8361 : 			zFree(crBlob.pbData);

	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8362 : 			zFree(binFileData);

	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8363 : 			return;

	jmp	$L210193
$L210224:

; 8364 : 		}
; 8365 : 		*(crBlob.pbData+crBlob.cbData)='\0';

	mov	edx, DWORD PTR _crBlob$[ebp]
	add	edx, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [edx], 0

; 8366 : 
; 8367 : 		zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8368 : 
; 8369 : 		// Add Object element to the Signature node
; 8370 : 
; 8371 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Object");

	push	OFFSET FLAT:$SG210226
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8372 : 		xmlAddChild(sigNode, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 8373 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)objectId);

	lea	eax, DWORD PTR _objectId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG210229
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8374 : 		xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210232
	push	OFFSET FLAT:$SG210233
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8375 : 		xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 8376 : 		zFree(crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 8377 : 
; 8378 : 		// Now add the reference element to the SignedInfo node
; 8379 : 
; 8380 : 		/*
; 8381 : 		 * Reference
; 8382 : 		*/
; 8383 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210236
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8384 : 		cur = xmlAddChild(signedInfoNode,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8385 : 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)uriPath);

	lea	edx, DWORD PTR _uriPath$[ebp]
	push	edx
	push	OFFSET FLAT:$SG210239
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8386 : 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 8387 : 
; 8388 : 		/*
; 8389 : 		 * Transforms
; 8390 : 		 */
; 8391 : 
; 8392 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210241
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8393 : 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8394 : 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 8395 : 
; 8396 : 		/*
; 8397 : 		 * Transform
; 8398 : 		 */
; 8399 : 
; 8400 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210243
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8401 : 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210246
	push	OFFSET FLAT:$SG210247
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8402 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8403 : #ifdef WIN32
; 8404 : 		DeleteFile(WindowImageFileName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1490				; 000005d2H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210193:

; 8405 : #else
; 8406 : 		unlink(WindowImageFileName);
; 8407 : #endif
; 8408 : 	}
; 8409 : 	ExitLog;
; 8410 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221683
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 612				; 00000264H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221683:
	DD	5
	DD	$L221682
$L221682:
	DD	-20					; ffffffecH
	DD	8
	DD	$L221676
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221677
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221678
	DD	-328					; fffffeb8H
	DD	261					; 00000105H
	DD	$L221679
	DD	-600					; fffffda8H
	DD	261					; 00000105H
	DD	$L221680
$L221680:
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221679:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221678:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221677:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221676:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ENDP ; CSignature::AddWindowImage
_TEXT	ENDS
PUBLIC	?get_AddWindowImage@CSignature@@UAGJPAH@Z	; CSignature::get_AddWindowImage
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_AddWindowImage@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_AddWindowImage

; 8414 : {

	push	ebp
	mov	ebp, esp

; 8415 : 	EnterLog;
; 8416 : #ifdef WIN32
; 8417 : 	*pVal = AddWindowImageFlag;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1796]
	mov	DWORD PTR [eax], edx

; 8418 : #endif
; 8419 : 	ExitLog;
; 8420 : 	return S_OK;

	xor	eax, eax

; 8421 : }

	pop	ebp
	ret	8
?get_AddWindowImage@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_AddWindowImage
_TEXT	ENDS
PUBLIC	?put_AddWindowImage@CSignature@@UAGJH@Z		; CSignature::put_AddWindowImage
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_AddWindowImage@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_AddWindowImage

; 8424 : {

	push	ebp
	mov	ebp, esp

; 8425 : 	EnterLog;
; 8426 : #ifdef WIN32
; 8427 : 	AddWindowImageFlag = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1796], ecx

; 8428 : #endif
; 8429 : 	ExitLog;
; 8430 : 	return S_OK;

	xor	eax, eax

; 8431 : }

	pop	ebp
	ret	8
?put_AddWindowImage@CSignature@@UAGJH@Z ENDP		; CSignature::put_AddWindowImage
_TEXT	ENDS
PUBLIC	?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z	; CSignature::SignXMLXpathStr
xdata$x	SEGMENT
$T221713 DD	0ffffffffH
	DD	FLAT:$L221696
	DD	00H
	DD	FLAT:$L221697
	DD	01H
	DD	FLAT:$L221698
$T221700 DD	019930520H
	DD	03H
	DD	FLAT:$T221713
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv283 = -320						; size = 4
$T221695 = -316						; size = 4
$T221694 = -312						; size = 4
$T221693 = -308						; size = 4
$T221692 = -304						; size = 4
$T221691 = -300						; size = 4
$T221690 = -296						; size = 4
$T221689 = -292						; size = 4
$T221688 = -288						; size = 4
_dataPtr$210550 = -284					; size = 4
_tmpEnvFlag$ = -280					; size = 2
_freeCharSigId$ = -276					; size = 4
__lpa$ = -272						; size = 4
__lpw$ = -268						; size = 4
__acp$ = -264						; size = 4
__convert$ = -260					; size = 4
_freeNewPtr$ = -256					; size = 4
_equalPtr$ = -252					; size = 4
_i$ = -248						; size = 4
_guidStr$ = -240					; size = 50
_sigGuid$ = -180					; size = 16
_templateFound$ = -160					; size = 4
_ptemp$ = -156						; size = 4
_xpathResultPtr$ = -152					; size = 4
_xpathPtr$ = -148					; size = 4
_sizeM$ = -144						; size = 4
_szPtr$ = -140						; size = 4
_curPtr$ = -136						; size = 4
_newPtr$ = -132						; size = 4
_ptr$ = -128						; size = 4
_charTest$ = -124					; size = 4
_tmpXpathStr$ = -116					; size = 4
_tmpXmlStr$ = -104					; size = 4
_sigId$ = -92						; size = 4
_iSize$ = -80						; size = 4
_mem$ = -72						; size = 4
_signedInfoNode$ = -68					; size = 4
_sigNode$ = -64						; size = 4
_parent$ = -60						; size = 4
_cur$ = -56						; size = 4
_root$ = -52						; size = 4
_doc$ = -48						; size = 4
_charSignedXMLStr$ = -40				; size = 4
_ki$ = -32						; size = 4
_curCharSigId$ = -28					; size = 4
_charSigId$ = -24					; size = 4
_charXMLStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_xmlStr$ = 12						; size = 4
_xpathExp$ = 16						; size = 4
_signatureId$ = 20					; size = 4
_signedXMLStr$ = 24					; size = 4
?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z PROC NEAR	; CSignature::SignXMLXpathStr

; 8435 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 308				; 00000134H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-320]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8436 : 	char *charXMLStr=NULL, *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charXMLStr$[ebp], 0
	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 8437 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 8438 : 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 8439 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 8440 : 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 8441 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 8442 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 8443 : 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 8444 : 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 8445 : 	CComBSTR tmpXpathStr;

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 8446 : 	char *charTest;
; 8447 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 8448 : 	unsigned int *szPtr;
; 8449 : 	unsigned int sizeM;
; 8450 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 8451 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 8452 : 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 8453 : 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 8454 : #ifdef WIN32
; 8455 : 	GUID sigGuid;
; 8456 : #else
; 8457 : 	uuid_t sigGuid;
; 8458 : #endif
; 8459 : 	char guidStr[50];
; 8460 : 	UINT i;
; 8461 : 	char *equalPtr;
; 8462 : 	BOOL freeNewPtr=FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 8463 : 
; 8464 : 	EnterLog;	
; 8465 : 	//if (! LicObj.checkLicense()) {
; 8466 : 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 8467 : 	//	return S_FALSE;
; 8468 : 	//}
; 8469 : 	//if (! LicObj.getSignAllowed()) {
; 8470 : 	//	setError(SigHandle, NO_SIGNING_LIC);
; 8471 : 	//	return S_FALSE;
; 8472 : 	//}
; 8473 : 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L210296

; 8474 : 	{
; 8475 : 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L210297

; 8476 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L210297:

; 8477 : 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 8478 : 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L210296:

; 8479 : 	}
; 8480 : 
; 8481 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 8482 : 
; 8483 : 
; 8484 : 	tmpXmlStr = xmlStr;

	mov	ecx, DWORD PTR _xmlStr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8485 : 	if (tmpXmlStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210302

; 8486 : 	{
; 8487 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 8488 : 		return S_FALSE;

	mov	DWORD PTR $T221688[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221688[ebp]
	jmp	$L210264
$L210302:

; 8489 : 	}
; 8490 : 
; 8491 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 8492 : 	sigId = signatureId;

	mov	ecx, DWORD PTR _signatureId$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8493 : 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210306

; 8494 : 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 8495 : 	else

	jmp	SHORT $L210307
$L210306:

; 8496 : 	{
; 8497 : 		charSigId = (char *)HeapW2A(signatureId);

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 8498 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L210307:

; 8499 : 	}
; 8500 : 
; 8501 : 
; 8502 : 	if (Base64DecodeXML == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2184], 0
	jne	$L210309

; 8503 : 	{
; 8504 : 		ptr = (unsigned char *)xmlStr;

	mov	ecx, DWORD PTR _xmlStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 8505 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _szPtr$[ebp], edx

; 8506 : 		sizeM = (*szPtr);

	mov	eax, DWORD PTR _szPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sizeM$[ebp], ecx

; 8507 : 
; 8508 : 		if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 8509 : 			((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L210315
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 254				; 000000feH
	je	SHORT $L210314
$L210315:
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 254				; 000000feH
	jne	SHORT $L210313
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L210313
$L210314:

; 8510 : 		{
; 8511 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 8512 : 			newPtr = ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], ecx

; 8513 : 		}
; 8514 : 		else

	jmp	SHORT $L210316
$L210313:

; 8515 : 		{
; 8516 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 8517 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 8518 : 
; 8519 : 			FileEncoding(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 8520 : //			*newPtr = 0xFF;
; 8521 : //			*(newPtr + 1) = 0xFE;
; 8522 : 
; 8523 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	add	eax, 2
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 8524 : 			sizeM += 4;

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	mov	DWORD PTR _sizeM$[ebp], ecx
$L210316:

; 8525 : 		}
; 8526 : 	}
; 8527 : 	else

	jmp	$L210318
$L210309:

; 8528 : 	{
; 8529 : 		ptr = HeapW2A(xmlStr);

	mov	edx, DWORD PTR _xmlStr$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 8530 : 		sizeM = strlen((const char *)ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 8531 : 		sizeM = base64decodeSize(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 8532 : 		newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 8533 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 8534 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	$L210321

; 8535 : 		{
; 8536 : 			zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8537 : 			zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8538 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210322

; 8539 : 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210322:

; 8540 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8541 : 			return S_FALSE;

	mov	DWORD PTR $T221689[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221689[ebp]
	jmp	$L210264
$L210321:

; 8542 : 		}
; 8543 : 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210318:

; 8544 : 	}
; 8545 : 
; 8546 : 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L210325

; 8547 : 	{
; 8548 : 		if (!LicObj.getFormSignAllowed(newPtr, sizeM, SigHandle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	SHORT $L210325

; 8549 : 		{
; 8550 : 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 8551 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210327

; 8552 : 				zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L210327:

; 8553 : 			return S_FALSE;

	mov	DWORD PTR $T221690[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221690[ebp]
	jmp	$L210264
$L210325:

; 8554 : 		}
; 8555 : 	}
; 8556 : 
; 8557 : 	// original document
; 8558 : 	doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 8559 : 	if (freeNewPtr == TRUE)

	cmp	DWORD PTR _freeNewPtr$[ebp], 1
	jne	SHORT $L210331

; 8560 : 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L210331:

; 8561 : 
; 8562 : 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L210332

; 8563 : 	{
; 8564 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 8565 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210333

; 8566 : 			zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L210333:

; 8567 : 		return S_FALSE;

	mov	DWORD PTR $T221691[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221691[ebp]
	jmp	$L210264
$L210332:

; 8568 : 	}
; 8569 : 
; 8570 : 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L210336

; 8571 : 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210337

; 8572 : 		{
; 8573 : #ifdef WIN32
; 8574 : 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8575 : 			GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 8576 : #else
; 8577 : 			uuid_generate(sigGuid);
; 8578 : 			uuid_unparse(sigGuid, guidStr);
; 8579 : #endif
; 8580 : 			charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 8581 : 		}
; 8582 : 		else

	jmp	SHORT $L210336
$L210337:

; 8583 : 		{
; 8584 : 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 8585 : 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L210336:

; 8586 : 		}
; 8587 : 
; 8588 : 	root = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 8589 : 	sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 8590 : 	if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L210342

; 8591 : 	{
; 8592 : 		templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 8593 : 		cur = sigNode->xmlChildrenNode;

	mov	ecx, DWORD PTR _sigNode$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$L210344:

; 8594 : 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L210342

; 8595 : 		{
; 8596 : 				if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG210348
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L210347

; 8597 : 				{
; 8598 : 					signedInfoNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], edx

; 8599 : 					break;

	jmp	SHORT $L210342
$L210347:

; 8600 : 				}
; 8601 : 				cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 8602 : 		}  // end while cur != NULL

	jmp	SHORT $L210344
$L210342:

; 8603 : 	}
; 8604 : 	  
; 8605 : 	  if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L210349

; 8606 : 	  {
; 8607 : 		  // Add a new Signature element
; 8608 : 		/*
; 8609 : 		* Signature
; 8610 : 		*/
; 8611 : 
; 8612 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210351
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8613 : 		sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 8614 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG210354
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8615 : 		cur = xmlAddChild(root,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8616 : 		//xmlNewNs(cur,(const unsigned char *)"http://www.w3.org/2000/09/xmldsig#",(const unsigned char *)NULL);
; 8617 : 
; 8618 : 		xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG210357
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8619 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8620 : 
; 8621 : 	
; 8622 : 		/*
; 8623 : 		* SignedInfo
; 8624 : 		*/
; 8625 : 		cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210359
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8626 : 		signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 8627 : 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8628 : 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 8629 : 
; 8630 : 		/*
; 8631 : 		 * Canonicalization Method
; 8632 : 		*/
; 8633 : 		cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG210361
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8634 : 		switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv283[ebp], edx
	cmp	DWORD PTR tv283[ebp], 3
	ja	SHORT $L210386
	mov	eax, DWORD PTR tv283[ebp]
	jmp	DWORD PTR $L221712[eax*4]
$L210366:

; 8635 : 		{
; 8636 : 			case WITH_COMMENTS:
; 8637 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210369
	push	OFFSET FLAT:$SG210370
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8638 : 				break;

	jmp	SHORT $L210363
$L210371:

; 8639 : 			case WITHOUT_COMMENTS:
; 8640 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG210374
	push	OFFSET FLAT:$SG210375
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8641 : 				break;

	jmp	SHORT $L210363
$L210376:

; 8642 : 			case EXC_WITH_COMMENTS:
; 8643 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG210379
	push	OFFSET FLAT:$SG210380
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8644 : 				break;

	jmp	SHORT $L210363
$L210381:

; 8645 : 			case EXC_WITHOUT_COMMENTS:
; 8646 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG210384
	push	OFFSET FLAT:$SG210385
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8647 : 				break;

	jmp	SHORT $L210363
$L210386:

; 8648 : 			default:
; 8649 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210389
	push	OFFSET FLAT:$SG210390
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210363:

; 8650 : 		}
; 8651 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8652 : 		/*
; 8653 : 		* Reference
; 8654 : 		*/
; 8655 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210392
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8656 : 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8657 : 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG210395
	push	OFFSET FLAT:$SG210396
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8658 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8659 : 
; 8660 : 		/*
; 8661 : 		* Transforms
; 8662 : 		*/
; 8663 : 	
; 8664 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210398
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8665 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8666 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8667 : 
; 8668 : 		/*
; 8669 : 		* Transform
; 8670 : 		*/
; 8671 : 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 8672 : 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L210400
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L210399
$L210400:

; 8673 : 		{
; 8674 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210402
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8675 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L210403

; 8676 : 			{
; 8677 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG210406
	push	OFFSET FLAT:$SG210407
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8678 : 			}
; 8679 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L210408
$L210403:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L210408

; 8680 : 			{
; 8681 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG210412
	push	OFFSET FLAT:$SG210413
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210408:

; 8682 : 			}
; 8683 : 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8684 : 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8685 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L210414

; 8686 : 			{
; 8687 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG210416
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8688 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG210419
	push	OFFSET FLAT:$SG210420
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8689 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG210423
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8690 : 			}
; 8691 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L210424
$L210414:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L210424

; 8692 : 			{
; 8693 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG210427
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8694 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG210430
	push	OFFSET FLAT:$SG210431
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8695 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG210434
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210424:

; 8696 : 			}
; 8697 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8698 : 			parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx
$L210399:

; 8699 : 		}
; 8700 : 		/*
; 8701 : 		* Transform
; 8702 : 		*/
; 8703 : 	
; 8704 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210436
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8705 : 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG210439
	push	OFFSET FLAT:$SG210440
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8706 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8707 : 
; 8708 : 		/*
; 8709 : 		* Transform
; 8710 : 		*/
; 8711 : 		
; 8712 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210442
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8713 : 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_XPATH);

	push	OFFSET FLAT:$SG210445
	push	OFFSET FLAT:$SG210446
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8714 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8715 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8716 : 
; 8717 : 		cur = xmlNewNode(NULL,(const unsigned char *)"XPath");

	push	OFFSET FLAT:$SG210448
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8718 : 		if (XpathNamespaceCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	$L210449

; 8719 : 		{
; 8720 : 			for (i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L210450
$L210451:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L210450:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	$L210449

; 8721 : 			{
; 8722 : 				equalPtr = StrChr(XpathNamespaceList[i], '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$[ebp], eax

; 8723 : 				if (equalPtr == NULL)

	cmp	DWORD PTR _equalPtr$[ebp], 0
	jne	SHORT $L210453

; 8724 : 				{
; 8725 : 					xmlNewNs(cur, (const unsigned char *)XpathNamespaceList[i], (const unsigned char *)NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8726 : 				}
; 8727 : 				else

	jmp	SHORT $L210456
$L210453:

; 8728 : 				{
; 8729 : 					*equalPtr = '\0';

	mov	ecx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 8730 : 					xmlNewNs(cur, (const unsigned char *)equalPtr+1, (const unsigned char *)XpathNamespaceList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8731 : 					*equalPtr = '=';

	mov	edx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [edx], 61			; 0000003dH
$L210456:

; 8732 : 				}
; 8733 : 			}

	jmp	$L210451
$L210449:

; 8734 : 		}
; 8735 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8736 : 		tmpXpathStr = xpathExp;

	mov	edx, DWORD PTR _xpathExp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8737 : 		if (tmpXpathStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210459

; 8738 : 		{
; 8739 : 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8740 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210460

; 8741 : 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210460:

; 8742 : 			return S_FALSE;

	mov	DWORD PTR $T221692[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221692[ebp]
	jmp	$L210264
$L210459:

; 8743 : 		}
; 8744 : 
; 8745 : 		charTest = (char *)HeapW2A(xpathExp);

	mov	eax, DWORD PTR _xpathExp$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charTest$[ebp], eax

; 8746 : 		xmlNodeSetContent(cur,(const unsigned char *)charTest);

	mov	ecx, DWORD PTR _charTest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 8747 : 		zFree(charTest);

	mov	eax, DWORD PTR _charTest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8748 : 	  }
; 8749 : 	  else // A Signature element with matching Id was found

	jmp	$L210465
$L210349:

; 8750 : 	  {
; 8751 : 		parent = signedInfoNode;

	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 8752 : 		/*
; 8753 : 		* Reference
; 8754 : 		*/
; 8755 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210467
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8756 : 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8757 : 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG210470
	push	OFFSET FLAT:$SG210471
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8758 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8759 : 
; 8760 : 		/*
; 8761 : 		* Transforms
; 8762 : 		*/
; 8763 : 	
; 8764 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210473
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8765 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8766 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8767 : 
; 8768 : 		/*
; 8769 : 		* Transform
; 8770 : 		*/
; 8771 : 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 8772 : 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L210475
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L210474
$L210475:

; 8773 : 		{
; 8774 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210477
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8775 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L210478

; 8776 : 			{
; 8777 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG210481
	push	OFFSET FLAT:$SG210482
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8778 : 			}
; 8779 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L210483
$L210478:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L210483

; 8780 : 			{
; 8781 : 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG210487
	push	OFFSET FLAT:$SG210488
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210483:

; 8782 : 			}
; 8783 : 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8784 : 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8785 : 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L210489

; 8786 : 			{
; 8787 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG210491
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8788 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG210494
	push	OFFSET FLAT:$SG210495
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8789 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG210498
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8790 : 			}
; 8791 : 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L210499
$L210489:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L210499

; 8792 : 			{
; 8793 : 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG210502
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8794 : 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG210505
	push	OFFSET FLAT:$SG210506
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8795 : 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG210509
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210499:

; 8796 : 			}
; 8797 : 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8798 : 			parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx
$L210474:

; 8799 : 		}
; 8800 : 
; 8801 : 		/*
; 8802 : 		* Transform
; 8803 : 		*/
; 8804 : 	
; 8805 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210511
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8806 : 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG210514
	push	OFFSET FLAT:$SG210515
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8807 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8808 : 
; 8809 : 		/*
; 8810 : 		* Transform
; 8811 : 		*/
; 8812 : 		
; 8813 : 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210517
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8814 : 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_XPATH);

	push	OFFSET FLAT:$SG210520
	push	OFFSET FLAT:$SG210521
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 8815 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8816 : 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 8817 : 
; 8818 : 		cur = xmlNewNode(NULL,(const unsigned char *)"XPath");

	push	OFFSET FLAT:$SG210523
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8819 : 		if (XpathNamespaceCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	$L210524

; 8820 : 		{
; 8821 : 			for (i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L210525
$L210526:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L210525:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	$L210524

; 8822 : 			{
; 8823 : 				equalPtr = StrChr(XpathNamespaceList[i], '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$[ebp], eax

; 8824 : 				if (equalPtr == NULL)

	cmp	DWORD PTR _equalPtr$[ebp], 0
	jne	SHORT $L210528

; 8825 : 				{
; 8826 : 					xmlNewNs(cur, (const unsigned char *)XpathNamespaceList[i], (const unsigned char *)NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8827 : 				}
; 8828 : 				else

	jmp	SHORT $L210531
$L210528:

; 8829 : 				{
; 8830 : 					*equalPtr = '\0';

	mov	ecx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 8831 : 					xmlNewNs(cur, (const unsigned char *)equalPtr+1, (const unsigned char *)XpathNamespaceList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 8832 : 					*equalPtr = '=';

	mov	edx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [edx], 61			; 0000003dH
$L210531:

; 8833 : 				}
; 8834 : 			}

	jmp	$L210526
$L210524:

; 8835 : 		}
; 8836 : 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 8837 : 		tmpXpathStr = xpathExp;

	mov	edx, DWORD PTR _xpathExp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8838 : 		if (tmpXpathStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210534

; 8839 : 		{
; 8840 : 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8841 : 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210535

; 8842 : 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210535:

; 8843 : 			return S_FALSE;

	mov	DWORD PTR $T221693[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221693[ebp]
	jmp	$L210264
$L210534:

; 8844 : 		}
; 8845 : 
; 8846 : 		charTest = (char *)HeapW2A(xpathExp);

	mov	eax, DWORD PTR _xpathExp$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charTest$[ebp], eax

; 8847 : 		xmlNodeSetContent(cur,(const unsigned char *)charTest);

	mov	ecx, DWORD PTR _charTest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 8848 : 		zFree(charTest);

	mov	eax, DWORD PTR _charTest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L210465:

; 8849 : 	  }
; 8850 : #ifdef WIN32
; 8851 : 	  if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L210540

; 8852 : 		  AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L210540:

; 8853 : 
; 8854 : 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L210541

; 8855 : 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L210541:

; 8856 : #endif
; 8857 : 	/*
; 8858 : 	 * init Signature. crBlob contains XML - envelope document
; 8859 : 	 */
; 8860 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 8861 : 	EnvelopingFlag = ENVELOPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+688], 2

; 8862 : 
; 8863 : 	if (!(CreateSigFromTmplBlob(doc,charSigId, &charSignedXMLStr, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L210543

; 8864 : 	{
; 8865 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L210544

; 8866 : 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210544:

; 8867 : 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 8868 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210545

; 8869 : 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L210545:

; 8870 : 		return S_FALSE;

	mov	DWORD PTR $T221694[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221694[ebp]
	jmp	$L210264
$L210543:

; 8871 : 	}
; 8872 : 	else
; 8873 : 	{
; 8874 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	$L210548

; 8875 : 		{
; 8876 : 			unsigned char *dataPtr = charSignedXMLStr;

	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	mov	DWORD PTR _dataPtr$210550[ebp], edx

; 8877 : 
; 8878 : 			if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) ||
; 8879 : 				((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff)))

	mov	eax, DWORD PTR _dataPtr$210550[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L210553
	mov	edx, DWORD PTR _dataPtr$210550[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L210552
$L210553:
	mov	ecx, DWORD PTR _dataPtr$210550[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L210551
	mov	eax, DWORD PTR _dataPtr$210550[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L210551
$L210552:

; 8880 : 			{
; 8881 : 				// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 8882 : 				// Just allocate memory and copy data and put the size information in front
; 8883 : 				*signedXMLStr = ::SysAllocStringByteLen((LPCSTR)(dataPtr), iSize);

	mov	esi, esp
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$210550[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 8884 : 				xmlFree(dataPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _dataPtr$210550[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 8885 : 			}
; 8886 : 			else

	jmp	SHORT $L210548
$L210551:

; 8887 : 			{
; 8888 : 				*signedXMLStr = A2WBSTR((LPCSTR)dataPtr, iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$210550[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [edx], eax

; 8889 : 				if (Base64EncodeXML == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2180], 1
	jne	SHORT $L210557

; 8890 : 					zFree(dataPtr);

	mov	ecx, DWORD PTR _dataPtr$210550[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 8891 : 				else

	jmp	SHORT $L210548
$L210557:

; 8892 : 					xmlFree(dataPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _dataPtr$210550[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210548:

; 8893 : 			}
; 8894 : 		}
; 8895 : 	}
; 8896 : 	EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 8897 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210559

; 8898 : 		zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210559:

; 8899 : 	ExitLog;
; 8900 : 	return S_OK;

	mov	DWORD PTR $T221695[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221695[ebp]
$L210264:

; 8901 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221711
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 320				; 00000140H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221711:
	DD	7
	DD	$L221710
$L221710:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221701
	DD	-80					; ffffffb0H
	DD	4
	DD	$L221702
	DD	-92					; ffffffa4H
	DD	4
	DD	$L221703
	DD	-104					; ffffff98H
	DD	4
	DD	$L221704
	DD	-116					; ffffff8cH
	DD	4
	DD	$L221705
	DD	-180					; ffffff4cH
	DD	16					; 00000010H
	DD	$L221706
	DD	-240					; ffffff10H
	DD	50					; 00000032H
	DD	$L221707
$L221707:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221706:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221705:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221704:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221703:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221702:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221701:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221712:
	DD	$L210371
	DD	$L210366
	DD	$L210381
	DD	$L210376
_TEXT	ENDS
text$x	SEGMENT
$L221696:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221697:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221698:
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221700
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z ENDP	; CSignature::SignXMLXpathStr
PUBLIC	?get_UseHMAC@CSignature@@UAGJPAH@Z		; CSignature::get_UseHMAC
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UseHMAC@CSignature@@UAGJPAH@Z PROC NEAR		; CSignature::get_UseHMAC

; 8904 : {

	push	ebp
	mov	ebp, esp

; 8905 : 	EnterLog;
; 8906 : 	*pVal = UseHMAC;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1800]
	mov	DWORD PTR [eax], edx

; 8907 : 	ExitLog;
; 8908 : 	return S_OK;

	xor	eax, eax

; 8909 : }

	pop	ebp
	ret	8
?get_UseHMAC@CSignature@@UAGJPAH@Z ENDP			; CSignature::get_UseHMAC
_TEXT	ENDS
PUBLIC	?put_UseHMAC@CSignature@@UAGJH@Z		; CSignature::put_UseHMAC
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_UseHMAC@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_UseHMAC

; 8912 : {

	push	ebp
	mov	ebp, esp

; 8913 : 	EnterLog;
; 8914 : 	UseHMAC = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1800], ecx

; 8915 : 	ExitLog;
; 8916 : 	return S_OK;

	xor	eax, eax

; 8917 : }

	pop	ebp
	ret	8
?put_UseHMAC@CSignature@@UAGJH@Z ENDP			; CSignature::put_UseHMAC
_TEXT	ENDS
PUBLIC	?get_HMACPassword@CSignature@@UAGJPAPAG@Z	; CSignature::get_HMACPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_HMACPassword@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_HMACPassword

; 8920 : {

	push	ebp
	mov	ebp, esp

; 8921 : 	EnterLog;
; 8922 : 	*pVal = HMACKey.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 8923 : 	ExitLog;
; 8924 : 	return S_OK;

	xor	eax, eax

; 8925 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_HMACPassword@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_HMACPassword
_TEXT	ENDS
PUBLIC	?put_HMACPassword@CSignature@@UAGJPAG@Z		; CSignature::put_HMACPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_HMACPassword@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_HMACPassword

; 8928 : {

	push	ebp
	mov	ebp, esp

; 8929 : 	HMACKey = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8930 : 
; 8931 : 	EnterLog;
; 8932 : 	if (HMACKey.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L210581

; 8933 : 	{
; 8934 : 		if (HMACPassword.pbData) 

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+908], 0
	je	SHORT $L210582

; 8935 : 			zFree (HMACPassword.pbData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+908]
	push	eax
	call	_rFree
	add	esp, 4
$L210582:

; 8936 : 		HMACPassword.pbData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], 0

; 8937 : 		HMACPassword.cbData = 0;								

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+912], 0

; 8938 : 		HMACPassword.cbData = base64encodeSize(HMACKey.Length());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+912], eax

; 8939 : 		if(!(HMACPassword.pbData = (BYTE*)zMalloc(HMACPassword.cbData+1))) 

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+908], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+908], 0
	jne	SHORT $L210584

; 8940 : 		{
; 8941 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8942 : 			return FALSE;

	xor	eax, eax
	jmp	$L210580
$L210584:

; 8943 : 		}
; 8944 : 		memset (HMACPassword.pbData,0,HMACPassword.cbData+1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+912]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+908]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 8945 : 		if (base64encode((unsigned char *)HMACKey.m_str,HMACKey.Length(),HMACPassword.pbData,HMACPassword.cbData)==-1) 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+912]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+908]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1804]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L210586

; 8946 : 		{
; 8947 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 8948 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L210580
$L210586:

; 8949 : 		}
; 8950 : 	}
; 8951 : 	else

	jmp	SHORT $L210587
$L210581:

; 8952 : 	{
; 8953 : 		if (HMACPassword.pbData) 

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+908], 0
	je	SHORT $L210588

; 8954 : 			zFree (HMACPassword.pbData);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+908]
	push	ecx
	call	_rFree
	add	esp, 4
$L210588:

; 8955 : 		HMACPassword.pbData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+908], 0

; 8956 : 		HMACPassword.cbData = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+912], 0
$L210587:

; 8957 : 	}
; 8958 : 	ExitLog;
; 8959 : 	return S_OK;

	xor	eax, eax
$L210580:

; 8960 : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_HMACPassword@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_HMACPassword
_TEXT	ENDS
PUBLIC	?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z	; CSignature::ChangeOrAddProperty
EXTRN	_VarBstrCat@12:NEAR
xdata$x	SEGMENT
$T221731 DD	0ffffffffH
	DD	FLAT:$L221722
$T221724 DD	019930520H
	DD	01H
	DD	FLAT:$T221731
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221721 = -96						; size = 4
$T221720 = -92						; size = 4
$T221719 = -88						; size = 4
_tempBstr1$ = -80					; size = 4
_midBstr$ = -72						; size = 4
_bstrPropStr$ = -64					; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_bstrByteSize$ = -40					; size = 4
_utf8CharStr$ = -36					; size = 4
_found$ = -32						; size = 4
_tmpCcomBSTR$ = -24					; size = 4
_propIndex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_propertyName$ = 12					; size = 4
_propertyValue$ = 16					; size = 4
?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z PROC NEAR	; CSignature::ChangeOrAddProperty

; 8963 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 8964 : 	int propIndex;
; 8965 : 	CComBSTR tmpCcomBSTR;

	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 8966 : 	BOOL found=FALSE;

	mov	DWORD PTR _found$[ebp], 0

; 8967 : 	unsigned char *utf8CharStr = NULL;

	mov	DWORD PTR _utf8CharStr$[ebp], 0

; 8968 : 	int bstrByteSize = 0;

	mov	DWORD PTR _bstrByteSize$[ebp], 0

; 8969 : 
; 8970 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 8971 : 	EnterLog;
; 8972 : 	tmpCcomBSTR = propertyName;

	mov	eax, DWORD PTR _propertyName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8973 : 
; 8974 : 	if (tmpCcomBSTR.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210604

; 8975 : 		return S_FALSE;

	mov	DWORD PTR $T221719[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221719[ebp]
	jmp	$L210594
$L210604:

; 8976 : 
; 8977 : 	tmpCcomBSTR = propertyValue;

	mov	ecx, DWORD PTR _propertyValue$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 8978 : 	if (tmpCcomBSTR.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210607

; 8979 : 		return S_FALSE;

	mov	DWORD PTR $T221720[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221720[ebp]
	jmp	$L210594
$L210607:

; 8980 : 
; 8981 : 	utf8CharStr = HeapW2A(propertyName);

	mov	edx, DWORD PTR _propertyName$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$[ebp], eax

; 8982 : 
; 8983 : 	for (propIndex = 0; propIndex < PropertyCount; propIndex++)

	mov	DWORD PTR _propIndex$[ebp], 0
	jmp	SHORT $L210610
$L210611:
	mov	eax, DWORD PTR _propIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _propIndex$[ebp], eax
$L210610:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _propIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+100]
	jge	SHORT $L210612

; 8984 : 	{
; 8985 : 		if (Properties[propIndex] != NULL)

	mov	eax, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+eax*4+136], 0
	je	SHORT $L210613

; 8986 : 		{
; 8987 : 			if (strstr((const char *)Properties[propIndex],(const char *)utf8CharStr) == NULL)

	mov	edx, DWORD PTR _utf8CharStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	push	edx
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L210616

; 8988 : 			{ // Property Name Not Found
; 8989 : 				continue;

	jmp	SHORT $L210611
$L210616:

; 8990 : 			}
; 8991 : 			else
; 8992 : 			{
; 8993 : 				found = TRUE;

	mov	DWORD PTR _found$[ebp], 1

; 8994 : 				break;

	jmp	SHORT $L210612
$L210613:

; 8995 : 			}
; 8996 : 		}
; 8997 : 	}

	jmp	SHORT $L210611
$L210612:

; 8998 : 	zFree(utf8CharStr);

	mov	eax, DWORD PTR _utf8CharStr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 8999 : 
; 9000 : 	BSTR bstrPropStr = NULL;

	mov	DWORD PTR _bstrPropStr$[ebp], 0

; 9001 : 	BSTR midBstr = SysAllocString(L"=");

	mov	esi, esp
	push	OFFSET FLAT:$SG210620
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _midBstr$[ebp], eax

; 9002 : 	BSTR tempBstr1 = NULL;

	mov	DWORD PTR _tempBstr1$[ebp], 0

; 9003 : 	VarBstrCat(propertyName, midBstr, &tempBstr1);

	lea	ecx, DWORD PTR _tempBstr1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _midBstr$[ebp]
	push	edx
	mov	eax, DWORD PTR _propertyName$[ebp]
	push	eax
	call	_VarBstrCat@12

; 9004 : 	VarBstrCat(tempBstr1, propertyValue, &bstrPropStr);

	lea	ecx, DWORD PTR _bstrPropStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _propertyValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _tempBstr1$[ebp]
	push	eax
	call	_VarBstrCat@12

; 9005 : 	SysFreeString(midBstr);

	mov	esi, esp
	mov	ecx, DWORD PTR _midBstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9006 : 	SysFreeString(tempBstr1);

	mov	esi, esp
	mov	edx, DWORD PTR _tempBstr1$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9007 : 	if (found)

	cmp	DWORD PTR _found$[ebp], 0
	je	SHORT $L210622

; 9008 : 	{
; 9009 : 		zFree(Properties[propIndex]);

	mov	eax, DWORD PTR _propIndex$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	push	edx
	call	_rFree
	add	esp, 4

; 9010 : 		Properties[propIndex] = HeapW2A(bstrPropStr);

	mov	eax, DWORD PTR _bstrPropStr$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _propIndex$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+136], eax

; 9011 : 	}
; 9012 : 	else

	jmp	SHORT $L210623
$L210622:

; 9013 : 	{
; 9014 : 		put_Properties(0, PropertyCount, bstrPropStr);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+64]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210623:

; 9015 : 	}
; 9016 : 	SysFreeString(bstrPropStr);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrPropStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9017 : 	ExitLog;
; 9018 : 	return S_OK;

	mov	DWORD PTR $T221721[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221721[ebp]
$L210594:

; 9019 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221730
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221730:
	DD	3
	DD	$L221729
$L221729:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L221725
	DD	-64					; ffffffc0H
	DD	4
	DD	$L221726
	DD	-80					; ffffffb0H
	DD	4
	DD	$L221727
$L221727:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	49					; 00000031H
	DB	0
$L221726:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221725:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	66					; 00000042H
	DB	83					; 00000053H
	DB	84					; 00000054H
	DB	82					; 00000052H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221722:
	lea	ecx, DWORD PTR _tmpCcomBSTR$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z:
	mov	eax, OFFSET FLAT:$T221724
	jmp	___CxxFrameHandler
text$x	ENDS
?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z ENDP	; CSignature::ChangeOrAddProperty
PUBLIC	?put_DetailedVerificationFlag@CSignature@@UAGJH@Z ; CSignature::put_DetailedVerificationFlag
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_DetailedVerificationFlag@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_DetailedVerificationFlag

; 9022 : {

	push	ebp
	mov	ebp, esp

; 9023 : 	EnterLog;
; 9024 : 	DetailedVerificationReportFlag = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1816], ecx

; 9025 : 	ExitLog;
; 9026 : 	return S_OK;

	xor	eax, eax

; 9027 : }

	pop	ebp
	ret	8
?put_DetailedVerificationFlag@CSignature@@UAGJH@Z ENDP	; CSignature::put_DetailedVerificationFlag
_TEXT	ENDS
PUBLIC	?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z	; CSignature::CaptureLiveSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T221737 = -144						; size = 4
$T221736 = -140						; size = 4
$T221735 = -136						; size = 4
_fHandle$210656 = -132					; size = 4
_charInputFile$210654 = -128				; size = 4
__lpa$ = -124						; size = 4
__lpw$ = -120						; size = 4
__acp$ = -116						; size = 4
__convert$ = -112					; size = 4
_guidStr$ = -104					; size = 50
_sigGuid$ = -44						; size = 16
_tmpFilePath$ = -20					; size = 4
_desktopHwnd$ = -12					; size = 4
_captureResult$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_signatureFilePath$ = 12				; size = 4
?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::CaptureLiveSignature

; 9030 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-144]
	mov	ecx, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9031 : 	BOOL captureResult=FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 9032 : 	HWND	desktopHwnd;
; 9033 : 	TEMP_FILE_INFO	*tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 9034 : #ifdef WIN32
; 9035 : 	GUID sigGuid;
; 9036 : #else
; 9037 : 	uuid_t sigGuid;
; 9038 : #endif
; 9039 : 	char guidStr[50];
; 9040 : 
; 9041 : 	EnterLog;
; 9042 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L210640

; 9043 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9044 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L210634
$L210640:

; 9045 : 	}
; 9046 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L210642

; 9047 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9048 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L210634
$L210642:

; 9049 : 	}
; 9050 : 
; 9051 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 9052 : 
; 9053 : #ifdef WIN32
; 9054 : 	CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9055 : 	GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9056 : #else
; 9057 : 	uuid_generate(sigGuid);
; 9058 : 	uuid_unparse(sigGuid, guidStr);
; 9059 : #endif
; 9060 : 	SigImageGuid = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 9061 : 	if (PhysicalSigUsage != FILE_PHYSICAL_SIG)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 1
	je	$L210648

; 9062 : 	{
; 9063 : #ifdef WIN32
; 9064 : 		SignatureCaptured = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+964], 0

; 9065 : 		desktopHwnd = GetDesktopWindow();	

	mov	esi, esp
	call	DWORD PTR __imp__GetDesktopWindow@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _desktopHwnd$[ebp], eax

; 9066 : 		GetClientRect(desktopHwnd, &SignatureCaptureWindowDim);		

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1752				; 000006d8H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _desktopHwnd$[ebp]
	push	edx
	call	DWORD PTR __imp__GetClientRect@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9067 : 		SignatureCaptureWindowDim.left = (SignatureCaptureWindowDim.right / 2) - 175; // UpperX		

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+1760]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 175				; 000000afH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1752], eax

; 9068 : 		SignatureCaptureWindowDim.top = (SignatureCaptureWindowDim.bottom / 2) - 125; // UpperY		

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1764]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, 125				; 0000007dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1756], eax

; 9069 : 		SignatureCaptureWindowDim.bottom = 250; // Height

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1764], 250		; 000000faH

; 9070 : 		SignatureCaptureWindowDim.right = 350;  // Width

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1760], 350		; 0000015eH

; 9071 : 
; 9072 : 		memset((void *)CapturedSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 9073 : 		captureResult = GetPhysicalSignatureFromTablet((char *)CapturedSignatureFileName, MAX_PATH, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	push	260					; 00000104H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPhysicalSignatureFromTablet@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromTablet
	mov	DWORD PTR _captureResult$[ebp], eax

; 9074 : 		if (!captureResult)

	cmp	DWORD PTR _captureResult$[ebp], 0
	jne	SHORT $L210651

; 9075 : 		{	
; 9076 : 			captureResult = GetPhysicalSignatureFromMouse((char *)CapturedSignatureFileName, MAX_PATH, guidStr);

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	push	260					; 00000104H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetPhysicalSignatureFromMouse@CSignature@@QAEHPADH0@Z ; CSignature::GetPhysicalSignatureFromMouse
	mov	DWORD PTR _captureResult$[ebp], eax
$L210651:

; 9077 : 		}
; 9078 : #endif
; 9079 : 	}
; 9080 : 	else

	jmp	$putResultOut$210659
$L210648:

; 9081 : 	{
; 9082 : #ifdef WIN32
; 9083 : 		char *charInputFile = (char *)PhysicalSignatureFileName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 968				; 000003c8H
	mov	DWORD PTR _charInputFile$210654[ebp], eax

; 9084 : 		FILE *fHandle = NULL;

	mov	DWORD PTR _fHandle$210656[ebp], 0

; 9085 : 
; 9086 : 		if (strlen((const char *)charInputFile) == 0)

	mov	ecx, DWORD PTR _charInputFile$210654[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L210658

; 9087 : 		{
; 9088 : 			captureResult = FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 9089 : 			goto putResultOut;

	jmp	$putResultOut$210659
$L210658:

; 9090 : 		}
; 9091 : 		else
; 9092 : 		{
; 9093 : 			if ((fHandle = fopen(charInputFile, "r")) == NULL)

	push	OFFSET FLAT:$SG210663
	mov	edx, DWORD PTR _charInputFile$210654[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fHandle$210656[ebp], eax
	cmp	DWORD PTR _fHandle$210656[ebp], 0
	jne	SHORT $L210662

; 9094 : 			{
; 9095 : 				captureResult = FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 9096 : 				goto putResultOut;

	jmp	$putResultOut$210659
$L210662:

; 9097 : 			}
; 9098 : 			else
; 9099 : 				fclose(fHandle);

	mov	eax, DWORD PTR _fHandle$210656[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 9100 : 		}
; 9101 : 
; 9102 : 		memset((void *)CapturedSignatureFileName, 0, MAX_PATH);

	push	260					; 00000104H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 9103 : 		ShowFileSignature(charInputFile, (char *)CapturedSignatureFileName, SignatureCaptured, &SignatureCaptureWindowDim, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1752				; 000006d8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+964]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1229				; 000004cdH
	push	eax
	mov	ecx, DWORD PTR _charInputFile$210654[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ShowFileSignature@CSignature@@QAEJPAD0HPAUtagRECT@@0@Z ; CSignature::ShowFileSignature

; 9104 : 		if (strlen((const char *)CapturedSignatureFileName) == 0)

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1229				; 000004cdH
	push	edx
	call	_strlen
	add	esp, 4
	test	eax, eax
	jne	SHORT $L210669

; 9105 : 		{
; 9106 : 			SigImageGuid = "";

	push	OFFSET FLAT:$SG210670
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 9107 : 			SignatureCaptured = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+964], 0

; 9108 : 			captureResult = FALSE;

	mov	DWORD PTR _captureResult$[ebp], 0

; 9109 : 			goto putResultOut;

	jmp	SHORT $putResultOut$210659
$L210669:

; 9110 : 		}
; 9111 : 		captureResult = TRUE;

	mov	DWORD PTR _captureResult$[ebp], 1
$putResultOut$210659:

; 9112 : #endif
; 9113 : 	}
; 9114 : putResultOut:
; 9115 : 	if (captureResult)

	cmp	DWORD PTR _captureResult$[ebp], 0
	je	$L210672

; 9116 : 	{
; 9117 : 		*signatureFilePath = A2WBSTR((LPCSTR)CapturedSignatureFileName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _signatureFilePath$[ebp]
	mov	DWORD PTR [edx], eax

; 9118 : 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221735[ebp], eax
	mov	eax, DWORD PTR $T221735[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], eax

; 9119 : 		strcpy((char *)tmpFilePath->fileName, (const char *)CapturedSignatureFileName);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1229				; 000004cdH
	push	ecx
	mov	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 9120 : 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T221736[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T221737[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 9121 : 		ExitLog;
; 9122 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L210634
$L210672:

; 9123 : 	}
; 9124 : 	else
; 9125 : 	{
; 9126 : 		*signatureFilePath = A2WBSTR((LPCSTR) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signatureFilePath$[ebp]
	mov	DWORD PTR [ecx], eax

; 9127 : 		SigImageGuid = "";

	push	OFFSET FLAT:$SG210683
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 9128 : 		return S_FALSE;

	mov	eax, 1
$L210634:

; 9129 : 	}
; 9130 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221743
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 144				; 00000090H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221743:
	DD	3
	DD	$L221742
$L221742:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221738
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$L221739
	DD	-104					; ffffff98H
	DD	50					; 00000032H
	DD	$L221740
$L221740:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221739:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221738:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::CaptureLiveSignature
_TEXT	ENDS
PUBLIC	?SignDataStr@CSignature@@UAGJPAGPAPAG@Z		; CSignature::SignDataStr
xdata$x	SEGMENT
$T221768 DD	0ffffffffH
	DD	FLAT:$L221754
$T221756 DD	019930520H
	DD	01H
	DD	FLAT:$T221768
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv280 = -320						; size = 4
$T221753 = -316						; size = 4
$T221752 = -312						; size = 4
$T221751 = -308						; size = 4
$T221750 = -304						; size = 4
$T221749 = -300						; size = 4
$T221748 = -296						; size = 4
$T221747 = -292						; size = 4
$T221746 = -288						; size = 4
_tmpEnvFlag$ = -284					; size = 2
_freeCharSigId$ = -280					; size = 4
_encodedData$ = -276					; size = 4
_encodedSize$ = -272					; size = 4
__lpa$ = -268						; size = 4
__lpw$ = -264						; size = 4
__acp$ = -260						; size = 4
__convert$ = -256					; size = 4
_elementId$ = -248					; size = 50
_guidStr$ = -188					; size = 50
_sigGuid$ = -128					; size = 16
_charSigId$ = -108					; size = 4
_tmpDataStr$ = -100					; size = 4
_iSize$ = -88						; size = 4
_curNs$ = -80						; size = 4
_mem$ = -76						; size = 4
_signedInfoNode$ = -72					; size = 4
_sigNode$ = -68						; size = 4
_parent$ = -64						; size = 4
_rootNode$ = -60					; size = 4
_cur$ = -56						; size = 4
_root$ = -52						; size = 4
_dtd$ = -48						; size = 4
_doc$ = -44						; size = 4
_ctxt$ = -40						; size = 4
_charSignedXMLStr$ = -32				; size = 4
_ki$ = -24						; size = 4
_charDataStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_dataStrPtr$ = 12					; size = 4
_signedXMLStr$ = 16					; size = 4
?SignDataStr@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::SignDataStr

; 9133 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignDataStr@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 308				; 00000134H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-320]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9134 : 	char *charDataStr=NULL;

	mov	DWORD PTR _charDataStr$[ebp], 0

; 9135 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 9136 : 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 9137 : 	xmlValidCtxtPtr ctxt;
; 9138 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 9139 : 	xmlDtdPtr dtd =NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 9140 : 	xmlNodePtr root=NULL, cur=NULL, rootNode=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 9141 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 9142 : 	xmlNsPtr curNs;
; 9143 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 9144 : 	CComBSTR tmpDataStr;

	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 9145 : 	char *charSigId;
; 9146 : #ifdef WIN32
; 9147 : 	GUID sigGuid;
; 9148 : #else
; 9149 : 	uuid_t sigGuid;
; 9150 : #endif
; 9151 : 	char guidStr[50];
; 9152 : 	char elementId[50];
; 9153 : 
; 9154 : 	EnterLog;
; 9155 : 
; 9156 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L210710

; 9157 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9158 : 		return S_FALSE;

	mov	DWORD PTR $T221746[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221746[ebp]
	jmp	$L210689
$L210710:

; 9159 : 	}
; 9160 : 	if (! LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L210713

; 9161 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9162 : 		return S_FALSE;

	mov	DWORD PTR $T221747[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221747[ebp]
	jmp	$L210689
$L210713:

; 9163 : 	}
; 9164 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L210716

; 9165 : 	{
; 9166 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L210717

; 9167 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L210717:

; 9168 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 9169 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L210716:

; 9170 : 	}
; 9171 : 
; 9172 : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 9173 : 
; 9174 : 	tmpDataStr = dataStrPtr;

	mov	edx, DWORD PTR _dataStrPtr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 9175 : 	if (tmpDataStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210722

; 9176 : 	{
; 9177 : 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9178 : 		return S_FALSE;

	mov	DWORD PTR $T221748[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221748[ebp]
	jmp	$L210689
$L210722:

; 9179 : 	}
; 9180 : 	
; 9181 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG210726
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 9182 : 
; 9183 : 	// DTD
; 9184 :     dtd = xmlNewDtd(doc, BAD_CAST "SignatureEnvelope",NULL,NULL);

	push	0
	push	0
	push	OFFSET FLAT:$SG210728
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dtd$[ebp], eax

; 9185 : 	// create DTD validation context
; 9186 :     ctxt = xmlNewValidCtxt();

	call	_xmlNewValidCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 9187 : 	// add ATTLIST
; 9188 : 	xmlAddAttributeDecl(ctxt, dtd, BAD_CAST "infomosaic:SignedObject",
; 9189 :                     BAD_CAST "Id", NULL, 
; 9190 : 					XML_ATTRIBUTE_ID, XML_ATTRIBUTE_IMPLIED, 
; 9191 : 					NULL, NULL);		    

	push	0
	push	0
	push	3
	push	2
	push	0
	push	OFFSET FLAT:$SG210731
	push	OFFSET FLAT:$SG210732
	mov	eax, DWORD PTR _dtd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAddAttributeDecl
	add	esp, 36					; 00000024H

; 9192 : 	
; 9193 :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 9194 : 	xmlFreeValidCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeValidCtxt
	add	esp, 4

; 9195 : 
; 9196 : 	// document, namespace, element name, element content
; 9197 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"SignatureEnvelope",NULL);

	push	0
	push	OFFSET FLAT:$SG210736
	push	0
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 9198 : 
; 9199 : 	// if you want any namespace definition here
; 9200 : 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/SignData/DTD.htm",(const unsigned char *)"infomosaic");

	push	OFFSET FLAT:$SG210739
	push	OFFSET FLAT:$SG210740
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 9201 : 	xmlSetNs(cur,curNs);

	mov	ecx, DWORD PTR _curNs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlSetNs
	add	esp, 8

; 9202 : 
; 9203 : 	// add root element
; 9204 : 	xmlDocSetRootElement(doc,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocSetRootElement
	add	esp, 8

; 9205 : 	rootNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], edx

; 9206 : 	/*
; 9207 : 	 * SignedDataString
; 9208 : 	*/
; 9209 : 	cur = xmlNewNode(curNs,(const unsigned char *)"SignedObject"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210742
	mov	eax, DWORD PTR _curNs$[ebp]
	push	eax
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9210 : 	cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9211 : #ifdef WIN32
; 9212 : 	CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9213 : 	GuidToString(&sigGuid, &elementId[1]);

	lea	ecx, DWORD PTR _elementId$[ebp+1]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9214 : #else
; 9215 : 	uuid_generate(sigGuid);
; 9216 : 	uuid_unparse(sigGuid, &elementId[1]);
; 9217 : #endif
; 9218 : 
; 9219 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)&elementId[1]);

	lea	eax, DWORD PTR _elementId$[ebp+1]
	push	eax
	push	OFFSET FLAT:$SG210745
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9220 : 	xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210748
	push	OFFSET FLAT:$SG210749
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9221 : 	elementId[0] = '#';

	mov	BYTE PTR _elementId$[ebp], 35		; 00000023H

; 9222 : 
; 9223 : 	charDataStr = (char *)HeapW2A(dataStrPtr);

	mov	eax, DWORD PTR _dataStrPtr$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charDataStr$[ebp], eax

; 9224 : 
; 9225 : 	if (charDataStr == NULL)

	cmp	DWORD PTR _charDataStr$[ebp], 0
	jne	SHORT $L210751

; 9226 : 	{
; 9227 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 9228 : 		xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 9229 : 		return S_FALSE;

	mov	DWORD PTR $T221749[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221749[ebp]
	jmp	$L210689
$L210751:

; 9230 : 	}
; 9231 : 	int encodedSize;
; 9232 : 	unsigned char *encodedData;
; 9233 : 
; 9234 : 	// Base64 encode
; 9235 : 	encodedSize = base64encodeSize(strlen(charDataStr));

	mov	ecx, DWORD PTR _charDataStr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _encodedSize$[ebp], eax

; 9236 : 	if(!(encodedData = (unsigned char*)zMalloc(encodedSize+1)))

	mov	edx, DWORD PTR _encodedSize$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _encodedData$[ebp], eax
	cmp	DWORD PTR _encodedData$[ebp], 0
	jne	SHORT $L210757

; 9237 : 	{
; 9238 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9239 : 		return S_FALSE;

	mov	DWORD PTR $T221750[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221750[ebp]
	jmp	$L210689
$L210757:

; 9240 : 	}
; 9241 : 	if ((encodedSize = base64encode(	(unsigned char *)charDataStr,
; 9242 : 						strlen(charDataStr),
; 9243 : 						(unsigned char*)encodedData,
; 9244 : 						encodedSize+1))==-1) 

	mov	edx, DWORD PTR _encodedSize$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _encodedData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charDataStr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _charDataStr$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _encodedSize$[ebp], eax
	cmp	DWORD PTR _encodedSize$[ebp], -1
	jne	SHORT $L210762

; 9245 : 	{
; 9246 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9247 : 		zFree(encodedData);

	mov	edx, DWORD PTR _encodedData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9248 : 		return S_FALSE;

	mov	DWORD PTR $T221751[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221751[ebp]
	jmp	$L210689
$L210762:

; 9249 : 	}
; 9250 : 	*(encodedData+encodedSize)='\0';

	mov	eax, DWORD PTR _encodedData$[ebp]
	add	eax, DWORD PTR _encodedSize$[ebp]
	mov	BYTE PTR [eax], 0

; 9251 : 	zFree(charDataStr);

	mov	ecx, DWORD PTR _charDataStr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 9252 : 	xmlNodeSetContent(cur,(const unsigned char *)encodedData);

	mov	edx, DWORD PTR _encodedData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 9253 : 	zFree(encodedData);

	mov	ecx, DWORD PTR _encodedData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 9254 : 	/*
; 9255 : 	 * Signature
; 9256 : 	*/
; 9257 : 
; 9258 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 9259 : 	if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210767

; 9260 : 	{
; 9261 : #ifdef WIN32
; 9262 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9263 : 		GuidToString(&sigGuid, guidStr);

	lea	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9264 : #else
; 9265 : 		uuid_generate(sigGuid);
; 9266 : 		uuid_unparse(sigGuid, guidStr);
; 9267 : #endif
; 9268 : 		charSigId = guidStr;

	lea	edx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], edx

; 9269 : 	}
; 9270 : 	else

	jmp	SHORT $L210768
$L210767:

; 9271 : 	{
; 9272 : 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+392]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 9273 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L210768:

; 9274 : 	}
; 9275 : 
; 9276 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210771
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9277 : 	sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 9278 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG210774
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9279 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9280 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG210777
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 9281 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 9282 : 
; 9283 : 	/*
; 9284 : 	 * SignedInfo
; 9285 : 	*/
; 9286 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210779
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9287 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 9288 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9289 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9290 : 
; 9291 : 	/*
; 9292 : 	 * Canonicalization Method
; 9293 : 	*/
; 9294 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG210781
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9295 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv280[ebp], edx
	cmp	DWORD PTR tv280[ebp], 3
	ja	SHORT $L210806
	mov	eax, DWORD PTR tv280[ebp]
	jmp	DWORD PTR $L221767[eax*4]
$L210786:

; 9296 : 	{
; 9297 : 		case WITH_COMMENTS:
; 9298 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210789
	push	OFFSET FLAT:$SG210790
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9299 : 			break;

	jmp	SHORT $L210783
$L210791:

; 9300 : 		case WITHOUT_COMMENTS:
; 9301 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG210794
	push	OFFSET FLAT:$SG210795
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9302 : 			break;

	jmp	SHORT $L210783
$L210796:

; 9303 : 		case EXC_WITH_COMMENTS:
; 9304 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG210799
	push	OFFSET FLAT:$SG210800
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9305 : 			break;

	jmp	SHORT $L210783
$L210801:

; 9306 : 		case EXC_WITHOUT_COMMENTS:
; 9307 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG210804
	push	OFFSET FLAT:$SG210805
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9308 : 			break;

	jmp	SHORT $L210783
$L210806:

; 9309 : 		default:
; 9310 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210809
	push	OFFSET FLAT:$SG210810
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210783:

; 9311 : 	}
; 9312 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9313 : 	/*
; 9314 : 	 * Reference
; 9315 : 	*/
; 9316 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210812
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9317 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9318 : 	xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)elementId);

	lea	ecx, DWORD PTR _elementId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG210815
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9319 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9320 : 
; 9321 : 	/*
; 9322 : 	 * Transforms
; 9323 : 	 */
; 9324 : 	
; 9325 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG210817
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9326 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9327 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9328 : 
; 9329 : 	/*
; 9330 : 	 * Transform
; 9331 : 	 */
; 9332 : 	
; 9333 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG210819
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9334 : 	xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG210822
	push	OFFSET FLAT:$SG210823
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9335 : 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9336 : #ifdef WIN32
; 9337 : 	if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L210824

; 9338 : 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L210824:

; 9339 : 
; 9340 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L210825

; 9341 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L210825:

; 9342 : #endif
; 9343 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 9344 : 	EnvelopingFlag = ENVELOPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+688], 2

; 9345 : 
; 9346 : 	if (!(CreateSigFromTmplBlob(doc,charSigId, &charSignedXMLStr, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L210827

; 9347 : 	{
; 9348 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L210828

; 9349 : 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210828:

; 9350 : 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 9351 : 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210829

; 9352 : 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L210829:

; 9353 : 		return S_FALSE;

	mov	DWORD PTR $T221752[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221752[ebp]
	jmp	$L210689
$L210827:

; 9354 : 	}
; 9355 : 
; 9356 : 	EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 9357 : 	*signedXMLStr = A2WBSTR((const char *)charSignedXMLStr, iSize);

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 9358 : 	if (Base64EncodeXML == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2180], 1
	jne	SHORT $L210833

; 9359 : 		zFree(charSignedXMLStr);

	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9360 : 	else

	jmp	SHORT $L210834
$L210833:

; 9361 : 		xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L210834:

; 9362 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L210835

; 9363 : 		zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210835:

; 9364 : 	ExitLog;
; 9365 : 	return S_OK;

	mov	DWORD PTR $T221753[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221753[ebp]
$L210689:

; 9366 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221766
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 320				; 00000140H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221766:
	DD	6
	DD	$L221765
$L221765:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221757
	DD	-88					; ffffffa8H
	DD	4
	DD	$L221758
	DD	-100					; ffffff9cH
	DD	4
	DD	$L221759
	DD	-128					; ffffff80H
	DD	16					; 00000010H
	DD	$L221760
	DD	-188					; ffffff44H
	DD	50					; 00000032H
	DD	$L221761
	DD	-248					; ffffff08H
	DD	50					; 00000032H
	DD	$L221762
$L221762:
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L221761:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221760:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221759:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221758:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221757:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221767:
	DD	$L210791
	DD	$L210786
	DD	$L210801
	DD	$L210796
_TEXT	ENDS
text$x	SEGMENT
$L221754:
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignDataStr@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221756
	jmp	___CxxFrameHandler
text$x	ENDS
?SignDataStr@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::SignDataStr
PUBLIC	?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z ; CSignature::put_ExcludeSignerCertificate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_ExcludeSignerCertificate

; 9369 : {

	push	ebp
	mov	ebp, esp

; 9370 : 	EnterLog;
; 9371 : 	ExcludeSignerCertificateFlag = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1820], ecx

; 9372 : 	ExitLog;
; 9373 : 	return S_OK;

	xor	eax, eax

; 9374 : }

	pop	ebp
	ret	8
?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z ENDP	; CSignature::put_ExcludeSignerCertificate
_TEXT	ENDS
PUBLIC	?put_OverwriteFile@CSignature@@UAGJH@Z		; CSignature::put_OverwriteFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_OverwriteFile@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_OverwriteFile

; 9377 : {

	push	ebp
	mov	ebp, esp

; 9378 : 	EnterLog;
; 9379 : 	OverwriteFileFlag = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1824], ecx

; 9380 : 	ExitLog;
; 9381 : 	return S_OK;

	xor	eax, eax

; 9382 : }

	pop	ebp
	ret	8
?put_OverwriteFile@CSignature@@UAGJH@Z ENDP		; CSignature::put_OverwriteFile
_TEXT	ENDS
PUBLIC	?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z	; CSignature::CoSignXMLStr
EXTRN	_xmlXPathFreeObject:NEAR
EXTRN	_xmlXPathNewContext:NEAR
EXTRN	_xmlXPathFreeContext:NEAR
EXTRN	_xmlXPathEvalExpression:NEAR
EXTRN	_xmlXPathRegisterNs:NEAR
xdata$x	SEGMENT
$T221799 DD	0ffffffffH
	DD	FLAT:$L221785
$T221787 DD	019930520H
	DD	01H
	DD	FLAT:$T221799
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv297 = -340						; size = 4
$T221784 = -336						; size = 4
$T221783 = -332						; size = 4
$T221782 = -328						; size = 4
$T221781 = -324						; size = 4
$T221780 = -320						; size = 4
$T221779 = -316						; size = 4
$T221778 = -312						; size = 4
$T221777 = -308						; size = 4
$T221776 = -304						; size = 4
$T221775 = -300						; size = 4
$T221774 = -296						; size = 4
$T221773 = -292						; size = 4
_tmpEnvFlag$ = -288					; size = 2
_freeNewPtr$ = -284					; size = 4
_i$210907 = -280					; size = 4
_freeCharSigId$ = -276					; size = 4
__lpa$ = -272						; size = 4
__lpw$ = -268						; size = 4
__acp$ = -264						; size = 4
__convert$ = -260					; size = 4
_uriPath$ = -256					; size = 4
_refArr$ = -252						; size = 4
_refNum$ = -248						; size = 4
_i$ = -244						; size = 4
_base64$ = -240						; size = 4
_sizeM$ = -236						; size = 4
_szPtr$ = -232						; size = 4
_curPtr$ = -228						; size = 4
_newPtr$ = -224						; size = 4
_ptr$ = -220						; size = 4
_guidStr$ = -212					; size = 50
_sigGuid$ = -152					; size = 16
_ptemp$ = -132						; size = 4
_xpathResultPtr$ = -128					; size = 4
_xpathPtr$ = -124					; size = 4
_result$ = -116						; size = 4
_elementEnc$ = -108					; size = 4
_charSigId$ = -104					; size = 4
_tmpDataStr$ = -96					; size = 4
_iSize$ = -84						; size = 4
_curNs$ = -76						; size = 4
_mem$ = -72						; size = 4
_signedInfoNode$ = -68					; size = 4
_sigNode$ = -64						; size = 4
_parent$ = -60						; size = 4
_rootNode$ = -56					; size = 4
_tmpNode$ = -52						; size = 4
_cur$ = -48						; size = 4
_root$ = -44						; size = 4
_doc$ = -40						; size = 4
_charSignedXMLStr$ = -32				; size = 4
_ki$ = -24						; size = 4
_charDataStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_signedDataXMLStr$ = 12					; size = 4
_coSignedXMLStr$ = 16					; size = 4
?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::CoSignXMLStr

; 9386 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 328				; 00000148H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-340]
	mov	ecx, 82					; 00000052H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9387 : 	char *charDataStr=NULL;

	mov	DWORD PTR _charDataStr$[ebp], 0

; 9388 : 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 9389 : 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 9390 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 9391 : 	xmlNodePtr root=NULL, cur=NULL, tmpNode, rootNode=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 9392 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 9393 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 9394 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 9395 : 	CComBSTR tmpDataStr;

	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 9396 : 	char *charSigId, *elementEnc;
; 9397 : 	BOOL result=0;

	mov	DWORD PTR _result$[ebp], 0

; 9398 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 9399 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 9400 : 	char *ptemp;
; 9401 : #ifdef WIN32
; 9402 : 	GUID sigGuid;
; 9403 : #else
; 9404 : 	uuid_t sigGuid;
; 9405 : #endif
; 9406 : 	char guidStr[50];
; 9407 : 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 9408 : 	unsigned int *szPtr;
; 9409 : 	unsigned int sizeM;
; 9410 : //	BOOL oldDetailedVerificationReportFlag;
; 9411 : 	BOOL base64;
; 9412 : 	int i, refNum=0;

	mov	DWORD PTR _refNum$[ebp], 0

; 9413 : 	PURI_STATUS *refArr=NULL;

	mov	DWORD PTR _refArr$[ebp], 0

; 9414 : 	PURI_PATH uriPath=NULL;

	mov	DWORD PTR _uriPath$[ebp], 0

; 9415 : 	
; 9416 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 9417 : 	EnterLog;
; 9418 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L210890

; 9419 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9420 : 		return S_FALSE;

	mov	DWORD PTR $T221773[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221773[ebp]
	jmp	$L210852
$L210890:

; 9421 : 	}
; 9422 : 	if (! LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L210893

; 9423 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9424 : 		return S_FALSE;

	mov	DWORD PTR $T221774[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221774[ebp]
	jmp	$L210852
$L210893:

; 9425 : 	}
; 9426 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L210896

; 9427 : 	{
; 9428 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L210897

; 9429 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L210897:

; 9430 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 9431 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L210896:

; 9432 : 	}
; 9433 : 	tmpDataStr = signedDataXMLStr;

	mov	edx, DWORD PTR _signedDataXMLStr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 9434 : 	if (tmpDataStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L210898

; 9435 : 	{
; 9436 : 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9437 : 		return S_FALSE;

	mov	DWORD PTR $T221775[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221775[ebp]
	jmp	$L210852
$L210898:

; 9438 : 	}
; 9439 : 
; 9440 : 	/* we need detailed signature verification report so save the current status */
; 9441 : 	//oldDetailedVerificationReportFlag = DetailedVerificationReportFlag;
; 9442 : 
; 9443 : 	///* enable detailed verification */
; 9444 : 	//DetailedVerificationReportFlag = 1;
; 9445 : 
; 9446 : 	/* verify signature */
; 9447 : 	VerifyXMLStr(signedDataXMLStr, &result);

	mov	esi, esp
	lea	edx, DWORD PTR _result$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedDataXMLStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+300]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9448 : 
; 9449 : 	///* restore old flag value */
; 9450 : 	//DetailedVerificationReportFlag = oldDetailedVerificationReportFlag;
; 9451 : 
; 9452 : 	if (result == 0) // Signature verification failed

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L210901

; 9453 : 	{
; 9454 : 		/* no need to set error code as VerifyXMLStr has already done that */
; 9455 : 		return S_FALSE;

	mov	DWORD PTR $T221776[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221776[ebp]
	jmp	$L210852
$L210901:

; 9456 : 	}
; 9457 : 
; 9458 : 	/* If the user has provided a signature Id, make sure there is no clash 
; 9459 : 	 * with the signature in the input signed XML
; 9460 : 	 */
; 9461 : 
; 9462 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 9463 : 	if (SignatureID.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L210905

; 9464 : 	{ 
; 9465 : 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 9466 : 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1

; 9467 : 		for (int i=0; i < signum; i++)

	mov	DWORD PTR _i$210907[ebp], 0
	jmp	SHORT $L210908
$L210909:
	mov	eax, DWORD PTR _i$210907[ebp]
	add	eax, 1
	mov	DWORD PTR _i$210907[ebp], eax
$L210908:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$210907[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L210910

; 9468 : 		{
; 9469 : 			if (!strcmp((const char *)sgArr[i]->sigId, (const char *)charSigId))

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$210907[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L210913

; 9470 : 			{
; 9471 : 				setError(SigHandle, DUPLICATE_SIG_ID);

	push	69					; 00000045H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9472 : 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9473 : 				return S_FALSE; /* There already a signature with a matching Id */

	mov	DWORD PTR $T221777[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221777[ebp]
	jmp	$L210852
$L210913:

; 9474 : 			}
; 9475 : 		}

	jmp	$L210909
$L210910:

; 9476 : 	}
; 9477 : 	else // no signature id provided, lets create one

	jmp	SHORT $L210916
$L210905:

; 9478 : 	{
; 9479 : #ifdef WIN32
; 9480 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9481 : 		GuidToString(&sigGuid, guidStr);

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9482 : #else
; 9483 : 		uuid_generate(sigGuid);
; 9484 : 		uuid_unparse(sigGuid, guidStr);
; 9485 : #endif
; 9486 : 		charSigId = guidStr;

	lea	eax, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], eax
$L210916:

; 9487 : 	}
; 9488 : 
; 9489 : 
; 9490 : 	/* The input has a valid signed XML so lets try to find element with Id == sData and sign it */
; 9491 : 
; 9492 : 	BOOL freeNewPtr = FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 9493 : 	if (Base64DecodeXML == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2184], 0
	jne	$L210918

; 9494 : 	{
; 9495 : 		ptr = (unsigned char *)signedDataXMLStr;

	mov	edx, DWORD PTR _signedDataXMLStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 9496 : 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _szPtr$[ebp], eax

; 9497 : 		sizeM = (*szPtr);

	mov	ecx, DWORD PTR _szPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _sizeM$[ebp], edx

; 9498 : 
; 9499 : 		if (((*ptr == 0xff) && (*(ptr + 1) == 0xfe)) ||
; 9500 : 			((*ptr == 0xfe) && (*(ptr + 1) == 0xff)))

	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L210924
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 254				; 000000feH
	je	SHORT $L210923
$L210924:
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 254				; 000000feH
	jne	SHORT $L210922
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $L210922
$L210923:

; 9501 : 		{
; 9502 : 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 9503 : 			newPtr = ptr;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], edx

; 9504 : 		}
; 9505 : 		else

	jmp	SHORT $L210925
$L210922:

; 9506 : 		{
; 9507 : 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 9508 : 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 9509 : 
; 9510 : 			FileEncoding(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 9511 : //			*newPtr = 0xFF;
; 9512 : //			*(newPtr + 1) = 0xFE;
; 9513 : 
; 9514 : 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 2
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	add	ecx, 2
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 9515 : 			sizeM += 4;

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	mov	DWORD PTR _sizeM$[ebp], edx
$L210925:

; 9516 : 		}
; 9517 : 	}
; 9518 : 	else

	jmp	$L210927
$L210918:

; 9519 : 	{
; 9520 : 		ptr = HeapW2A(signedDataXMLStr);

	mov	eax, DWORD PTR _signedDataXMLStr$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 9521 : 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 9522 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 9523 : 		newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 9524 : 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 9525 : 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L210930

; 9526 : 		{
; 9527 : 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 9528 : 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9529 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9530 : 			return S_FALSE;

	mov	DWORD PTR $T221778[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221778[ebp]
	jmp	$L210852
$L210930:

; 9531 : 		}
; 9532 : 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210927:

; 9533 : 	}
; 9534 : 
; 9535 : 	// original document
; 9536 : 	doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 9537 : 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L210934

; 9538 : 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L210934:

; 9539 : 
; 9540 : 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L210935

; 9541 : 	{
; 9542 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9543 : 		return S_FALSE;

	mov	DWORD PTR $T221779[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221779[ebp]
	jmp	$L210852
$L210935:

; 9544 : 	}
; 9545 : 
; 9546 : 	ptemp = (char *)zMalloc(4096);

	push	4096					; 00001000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptemp$[ebp], eax

; 9547 : 
; 9548 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::infomosaic:%s]","SignedObject");

	push	OFFSET FLAT:$SG210939
	push	OFFSET FLAT:$SG210940
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 9549 : 
; 9550 : 	xpathPtr = xmlXPathNewContext(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 9551 : 
; 9552 : 	// register additional namespace for the signature
; 9553 : 	if (xmlXPathRegisterNs(xpathPtr,(const unsigned char *)"infomosaic",(const unsigned char *)"http://www.infomosaic.net/SignData/DTD.htm")!=0)

	push	OFFSET FLAT:$SG210944
	push	OFFSET FLAT:$SG210945
	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L210943

; 9554 : 	{
; 9555 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9556 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9557 : 		zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9558 : 		return S_FALSE;

	mov	DWORD PTR $T221780[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221780[ebp]
	jmp	$L210852
$L210943:

; 9559 : 	}
; 9560 : 
; 9561 : 	// apply XPath
; 9562 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 9563 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L210949

; 9564 : 	{
; 9565 : 		// not found
; 9566 : 		setError(SigHandle, INVALID_SDATA_NS);

	push	70					; 00000046H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9567 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9568 : 		zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9569 : 		return S_FALSE;

	mov	DWORD PTR $T221781[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221781[ebp]
	jmp	$L210852
$L210949:

; 9570 : 	}
; 9571 : 	xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 9572 : 
; 9573 :     rootNode = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _rootNode$[ebp], eax

; 9574 : 
; 9575 : 	/*
; 9576 : 	 * Signature
; 9577 : 	*/
; 9578 : 
; 9579 : 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210953
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9580 : 	sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 9581 : 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG210956
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9582 : 	cur = xmlAddChild(rootNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9583 : 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG210959
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 9584 : 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 9585 : 
; 9586 : 	/*
; 9587 : 	 * SignedInfo
; 9588 : 	*/
; 9589 : 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG210961
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9590 : 	signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 9591 : 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9592 : 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9593 : 
; 9594 : 	/*
; 9595 : 	 * Canonicalization Method
; 9596 : 	*/
; 9597 : 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG210963
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9598 : 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv297[ebp], edx
	cmp	DWORD PTR tv297[ebp], 3
	ja	SHORT $L210988
	mov	eax, DWORD PTR tv297[ebp]
	jmp	DWORD PTR $L221798[eax*4]
$L210968:

; 9599 : 	{
; 9600 : 		case WITH_COMMENTS:
; 9601 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210971
	push	OFFSET FLAT:$SG210972
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9602 : 			break;

	jmp	SHORT $L210965
$L210973:

; 9603 : 		case WITHOUT_COMMENTS:
; 9604 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG210976
	push	OFFSET FLAT:$SG210977
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9605 : 			break;

	jmp	SHORT $L210965
$L210978:

; 9606 : 		case EXC_WITH_COMMENTS:
; 9607 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG210981
	push	OFFSET FLAT:$SG210982
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9608 : 			break;

	jmp	SHORT $L210965
$L210983:

; 9609 : 		case EXC_WITHOUT_COMMENTS:
; 9610 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG210986
	push	OFFSET FLAT:$SG210987
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9611 : 			break;

	jmp	SHORT $L210965
$L210988:

; 9612 : 		default:
; 9613 : 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG210991
	push	OFFSET FLAT:$SG210992
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L210965:

; 9614 : 	}
; 9615 : 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9616 : 	/*
; 9617 : 	 * Reference
; 9618 : 	*/
; 9619 : 
; 9620 : 	// Add a reference for each reference in the previous signature, except for Properties, 
; 9621 : 	// Signature/Window Image and TimeStamp references
; 9622 : 	// Lets only look at the first signature found i.e. i=0
; 9623 : 
; 9624 : 	refNum = sgArr[0]->refNumber; // Number of URI in this signature

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _refNum$[ebp], edx

; 9625 : 	refArr = sgArr[0]->refArray;  // The URI Array itself

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _refArr$[ebp], eax

; 9626 : 
; 9627 : 	for (i=0; i < refNum; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L210993
$L210994:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L210993:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _refNum$[ebp]
	jge	$L210995

; 9628 : 	{
; 9629 : 		if (!(strstr((const char *)refArr[i]->URI,"SignatureImage_")) && 
; 9630 : 			!(strstr((const char *)refArr[i]->URI,"WindowImage_")) &&
; 9631 : 			!(strstr((const char *)refArr[i]->URI,TIME_STAMP_PREFIX)) && 
; 9632 : 			//!(strstr((const char *)refArr[i]->URI,TIME_RFC_3161_PREFIX)) && 
; 9633 : 			//!(strstr((const char *)refArr[i]->URI,TIME_SNTP_RFC_1305_PREFIX)) && 
; 9634 : 			!(strstr((const char *)refArr[i]->URI,"PROPERTIES_")) &&
; 9635 : 			!(strstr((const char *)refArr[i]->URI,"Comments_")))

	push	OFFSET FLAT:$SG211002
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$L211001
	push	OFFSET FLAT:$SG211003
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$L211001
	push	OFFSET FLAT:$SG211004
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$L211001
	push	OFFSET FLAT:$SG211005
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$L211001
	push	OFFSET FLAT:$SG211006
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	jne	$L211001

; 9636 : 		{
; 9637 : 
; 9638 : 			cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG211008
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9639 : 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9640 : 			xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)refArr[i]->URI);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET FLAT:$SG211011
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9641 : 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9642 : 
; 9643 : 			sprintf (ptemp,"(//. | //@* | //namespace::*)[self::infomosaic:%s[@Id='%s']]","SignedObject", refArr[i]->URI+1);

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	push	OFFSET FLAT:$SG211012
	push	OFFSET FLAT:$SG211013
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 9644 : 
; 9645 : 			// apply XPath
; 9646 : 			xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 9647 : 			if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L211015

; 9648 : 			{
; 9649 : 				// not found
; 9650 : 				setError(SigHandle, INVALID_SDATA_NS);

	push	70					; 00000046H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9651 : 				xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9652 : 				zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9653 : 				return S_FALSE;

	mov	DWORD PTR $T221782[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221782[ebp]
	jmp	$L210852
$L211015:

; 9654 : 			}
; 9655 : 
; 9656 : 
; 9657 : 			if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$L211018
	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+8], 0
	je	$L211018

; 9658 : 			{
; 9659 : 				// we found something, try to parse it
; 9660 : 				// start traversing the document, looking for Signature's children elements
; 9661 : 				tmpNode = xpathResultPtr->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tmpNode$[ebp], eax

; 9662 : 				elementEnc = (char *)xmlGetProp(tmpNode, (const unsigned char *)"Encoding");

	push	OFFSET FLAT:$SG211021
	mov	ecx, DWORD PTR _tmpNode$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _elementEnc$[ebp], eax

; 9663 : 				if (elementEnc != NULL)

	cmp	DWORD PTR _elementEnc$[ebp], 0
	je	SHORT $L211022

; 9664 : 					if (!(strcmp(elementEnc, ALG_BASE64)))

	push	OFFSET FLAT:$SG211024
	mov	edx, DWORD PTR _elementEnc$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L211023

; 9665 : 						base64 = TRUE;

	mov	DWORD PTR _base64$[ebp], 1

; 9666 : 					else

	jmp	SHORT $L211025
$L211023:

; 9667 : 						base64 = FALSE;

	mov	DWORD PTR _base64$[ebp], 0
$L211025:

; 9668 : 				else

	jmp	SHORT $L211026
$L211022:

; 9669 : 					base64 = FALSE;

	mov	DWORD PTR _base64$[ebp], 0
$L211026:

; 9670 : 
; 9671 : 				zFree(elementEnc);

	mov	eax, DWORD PTR _elementEnc$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9672 : 
; 9673 : 				/*
; 9674 : 				 * Transforms
; 9675 : 				 */
; 9676 : 				
; 9677 : 				cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG211028
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9678 : 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9679 : 				parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9680 : 
; 9681 : 				/*
; 9682 : 				 * Transform
; 9683 : 				 */
; 9684 : 
; 9685 : 				if (base64)

	cmp	DWORD PTR _base64$[ebp], 0
	je	SHORT $L211029

; 9686 : 				{
; 9687 : 					cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG211031
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9688 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG211034
	push	OFFSET FLAT:$SG211035
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9689 : 					cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9690 : 				}
; 9691 : 				else

	jmp	$L211018
$L211029:

; 9692 : 				{
; 9693 : 					/*
; 9694 : 					* Transform
; 9695 : 					*/
; 9696 : 					if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 9697 : 						(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	je	SHORT $L211038
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	$L211037
$L211038:

; 9698 : 					{
; 9699 : 						cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG211040
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9700 : 						if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L211041

; 9701 : 						{
; 9702 : 							xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG211044
	push	OFFSET FLAT:$SG211045
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9703 : 						}
; 9704 : 						else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L211046
$L211041:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L211046

; 9705 : 						{
; 9706 : 							xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG211050
	push	OFFSET FLAT:$SG211051
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L211046:

; 9707 : 						}
; 9708 : 						cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9709 : 						parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9710 : 						if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L211052

; 9711 : 						{
; 9712 : 							cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG211054
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9713 : 							xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG211057
	push	OFFSET FLAT:$SG211058
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 9714 : 							xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG211061
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9715 : 						}
; 9716 : 						else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L211062
$L211052:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L211062

; 9717 : 						{
; 9718 : 							cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG211065
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9719 : 							xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG211068
	push	OFFSET FLAT:$SG211069
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 9720 : 							xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG211072
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L211062:

; 9721 : 						}
; 9722 : 						cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9723 : 						parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx
$L211037:

; 9724 : 					}
; 9725 : 					cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG211074
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9726 : 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_XPATH);

	push	OFFSET FLAT:$SG211077
	push	OFFSET FLAT:$SG211078
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9727 : 					cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9728 : 					parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 9729 : 
; 9730 : 					cur = xmlNewNode(NULL,(const unsigned char *)"XPath");

	push	OFFSET FLAT:$SG211080
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9731 : 					cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9732 : 					xmlNodeSetContent(cur,(const unsigned char *)"self::text()");

	push	OFFSET FLAT:$SG211082
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L211018:

; 9733 : 				}
; 9734 : 			}
; 9735 : 			parent = signedInfoNode;

	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 9736 : 			xmlXPathFreeObject(xpathResultPtr);

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4
$L211001:

; 9737 : 		}
; 9738 : 	}

	jmp	$L210994
$L210995:

; 9739 : 	zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9740 : 	xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 9741 : 
; 9742 : #ifdef WIN32
; 9743 : 	if (AddWindowImageFlag == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 1
	jne	SHORT $L211083

; 9744 : 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L211083:

; 9745 : 
; 9746 : 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $L211084

; 9747 : 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L211084:

; 9748 : #endif
; 9749 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], dx

; 9750 : 	EnvelopingFlag = ENVELOPED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+688], 2

; 9751 : 
; 9752 : 	if (!(CreateSigFromTmplBlob(doc,
; 9753 : 								charSigId, &charSignedXMLStr, &iSize)))

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L211086

; 9754 : 	{
; 9755 : 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L211087

; 9756 : 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L211087:

; 9757 : 		EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 9758 : 		return S_FALSE;

	mov	DWORD PTR $T221783[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221783[ebp]
	jmp	SHORT $L210852
$L211086:

; 9759 : 	}
; 9760 : 	EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 9761 : 	*coSignedXMLStr = A2WBSTR((const char *)charSignedXMLStr, iSize);

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _coSignedXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 9762 : 	xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9763 : 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L211091

; 9764 : 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L211091:

; 9765 : 	ExitLog;
; 9766 : 	return S_OK;

	mov	DWORD PTR $T221784[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221784[ebp]
$L210852:

; 9767 : 
; 9768 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221797
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 340				; 00000154H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221797:
	DD	6
	DD	$L221796
$L221796:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221788
	DD	-84					; ffffffacH
	DD	4
	DD	$L221789
	DD	-96					; ffffffa0H
	DD	4
	DD	$L221790
	DD	-116					; ffffff8cH
	DD	4
	DD	$L221791
	DD	-152					; ffffff68H
	DD	16					; 00000010H
	DD	$L221792
	DD	-212					; ffffff2cH
	DD	50					; 00000032H
	DD	$L221793
$L221793:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221792:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221791:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$L221790:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221789:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221788:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221798:
	DD	$L210973
	DD	$L210968
	DD	$L210983
	DD	$L210978
_TEXT	ENDS
text$x	SEGMENT
$L221785:
	lea	ecx, DWORD PTR _tmpDataStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221787
	jmp	___CxxFrameHandler
text$x	ENDS
?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::CoSignXMLStr
PUBLIC	?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z		; CSignature::CoSignFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hr$ = -28						; size = 4
_inputXMLStr$ = -20					; size = 4
_coSignedXMLStr$ = -8					; size = 4
_this$ = 8						; size = 4
_inputSignedXMLFile$ = 12				; size = 4
_outFileName$ = 16					; size = 4
_outFilePath$ = 20					; size = 4
?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::CoSignFile

; 9771 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 9772 : 	BSTR coSignedXMLStr=NULL, inputXMLStr=NULL;

	mov	DWORD PTR _coSignedXMLStr$[ebp], 0
	mov	DWORD PTR _inputXMLStr$[ebp], 0

; 9773 : 	HRESULT hr;
; 9774 : 
; 9775 : 	EnterLog;
; 9776 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L211103

; 9777 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9778 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211099
$L211103:

; 9779 : 	}
; 9780 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L211105

; 9781 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9782 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211099
$L211105:

; 9783 : 	}
; 9784 : 
; 9785 : 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L211107

; 9786 : 	{
; 9787 : 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L211108

; 9788 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L211108:

; 9789 : 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 9790 : 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L211107:

; 9791 : 	}
; 9792 : 	hr = ReadAll(inputSignedXMLFile, &inputXMLStr);

	mov	esi, esp
	lea	edx, DWORD PTR _inputXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputSignedXMLFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+236]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 9793 : 	if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L211110

; 9794 : 	{
; 9795 : 		return S_FALSE; // File could not be read

	mov	eax, 1
	jmp	$L211099
$L211110:

; 9796 : 	}
; 9797 : 
; 9798 : 	hr = CoSignXMLStr(inputXMLStr, &coSignedXMLStr);

	mov	esi, esp
	lea	ecx, DWORD PTR _coSignedXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+456]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 9799 : 	if ((hr != S_OK) || (coSignedXMLStr == NULL))

	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $L211114
	cmp	DWORD PTR _coSignedXMLStr$[ebp], 0
	jne	SHORT $L211113
$L211114:

; 9800 : 	{
; 9801 : 		SysFreeString(inputXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _inputXMLStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9802 : 		return S_FALSE; // Co signing failed

	mov	eax, 1
	jmp	$L211099
$L211113:

; 9803 : 	}
; 9804 : 	hr = SaveXMLStr(coSignedXMLStr, outFileName, outFilePath);

	mov	esi, esp
	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _coSignedXMLStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+240]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 9805 : 	if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L211117

; 9806 : 	{
; 9807 : 		SysFreeString(inputXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _inputXMLStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9808 : 		SysFreeString(coSignedXMLStr);

	mov	esi, esp
	mov	edx, DWORD PTR _coSignedXMLStr$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9809 : 		return S_FALSE; // file save failed

	mov	eax, 1
	jmp	SHORT $L211099
$L211117:

; 9810 : 	}
; 9811 : 	SysFreeString(inputXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _inputXMLStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9812 : 	SysFreeString(coSignedXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _coSignedXMLStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9813 : 	ExitLog;
; 9814 : 	return S_OK;

	xor	eax, eax
$L211099:

; 9815 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221804
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221804:
	DD	2
	DD	$L221803
$L221803:
	DD	-8					; fffffff8H
	DD	4
	DD	$L221801
	DD	-20					; ffffffecH
	DD	4
	DD	$L221802
$L221802:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221801:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::CoSignFile
_TEXT	ENDS
PUBLIC	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
PUBLIC	?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ; CSignature::SignFiles
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv336 = -272						; size = 4
__lpa$ = -268						; size = 4
__lpw$ = -264						; size = 4
__acp$ = -260						; size = 4
__convert$ = -256					; size = 4
_freeCharSigId$ = -252					; size = 4
_tmpEnvFlag$ = -248					; size = 2
_hResult$ = -244					; size = 4
_signedXMLBstr$ = -240					; size = 4
_charSignedXMLStr$ = -232				; size = 4
_iSize$ = -220						; size = 4
_mem$ = -212						; size = 4
_curNs$ = -208						; size = 4
_signedInfoNode$ = -204					; size = 4
_sigNode$ = -200					; size = 4
_commNode$ = -196					; size = 4
_parent$ = -192						; size = 4
_rootNode$ = -188					; size = 4
_cur$ = -184						; size = 4
_dtd$ = -180						; size = 4
_doc$ = -176						; size = 4
_ctxt$ = -172						; size = 4
_charSigId$ = -168					; size = 4
_binFileData$ = -160					; size = 4
_fileSize$ = -148					; size = 4
_crBlob$ = -136						; size = 8
_guidStr$ = -120					; size = 50
_maxGuidLen$ = -64					; size = 4
_objectId$ = -60					; size = 4
_sigGuid$ = -52						; size = 16
_bareFileName$ = -32					; size = 4
_charInputFile$ = -28					; size = 4
_bstrList$ = -24					; size = 4
_itemCount$ = -16					; size = 4
_elementCount$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_fileList$ = 12						; size = 16
_outFileName$ = 28					; size = 4
_outFilePath$ = 32					; size = 4
?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z PROC NEAR ; CSignature::SignFiles

; 9818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-272]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9819 : 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 9820 : 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 9821 : 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 9822 : 	char *charInputFile=NULL;

	mov	DWORD PTR _charInputFile$[ebp], 0

; 9823 : 	unsigned char *bareFileName=NULL;

	mov	DWORD PTR _bareFileName$[ebp], 0

; 9824 : #ifdef WIN32
; 9825 : 	GUID sigGuid;
; 9826 : #else
; 9827 : 	uuid_t sigGuid;
; 9828 : #endif
; 9829 : 	char **objectId=NULL;

	mov	DWORD PTR _objectId$[ebp], 0

; 9830 : 	const UINT maxGuidLen =	50;

	mov	DWORD PTR _maxGuidLen$[ebp], 50		; 00000032H

; 9831 : 	char guidStr[maxGuidLen];
; 9832 : 	DS_DATA_BLOB crBlob;
; 9833 : 	DWORD fileSize;
; 9834 : 	unsigned char *binFileData=NULL;

	mov	DWORD PTR _binFileData$[ebp], 0

; 9835 : 	char *charSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 9836 : 	xmlValidCtxtPtr ctxt;
; 9837 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 9838 : 	xmlDtdPtr dtd =NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 9839 : 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 9840 : 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 9841 : 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 9842 : 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 9843 : 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 9844 : 	BSTR signedXMLBstr;
; 9845 : 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 9846 : 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 9847 : 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 9848 : 
; 9849 : 	EnterLog;
; 9850 : 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L211157

; 9851 : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9852 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211125
$L211157:

; 9853 : 	}
; 9854 : 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L211159

; 9855 : 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 9856 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211125
$L211159:

; 9857 : 	}
; 9858 : 
; 9859 : 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L211161

; 9860 : 	{
; 9861 : 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L211162

; 9862 : 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L211162:

; 9863 : 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 9864 : 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L211161:

; 9865 : 	}
; 9866 : 
; 9867 : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 9868 : 
; 9869 : 	if ((fileList.vt != VT_BSTR) &&
; 9870 : 		(fileList.vt != VT_DISPATCH) &&
; 9871 : 		!(fileList.vt & VT_ARRAY) && 
; 9872 : 		!(fileList.vt & VT_BYREF))

	movzx	ecx, WORD PTR _fileList$[ebp]
	cmp	ecx, 8
	je	SHORT $L211167
	movzx	edx, WORD PTR _fileList$[ebp]
	cmp	edx, 9
	je	SHORT $L211167
	movzx	eax, WORD PTR _fileList$[ebp]
	and	eax, 8192				; 00002000H
	jne	SHORT $L211167
	movzx	ecx, WORD PTR _fileList$[ebp]
	and	ecx, 16384				; 00004000H
	jne	SHORT $L211167

; 9873 : 	{
; 9874 : 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9875 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211125
$L211167:

; 9876 : 	}
; 9877 : 
; 9878 : 	bstrList = GetBstrArrayFromVariant(fileList, &itemCount);

	lea	ecx, DWORD PTR _itemCount$[ebp]
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _fileList$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _fileList$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _fileList$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _fileList$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 9879 : 
; 9880 : 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L211170
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L211169
$L211170:

; 9881 : 	{
; 9882 : 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9883 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L211125
$L211169:

; 9884 : 	}
; 9885 : 
; 9886 : 	crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 9887 : 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 9888 : 
; 9889 : 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG211173
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 9890 : 	// DTD
; 9891 :     dtd = xmlNewDtd(doc, BAD_CAST "SignatureEnvelope",NULL,NULL);

	push	0
	push	0
	push	OFFSET FLAT:$SG211175
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dtd$[ebp], eax

; 9892 : 	// create DTD validation context
; 9893 :     ctxt = xmlNewValidCtxt();

	call	_xmlNewValidCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 9894 : 	// add ATTLIST
; 9895 : 	xmlAddAttributeDecl(ctxt, dtd, BAD_CAST "infomosaic:SignedObject",
; 9896 :                     BAD_CAST "Id", NULL, 
; 9897 : 					XML_ATTRIBUTE_ID, XML_ATTRIBUTE_IMPLIED, 
; 9898 : 					NULL, NULL);		    

	push	0
	push	0
	push	3
	push	2
	push	0
	push	OFFSET FLAT:$SG211178
	push	OFFSET FLAT:$SG211179
	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlAddAttributeDecl
	add	esp, 36					; 00000024H

; 9899 : 	
; 9900 :     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	mov	ecx, DWORD PTR _dtd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8

; 9901 : 	xmlFreeValidCtxt(ctxt);

	mov	eax, DWORD PTR _ctxt$[ebp]
	push	eax
	call	_xmlFreeValidCtxt
	add	esp, 4

; 9902 : 	// document, namespace, element name, element content
; 9903 : 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"SignatureEnvelope",NULL);

	push	0
	push	OFFSET FLAT:$SG211183
	push	0
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 9904 : 
; 9905 : 	// if you want any namespace definition here
; 9906 : 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/SignData/DTD.htm",(const unsigned char *)"infomosaic");

	push	OFFSET FLAT:$SG211186
	push	OFFSET FLAT:$SG211187
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 9907 : 	xmlSetNs(cur,curNs);

	mov	eax, DWORD PTR _curNs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlSetNs
	add	esp, 8

; 9908 : 
; 9909 : 	// add root element
; 9910 : 	xmlDocSetRootElement(doc,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocSetRootElement
	add	esp, 8

; 9911 : 	rootNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], ecx

; 9912 : 	/*
; 9913 : 	 * SignedObject
; 9914 : 	*/
; 9915 : 	objectId = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _objectId$[ebp], eax

; 9916 : 	if (objectId == NULL)

	cmp	DWORD PTR _objectId$[ebp], 0
	jne	SHORT $L211190

; 9917 : 	{
; 9918 : 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9919 : 		hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 9920 : 		goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211190:

; 9921 : 	}
; 9922 : 	memset(objectId, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _objectId$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 9923 : 
; 9924 : 	for (elementCount=0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211195
$L211196:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L211195:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	$L211197

; 9925 : 	{
; 9926 : //		charInputFile = (char *)HeapW2A(bstrList[elementCount]);
; 9927 : 		bareFileName  = xsRemoveBstrPath(bstrList[elementCount]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsRemoveBstrPath@CSignature@@QAEPAEPAG@Z ; CSignature::xsRemoveBstrPath
	mov	DWORD PTR _bareFileName$[ebp], eax

; 9928 : 
; 9929 : 		objectId[elementCount] = (char *) zMalloc (sizeof(char) * maxGuidLen);

	push	50					; 00000032H
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _objectId$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 9930 : 		if (objectId[elementCount] == NULL)

	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _objectId$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $L211200

; 9931 : 		{
; 9932 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 9933 : 			hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 9934 : 			goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211200:

; 9935 : 		}
; 9936 : #ifdef WIN32
; 9937 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9938 : 		GuidToString(&sigGuid, objectId[elementCount]+1);

	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _objectId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9939 : #else
; 9940 : 		uuid_generate(sigGuid);
; 9941 : 		uuid_unparse(sigGuid, objectId[elementCount] + 1);
; 9942 : #endif
; 9943 : 		*objectId[elementCount] = '#';

	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _objectId$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	BYTE PTR [edx], 35			; 00000023H

; 9944 : 		
; 9945 : 		cur = xmlNewNode(curNs,(const unsigned char *)"SignedObject"); // Using the parent element's name space

	push	OFFSET FLAT:$SG211204
	mov	eax, DWORD PTR _curNs$[ebp]
	push	eax
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9946 : 		cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 9947 : 		xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG211207
	push	OFFSET FLAT:$SG211208
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9948 : 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)objectId[elementCount]+1);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _objectId$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	add	eax, 1
	push	eax
	push	OFFSET FLAT:$SG211211
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9949 : 		xmlNewProp(cur, (const unsigned char *)"FileName", (const unsigned char *)bareFileName);

	mov	edx, DWORD PTR _bareFileName$[ebp]
	push	edx
	push	OFFSET FLAT:$SG211214
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 9950 : 		zFree(bareFileName);

	mov	ecx, DWORD PTR _bareFileName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 9951 : 
; 9952 : 		if (ReadAllBin(bstrList[elementCount], &binFileData, &fileSize) == S_FALSE)

	lea	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L211216

; 9953 : 		{
; 9954 : 			setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 9955 : 			zFree(charInputFile);

	mov	eax, DWORD PTR _charInputFile$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9956 : 			xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9957 : 			hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 9958 : 			goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211216:

; 9959 : 		}
; 9960 : //		zFree(charInputFile);
; 9961 : 		crBlob.cbData = base64encodeSize(fileSize);

	mov	edx, DWORD PTR _fileSize$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp+4], eax

; 9962 : 		// allocate memory
; 9963 : 		if(!(crBlob.pbData = (unsigned char*)zMalloc(crBlob.cbData+1)))

	mov	eax, DWORD PTR _crBlob$[ebp+4]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crBlob$[ebp], eax
	cmp	DWORD PTR _crBlob$[ebp], 0
	jne	SHORT $L211220

; 9964 : 		{
; 9965 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 9966 : 			zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9967 : 			xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9968 : 			hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 9969 : 			goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211220:

; 9970 : 		}
; 9971 : 		if (base64encode((unsigned char *)binFileData,fileSize,(unsigned char*)crBlob.pbData,crBlob.cbData)==-1) 

	mov	edx, DWORD PTR _crBlob$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _binFileData$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L211225

; 9972 : 		{
; 9973 : 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 9974 : 			zFree(crBlob.pbData);

	mov	edx, DWORD PTR _crBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 9975 : 			zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9976 : 			xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 9977 : 			hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 9978 : 			goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211225:

; 9979 : 		}
; 9980 : 		*(crBlob.pbData+crBlob.cbData)='\0';

	mov	edx, DWORD PTR _crBlob$[ebp]
	add	edx, DWORD PTR _crBlob$[ebp+4]
	mov	BYTE PTR [edx], 0

; 9981 : 
; 9982 : 		zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9983 : 
; 9984 : 		xmlNodeSetContent(cur,(const unsigned char *)crBlob.pbData);

	mov	ecx, DWORD PTR _crBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 9985 : 		zFree(crBlob.pbData);

	mov	eax, DWORD PTR _crBlob$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 9986 : 		crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 9987 : 		crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 9988 : 	}

	jmp	$L211196
$L211197:

; 9989 : 	/*
; 9990 : 	 * Signature
; 9991 : 	*/
; 9992 : 
; 9993 : 	if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211229

; 9994 : 	{
; 9995 : #ifdef WIN32
; 9996 : 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 9997 : 		GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 9998 : #else
; 9999 : 		uuid_generate(sigGuid);
; 10000: 		uuid_unparse(sigGuid, guidStr);
; 10001: #endif
; 10002: 		charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 10003: 	}
; 10004: 	else

	jmp	SHORT $L211230
$L211229:

; 10005: 	{
; 10006: 		charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 10007: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L211230:

; 10008: 	}
; 10009: 
; 10010: 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG211233
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10011: 	sigNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], ecx

; 10012: 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG211236
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10013: 	cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10014: 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG211239
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 10015: 	parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 10016: 
; 10017: 	/*
; 10018: 	 * SignedInfo
; 10019: 	*/
; 10020: 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG211241
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10021: 	signedInfoNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], edx

; 10022: 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10023: 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 10024: 
; 10025: 	/*
; 10026: 	 * Canonicalization Method
; 10027: 	*/
; 10028: 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG211243
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10029: 	switch(CanonicalizationMethod)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3336]
	mov	DWORD PTR tv336[ebp], ecx
	cmp	DWORD PTR tv336[ebp], 3
	ja	SHORT $L211268
	mov	edx, DWORD PTR tv336[ebp]
	jmp	DWORD PTR $L221818[edx*4]
$L211248:

; 10030: 	{
; 10031: 		case WITH_COMMENTS:
; 10032: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG211251
	push	OFFSET FLAT:$SG211252
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10033: 			break;

	jmp	SHORT $L211245
$L211253:

; 10034: 		case WITHOUT_COMMENTS:
; 10035: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG211256
	push	OFFSET FLAT:$SG211257
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10036: 			break;

	jmp	SHORT $L211245
$L211258:

; 10037: 		case EXC_WITH_COMMENTS:
; 10038: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG211261
	push	OFFSET FLAT:$SG211262
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10039: 			break;

	jmp	SHORT $L211245
$L211263:

; 10040: 		case EXC_WITHOUT_COMMENTS:
; 10041: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG211266
	push	OFFSET FLAT:$SG211267
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10042: 			break;

	jmp	SHORT $L211245
$L211268:

; 10043: 		default:
; 10044: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG211271
	push	OFFSET FLAT:$SG211272
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L211245:

; 10045: 	}
; 10046: 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10047: 	/*
; 10048: 	 * Reference
; 10049: 	*/
; 10050: 
; 10051: 	for (elementCount=0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211273
$L211274:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L211273:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	$L211275

; 10052: 	{
; 10053: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG211277
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10054: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10055: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)objectId[elementCount]);

	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _objectId$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET FLAT:$SG211280
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10056: 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 10057: 
; 10058: 		/*
; 10059: 		 * Transforms
; 10060: 		 */
; 10061: 		
; 10062: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG211282
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10063: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10064: 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 10065: 
; 10066: 		/*
; 10067: 		 * Transform
; 10068: 		 */
; 10069: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG211284
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10070: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG211287
	push	OFFSET FLAT:$SG211288
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 10071: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 10072: 		parent = signedInfoNode;

	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 10073: 	}

	jmp	$L211274
$L211275:

; 10074: #ifdef WIN32
; 10075: 	if (AddWindowImageFlag == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 1
	jne	SHORT $L211289

; 10076: 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L211289:

; 10077: 
; 10078: 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $L211290

; 10079: 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L211290:

; 10080: #endif
; 10081: 	EnvelopingFlag = ENVELOPED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+688], 2

; 10082: 
; 10083: 	if (!(CreateSigFromTmplBlob(doc,charSigId, &charSignedXMLStr, &iSize)))

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L211291

; 10084: 	{
; 10085: 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L211292

; 10086: 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L211292:

; 10087: 		hResult = S_FALSE;

	mov	DWORD PTR _hResult$[ebp], 1

; 10088: 		EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 10089: 		goto ExitSignFiles;

	jmp	$ExitSignFiles$211192
$L211291:

; 10090: 	}
; 10091: 	EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 10092: 
; 10093: 	signedXMLBstr = A2WBSTR((const char *)charSignedXMLStr, iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _signedXMLBstr$[ebp], eax

; 10094: 	if (Base64EncodeXML == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 1
	jne	SHORT $L211296

; 10095: 		zFree(charSignedXMLStr);

	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10096: 	else

	jmp	SHORT $L211297
$L211296:

; 10097: 		xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L211297:

; 10098: 
; 10099: 	hResult = SaveXMLStr(signedXMLBstr, outFileName, outFilePath);

	mov	esi, esp
	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedXMLBstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+240]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 10100: 	SysFreeString(signedXMLBstr);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXMLBstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$ExitSignFiles$211192:

; 10101: 
; 10102: ExitSignFiles:
; 10103: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211298
$L211299:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211298:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211300

; 10104: 	{
; 10105: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10106: 		if (objectId != NULL)

	cmp	DWORD PTR _objectId$[ebp], 0
	je	SHORT $L211301

; 10107: 			if (objectId[elementCount] != NULL)

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _objectId$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L211301

; 10108: 				zFree(objectId[elementCount]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _objectId$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4
$L211301:

; 10109: 	}

	jmp	SHORT $L211299
$L211300:

; 10110: 	zFree(bstrList);

	mov	eax, DWORD PTR _bstrList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 10111: 	if (objectId != NULL)

	cmp	DWORD PTR _objectId$[ebp], 0
	je	SHORT $L211303

; 10112: 		zFree(objectId);

	mov	ecx, DWORD PTR _objectId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L211303:

; 10113: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L211304

; 10114: 		zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L211304:

; 10115: 	ExitLog;
; 10116: 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]
$L211125:

; 10117: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221817
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 272				; 00000110H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L221817:
	DD	8
	DD	$L221816
$L221816:
	DD	-16					; fffffff0H
	DD	4
	DD	$L221807
	DD	-52					; ffffffccH
	DD	16					; 00000010H
	DD	$L221808
	DD	-120					; ffffff88H
	DD	50					; 00000032H
	DD	$L221809
	DD	-136					; ffffff78H
	DD	8
	DD	$L221810
	DD	-148					; ffffff6cH
	DD	4
	DD	$L221811
	DD	-160					; ffffff60H
	DD	4
	DD	$L221812
	DD	-220					; ffffff24H
	DD	4
	DD	$L221813
	DD	-232					; ffffff18H
	DD	4
	DD	$L221814
$L221814:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221813:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221812:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L221811:
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221810:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221809:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221808:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L221807:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221818:
	DD	$L211253
	DD	$L211248
	DD	$L211263
	DD	$L211258
?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ENDP	; CSignature::SignFiles
_TEXT	ENDS
PUBLIC	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ		; ATL::CSimpleStringT<char,0>::operator char const *
PUBLIC	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
PUBLIC	??0CComVariant@ATL@@QAE@XZ			; ATL::CComVariant::CComVariant
PUBLIC	??1CComVariant@ATL@@QAE@XZ			; ATL::CComVariant::~CComVariant
PUBLIC	?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
PUBLIC	?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z ; CSignature::GetIDispatchProperty
EXTRN	__imp__SafeArrayGetDim@4:NEAR
EXTRN	__imp__SafeArrayGetElemsize@4:NEAR
EXTRN	__imp__SafeArrayGetUBound@12:NEAR
EXTRN	__imp__SafeArrayGetLBound@12:NEAR
EXTRN	__imp__SafeArrayGetElement@12:NEAR
EXTRN	__imp__SafeArrayGetVartype@8:NEAR
xdata$x	SEGMENT
$T221837 DD	0ffffffffH
	DD	FLAT:$L221821
	DD	00H
	DD	FLAT:$L221822
	DD	01H
	DD	FLAT:$L221823
$T221825 DD	019930520H
	DD	03H
	DD	FLAT:$T221837
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221820 = -184						; size = 4
_I$211402 = -180					; size = 4
_Length$211396 = -176					; size = 4
_TString$211395 = -168					; size = 4
_Error$211391 = -157					; size = 1
_ComVariant$211390 = -152				; size = 16
_lpDispatch$211389 = -132				; size = 4
__lpa$ = -128						; size = 4
__lpw$ = -124						; size = 4
__acp$ = -120						; size = 4
__convert$ = -116					; size = 4
_numElements$ = -112					; size = 4
_tmpCcBstr$ = -104					; size = 4
_fList$ = -96						; size = 4
_tmpBstr$ = -88						; size = 4
_bstrList$ = -80					; size = 4
_elementCount$ = -72					; size = 4
_arrayType$ = -60					; size = 2
_uBound$ = -48						; size = 4
_lBound$ = -36						; size = 4
_elementSize$ = -28					; size = 4
_arrayDim$ = -24					; size = 4
_vA$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileList$ = 8						; size = 16
_itemCount$ = 24					; size = 4
?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z PROC NEAR ; CSignature::GetBstrArrayFromVariant
; _this$ = ecx

; 10120: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 10121: 	VARIANT **vA;
; 10122: 	UINT arrayDim, elementSize;
; 10123: 	long lBound, uBound;
; 10124: 	VARTYPE arrayType;
; 10125: 	long elementCount;
; 10126: 	BSTR	*bstrList = NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 10127: 	BSTR	tmpBstr;
; 10128: 	VARIANT *fList;
; 10129: 	CComBSTR tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 10130: 	UINT numElements=0;

	mov	DWORD PTR _numElements$[ebp], 0

; 10131: 
; 10132: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10133: 	EnterLog;
; 10134: 	fList = &fileList;

	lea	eax, DWORD PTR _fileList$[ebp]
	mov	DWORD PTR _fList$[ebp], eax

; 10135: 	*itemCount = 0;

	mov	ecx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx], 0

; 10136: 
; 10137: 	if (fileList.vt == 0x400c)

	movzx	edx, WORD PTR _fileList$[ebp]
	cmp	edx, 16396				; 0000400cH
	jne	SHORT $L211326

; 10138: 	{
; 10139: 		fList = fileList.pvarVal;

	mov	eax, DWORD PTR _fileList$[ebp+8]
	mov	DWORD PTR _fList$[ebp], eax
$L211326:

; 10140: 	}
; 10141: 
; 10142: 	if (fList->vt == VT_BSTR) // This is just a BSTR so there is just one file being signed

	mov	ecx, DWORD PTR _fList$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 8
	jne	SHORT $L211327

; 10143: 	{
; 10144: 		tmpCcBstr = fList->bstrVal;

	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 10145: 		if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211328

; 10146: 		{
; 10147: 			*itemCount = 0;

	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [edx], 0

; 10148: 			goto getBstrArrayExit;

	jmp	$getBstrArrayExit$211329
$L211328:

; 10149: 		}
; 10150: 		else
; 10151: 		{
; 10152: 			*itemCount = 1;

	mov	eax, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [eax], 1

; 10153: 			bstrList = (BSTR *) zMalloc (sizeof(BSTR *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _bstrList$[ebp], eax

; 10154: 			bstrList[0] = SysAllocString(fList->bstrVal);

	mov	esi, esp
	mov	ecx, DWORD PTR _fList$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [ecx], eax

; 10155: 		}
; 10156: 	}
; 10157: 	else

	jmp	$getBstrArrayExit$211329
$L211327:

; 10158: 	{
; 10159: 		if (fList->vt & VT_ARRAY)

	mov	edx, DWORD PTR _fList$[ebp]
	movzx	eax, WORD PTR [edx]
	and	eax, 8192				; 00002000H
	je	$L211335

; 10160: 		{
; 10161: 			if (fList->vt & VT_BYREF)

	mov	ecx, DWORD PTR _fList$[ebp]
	movzx	edx, WORD PTR [ecx]
	and	edx, 16384				; 00004000H
	je	$L211336

; 10162: 			{
; 10163: 				arrayDim = SafeArrayGetDim(*(fList->pparray));

	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SafeArrayGetDim@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _arrayDim$[ebp], eax

; 10164: 				SafeArrayGetLBound(*(fList->pparray), 1,  &lBound);

	mov	esi, esp
	lea	eax, DWORD PTR _lBound$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _fList$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SafeArrayGetLBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10165: 				SafeArrayGetUBound(*(fList->pparray), 1,  &uBound);

	mov	esi, esp
	lea	ecx, DWORD PTR _uBound$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _fList$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetUBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10166: 				SafeArrayGetVartype(*(fList->pparray), &arrayType);

	mov	esi, esp
	lea	edx, DWORD PTR _arrayType$[ebp]
	push	edx
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SafeArrayGetVartype@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10167: 				if (arrayType & VT_VARIANT)

	movzx	eax, WORD PTR _arrayType$[ebp]
	and	eax, 12					; 0000000cH
	je	$L211337

; 10168: 				{
; 10169: 					vA = (VARIANT **)zMalloc(sizeof(VARIANT *) * (uBound - lBound + 1));

	mov	ecx, DWORD PTR _uBound$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vA$[ebp], eax

; 10170: 					for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	eax, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], eax
	jmp	SHORT $L211340
$L211341:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L211340:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211342

; 10171: 					{
; 10172: 						elementSize = SafeArrayGetElemsize( *(fList->pparray));

	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__SafeArrayGetElemsize@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _elementSize$[ebp], eax

; 10173: 						vA[elementCount - lBound]	= (VARIANT *)zMalloc(elementSize);

	mov	eax, DWORD PTR _elementSize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _elementCount$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	mov	edx, DWORD PTR _vA$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10174: 						SafeArrayGetElement(*(fList->pparray), &elementCount, vA[elementCount - lBound]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	mov	esi, esp
	mov	ecx, DWORD PTR _vA$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	eax, DWORD PTR _elementCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fList$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SafeArrayGetElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10175: 					}

	jmp	SHORT $L211341
$L211342:

; 10176: 					bstrList = (BSTR *) zMalloc (sizeof(BSTR *) * (uBound - lBound + 1));

	mov	ecx, DWORD PTR _uBound$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _bstrList$[ebp], eax

; 10177: 					memset((void *)bstrList, 0, sizeof(BSTR *) * (uBound - lBound + 1));

	mov	eax, DWORD PTR _uBound$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	push	0
	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 10178: 					for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	eax, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], eax
	jmp	SHORT $L211348
$L211349:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L211348:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211350

; 10179: 					{
; 10180: 						tmpCcBstr = vA[elementCount - lBound]->bstrVal;

	mov	eax, DWORD PTR _elementCount$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	mov	ecx, DWORD PTR _vA$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 10181: 						if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211351

; 10182: 						{
; 10183: 							continue;

	jmp	SHORT $L211349
$L211351:

; 10184: 						}
; 10185: 						else
; 10186: 						{
; 10187: 							bstrList[numElements] = SysAllocString(vA[elementCount - lBound]->bstrVal);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	mov	edx, DWORD PTR _vA$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _numElements$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 10188: 							numElements++;

	mov	edx, DWORD PTR _numElements$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElements$[ebp], edx

; 10189: 						}
; 10190: 					}

	jmp	SHORT $L211349
$L211350:

; 10191: 					for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	eax, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], eax
	jmp	SHORT $L211353
$L211354:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L211353:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211355

; 10192: 					{
; 10193: 						VariantClear(vA[elementCount - lBound]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	mov	esi, esp
	mov	ecx, DWORD PTR _vA$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10194: 						zFree(vA[elementCount - lBound]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	mov	ecx, DWORD PTR _vA$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 10195: 					}

	jmp	SHORT $L211354
$L211355:

; 10196: 					zFree(vA);

	mov	eax, DWORD PTR _vA$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 10197: 					*itemCount = numElements;

	mov	ecx, DWORD PTR _itemCount$[ebp]
	mov	edx, DWORD PTR _numElements$[ebp]
	mov	DWORD PTR [ecx], edx
$L211337:

; 10198: 				}
; 10199: 			}
; 10200: 			else

	jmp	$L211356
$L211336:

; 10201: 			{
; 10202: 				arrayDim = SafeArrayGetDim(fList->parray);

	mov	esi, esp
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetDim@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _arrayDim$[ebp], eax

; 10203: 				SafeArrayGetLBound(fList->parray, 1,  &lBound);

	mov	esi, esp
	lea	edx, DWORD PTR _lBound$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetLBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10204: 				SafeArrayGetUBound(fList->parray, 1,  &uBound);

	mov	esi, esp
	lea	edx, DWORD PTR _uBound$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetUBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10205: 				SafeArrayGetVartype(fList->parray, &arrayType);

	mov	esi, esp
	lea	edx, DWORD PTR _arrayType$[ebp]
	push	edx
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetVartype@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10206: 				if (arrayType == VT_BSTR)

	movzx	edx, WORD PTR _arrayType$[ebp]
	cmp	edx, 8
	jne	$L211357

; 10207: 				{
; 10208: 					bstrList = (BSTR *) zMalloc (sizeof(BSTR *) * (uBound - lBound + 1));

	mov	eax, DWORD PTR _uBound$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _bstrList$[ebp], eax

; 10209: 					memset((void *)bstrList, 0, sizeof(BSTR *) * (uBound - lBound + 1));

	mov	edx, DWORD PTR _uBound$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	push	0
	mov	ecx, DWORD PTR _bstrList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10210: 					for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	edx, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], edx
	jmp	SHORT $L211362
$L211363:
	mov	eax, DWORD PTR _elementCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _elementCount$[ebp], eax
$L211362:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	cmp	ecx, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211364

; 10211: 					{
; 10212: 						SafeArrayGetElement(fList->parray, &elementCount, &tmpBstr);

	mov	esi, esp
	lea	edx, DWORD PTR _tmpBstr$[ebp]
	push	edx
	lea	eax, DWORD PTR _elementCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fList$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__SafeArrayGetElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10213: 						tmpCcBstr = tmpBstr;

	mov	eax, DWORD PTR _tmpBstr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 10214: 						if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211365

; 10215: 						{
; 10216: 							continue;

	jmp	SHORT $L211363
$L211365:

; 10217: 						}
; 10218: 						else
; 10219: 						{
; 10220: 							bstrList[numElements] = SysAllocString(tmpBstr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpBstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _numElements$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 10221: 							numElements++;

	mov	edx, DWORD PTR _numElements$[ebp]
	add	edx, 1
	mov	DWORD PTR _numElements$[ebp], edx

; 10222: 						}
; 10223: 					}

	jmp	SHORT $L211363
$L211364:

; 10224: 					*itemCount = numElements;

	mov	eax, DWORD PTR _itemCount$[ebp]
	mov	ecx, DWORD PTR _numElements$[ebp]
	mov	DWORD PTR [eax], ecx

; 10225: 				}
; 10226: 				else if (arrayType == VT_VARIANT)

	jmp	$L211356
$L211357:
	movzx	edx, WORD PTR _arrayType$[ebp]
	cmp	edx, 12					; 0000000cH
	jne	$L211356

; 10227: 					{
; 10228: 						vA = (VARIANT **)zMalloc(sizeof(VARIANT *) * (uBound - lBound + 1));

	mov	eax, DWORD PTR _uBound$[ebp]
	sub	eax, DWORD PTR _lBound$[ebp]
	lea	ecx, DWORD PTR [eax*4+4]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _vA$[ebp], eax

; 10229: 						for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	edx, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], edx
	jmp	SHORT $L211371
$L211372:
	mov	eax, DWORD PTR _elementCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _elementCount$[ebp], eax
$L211371:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	cmp	ecx, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211373

; 10230: 						{
; 10231: 							elementSize = SafeArrayGetElemsize( fList->parray);

	mov	esi, esp
	mov	edx, DWORD PTR _fList$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__SafeArrayGetElemsize@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _elementSize$[ebp], eax

; 10232: 							vA[elementCount - lBound]	= (VARIANT *)zMalloc(elementSize);

	mov	ecx, DWORD PTR _elementSize$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _elementCount$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	mov	ecx, DWORD PTR _vA$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 10233: 							SafeArrayGetElement(fList->parray, &elementCount, vA[elementCount - lBound]);

	mov	edx, DWORD PTR _elementCount$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	mov	esi, esp
	mov	eax, DWORD PTR _vA$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	lea	edx, DWORD PTR _elementCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10234: 						}

	jmp	SHORT $L211372
$L211373:

; 10235: 						bstrList = (BSTR *) zMalloc (sizeof(BSTR *) * (uBound - lBound + 1));

	mov	edx, DWORD PTR _uBound$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _bstrList$[ebp], eax

; 10236: 						memset((void *)bstrList, 0, sizeof(BSTR *) * (uBound - lBound + 1));

	mov	ecx, DWORD PTR _uBound$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	push	0
	mov	eax, DWORD PTR _bstrList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 10237: 						for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	ecx, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], ecx
	jmp	SHORT $L211379
$L211380:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211379:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211381

; 10238: 						{
; 10239: 							tmpCcBstr = vA[elementCount - lBound]->bstrVal;

	mov	ecx, DWORD PTR _elementCount$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	mov	edx, DWORD PTR _vA$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 10240: 							if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211382

; 10241: 							{
; 10242: 								continue;

	jmp	SHORT $L211380
$L211382:

; 10243: 							}
; 10244: 							else
; 10245: 							{
; 10246: 								bstrList[numElements] = SysAllocString(vA[elementCount - lBound]->bstrVal);

	mov	edx, DWORD PTR _elementCount$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	mov	eax, DWORD PTR _vA$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	esi, esp
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _numElements$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10247: 								numElements++;

	mov	eax, DWORD PTR _numElements$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElements$[ebp], eax

; 10248: 							}
; 10249: 						}

	jmp	SHORT $L211380
$L211381:

; 10250: 						for (elementCount=lBound; elementCount <= uBound; elementCount++)

	mov	ecx, DWORD PTR _lBound$[ebp]
	mov	DWORD PTR _elementCount$[ebp], ecx
	jmp	SHORT $L211384
$L211385:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211384:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _uBound$[ebp]
	jg	SHORT $L211386

; 10251: 						{
; 10252: 							VariantClear(vA[elementCount - lBound]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	mov	esi, esp
	mov	edx, DWORD PTR _vA$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10253: 							zFree(vA[elementCount - lBound]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	sub	ecx, DWORD PTR _lBound$[ebp]
	mov	edx, DWORD PTR _vA$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 10254: 						}

	jmp	SHORT $L211385
$L211386:

; 10255: 						zFree(vA);

	mov	ecx, DWORD PTR _vA$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 10256: 						*itemCount = numElements;

	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	eax, DWORD PTR _numElements$[ebp]
	mov	DWORD PTR [edx], eax
$L211356:

; 10257: 					}
; 10258: 			}
; 10259: 		}
; 10260: 		else

	jmp	$getBstrArrayExit$211329
$L211335:

; 10261: 		{
; 10262: #ifdef WIN32
; 10263: 			if (fList->vt == VT_DISPATCH)

	mov	ecx, DWORD PTR _fList$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 9
	jne	$getBstrArrayExit$211329

; 10264: 			{
; 10265: 				LPDISPATCH lpDispatch = fList->pdispVal;

	mov	eax, DWORD PTR _fList$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lpDispatch$211389[ebp], ecx

; 10266: 				CComVariant ComVariant;

	lea	ecx, DWORD PTR _ComVariant$211390[ebp]
	call	??0CComVariant@ATL@@QAE@XZ		; ATL::CComVariant::CComVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 10267: 				bool Error = false;

	mov	BYTE PTR _Error$211391[ebp], 0

; 10268: 
; 10269: 				if (GetIDispatchProperty(lpDispatch, "length", ComVariant))

	lea	edx, DWORD PTR _ComVariant$211390[ebp]
	push	edx
	push	OFFSET FLAT:$SG211393
	mov	eax, DWORD PTR _lpDispatch$211389[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z ; CSignature::GetIDispatchProperty
	movzx	ecx, al
	test	ecx, ecx
	je	$L211392

; 10270: 				{
; 10271: 					if (ComVariant.vt == VT_I4)

	movzx	edx, WORD PTR _ComVariant$211390[ebp]
	cmp	edx, 3
	jne	$L211392

; 10272: 					{
; 10273: //#ifdef WIN32
; 10274: 						CString TString;

	lea	ecx, DWORD PTR _TString$211395[ebp]
	call	??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 10275: //#else
; 10276: //						char TString[50];
; 10277: //#endif
; 10278: 						int Length = (int) ComVariant.lVal;

	mov	eax, DWORD PTR _ComVariant$211390[ebp+8]
	mov	DWORD PTR _Length$211396[ebp], eax

; 10279: 				
; 10280: 						bstrList = (BSTR *) zMalloc (sizeof(BSTR *) * Length);

	mov	ecx, DWORD PTR _Length$211396[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _bstrList$[ebp], eax

; 10281: 						memset((void *)bstrList, 0, sizeof(BSTR *) * Length);

	mov	edx, DWORD PTR _Length$211396[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _bstrList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 10282: 						for(int I = 0; I < Length; I++)

	mov	DWORD PTR _I$211402[ebp], 0
	jmp	SHORT $L211403
$L211404:
	mov	ecx, DWORD PTR _I$211402[ebp]
	add	ecx, 1
	mov	DWORD PTR _I$211402[ebp], ecx
$L211403:
	mov	edx, DWORD PTR _I$211402[ebp]
	cmp	edx, DWORD PTR _Length$211396[ebp]
	jge	$L211405

; 10283: 						{
; 10284: //#ifdef WIN32
; 10285: 							TString.Format("%d", I);

	mov	eax, DWORD PTR _I$211402[ebp]
	push	eax
	push	OFFSET FLAT:$SG211406
	lea	ecx, DWORD PTR _TString$211395[ebp]
	push	ecx
	call	?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
	add	esp, 12					; 0000000cH

; 10286: //#else
; 10287: //							sprintf(TString, "%d", I);
; 10288: //#endif
; 10289: 							if(GetIDispatchProperty(lpDispatch, (LPCSTR) TString, ComVariant))

	lea	edx, DWORD PTR _ComVariant$211390[ebp]
	push	edx
	lea	ecx, DWORD PTR _TString$211395[ebp]
	call	??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ	; ATL::CSimpleStringT<char,0>::operator char const *
	push	eax
	mov	eax, DWORD PTR _lpDispatch$211389[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z ; CSignature::GetIDispatchProperty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L211408

; 10290: 							{
; 10291: 								if (ComVariant.vt == VT_BSTR)

	movzx	edx, WORD PTR _ComVariant$211390[ebp]
	cmp	edx, 8
	jne	SHORT $L211408

; 10292: 								{
; 10293: 									bstrList[I] = SysAllocString(ComVariant.bstrVal);

	mov	esi, esp
	mov	eax, DWORD PTR _ComVariant$211390[ebp+8]
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _I$211402[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10294: 									numElements++;

	mov	eax, DWORD PTR _numElements$[ebp]
	add	eax, 1
	mov	DWORD PTR _numElements$[ebp], eax
$L211408:

; 10295: 								}
; 10296: 							}
; 10297: 						}

	jmp	$L211404
$L211405:

; 10298: 						*itemCount = numElements;

	mov	ecx, DWORD PTR _itemCount$[ebp]
	mov	edx, DWORD PTR _numElements$[ebp]
	mov	DWORD PTR [ecx], edx

; 10299: 					}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _TString$211395[ebp]
	call	??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
$L211392:

; 10300: 				}
; 10301: 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ComVariant$211390[ebp]
	call	??1CComVariant@ATL@@QAE@XZ		; ATL::CComVariant::~CComVariant
$getBstrArrayExit$211329:

; 10302: #endif
; 10303: 		}
; 10304: 	}
; 10305: getBstrArrayExit:
; 10306: 	ExitLog;
; 10307: 	return bstrList;

	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR $T221820[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221820[ebp]

; 10308: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221836
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 184				; 000000b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221836:
	DD	8
	DD	$L221835
$L221835:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L221826
	DD	-48					; ffffffd0H
	DD	4
	DD	$L221827
	DD	-60					; ffffffc4H
	DD	2
	DD	$L221828
	DD	-72					; ffffffb8H
	DD	4
	DD	$L221829
	DD	-88					; ffffffa8H
	DD	4
	DD	$L221830
	DD	-104					; ffffff98H
	DD	4
	DD	$L221831
	DD	-152					; ffffff68H
	DD	16					; 00000010H
	DD	$L221832
	DD	-168					; ffffff58H
	DD	4
	DD	$L221833
$L221833:
	DB	84					; 00000054H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
$L221832:
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	109					; 0000006dH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221831:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221830:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221829:
	DB	101					; 00000065H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221828:
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$L221827:
	DB	117					; 00000075H
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$L221826:
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221821:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221822:
	lea	ecx, DWORD PTR _ComVariant$211390[ebp]
	jmp	??1CComVariant@ATL@@QAE@XZ		; ATL::CComVariant::~CComVariant
$L221823:
	lea	ecx, DWORD PTR _TString$211395[ebp]
	jmp	??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
__ehhandler$?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z:
	mov	eax, OFFSET FLAT:$T221825
	jmp	___CxxFrameHandler
text$x	ENDS
?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ENDP ; CSignature::GetBstrArrayFromVariant
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComVariant@ATL@@QAE@XZ PROC NEAR			; ATL::CComVariant::CComVariant, COMDAT
; _this$ = ecx

; 1531 : 	CComVariant() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 	{
; 1533 : 		::VariantInit(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1534 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComVariant@ATL@@QAE@XZ ENDP				; ATL::CComVariant::CComVariant
_TEXT	ENDS
PUBLIC	?Clear@CComVariant@ATL@@QAEJXZ			; ATL::CComVariant::Clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComVariant@ATL@@QAE@XZ PROC NEAR			; ATL::CComVariant::~CComVariant, COMDAT
; _this$ = ecx

; 1536 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		Clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Clear@CComVariant@ATL@@QAEJXZ		; ATL::CComVariant::Clear

; 1538 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComVariant@ATL@@QAE@XZ ENDP				; ATL::CComVariant::~CComVariant
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Clear@CComVariant@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CComVariant@ATL@@QAEJXZ PROC NEAR		; ATL::CComVariant::Clear, COMDAT
; _this$ = ecx

; 2095 : 	HRESULT Clear() { return ::VariantClear(this); }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Clear@CComVariant@ATL@@QAEJXZ ENDP			; ATL::CComVariant::Clear
_TEXT	ENDS
PUBLIC	??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z	; ATL::CComVariant::CComVariant
PUBLIC	??4CComVariant@ATL@@QAEAAV01@ABV01@@Z		; ATL::CComVariant::operator=
PUBLIC	?ANSIToUnicode@CSignature@@QAEPAGPBD@Z		; CSignature::ANSIToUnicode
EXTRN	_GUID_NULL:BYTE
;	COMDAT xdata$x
; File c:\activex\xmlsign\signature.h
xdata$x	SEGMENT
$T221861 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L221848
$T221863 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L221847
$T221862 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T221863
$T221850 DD	019930520H
	DD	03H
	DD	FLAT:$T221861
	DD	01H
	DD	FLAT:$T221862
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z
_TEXT	SEGMENT
tv130 = -184						; size = 4
$T221845 = -180						; size = 4
_ExVariant$203937 = -172				; size = 16
_nArgErr$203928 = -148					; size = 4
_excepinfo$203927 = -136				; size = 32
_dispparamsNoArgs$203926 = -96				; size = 16
_pVarResult$203925 = -72				; size = 16
_Hr$ = -52						; size = 4
_szMember$ = -44					; size = 4
_dispid$ = -32						; size = 4
_Ret$ = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__lpDispatch$ = 8					; size = 4
__Name$ = 12						; size = 4
__ExVariant$ = 16					; size = 4
?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z PROC NEAR ; CSignature::GetIDispatchProperty, COMDAT
; _this$ = ecx

; 617  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 168				; 000000a8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 42					; 0000002aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 618  : 		bool Ret = false;

	mov	BYTE PTR _Ret$[ebp], 0

; 619  : 	
; 620  : 		DISPID dispid = 0;

	mov	DWORD PTR _dispid$[ebp], 0

; 621  : 		OLECHAR FAR* szMember = ANSIToUnicode(_Name);

	mov	eax, DWORD PTR __Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ANSIToUnicode@CSignature@@QAEPAGPBD@Z	; CSignature::ANSIToUnicode
	mov	DWORD PTR _szMember$[ebp], eax

; 622  : 	
; 623  : 		HRESULT Hr = _lpDispatch->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid);

	mov	esi, esp
	lea	ecx, DWORD PTR _dispid$[ebp]
	push	ecx
	push	2048					; 00000800H
	push	1
	lea	edx, DWORD PTR _szMember$[ebp]
	push	edx
	push	OFFSET FLAT:_GUID_NULL
	mov	eax, DWORD PTR __lpDispatch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpDispatch$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _Hr$[ebp], eax

; 624  : 	
; 625  : 		if(Hr == S_OK)

	cmp	DWORD PTR _Hr$[ebp], 0
	jne	$L203924

; 626  : 		{
; 627  : 			VARIANT pVarResult;
; 628  : 	
; 629  : 			DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

	mov	DWORD PTR _dispparamsNoArgs$203926[ebp], 0
	mov	DWORD PTR _dispparamsNoArgs$203926[ebp+4], 0
	mov	DWORD PTR _dispparamsNoArgs$203926[ebp+8], 0
	mov	DWORD PTR _dispparamsNoArgs$203926[ebp+12], 0

; 630  : 			EXCEPINFO excepinfo;
; 631  : 			UINT nArgErr;
; 632  : 	
; 633  : 			Ret = true;

	mov	BYTE PTR _Ret$[ebp], 1

; 634  : 	
; 635  : 			try
; 636  : 			{

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 637  : 				Hr = _lpDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
; 638  : 										&dispparamsNoArgs, &pVarResult, &excepinfo, &nArgErr);

	mov	esi, esp
	lea	eax, DWORD PTR _nArgErr$203928[ebp]
	push	eax
	lea	ecx, DWORD PTR _excepinfo$203927[ebp]
	push	ecx
	lea	edx, DWORD PTR _pVarResult$203925[ebp]
	push	edx
	lea	eax, DWORD PTR _dispparamsNoArgs$203926[ebp]
	push	eax
	push	2
	push	2048					; 00000800H
	push	OFFSET FLAT:_GUID_NULL
	mov	ecx, DWORD PTR _dispid$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpDispatch$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpDispatch$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+24]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv130[ebp], eax
	mov	edx, DWORD PTR tv130[ebp]
	mov	DWORD PTR _Hr$[ebp], edx
	jmp	SHORT $L221846
$L221847:

; 639  : 			}
; 640  : 			catch(...)
; 641  : 			{
; 642  : 				Ret = false;

	mov	BYTE PTR _Ret$[ebp], 0

; 643  : 			}

	mov	eax, $L221846
	ret	0
$L221846:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 644  : 			
; 645  : 			CComVariant ExVariant(pVarResult);

	lea	eax, DWORD PTR _pVarResult$203925[ebp]
	push	eax
	lea	ecx, DWORD PTR _ExVariant$203937[ebp]
	call	??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z ; ATL::CComVariant::CComVariant
	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 646  : 			_ExVariant = ExVariant;

	lea	ecx, DWORD PTR _ExVariant$203937[ebp]
	push	ecx
	mov	ecx, DWORD PTR __ExVariant$[ebp]
	call	??4CComVariant@ATL@@QAEAAV01@ABV01@@Z	; ATL::CComVariant::operator=

; 647  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR _ExVariant$203937[ebp]
	call	??1CComVariant@ATL@@QAE@XZ		; ATL::CComVariant::~CComVariant
$L203924:

; 648  : 		delete szMember;

	mov	edx, DWORD PTR _szMember$[ebp]
	mov	DWORD PTR $T221845[ebp], edx
	mov	eax, DWORD PTR $T221845[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 649  : 		return Ret;

	mov	al, BYTE PTR _Ret$[ebp]

; 650  : 	};

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221860
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 184				; 000000b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221860:
	DD	7
	DD	$L221859
$L221859:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221851
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221852
	DD	-72					; ffffffb8H
	DD	16					; 00000010H
	DD	$L221853
	DD	-96					; ffffffa0H
	DD	16					; 00000010H
	DD	$L221854
	DD	-136					; ffffff78H
	DD	32					; 00000020H
	DD	$L221855
	DD	-148					; ffffff6cH
	DD	4
	DD	$L221856
	DD	-172					; ffffff54H
	DD	16					; 00000010H
	DD	$L221857
$L221857:
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L221856:
	DB	110					; 0000006eH
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	69					; 00000045H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	0
$L221855:
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$L221854:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	0
$L221853:
	DB	112					; 00000070H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
$L221852:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L221851:
	DB	100					; 00000064H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L221848:
	lea	ecx, DWORD PTR _ExVariant$203937[ebp]
	jmp	??1CComVariant@ATL@@QAE@XZ		; ATL::CComVariant::~CComVariant
__ehhandler$?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z:
	mov	eax, OFFSET FLAT:$T221850
	jmp	___CxxFrameHandler
text$x	ENDS
?GetIDispatchProperty@CSignature@@QAE_NQAUIDispatch@@PBDAAVCComVariant@ATL@@@Z ENDP ; CSignature::GetIDispatchProperty
PUBLIC	?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z ; ATL::CComVariant::InternalCopy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_varSrc$ = 8						; size = 4
??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z PROC NEAR	; ATL::CComVariant::CComVariant, COMDAT
; _this$ = ecx

; 1540 : 	CComVariant(const VARIANT& varSrc)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1541 : 	{
; 1542 : 		vt = VT_EMPTY;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax], 0

; 1543 : 		InternalCopy(&varSrc);

	mov	ecx, DWORD PTR _varSrc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z ; ATL::CComVariant::InternalCopy

; 1544 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z ENDP		; ATL::CComVariant::CComVariant
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_varSrc$ = 8						; size = 4
??4CComVariant@ATL@@QAEAAV01@ABV01@@Z PROC NEAR		; ATL::CComVariant::operator=, COMDAT
; _this$ = ecx

; 1684 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1685 : 		InternalCopy(&varSrc);

	mov	eax, DWORD PTR _varSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z ; ATL::CComVariant::InternalCopy

; 1686 : 		return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1687 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CComVariant@ATL@@QAEAAV01@ABV01@@Z ENDP		; ATL::CComVariant::operator=
_TEXT	ENDS
PUBLIC	?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z	; ATL::CComVariant::Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z PROC NEAR ; ATL::CComVariant::InternalCopy, COMDAT
; _this$ = ecx

; 2188 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2189 : 		HRESULT hr = Copy(pSrc);

	mov	eax, DWORD PTR _pSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z ; ATL::CComVariant::Copy
	mov	DWORD PTR _hr$[ebp], eax

; 2190 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L82841

; 2191 : 		{
; 2192 : 			vt = VT_ERROR;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx], 10			; 0000000aH

; 2193 : 			scode = hr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [edx+8], eax
$L82841:

; 2194 : 		}
; 2195 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z ENDP ; ATL::CComVariant::InternalCopy
_TEXT	ENDS
EXTRN	__imp__VariantCopy@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z PROC NEAR	; ATL::CComVariant::Copy, COMDAT
; _this$ = ecx

; 2096 : 	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, esp
	mov	eax, DWORD PTR _pSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__VariantCopy@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z ENDP	; ATL::CComVariant::Copy
_TEXT	ENDS
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.h
;	COMDAT ?ANSIToUnicode@CSignature@@QAEPAGPBD@Z
_TEXT	SEGMENT
$T221876 = -16						; size = 4
_I$203905 = -12						; size = 4
_lpszW$ = -8						; size = 4
_this$ = -4						; size = 4
_String$ = 8						; size = 4
?ANSIToUnicode@CSignature@@QAEPAGPBD@Z PROC NEAR	; CSignature::ANSIToUnicode, COMDAT
; _this$ = ecx

; 608  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		LPWSTR lpszW = new WCHAR[strlen(String) + 1];

	mov	eax, DWORD PTR _String$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T221876[ebp], eax
	mov	edx, DWORD PTR $T221876[ebp]
	mov	DWORD PTR _lpszW$[ebp], edx

; 610  : 		for(size_t I = 0; I <= strlen(String); I++)

	mov	DWORD PTR _I$203905[ebp], 0
	jmp	SHORT $L203906
$L203907:
	mov	eax, DWORD PTR _I$203905[ebp]
	add	eax, 1
	mov	DWORD PTR _I$203905[ebp], eax
$L203906:
	mov	ecx, DWORD PTR _String$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _I$203905[ebp], eax
	ja	SHORT $L203908

; 611  : 			lpszW[I] = (WCHAR) String[I];

	mov	edx, DWORD PTR _String$[ebp]
	add	edx, DWORD PTR _I$203905[ebp]
	movsx	ax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _I$203905[ebp]
	mov	edx, DWORD PTR _lpszW$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	jmp	SHORT $L203907
$L203908:

; 612  : 	
; 613  : 		return lpszW;

	mov	eax, DWORD PTR _lpszW$[ebp]

; 614  : 	};

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ANSIToUnicode@CSignature@@QAEPAGPBD@Z ENDP		; CSignature::ANSIToUnicode
_TEXT	ENDS
PUBLIC	?put_ConfigFileName@CSignature@@UAGJPAG@Z	; CSignature::put_ConfigFileName
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_aNewVal$211421 = -32					; size = 4
__lpa$ = -28						; size = 4
__lpw$ = -24						; size = 4
__acp$ = -20						; size = 4
__convert$ = -16					; size = 4
_configfileStatus$ = -8					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_ConfigFileName@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_ConfigFileName

; 10311: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 10312: 	BOOL configfileStatus=FALSE;

	mov	DWORD PTR _configfileStatus$[ebp], 0

; 10313: 
; 10314: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10315: 	EnterLog;
; 10316: 	FileExists(newVal, &configfileStatus);

	mov	esi, esp
	lea	eax, DWORD PTR _configfileStatus$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+204]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10317: 	if (configfileStatus) // Config file exists

	cmp	DWORD PTR _configfileStatus$[ebp], 0
	je	SHORT $L211420

; 10318: 	{
; 10319: 		char *aNewVal = (char *)HeapW2A(newVal);

	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _aNewVal$211421[ebp], eax

; 10320: 		ConfObj.setConfigFile(aNewVal);

	mov	eax, DWORD PTR _aNewVal$211421[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	?setConfigFile@CConfig@@QAEXPAD@Z	; CConfig::setConfigFile

; 10321: 		ConfObj.getConfigDetails(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 880				; 00000370H
	call	?getConfigDetails@CConfig@@QAEHPAU_GLOBAL_SIG@@@Z ; CConfig::getConfigDetails

; 10322: 		zFree(aNewVal);

	mov	eax, DWORD PTR _aNewVal$211421[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 10323: 		ExitLog;
; 10324: 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L211414
$L211420:

; 10325: 	}
; 10326: 	else
; 10327: 	{
; 10328: 		setError(SigHandle, NO_SECUREXML_CONFIG);

	push	66					; 00000042H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10329: 		return S_FALSE;

	mov	eax, 1
$L211414:

; 10330: 	}
; 10331: 
; 10332: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221881
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221881:
	DD	1
	DD	$L221880
$L221880:
	DD	-8					; fffffff8H
	DD	4
	DD	$L221879
$L221879:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
?put_ConfigFileName@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_ConfigFileName
_TEXT	ENDS
PUBLIC	?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_CRLLocation
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$211436 = -24						; size = 4
_bstrList$ = -20					; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_CRLLocation

; 10335: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 10336: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 10337: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 10338: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 10339: 
; 10340: 	EnterLog;
; 10341: 
; 10342: 
; 10343: 	if ((newVal.vt != VT_BSTR) &&
; 10344: 		(newVal.vt != VT_DISPATCH) &&
; 10345: 		!(newVal.vt & VT_ARRAY) && 
; 10346: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L211433
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L211433
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L211433
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L211433

; 10347: 	{
; 10348: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10349: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211429
$L211433:

; 10350: 	}
; 10351: 	if (CertVerifyParams.altCrlCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1836], 0
	je	SHORT $L211435

; 10352: 	{
; 10353: 		for (unsigned int i=0; i < CertVerifyParams.altCrlCount; i++)

	mov	DWORD PTR _i$211436[ebp], 0
	jmp	SHORT $L211437
$L211438:
	mov	ecx, DWORD PTR _i$211436[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$211436[ebp], ecx
$L211437:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$211436[ebp]
	cmp	eax, DWORD PTR [edx+1836]
	jae	SHORT $L211439

; 10354: 			zFree(CertVerifyParams.crlAltUrl[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1832]
	mov	eax, DWORD PTR _i$211436[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L211438
$L211439:

; 10355: 		zFree(CertVerifyParams.crlAltUrl);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1832]
	push	eax
	call	_rFree
	add	esp, 4
$L211435:

; 10356: 	}
; 10357: 
; 10358: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	ecx, DWORD PTR _itemCount$[ebp]
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 10359: 
; 10360: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L211441
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L211440
$L211441:

; 10361: 	{
; 10362: 		CertVerifyParams.crlAltUrl = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1832], 0

; 10363: 		CertVerifyParams.altCrlCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1836], 0

; 10364: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10365: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211429
$L211440:

; 10366: 	}
; 10367: 	CertVerifyParams.altCrlCount = itemCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [eax+1836], ecx

; 10368: 	CertVerifyParams.crlAltUrl = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1832], eax

; 10369: 	if (CertVerifyParams.crlAltUrl == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1832], 0
	jne	SHORT $L211445

; 10370: 	{
; 10371: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 10372: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211429
$L211445:

; 10373: 	}
; 10374: 	memset(CertVerifyParams.crlAltUrl, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1832]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10375: 
; 10376: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211448
$L211449:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211448:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211450

; 10377: 	{
; 10378: 		CertVerifyParams.crlAltUrl[elementCount] = (char *)HeapW2A(bstrList[elementCount]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1832]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10379: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10380: 	}

	jmp	SHORT $L211449
$L211450:

; 10381: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10382: 	ExitLog;
; 10383: 	return S_OK;

	xor	eax, eax
$L211429:

; 10384: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221885
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221885:
	DD	1
	DD	$L221884
$L221884:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221883
$L221883:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z ENDP	; CSignature::put_CRLLocation
_TEXT	ENDS
PUBLIC	?VerifyActiveCertificate@CSignature@@UAGJPAH@Z	; CSignature::VerifyActiveCertificate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$211470 = -52						; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_freeSigningCert$ = -32					; size = 4
_signingCert$ = -28					; size = 4
_tsSysTime$ = -20					; size = 16
_this$ = 8						; size = 4
_result$ = 12						; size = 4
?VerifyActiveCertificate@CSignature@@UAGJPAH@Z PROC NEAR ; CSignature::VerifyActiveCertificate

; 10387: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10388: 	SYSTEMTIME	tsSysTime;
; 10389: 	unsigned char *signingCert;
; 10390: 	BOOL freeSigningCert = FALSE;

	mov	DWORD PTR _freeSigningCert$[ebp], 0

; 10391: 
; 10392: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10393: 	EnterLog;
; 10394: 	if (CurrentCertificate == NOT_INITIALIZED)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], -1
	jne	SHORT $L211464

; 10395: 	{
; 10396: 		setError(SigHandle, NO_CERTIFICATE);

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10397: 		*result = FALSE;

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], 0
$L211464:

; 10398: 	}
; 10399: 
; 10400: 	if (CurrentCertificate == USE_PFX_CERT)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+120], -2			; fffffffeH
	jne	SHORT $L211465

; 10401: 		signingCert = B64PfxDataPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+920]
	mov	DWORD PTR _signingCert$[ebp], eax

; 10402: 	else

	jmp	SHORT $L211466
$L211465:

; 10403: 		if (CurrentCertificate == USE_BASE64_CERT)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+120], -3			; fffffffdH
	jne	SHORT $L211467

; 10404: 		{
; 10405: 			signingCert = HeapW2A(SignerCertificate.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+396]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _signingCert$[ebp], eax

; 10406: 			freeSigningCert = TRUE;

	mov	DWORD PTR _freeSigningCert$[ebp], 1

; 10407: 		}
; 10408: 		else

	jmp	SHORT $L211466
$L211467:

; 10409: 			signingCert = cV[CurrentCertificate]->certificate;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	eax, DWORD PTR [edx+2048]
	mov	DWORD PTR _signingCert$[ebp], eax
$L211466:

; 10410: 
; 10411: 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 10412: 		(CertVerifyParams.usedCrlList != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1888], 0
	je	$L211469
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1892], 0
	je	SHORT $L211469

; 10413: 	{
; 10414: 		for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$211470[ebp], 0
	jmp	SHORT $L211471
$L211472:
	mov	eax, DWORD PTR _i$211470[ebp]
	add	eax, 1
	mov	DWORD PTR _i$211470[ebp], eax
$L211471:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$211470[ebp]
	cmp	edx, DWORD PTR [ecx+1888]
	jae	SHORT $L211473

; 10415: 		{
; 10416: 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$211470[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L211474

; 10417: 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$211470[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L211474:

; 10418: 		}

	jmp	SHORT $L211472
$L211473:

; 10419: 		zFree(CertVerifyParams.usedCrlList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	push	edx
	call	_rFree
	add	esp, 4

; 10420: 		CertVerifyParams.usedCrlList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1892], 0

; 10421: 		CertVerifyParams.usedCrlCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1888], 0
$L211469:

; 10422: 	}
; 10423: 
; 10424: #ifdef WIN32
; 10425: 	GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	edx, DWORD PTR _tsSysTime$[ebp]
	push	edx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10426: #else
; 10427: 	GetSystemTimeLinux(&tsSysTime);
; 10428: #endif
; 10429: 	if (CheckCertificateValidity(signingCert, 
; 10430: 							&tsSysTime, 
; 10431: 							&PfxPassword,
; 10432: 							&CertVerifyParams,
; 10433: 							SigHandle) == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	lea	ecx, DWORD PTR _tsSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signingCert$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::CheckCertificateValidity
	test	eax, eax
	jne	SHORT $L211475

; 10434: 	{
; 10435: 		*result = FALSE;

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [eax], 0

; 10436: 		if (freeSigningCert)

	cmp	DWORD PTR _freeSigningCert$[ebp], 0
	je	SHORT $L211476

; 10437: 			zFree(signingCert);

	mov	ecx, DWORD PTR _signingCert$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L211476:

; 10438: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211456
$L211475:

; 10439: 	}
; 10440: 
; 10441: 	*result = TRUE;

	mov	edx, DWORD PTR _result$[ebp]
	mov	DWORD PTR [edx], 1

; 10442: 	if (freeSigningCert)

	cmp	DWORD PTR _freeSigningCert$[ebp], 0
	je	SHORT $L211478

; 10443: 		zFree(signingCert);

	mov	eax, DWORD PTR _signingCert$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L211478:

; 10444: 	ExitLog;
; 10445: 	return S_OK;

	xor	eax, eax
$L211456:

; 10446: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221889
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221889:
	DD	1
	DD	$L221888
$L221888:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$L221887
$L221887:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?VerifyActiveCertificate@CSignature@@UAGJPAH@Z ENDP	; CSignature::VerifyActiveCertificate
_TEXT	ENDS
PUBLIC	?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_CertificatePolicy
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$211490 = -24						; size = 4
_bstrList$ = -20					; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_CertificatePolicy

; 10449: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 10450: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 10451: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 10452: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 10453: 
; 10454: 	EnterLog;
; 10455: 	if ((newVal.vt != VT_BSTR) &&
; 10456: 		(newVal.vt != VT_DISPATCH) &&
; 10457: 		!(newVal.vt & VT_ARRAY) && 
; 10458: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L211487
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L211487
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L211487
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L211487

; 10459: 	{
; 10460: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10461: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211483
$L211487:

; 10462: 	}
; 10463: 	if (CertVerifyParams.userPolicyCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1852], 0
	je	SHORT $L211489

; 10464: 	{
; 10465: 		for (unsigned int i=0; i < CertVerifyParams.userPolicyCount; i++)

	mov	DWORD PTR _i$211490[ebp], 0
	jmp	SHORT $L211491
$L211492:
	mov	ecx, DWORD PTR _i$211490[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$211490[ebp], ecx
$L211491:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$211490[ebp]
	cmp	eax, DWORD PTR [edx+1852]
	jae	SHORT $L211493

; 10466: 			zFree(CertVerifyParams.userPolicySet[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1848]
	mov	eax, DWORD PTR _i$211490[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L211492
$L211493:

; 10467: 		zFree(CertVerifyParams.userPolicySet);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1848]
	push	eax
	call	_rFree
	add	esp, 4
$L211489:

; 10468: 	}
; 10469: 
; 10470: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	ecx, DWORD PTR _itemCount$[ebp]
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 10471: 
; 10472: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L211495
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L211494
$L211495:

; 10473: 	{// This is a valid way to clear user certificate policies, hence don't set any error
; 10474: 		CertVerifyParams.userPolicySet = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1848], 0

; 10475: 		CertVerifyParams.userPolicyCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1852], 0

; 10476: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211483
$L211494:

; 10477: 	}
; 10478: 
; 10479: 	CertVerifyParams.userPolicyCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+1852], edx

; 10480: 	CertVerifyParams.userPolicySet = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1848], eax

; 10481: 	if (CertVerifyParams.userPolicySet == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1848], 0
	jne	SHORT $L211499

; 10482: 	{
; 10483: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 10484: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211483
$L211499:

; 10485: 	}
; 10486: 	memset(CertVerifyParams.userPolicySet, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1848]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10487: 
; 10488: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211502
$L211503:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211502:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211504

; 10489: 	{
; 10490: 		CertVerifyParams.userPolicySet[elementCount] = (char *)HeapW2A(bstrList[elementCount]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1848]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10491: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10492: 	}

	jmp	SHORT $L211503
$L211504:

; 10493: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10494: 	ExitLog;
; 10495: 	return S_OK;

	xor	eax, eax
$L211483:

; 10496: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221893
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221893:
	DD	1
	DD	$L221892
$L221892:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221891
$L221891:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_CertificatePolicy
_TEXT	ENDS
PUBLIC	?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z ; CSignature::get_AuthorityConstrainedPolicy
EXTRN	__imp__SafeArrayCreate@12:NEAR
EXTRN	__imp__SafeArrayPutElement@12:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_arrElement$211530 = -60				; size = 4
_i$211525 = -52						; size = 4
__lpa$ = -44						; size = 4
__lpw$ = -40						; size = 4
__acp$ = -36						; size = 4
__convert$ = -32					; size = 4
_hr$ = -28						; size = 4
_rgsabound$ = -20					; size = 8
_outArray$ = -8						; size = 4
_outVariant$ = -4					; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z PROC NEAR ; CSignature::get_AuthorityConstrainedPolicy

; 10499: {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10500: 	VARIANT *outVariant;
; 10501: 	SAFEARRAY *outArray;
; 10502: 	SAFEARRAYBOUND rgsabound[1];
; 10503: 	HRESULT hr;
; 10504: 	
; 10505: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10506: 	EnterLog;
; 10507: 	outVariant = (VARIANT *)zMalloc(sizeof(VARIANT));

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outVariant$[ebp], eax

; 10508: 	outArray = (SAFEARRAY *)zMalloc(sizeof(SAFEARRAY *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outArray$[ebp], eax

; 10509: 
; 10510: 	VariantInit(outVariant);

	mov	esi, esp
	mov	eax, DWORD PTR _outVariant$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10511: 
; 10512: 	rgsabound[0].lLbound = 0;

	mov	DWORD PTR _rgsabound$[ebp+4], 0

; 10513: 	rgsabound[0].cElements = CertVerifyParams.authPolicySetCountOut;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1872]
	mov	DWORD PTR _rgsabound$[ebp], edx

; 10514: 
; 10515: 	outArray = SafeArrayCreate(VT_BSTR, 
; 10516: 								1,
; 10517: 								rgsabound);

	mov	esi, esp
	lea	eax, DWORD PTR _rgsabound$[ebp]
	push	eax
	push	1
	push	8
	call	DWORD PTR __imp__SafeArrayCreate@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _outArray$[ebp], eax

; 10518: 	if (outArray == NULL)

	cmp	DWORD PTR _outArray$[ebp], 0
	jne	SHORT $L211523

; 10519: 	{
; 10520: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10521: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211510
$L211523:

; 10522: 	}
; 10523: 	for (long i=0; i<(long)CertVerifyParams.authPolicySetCountOut; i++)

	mov	DWORD PTR _i$211525[ebp], 0
	jmp	SHORT $L211527
$L211528:
	mov	eax, DWORD PTR _i$211525[ebp]
	add	eax, 1
	mov	DWORD PTR _i$211525[ebp], eax
$L211527:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$211525[ebp]
	cmp	edx, DWORD PTR [ecx+1872]
	jge	SHORT $L211529

; 10524: 	{
; 10525: 		BSTR arrElement;
; 10526: 		arrElement = A2WBSTR(CertVerifyParams.authPolicySetOut[i]);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1868]
	mov	edx, DWORD PTR _i$211525[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _arrElement$211530[ebp], eax

; 10527: 		hr = SafeArrayPutElement(outArray, &i, arrElement);

	mov	esi, esp
	mov	ecx, DWORD PTR _arrElement$211530[ebp]
	push	ecx
	lea	edx, DWORD PTR _i$211525[ebp]
	push	edx
	mov	eax, DWORD PTR _outArray$[ebp]
	push	eax
	call	DWORD PTR __imp__SafeArrayPutElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 10528: 		if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L211532

; 10529: 		{
; 10530: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10531: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211510
$L211532:

; 10532: 		}
; 10533: 	}

	jmp	SHORT $L211528
$L211529:

; 10534: 	(*outVariant).vt = (VT_ARRAY | VT_BSTR);

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	WORD PTR [eax], 8200			; 00002008H

; 10535: 	(*outVariant).parray = outArray;

	mov	ecx, DWORD PTR _outVariant$[ebp]
	mov	edx, DWORD PTR _outArray$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 10536: 	*pVal = *outVariant;

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 10537: 	ExitLog;
; 10538: 	return S_OK;

	xor	eax, eax
$L211510:

; 10539: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221898
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221898:
	DD	2
	DD	$L221897
$L221897:
	DD	-20					; ffffffecH
	DD	8
	DD	$L221895
	DD	-52					; ffffffccH
	DD	4
	DD	$L221896
$L221896:
	DB	105					; 00000069H
	DB	0
$L221895:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z ENDP ; CSignature::get_AuthorityConstrainedPolicy
_TEXT	ENDS
PUBLIC	?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z ; CSignature::get_UserConstrainedPolicy
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_arrElement$211558 = -60				; size = 4
_i$211553 = -52						; size = 4
__lpa$ = -44						; size = 4
__lpw$ = -40						; size = 4
__acp$ = -36						; size = 4
__convert$ = -32					; size = 4
_hr$ = -28						; size = 4
_rgsabound$ = -20					; size = 8
_outArray$ = -8						; size = 4
_outVariant$ = -4					; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z PROC NEAR ; CSignature::get_UserConstrainedPolicy

; 10542: {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10543: 	VARIANT *outVariant;
; 10544: 	SAFEARRAY *outArray;
; 10545: 	SAFEARRAYBOUND rgsabound[1];
; 10546: 	HRESULT hr;
; 10547: 	
; 10548: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10549: 	EnterLog;
; 10550: 	outVariant = (VARIANT *)zMalloc(sizeof(VARIANT));

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outVariant$[ebp], eax

; 10551: 	outArray = (SAFEARRAY *)zMalloc(sizeof(SAFEARRAY *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outArray$[ebp], eax

; 10552: 
; 10553: 	VariantInit(outVariant);

	mov	esi, esp
	mov	eax, DWORD PTR _outVariant$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10554: 	rgsabound[0].lLbound = 0;

	mov	DWORD PTR _rgsabound$[ebp+4], 0

; 10555: 	rgsabound[0].cElements = CertVerifyParams.userPolicySetCountOut;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1880]
	mov	DWORD PTR _rgsabound$[ebp], edx

; 10556: 
; 10557: 	outArray = SafeArrayCreate(VT_BSTR, 
; 10558: 								1,
; 10559: 								rgsabound);

	mov	esi, esp
	lea	eax, DWORD PTR _rgsabound$[ebp]
	push	eax
	push	1
	push	8
	call	DWORD PTR __imp__SafeArrayCreate@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _outArray$[ebp], eax

; 10560: 	if (outArray == NULL)

	cmp	DWORD PTR _outArray$[ebp], 0
	jne	SHORT $L211551

; 10561: 	{
; 10562: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10563: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211538
$L211551:

; 10564: 	}
; 10565: 	for (long i=0; i<(long)CertVerifyParams.userPolicySetCountOut; i++)

	mov	DWORD PTR _i$211553[ebp], 0
	jmp	SHORT $L211555
$L211556:
	mov	eax, DWORD PTR _i$211553[ebp]
	add	eax, 1
	mov	DWORD PTR _i$211553[ebp], eax
$L211555:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$211553[ebp]
	cmp	edx, DWORD PTR [ecx+1880]
	jge	SHORT $L211557

; 10566: 	{
; 10567: 		BSTR arrElement;
; 10568: 		arrElement = A2WBSTR(CertVerifyParams.userPolicySetOut[i]);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1876]
	mov	edx, DWORD PTR _i$211553[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _arrElement$211558[ebp], eax

; 10569: 		hr = SafeArrayPutElement(outArray, &i, arrElement);

	mov	esi, esp
	mov	ecx, DWORD PTR _arrElement$211558[ebp]
	push	ecx
	lea	edx, DWORD PTR _i$211553[ebp]
	push	edx
	mov	eax, DWORD PTR _outArray$[ebp]
	push	eax
	call	DWORD PTR __imp__SafeArrayPutElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 10570: 		if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L211560

; 10571: 		{
; 10572: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10573: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211538
$L211560:

; 10574: 		}
; 10575: 	}

	jmp	SHORT $L211556
$L211557:

; 10576: 	(*outVariant).vt = (VT_ARRAY | VT_BSTR);

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	WORD PTR [eax], 8200			; 00002008H

; 10577: 	(*outVariant).parray = outArray;

	mov	ecx, DWORD PTR _outVariant$[ebp]
	mov	edx, DWORD PTR _outArray$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 10578: 
; 10579: 	*pVal = *outVariant;

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 10580: 	ExitLog;
; 10581: 	return S_OK;

	xor	eax, eax
$L211538:

; 10582: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221903
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221903:
	DD	2
	DD	$L221902
$L221902:
	DD	-20					; ffffffecH
	DD	8
	DD	$L221900
	DD	-52					; ffffffccH
	DD	4
	DD	$L221901
$L221901:
	DB	105					; 00000069H
	DB	0
$L221900:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z ENDP ; CSignature::get_UserConstrainedPolicy
_TEXT	ENDS
PUBLIC	?put_CertificatePolicyChecking@CSignature@@UAGJH@Z ; CSignature::put_CertificatePolicyChecking
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertificatePolicyChecking@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_CertificatePolicyChecking

; 10585: {

	push	ebp
	mov	ebp, esp

; 10586: 	EnterLog;
; 10587: 	if (DoDCompliance == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jne	SHORT $L211567

; 10588: 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211568

; 10589: 			CertVerifyParams.verificationOptions |= VERIFY_POLICY;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10590: 		else

	jmp	SHORT $L211567
$L211568:

; 10591: 			CertVerifyParams.verificationOptions &= (~VERIFY_POLICY);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx
$L211567:

; 10592: 	ExitLog;
; 10593: 	return S_OK;

	xor	eax, eax

; 10594: }

	pop	ebp
	ret	8
?put_CertificatePolicyChecking@CSignature@@UAGJH@Z ENDP	; CSignature::put_CertificatePolicyChecking
_TEXT	ENDS
PUBLIC	?put_CertificateChainValidation@CSignature@@UAGJH@Z ; CSignature::put_CertificateChainValidation
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertificateChainValidation@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_CertificateChainValidation

; 10597: {

	push	ebp
	mov	ebp, esp

; 10598: 	EnterLog;
; 10599: 	if (DoDCompliance == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jne	SHORT $L211575

; 10600: 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211576

; 10601: 		{
; 10602: 			CertVerifyParams.verificationOptions |= VERIFY_CHAIN;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10603: 			CertVerifyParams.verificationOptions |= VERIFY_PATH_LENGTH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10604: 		}
; 10605: 		else

	jmp	SHORT $L211575
$L211576:

; 10606: 		{
; 10607: 			CertVerifyParams.verificationOptions &= (~VERIFY_CHAIN);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10608: 			CertVerifyParams.verificationOptions &= (~VERIFY_PATH_LENGTH);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx
$L211575:

; 10609: 		}
; 10610: 	ExitLog;
; 10611: 	return S_OK;

	xor	eax, eax

; 10612: }

	pop	ebp
	ret	8
?put_CertificateChainValidation@CSignature@@UAGJH@Z ENDP ; CSignature::put_CertificateChainValidation
_TEXT	ENDS
PUBLIC	?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z ; CSignature::put_CertificatePathLengthChecking
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_CertificatePathLengthChecking

; 10615: {

	push	ebp
	mov	ebp, esp

; 10616: 	EnterLog;
; 10617: 	if (DoDCompliance == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jne	SHORT $L211583

; 10618: 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211584

; 10619: 			CertVerifyParams.verificationOptions |= VERIFY_PATH_LENGTH;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10620: 		else

	jmp	SHORT $L211583
$L211584:

; 10621: 			CertVerifyParams.verificationOptions &= (~VERIFY_PATH_LENGTH);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx
$L211583:

; 10622: 	ExitLog;
; 10623: 	return S_OK;

	xor	eax, eax

; 10624: }

	pop	ebp
	ret	8
?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z ENDP ; CSignature::put_CertificatePathLengthChecking
_TEXT	ENDS
PUBLIC	?put_DoDCompliance@CSignature@@UAGJH@Z		; CSignature::put_DoDCompliance
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_DoDCompliance@CSignature@@UAGJH@Z PROC NEAR	; CSignature::put_DoDCompliance

; 10627: {

	push	ebp
	mov	ebp, esp

; 10628: 	EnterLog;
; 10629: 	DoDCompliance = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+952], ecx

; 10630: 	if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211591

; 10631: 		CertVerifyParams.verificationOptions |=	(VERIFY_CRL | 
; 10632: 											VERIFY_POLICY | 
; 10633: 											VERIFY_CHAIN | 
; 10634: 											VERIFY_PATH_LENGTH |
; 10635: 											EXPLICIT_TRUST);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	or	eax, 47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 10636: 	else

	jmp	SHORT $L211592
$L211591:

; 10637: 	{
; 10638: 		CertVerifyParams.verificationOptions &= (~VERIFY_CRL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 10639: 		CertVerifyParams.verificationOptions &= (~VERIFY_POLICY);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 10640: 		CertVerifyParams.verificationOptions &= (~VERIFY_CHAIN);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 10641: 		CertVerifyParams.verificationOptions &= (~VERIFY_PATH_LENGTH);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax

; 10642: 		CertVerifyParams.verificationOptions &= (~EXPLICIT_TRUST);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1856], eax
$L211592:

; 10643: 	}
; 10644: 	ExitLog;
; 10645: 	return S_OK;

	xor	eax, eax

; 10646: }

	pop	ebp
	ret	8
?put_DoDCompliance@CSignature@@UAGJH@Z ENDP		; CSignature::put_DoDCompliance
_TEXT	ENDS
PUBLIC	?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z ; CSignature::get_CertificatePolicyExplicit
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z PROC NEAR ; CSignature::get_CertificatePolicyExplicit

; 10649: {

	push	ebp
	mov	ebp, esp

; 10650: 	EnterLog;
; 10651: 	if (CertVerifyParams.explicitPolicyInd == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1884], 0
	jne	SHORT $L211598

; 10652: 		*pVal = TRUE;

	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], 1

; 10653: 	else

	jmp	SHORT $L211599
$L211598:

; 10654: 		*pVal = FALSE;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 0
$L211599:

; 10655: 	ExitLog;
; 10656: 	return S_OK;

	xor	eax, eax

; 10657: }

	pop	ebp
	ret	8
?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z ENDP ; CSignature::get_CertificatePolicyExplicit
_TEXT	ENDS
PUBLIC	?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z ; CSignature::put_CertificatePolicyExplicit
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_CertificatePolicyExplicit

; 10660: {

	push	ebp
	mov	ebp, esp

; 10661: 	EnterLog;
; 10662: 	if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211605

; 10663: 		CertVerifyParams.verificationOptions |= POLICY_EXPLICIT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], ecx

; 10664: 	else

	jmp	SHORT $L211606
$L211605:

; 10665: 		CertVerifyParams.verificationOptions &= (~POLICY_EXPLICIT);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1856], ecx
$L211606:

; 10666: 	CertVerifyParams.explicitPolicyInd = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1884], ecx

; 10667: 	ExitLog;
; 10668: 	return S_OK;

	xor	eax, eax

; 10669: }

	pop	ebp
	ret	8
?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z ENDP	; CSignature::put_CertificatePolicyExplicit
_TEXT	ENDS
PUBLIC	?put_CertificateTrustExplicit@CSignature@@UAGJH@Z ; CSignature::put_CertificateTrustExplicit
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertificateTrustExplicit@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_CertificateTrustExplicit

; 10672: {

	push	ebp
	mov	ebp, esp

; 10673: 	EnterLog;
; 10674: 	if (DoDCompliance == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+952], 0
	jne	SHORT $L211612

; 10675: 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L211613

; 10676: 			CertVerifyParams.verificationOptions |= EXPLICIT_TRUST;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx

; 10677: 		else

	jmp	SHORT $L211612
$L211613:

; 10678: 			CertVerifyParams.verificationOptions &= (~EXPLICIT_TRUST);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1856], edx
$L211612:

; 10679: 	ExitLog;
; 10680: 	return S_OK;

	xor	eax, eax

; 10681: }

	pop	ebp
	ret	8
?put_CertificateTrustExplicit@CSignature@@UAGJH@Z ENDP	; CSignature::put_CertificateTrustExplicit
_TEXT	ENDS
PUBLIC	?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_RecipientCertificates
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$211626 = -24						; size = 4
_bstrList$ = -20					; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_RecipientCertificates

; 10684: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 10685: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 10686: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 10687: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 10688: 
; 10689: 	EnterLog;
; 10690: 	if ((newVal.vt != VT_BSTR) &&
; 10691: 		(newVal.vt != VT_DISPATCH) &&
; 10692: 		!(newVal.vt & VT_ARRAY) && 
; 10693: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L211623
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L211623
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L211623
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L211623

; 10694: 	{
; 10695: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 10696: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211619
$L211623:

; 10697: 	}
; 10698: 	if (RecipientCertificateCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L211625

; 10699: 	{
; 10700: 		for (unsigned int i=0; i < RecipientCertificateCount; i++)

	mov	DWORD PTR _i$211626[ebp], 0
	jmp	SHORT $L211627
$L211628:
	mov	ecx, DWORD PTR _i$211626[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$211626[ebp], ecx
$L211627:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$211626[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jae	SHORT $L211629

; 10701: 			zFree(RecipientCertificateList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _i$211626[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L211628
$L211629:

; 10702: 		zFree(RecipientCertificateList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_rFree
	add	esp, 4

; 10703: 		RecipientCertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
$L211625:

; 10704: 	}
; 10705: 
; 10706: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	edx, DWORD PTR _itemCount$[ebp]
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 10707: 
; 10708: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L211631
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L211630
$L211631:

; 10709: 	{
; 10710: 		RecipientCertificateList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 10711: 		RecipientCertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 10712: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 10713: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211619
$L211630:

; 10714: 	}
; 10715: 
; 10716: 	RecipientCertificateCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+48], edx

; 10717: 	RecipientCertificateList = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 10718: 	if (RecipientCertificateList == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $L211635

; 10719: 	{
; 10720: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 10721: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211619
$L211635:

; 10722: 	}
; 10723: 	memset(RecipientCertificateList, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10724: 
; 10725: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211638
$L211639:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211638:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211640

; 10726: 	{
; 10727: 		RecipientCertificateList[elementCount] = (char *)HeapW2A(bstrList[elementCount]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 10728: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 10729: 	}

	jmp	SHORT $L211639
$L211640:

; 10730: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10731: 	ExitLog;
; 10732: 	return S_OK;

	xor	eax, eax
$L211619:

; 10733: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221914
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221914:
	DD	1
	DD	$L221913
$L221913:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221912
$L221912:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_RecipientCertificates
_TEXT	ENDS
PUBLIC	?EncryptStr@CSignature@@UAGJPAGPAPAG@Z		; CSignature::EncryptStr
PUBLIC	?EncryptBlob@CSignature@@QAEPAEPAU_DS_DATA_BLOB@@PAK@Z ; CSignature::EncryptBlob
xdata$x	SEGMENT
$T221930 DD	0ffffffffH
	DD	FLAT:$L221921
$T221923 DD	019930520H
	DD	01H
	DD	FLAT:$T221930
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221920 = -92						; size = 4
$T221919 = -88						; size = 4
$T221918 = -84						; size = 4
$T221917 = -80						; size = 4
$T221916 = -76						; size = 4
__lpa$ = -72						; size = 4
__lpw$ = -68						; size = 4
__acp$ = -64						; size = 4
__convert$ = -60					; size = 4
_encodedEncryptedDataSize$ = -52			; size = 4
_encodedEncryptedData$ = -44				; size = 4
_inputBlob$ = -36					; size = 8
_ccBstrInputStr$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_inputStr$ = 12						; size = 4
_cipherStr$ = 16					; size = 4
?EncryptStr@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::EncryptStr

; 10736: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EncryptStr@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10737: 	CComBSTR ccBstrInputStr;

	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 10738: 	DS_DATA_BLOB inputBlob;
; 10739: 	BYTE *encodedEncryptedData=NULL;

	mov	DWORD PTR _encodedEncryptedData$[ebp], 0

; 10740: 	unsigned long encodedEncryptedDataSize;
; 10741: 
; 10742: 	EnterLog;
; 10743: 	
; 10744: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L211652

; 10745: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 10746: 		return S_FALSE;

	mov	DWORD PTR $T221916[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221916[ebp]
	jmp	$L211647
$L211652:

; 10747: 	}
; 10748: 	if (!LicObj.getEncryptAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getEncryptAllowed@CLicense@@QAEHXZ	; CLicense::getEncryptAllowed
	test	eax, eax
	jne	SHORT $L211655

; 10749: 		setError(SigHandle, NO_ENCRYPT_LIC);

	push	91					; 0000005bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 10750: 		return S_FALSE;

	mov	DWORD PTR $T221917[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221917[ebp]
	jmp	$L211647
$L211655:

; 10751: 	}
; 10752: 	
; 10753: 	ccBstrInputStr = inputStr;

	mov	ecx, DWORD PTR _inputStr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 10754: 	if (ccBstrInputStr.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211658

; 10755: 	{
; 10756: 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 10757: 		return S_FALSE;

	mov	DWORD PTR $T221918[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221918[ebp]
	jmp	$L211647
$L211658:

; 10758: 	}
; 10759: 
; 10760: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 10761: 
; 10762: 	inputBlob.pbData = (BYTE *)HeapW2A(inputStr);

	mov	ecx, DWORD PTR _inputStr$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _inputBlob$[ebp], eax

; 10763: 	inputBlob.cbData = strlen((const char *)inputBlob.pbData) + 1;

	mov	edx, DWORD PTR _inputBlob$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _inputBlob$[ebp+4], eax

; 10764: 
; 10765: 	encodedEncryptedData = EncryptBlob(&inputBlob,
; 10766: 										&encodedEncryptedDataSize);

	lea	eax, DWORD PTR _encodedEncryptedDataSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _inputBlob$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncryptBlob@CSignature@@QAEPAEPAU_DS_DATA_BLOB@@PAK@Z ; CSignature::EncryptBlob
	mov	DWORD PTR _encodedEncryptedData$[ebp], eax

; 10767: 	if (encodedEncryptedData == NULL)

	cmp	DWORD PTR _encodedEncryptedData$[ebp], 0
	jne	SHORT $L211667

; 10768: 		return S_FALSE;

	mov	DWORD PTR $T221919[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221919[ebp]
	jmp	SHORT $L211647
$L211667:

; 10769: 	*cipherStr = A2WBSTR((LPCSTR)encodedEncryptedData, encodedEncryptedDataSize);

	mov	edx, DWORD PTR _encodedEncryptedDataSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _encodedEncryptedData$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _cipherStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 10770: 	zFree(encodedEncryptedData);

	mov	edx, DWORD PTR _encodedEncryptedData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10771: 	zFree(inputBlob.pbData);

	mov	eax, DWORD PTR _inputBlob$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 10772: 	ExitLog;
; 10773: 	return S_OK;

	mov	DWORD PTR $T221920[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221920[ebp]
$L211647:

; 10774: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221929
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221929:
	DD	3
	DD	$L221928
$L221928:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221924
	DD	-36					; ffffffdcH
	DD	8
	DD	$L221925
	DD	-52					; ffffffccH
	DD	4
	DD	$L221926
$L221926:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221925:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221924:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221921:
	lea	ecx, DWORD PTR _ccBstrInputStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?EncryptStr@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T221923
	jmp	___CxxFrameHandler
text$x	ENDS
?EncryptStr@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::EncryptStr
PUBLIC	?DecryptBlob@CSignature@@IAEHPAU_DS_DATA_BLOB@@0@Z ; CSignature::DecryptBlob
PUBLIC	?DecryptStr@CSignature@@UAGJPAGPAPAG@Z		; CSignature::DecryptStr
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_dBlob$ = -40						; size = 8
_cBlob$ = -24						; size = 8
_cbEncryptedBlob$ = -12					; size = 4
_pbEncryptedBlob$ = -8					; size = 4
_EncryptedString$ = -4					; size = 4
_this$ = 8						; size = 4
_cipherText$ = 12					; size = 4
_plainText$ = 16					; size = 4
?DecryptStr@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::DecryptStr

; 10777: {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	edi
	lea	edi, DWORD PTR [ebp-44]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 10778: 	char* EncryptedString = NULL;

	mov	DWORD PTR _EncryptedString$[ebp], 0

; 10779: 	BYTE*    pbEncryptedBlob = NULL;

	mov	DWORD PTR _pbEncryptedBlob$[ebp], 0

; 10780: 	DWORD    cbEncryptedBlob =0;

	mov	DWORD PTR _cbEncryptedBlob$[ebp], 0

; 10781: 	DS_DATA_BLOB cBlob;
; 10782: 	DS_DATA_BLOB dBlob;
; 10783: 
; 10784: 	EncryptedString = (char *)HeapW2A(cipherText);

	mov	eax, DWORD PTR _cipherText$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _EncryptedString$[ebp], eax

; 10785: 
; 10786: 	cbEncryptedBlob = base64decodeSize((DWORD)strlen((const char *)EncryptedString));

	mov	ecx, DWORD PTR _EncryptedString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _cbEncryptedBlob$[ebp], eax

; 10787: 	pbEncryptedBlob = (BYTE *) zMalloc (cbEncryptedBlob+1);

	mov	edx, DWORD PTR _cbEncryptedBlob$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbEncryptedBlob$[ebp], eax

; 10788: 	memset(pbEncryptedBlob,0,cbEncryptedBlob+1);

	mov	eax, DWORD PTR _cbEncryptedBlob$[ebp]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 10789: 	cbEncryptedBlob = base64decode((unsigned char *)EncryptedString,(unsigned char *)pbEncryptedBlob,cbEncryptedBlob);

	mov	edx, DWORD PTR _cbEncryptedBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbEncryptedBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _EncryptedString$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cbEncryptedBlob$[ebp], eax

; 10790: 	zFree(EncryptedString);

	mov	edx, DWORD PTR _EncryptedString$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10791: 
; 10792: 	cBlob.cbData = cbEncryptedBlob;

	mov	eax, DWORD PTR _cbEncryptedBlob$[ebp]
	mov	DWORD PTR _cBlob$[ebp+4], eax

; 10793: 	cBlob.pbData = pbEncryptedBlob;

	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	mov	DWORD PTR _cBlob$[ebp], ecx

; 10794: 	dBlob.cbData = 0;

	mov	DWORD PTR _dBlob$[ebp+4], 0

; 10795: 	dBlob.pbData = NULL;

	mov	DWORD PTR _dBlob$[ebp], 0

; 10796: 
; 10797: 	if (!DecryptBlob(&cBlob, &dBlob)) {

	lea	edx, DWORD PTR _dBlob$[ebp]
	push	edx
	lea	eax, DWORD PTR _cBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecryptBlob@CSignature@@IAEHPAU_DS_DATA_BLOB@@0@Z ; CSignature::DecryptBlob
	test	eax, eax
	jne	SHORT $L211689

; 10798: 		zFree(pbEncryptedBlob);

	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 10799: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211677
$L211689:

; 10800: 	}
; 10801: 	if (dBlob.pbData) {

	cmp	DWORD PTR _dBlob$[ebp], 0
	je	SHORT $L211691

; 10802: 		*plainText = A2WBSTR((LPCSTR) dBlob.pbData,dBlob.cbData);

	mov	edx, DWORD PTR _dBlob$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _dBlob$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _plainText$[ebp]
	mov	DWORD PTR [ecx], eax

; 10803: 		zFree(dBlob.pbData);

	mov	edx, DWORD PTR _dBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 10804: 	}else{

	jmp	SHORT $L211693
$L211691:

; 10805: 		*plainText = NULL;

	mov	eax, DWORD PTR _plainText$[ebp]
	mov	DWORD PTR [eax], 0
$L211693:

; 10806: 	}
; 10807: 	return S_OK;

	xor	eax, eax
$L211677:

; 10808: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221935
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L221935:
	DD	2
	DD	$L221934
$L221934:
	DD	-24					; ffffffe8H
	DD	8
	DD	$L221932
	DD	-40					; ffffffd8H
	DD	8
	DD	$L221933
$L221933:
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221932:
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?DecryptStr@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::DecryptStr
; Function compile flags: /Odt /RTCsu
_pct$ = -32						; size = 4
_cbDecryptedMessage$ = -8				; size = 4
_this$ = -4						; size = 4
_cBlob$ = 8						; size = 4
_dBlob$ = 12						; size = 4
?DecryptBlob@CSignature@@IAEHPAU_DS_DATA_BLOB@@0@Z PROC NEAR ; CSignature::DecryptBlob
; _this$ = ecx

; 10817: {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 10818: 	DWORD cbDecryptedMessage = 0;

	mov	DWORD PTR _cbDecryptedMessage$[ebp], 0

; 10819: 
; 10820: #ifdef NSS
; 10821: 	SECItem	pfxBlob;
; 10822: 	CERTCertificate *pct=NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 10823: 
; 10824: 	// NSS doesn't trust the root certificate in the chain.
; 10825: 	// This part requires additional attention - implement PKCS7 on our own.
; 10826: 	setError(SigHandle, NSS_NOT_SUPPORTED);

	push	127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 10827: 	return FALSE;

	xor	eax, eax

; 10828: 
; 10829: #else
; 10830: 	CRYPT_DECRYPT_MESSAGE_PARA  DecryptParams;
; 10831: 	DWORD  DecryptParamsSize = sizeof(DecryptParams);
; 10832: 	HCRYPTPROV hCryptProv;
; 10833: 	HCERTSTORE hStoreHandle;
; 10834: 	CRYPT_DATA_BLOB	pfxBlob;
; 10835: #endif
; 10836: 
; 10837: 	BYTE*  pbDecryptedMessage = NULL;
; 10838: 	BOOL   fReturn = TRUE;
; 10839: 	BYTE*    pbEncryptedBlob = NULL;
; 10840: 	DWORD    cbEncryptedBlob =0;
; 10841: 
; 10842: 	EnterLog;
; 10843: 	if (! LicObj.checkLicense()) {
; 10844: 		setError(SigHandle, INVALID_SECUREXML_LIC);
; 10845: 		return FALSE;
; 10846: 	}
; 10847: 	if (!LicObj.getDecryptAllowed()) {
; 10848: 		setError(SigHandle, NO_DECRYPT_LIC);
; 10849: 		return FALSE;
; 10850: 	}
; 10851: 	if (!cBlob || !dBlob || !dBlob->pbData) {
; 10852: 		return FALSE;
; 10853: 	}
; 10854: 
; 10855: 	cbEncryptedBlob = cBlob->cbData;
; 10856: 	pbEncryptedBlob = cBlob->pbData;
; 10857: 
; 10858: #ifndef NSS
; 10859: 	if(!(CryptAcquireContext(
; 10860: 				&hCryptProv,         // Address for handle to be returned.
; 10861: 				NULL,                // Use the current user's logon name.
; 10862: 				MS_ENHANCED_PROV,    // Use the default provider.
; 10863: 				PROV_RSA_FULL,       // Need to both encrypt and sign.
; 10864: 				CRYPT_MACHINE_KEYSET )))                 // No flags needed.
; 10865: 	{ // Keyset does not exist. lets create one
; 10866: 		if(!(CryptAcquireContext(
; 10867: 				&hCryptProv,         // Address for handle to be returned.
; 10868: 				NULL,                // Use the current user's logon name.
; 10869: 				MS_ENHANCED_PROV,    // Use the default provider.
; 10870: 				PROV_RSA_FULL,       // Need to both encrypt and sign.
; 10871: 				CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET )))   // No flags needed.
; 10872: 		{
; 10873: 			setError(SigHandle, CAPI_ACQUIRE_CNTX);
; 10874: 			return FALSE;
; 10875: 		}
; 10876: 	}
; 10877: #endif
; 10878: USES_CONVERSION;
; 10879: 
; 10880: 	if ((DecryptUsingPfxFileCert) && (DecrytionPfxCertFile.Length() != 0))
; 10881: 	{
; 10882: #ifdef NSS
; 10883: 		SECItem pwd;
; 10884: 		pwd.len = DecrytionPfxPassword.cbData + 1; // counting on '\0'
; 10885: 		pwd.data = (BYTE *) zMalloc(pwd.len);
; 10886: 		memset(pwd.data,0,pwd.len);
; 10887: 		memcpy(pwd.data,DecrytionPfxPassword.pbData,DecrytionPfxPassword.cbData);
; 10888: 
; 10889: 		ReadAllBin(DecrytionPfxCertFile.m_str, &pfxBlob.data, (DWORD *) &pfxBlob.len);
; 10890: 		if ((pfxBlob.data != NULL) &&
; 10891: 			crNSS_PFXIsPFXBlob(&pfxBlob, &pwd, SigHandle))
; 10892: 		{
; 10893: 			if (!(pct = NSS_ImportPKCS12Object(&pfxBlob, &pwd, SigHandle))) {
; 10894: 				setError(SigHandle, PFX_IMPORT_FAILED);
; 10895: 				zFree(pfxBlob.data);
; 10896: 				return FALSE;
; 10897: 			}
; 10898: 		}else{
; 10899: 			setError(SigHandle, PFX_BAD_PASSWORD);
; 10900: 			if (pfxBlob.data)
; 10901: 				zFree(pfxBlob.data);
; 10902: 			return FALSE;
; 10903: 		}
; 10904: 		if (pfxBlob.data)
; 10905: 			zFree(pfxBlob.data);
; 10906: 		if (pwd.data) 
; 10907: 			zFree(pwd.data);
; 10908: #else
; 10909: 		ReadAllBin(DecrytionPfxCertFile.m_str, &pfxBlob.pbData, &pfxBlob.cbData);
; 10910: 		if ((pfxBlob.pbData != NULL) &&
; 10911: 			(PFXIsPFXBlob(&pfxBlob)))
; 10912: 		{
; 10913: 			// this is PFX, import it and deal with temp store
; 10914: 			LPCWSTR password = (LPCWSTR) DecrytionPfxPassword.pbData;
; 10915: 
; 10916: 			if (!PFXVerifyPassword(&pfxBlob, password, CRYPT_MACHINE_KEYSET))
; 10917: 			{
; 10918: 				setError(SigHandle, PFX_BAD_PASSWORD);
; 10919: 				zFree(pfxBlob.pbData);
; 10920: 				return FALSE;
; 10921: 			}
; 10922: 			if ((hStoreHandle =  PFXImportCertStore(
; 10923: 									&pfxBlob, 
; 10924: 									password, 
; 10925: 									CRYPT_MACHINE_KEYSET | CRYPT_EXPORTABLE
; 10926: 									)) == NULL)
; 10927: 			{
; 10928: 				setError(SigHandle, PFX_IMPORT_FAILED);
; 10929: 				zFree(pfxBlob.pbData);
; 10930: 				return FALSE;
; 10931: 			}
; 10932: 		}
; 10933: 		if (pfxBlob.pbData != NULL)
; 10934: 			zFree(pfxBlob.pbData);
; 10935: #endif
; 10936: 	}
; 10937: 	else
; 10938: 	{
; 10939: #ifdef NSS
; 10940: 		// enumerate all certificate from the store
; 10941: 		// --!!TODO
; 10942: 		setError(SigHandle, CAPI_OPEN_STORE);
; 10943: 		return FALSE;
; 10944: 
; 10945: #else
; 10946: 		char *aStoreName = (char *)HeapW2A(StoreName.m_str);
; 10947: 		if(!(hStoreHandle = CertOpenSystemStore(
; 10948: 			hCryptProv, aStoreName)))
; 10949: 		{
; 10950: 			setError(SigHandle, CAPI_OPEN_STORE);
; 10951: 			zFree(aStoreName);
; 10952: 			return FALSE;
; 10953: 		}
; 10954: 		zFree(aStoreName);
; 10955: #endif
; 10956: 	}
; 10957: 
; 10958: #ifdef NSS
; 10959: 	// decrypt here
; 10960: 	// --!!TODO
; 10961: #else
; 10962: 	HCERTSTORE CertStoreArray[] = {hStoreHandle};
; 10963: 	memset(&DecryptParams, 0, DecryptParamsSize);
; 10964: 	DecryptParams.cbSize = DecryptParamsSize;
; 10965: 	DecryptParams.dwMsgAndCertEncodingType = MY_ENCODING_TYPE;
; 10966: 	DecryptParams.cCertStore = 1;
; 10967: 	DecryptParams.rghCertStore = CertStoreArray;
; 10968: 
; 10969: 	//--------------------------------------------------------------------
; 10970: 	//  Decrypt the message data.
; 10971: 	//  Call CryptDecryptMessage to get the returned data size.
; 10972: 
; 10973: 	if(!(CryptDecryptMessage(
; 10974: 			&DecryptParams,
; 10975: 			pbEncryptedBlob,
; 10976: 			cbEncryptedBlob,
; 10977: 			NULL,
; 10978: 			&cbDecryptedMessage,
; 10979: 			NULL)))
; 10980: 	{
; 10981: 		setError(SigHandle, CAPI_DECRYPT_MSG);
; 10982: 		return FALSE;
; 10983: 	}
; 10984: 	//--------------------------------------------------------------------
; 10985: 	// Allocate memory for the returned decrypted data.
; 10986: 
; 10987: 	if(!(pbDecryptedMessage = (BYTE*)zMalloc(
; 10988: 		cbDecryptedMessage)))
; 10989: 	{
; 10990: 		setError(SigHandle, MEMORY_FAULT);
; 10991: 		return FALSE;
; 10992: 	}
; 10993: 	//--------------------------------------------------------------------
; 10994: 	// Call CryptDecryptMessage to decrypt the data.
; 10995: 
; 10996: 	if(!(CryptDecryptMessage(
; 10997: 			&DecryptParams,
; 10998: 			pbEncryptedBlob,
; 10999: 			cbEncryptedBlob,
; 11000: 			pbDecryptedMessage,
; 11001: 			&cbDecryptedMessage,
; 11002: 			NULL)))
; 11003: 	{
; 11004: 		setError(SigHandle, DECRYPTION_FAILED);
; 11005: 		zFree(pbDecryptedMessage);
; 11006: 		return FALSE;
; 11007: 	}
; 11008: #endif
; 11009: 
; 11010: 	dBlob->cbData = cbDecryptedMessage;
; 11011: 	dBlob->pbData = pbDecryptedMessage;
; 11012: 
; 11013: 	//--------------------------------------------------------------------
; 11014: 	// Clean up memory.
; 11015: #ifdef NSS
; 11016: 	if (pct) {
; 11017: 		SEC_DeletePermCertificate(pct);
; 11018: 		CERT_DestroyCertificate(pct);
; 11019: 	}
; 11020: #else
; 11021: 	CertCloseStore(
; 11022: 			hStoreHandle, 
; 11023: 			CERT_CLOSE_STORE_CHECK_FLAG);
; 11024: 	if(hCryptProv)
; 11025: 		CryptReleaseContext(hCryptProv,0);
; 11026: #endif
; 11027: 
; 11028: 	ExitLog;
; 11029: 	return TRUE;
; 11030: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221940
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221940:
	DD	2
	DD	$L221939
$L221939:
	DD	-24					; ffffffe8H
	DD	12					; 0000000cH
	DD	$L221937
	DD	-80					; ffffffb0H
	DD	12					; 0000000cH
	DD	$L221938
$L221938:
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	0
$L221937:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?DecryptBlob@CSignature@@IAEHPAU_DS_DATA_BLOB@@0@Z ENDP	; CSignature::DecryptBlob
_TEXT	ENDS
PUBLIC	?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z	; CSignature::EncryptFileA
xdata$x	SEGMENT
$T221957 DD	0ffffffffH
	DD	FLAT:$L221948
$T221950 DD	019930520H
	DD	01H
	DD	FLAT:$T221957
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221947 = -100						; size = 4
$T221946 = -96						; size = 4
$T221945 = -92						; size = 4
$T221944 = -88						; size = 4
$T221943 = -84						; size = 4
$T221942 = -80						; size = 4
_bstrEncodedEncryptedData$ = -76			; size = 4
__lpa$ = -72						; size = 4
__lpw$ = -68						; size = 4
__acp$ = -64						; size = 4
__convert$ = -60					; size = 4
_encodedEncryptedDataSize$ = -52			; size = 4
_encodedEncryptedData$ = -44				; size = 4
_inputBlob$ = -36					; size = 8
_ccBstrInputFile$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_inputFile$ = 12					; size = 4
_outputFile$ = 16					; size = 4
_encryptedFile$ = 20					; size = 4
?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::EncryptFileA

; 11033: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11034: 	CComBSTR ccBstrInputFile;

	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 11035: 	DS_DATA_BLOB inputBlob;
; 11036: 	BYTE *encodedEncryptedData=NULL;

	mov	DWORD PTR _encodedEncryptedData$[ebp], 0

; 11037: 	unsigned long encodedEncryptedDataSize;
; 11038: 
; 11039: 	EnterLog;
; 11040: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L211737

; 11041: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11042: 		return S_FALSE;

	mov	DWORD PTR $T221942[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221942[ebp]
	jmp	$L211732
$L211737:

; 11043: 	}
; 11044: 	if (!LicObj.getEncryptAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getEncryptAllowed@CLicense@@QAEHXZ	; CLicense::getEncryptAllowed
	test	eax, eax
	jne	SHORT $L211740

; 11045: 		setError(SigHandle, NO_ENCRYPT_LIC);

	push	91					; 0000005bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11046: 		return S_FALSE;

	mov	DWORD PTR $T221943[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221943[ebp]
	jmp	$L211732
$L211740:

; 11047: 	}
; 11048: 
; 11049: 	ccBstrInputFile = inputFile;

	mov	ecx, DWORD PTR _inputFile$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 11050: 	if (ccBstrInputFile.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211743

; 11051: 	{
; 11052: 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11053: 		return S_FALSE;

	mov	DWORD PTR $T221944[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221944[ebp]
	jmp	$L211732
$L211743:

; 11054: 	}
; 11055: 
; 11056: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 11057: 
; 11058: 	if (ReadAllBin(inputFile, 
; 11059: 					&inputBlob.pbData, 
; 11060: 					&inputBlob.cbData) == S_FALSE)

	lea	ecx, DWORD PTR _inputBlob$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _inputBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L211751

; 11061: 	{
; 11062: 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11063: 		return S_FALSE;

	mov	DWORD PTR $T221945[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221945[ebp]
	jmp	$L211732
$L211751:

; 11064: 	}
; 11065: 	encodedEncryptedData = EncryptBlob(&inputBlob,
; 11066: 										&encodedEncryptedDataSize);

	lea	eax, DWORD PTR _encodedEncryptedDataSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _inputBlob$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EncryptBlob@CSignature@@QAEPAEPAU_DS_DATA_BLOB@@PAK@Z ; CSignature::EncryptBlob
	mov	DWORD PTR _encodedEncryptedData$[ebp], eax

; 11067: 	if (inputBlob.pbData)

	cmp	DWORD PTR _inputBlob$[ebp], 0
	je	SHORT $L211754

; 11068: 		zFree(inputBlob.pbData);

	mov	edx, DWORD PTR _inputBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L211754:

; 11069: 
; 11070: 	if (encodedEncryptedData == NULL)

	cmp	DWORD PTR _encodedEncryptedData$[ebp], 0
	jne	SHORT $L211755

; 11071: 		return S_FALSE;

	mov	DWORD PTR $T221946[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221946[ebp]
	jmp	SHORT $L211732
$L211755:

; 11072: 
; 11073: 	BSTR bstrEncodedEncryptedData = A2WBSTR((LPCSTR)encodedEncryptedData, encodedEncryptedDataSize);

	mov	eax, DWORD PTR _encodedEncryptedDataSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encodedEncryptedData$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrEncodedEncryptedData$[ebp], eax

; 11074: 	zFree(encodedEncryptedData);

	mov	edx, DWORD PTR _encodedEncryptedData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11075: 
; 11076: 	SaveXMLStr(bstrEncodedEncryptedData, outputFile, encryptedFile);

	mov	esi, esp
	mov	eax, DWORD PTR _encryptedFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outputFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrEncodedEncryptedData$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+240]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11077: 	SysFreeString(bstrEncodedEncryptedData);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrEncodedEncryptedData$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11078: 	ExitLog;
; 11079: 	return S_OK;

	mov	DWORD PTR $T221947[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221947[ebp]
$L211732:

; 11080: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221956
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221956:
	DD	3
	DD	$L221955
$L221955:
	DD	-20					; ffffffecH
	DD	4
	DD	$L221951
	DD	-36					; ffffffdcH
	DD	8
	DD	$L221952
	DD	-52					; ffffffccH
	DD	4
	DD	$L221953
$L221953:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221952:
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221951:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221948:
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221950
	jmp	___CxxFrameHandler
text$x	ENDS
?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::EncryptFileA
PUBLIC	??0CComBSTR@ATL@@QAE@PBG@Z			; ATL::CComBSTR::CComBSTR
PUBLIC	?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z	; CSignature::DecryptFileA
xdata$x	SEGMENT
$T221984 DD	0ffffffffH
	DD	FLAT:$L221968
	DD	00H
	DD	FLAT:$L221969
$T221971 DD	019930520H
	DD	02H
	DD	FLAT:$T221984
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T221967 = -432						; size = 4
$T221966 = -428						; size = 4
$T221965 = -424						; size = 4
$T221964 = -420						; size = 4
$T221963 = -416						; size = 4
$T221962 = -412						; size = 4
$T221961 = -408						; size = 4
$T221960 = -404						; size = 4
_dwBytesWritten$ = -396					; size = 4
_hTempFile$ = -388					; size = 4
_aOutputFile$211808 = -384				; size = 4
_ccBstrOutputFile$ = -376				; size = 4
_ccBstrInputFile$ = -364				; size = 4
_dBlob$ = -352						; size = 8
_eBlob$ = -336						; size = 8
_tmpFilePath$ = -320					; size = 4
_TempPath$ = -308					; size = 260
_bstrEncryptedString$ = -40				; size = 4
_cbEncryptedBlob$ = -32					; size = 4
_pbEncryptedBlob$ = -28					; size = 4
_fReturn$ = -24						; size = 4
_EncryptedString$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputFile$ = 12					; size = 4
_outputFile$ = 16					; size = 4
_decryptedFile$ = 20					; size = 4
?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::DecryptFileA

; 11083: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 420				; 000001a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-432]
	mov	ecx, 105				; 00000069H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 11084: 	char* EncryptedString;
; 11085: 	BOOL   fReturn = TRUE;

	mov	DWORD PTR _fReturn$[ebp], 1

; 11086: 	BYTE*    pbEncryptedBlob;
; 11087: 	DWORD    cbEncryptedBlob;
; 11088: 	BSTR bstrEncryptedString;
; 11089: 	char TempPath[MAX_PATH];
; 11090: 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 11091: 	DS_DATA_BLOB eBlob;
; 11092: 	DS_DATA_BLOB dBlob;
; 11093: 
; 11094: 	EnterLog;
; 11095: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L211777

; 11096: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11097: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211767
$L211777:

; 11098: 	}
; 11099: 	if (!LicObj.getDecryptAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getDecryptAllowed@CLicense@@QAEHXZ	; CLicense::getDecryptAllowed
	test	eax, eax
	jne	SHORT $L211779

; 11100: 		setError(SigHandle, NO_DECRYPT_LIC);

	push	92					; 0000005cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11101: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211767
$L211779:

; 11102: 	}
; 11103: 
; 11104: 	CComBSTR ccBstrInputFile = inputFile;

	mov	ecx, DWORD PTR _inputFile$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??0CComBSTR@ATL@@QAE@PBG@Z		; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 11105: 	if (ccBstrInputFile.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L211782

; 11106: 	{
; 11107: 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11108: 		return S_FALSE;

	mov	DWORD PTR $T221960[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221960[ebp]
	jmp	$L211767
$L211782:

; 11109: 	}
; 11110: 	if (ReadAll(inputFile, &bstrEncryptedString) == S_FALSE)

	mov	esi, esp
	lea	ecx, DWORD PTR _bstrEncryptedString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+236]
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $L211786

; 11111: 	{
; 11112: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11113: 		return S_FALSE;

	mov	DWORD PTR $T221961[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221961[ebp]
	jmp	$L211767
$L211786:

; 11114: 	}
; 11115: 	EncryptedString = (char *)HeapW2A(bstrEncryptedString);

	mov	edx, DWORD PTR _bstrEncryptedString$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _EncryptedString$[ebp], eax

; 11116: 	SysFreeString(bstrEncryptedString);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrEncryptedString$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11117: 
; 11118: 	cbEncryptedBlob = base64decodeSize((DWORD)strlen((const char *)EncryptedString));

	mov	ecx, DWORD PTR _EncryptedString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _cbEncryptedBlob$[ebp], eax

; 11119: 	pbEncryptedBlob = (BYTE *) zMalloc (cbEncryptedBlob+1);

	mov	edx, DWORD PTR _cbEncryptedBlob$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbEncryptedBlob$[ebp], eax

; 11120: 	memset(pbEncryptedBlob,0,cbEncryptedBlob+1);

	mov	eax, DWORD PTR _cbEncryptedBlob$[ebp]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 11121: 	cbEncryptedBlob = base64decode((unsigned char *)EncryptedString,(unsigned char *)pbEncryptedBlob,cbEncryptedBlob);

	mov	edx, DWORD PTR _cbEncryptedBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbEncryptedBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _EncryptedString$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cbEncryptedBlob$[ebp], eax

; 11122: 
; 11123: 	zFree(EncryptedString);

	mov	edx, DWORD PTR _EncryptedString$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11124: 
; 11125: 	eBlob.cbData = cbEncryptedBlob;

	mov	eax, DWORD PTR _cbEncryptedBlob$[ebp]
	mov	DWORD PTR _eBlob$[ebp+4], eax

; 11126: 	eBlob.pbData = pbEncryptedBlob;

	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	mov	DWORD PTR _eBlob$[ebp], ecx

; 11127: 
; 11128: 	if (!DecryptBlob(&eBlob,&dBlob)) {

	lea	edx, DWORD PTR _dBlob$[ebp]
	push	edx
	lea	eax, DWORD PTR _eBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DecryptBlob@CSignature@@IAEHPAU_DS_DATA_BLOB@@0@Z ; CSignature::DecryptBlob
	test	eax, eax
	jne	SHORT $L211795

; 11129: 		zFree(pbEncryptedBlob);		

	mov	ecx, DWORD PTR _pbEncryptedBlob$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11130: 		return S_FALSE;

	mov	DWORD PTR $T221962[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221962[ebp]
	jmp	$L211767
$L211795:

; 11131: 	}
; 11132: 	zFree(pbEncryptedBlob);

	mov	edx, DWORD PTR _pbEncryptedBlob$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11133: 
; 11134: 	CComBSTR ccBstrOutputFile = outputFile;

	mov	eax, DWORD PTR _outputFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrOutputFile$[ebp]
	call	??0CComBSTR@ATL@@QAE@PBG@Z		; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 11135: 	if (ccBstrOutputFile.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrOutputFile$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	$L211799

; 11136: 	{
; 11137: 		GetTempPath((DWORD)MAX_PATH, TempPath);

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11138: 		GetTempFileName(TempPath, // dir. for temp. files 
; 11139: 			"INFM",                // temp. file name prefix 
; 11140: 			0,                    // create unique name 
; 11141: 			szTempName);          // buffer for name

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG211801
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11142: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T221963[ebp], eax
	mov	ecx, DWORD PTR $T221963[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 11143: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 11144: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T221964[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T221965[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 11145: 	}
; 11146: 	else

	jmp	SHORT $L211807
$L211799:

; 11147: 	{
; 11148: 		char *aOutputFile = (char *)HeapW2A(outputFile);

	mov	ecx, DWORD PTR _outputFile$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _aOutputFile$211808[ebp], eax

; 11149: 		strcpy(szTempName, aOutputFile);

	mov	edx, DWORD PTR _aOutputFile$211808[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	_strcpy
	add	esp, 8

; 11150: 		zFree(aOutputFile);

	mov	ecx, DWORD PTR _aOutputFile$211808[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L211807:

; 11151: 	}
; 11152: 
; 11153: #ifdef WIN32
; 11154: 	HANDLE hTempFile;
; 11155: 	hTempFile = CreateFile((LPCSTR) szTempName,  // file name 
; 11156: 		GENERIC_READ | GENERIC_WRITE, // open for read/write 
; 11157: 		0,                            // do not share 
; 11158: 		NULL,                         // no security 
; 11159: 		CREATE_ALWAYS,                // overwrite existing file
; 11160: 		FILE_ATTRIBUTE_NORMAL,        // normal file 
; 11161: 		NULL);                        // no attr. template 

	mov	esi, esp
	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	0
	push	-1073741824				; c0000000H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hTempFile$[ebp], eax

; 11162: 	if (hTempFile == INVALID_HANDLE_VALUE) 

	cmp	DWORD PTR _hTempFile$[ebp], -1
	jne	SHORT $L211814

; 11163: 	{
; 11164: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11165: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L211815

; 11166: 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L211815:

; 11167: 		return S_FALSE;

	mov	DWORD PTR $T221966[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrOutputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221966[ebp]
	jmp	$L211767
$L211814:

; 11168: 	}
; 11169: 	DWORD dwBytesWritten;
; 11170: 	// Write the signature buffer to the temporary file. 
; 11171: 	WriteFile(hTempFile, dBlob.pbData, dBlob.cbData , 
; 11172: 				&dwBytesWritten, NULL); 

	mov	esi, esp
	push	0
	lea	ecx, DWORD PTR _dwBytesWritten$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dBlob$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _dBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hTempFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__WriteFile@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11173: 	// Close file. 
; 11174: 	CloseHandle(hTempFile);

	mov	esi, esp
	mov	edx, DWORD PTR _hTempFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 11175: #else
; 11176: 	FILE *hTempFile;
; 11177: 	hTempFile = fopen(szTempName, "w+");
; 11178: 	if (!hTempFile)
; 11179: 	{
; 11180: 		setError(SigHandle, IO_ERROR);
; 11181: 		if (tmpFilePath != NULL)
; 11182: 			tmpFileList->remove(tmpFilePath);
; 11183: 		return S_FALSE;
; 11184: 	}
; 11185: 	size_t dwBytesWritten = fwrite(dBlob.pbData, 1, dBlob.cbData, hTempFile);
; 11186: 	fclose(hTempFile);
; 11187: #endif
; 11188: 	zFree(dBlob.pbData);

	mov	eax, DWORD PTR _dBlob$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11189: 	*decryptedFile = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _decryptedFile$[ebp]
	mov	DWORD PTR [edx], eax

; 11190: 	ExitLog;
; 11191: 	return S_OK;

	mov	DWORD PTR $T221967[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrOutputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T221967[ebp]
$L211767:

; 11192: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221983
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 432				; 000001b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L221983:
	DD	8
	DD	$L221982
$L221982:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L221972
	DD	-308					; fffffeccH
	DD	260					; 00000104H
	DD	$L221973
	DD	-320					; fffffec0H
	DD	4
	DD	$L221974
	DD	-336					; fffffeb0H
	DD	8
	DD	$L221975
	DD	-352					; fffffea0H
	DD	8
	DD	$L221976
	DD	-364					; fffffe94H
	DD	4
	DD	$L221977
	DD	-376					; fffffe88H
	DD	4
	DD	$L221978
	DD	-396					; fffffe74H
	DD	4
	DD	$L221979
$L221979:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	87					; 00000057H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L221978:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	79					; 0000004fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L221977:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L221976:
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221975:
	DB	101					; 00000065H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L221974:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221973:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L221972:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L221968:
	lea	ecx, DWORD PTR _ccBstrInputFile$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L221969:
	lea	ecx, DWORD PTR _ccBstrOutputFile$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T221971
	jmp	___CxxFrameHandler
text$x	ENDS
?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::DecryptFileA
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComBSTR@ATL@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
??0CComBSTR@ATL@@QAE@PBG@Z PROC NEAR			; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 571  : 	CComBSTR(LPCOLESTR pSrc)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 572  : 	{
; 573  : 		if (pSrc == NULL)

	cmp	DWORD PTR _pSrc$[ebp], 0
	jne	SHORT $L81652

; 574  : 			m_str = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 575  : 		else

	jmp	SHORT $L81651
$L81652:

; 576  : 		{
; 577  : 			m_str = ::SysAllocString(pSrc);

	mov	esi, esp
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 578  : 			if (m_str == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L81651

; 579  : 				AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L81651:

; 580  : 		}
; 581  : 	}

	mov	eax, DWORD PTR _this$[ebp]
$L221985:
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0CComBSTR@ATL@@QAE@PBG@Z ENDP				; ATL::CComBSTR::CComBSTR
_TEXT	ENDS
EXTRN	_DecodeDERCertificate:NEAR
EXTRN	_xsDereferenceURI:NEAR
EXTRN	_CERT_DestroyCertificate:NEAR
EXTRN	_SEC_PKCS7DestroyContentInfo:NEAR
EXTRN	_SEC_PKCS7CreateEnvelopedData:NEAR
EXTRN	_SEC_PKCS7AddRecipient:NEAR
EXTRN	_SEC_PKCS7EncoderStart:NEAR
EXTRN	_SEC_PKCS7EncoderUpdate:NEAR
EXTRN	_SEC_PKCS7EncoderFinish:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_cert$211901 = -100					; size = 4
_outFile$ = -92						; size = 4
_pbRef$ = -88						; size = 4
_cbRef$ = -80						; size = 4
_encodedEncryptedData$ = -72				; size = 4
_encodedSize$ = -68					; size = 4
_err$ = -64						; size = 4
_derCert$ = -56						; size = 12
_j$ = -40						; size = 4
_i$ = -36						; size = 4
_certCount$ = -32					; size = 4
_certArray$ = -28					; size = 4
_certs$ = -24						; size = 4
_rv$ = -16						; size = 4
_ecx$ = -12						; size = 4
_cinfo$ = -8						; size = 4
_this$ = -4						; size = 4
_blobPtr$ = 8						; size = 4
_encryptedSize$ = 12					; size = 4
?EncryptBlob@CSignature@@QAEPAEPAU_DS_DATA_BLOB@@PAK@Z PROC NEAR ; CSignature::EncryptBlob
; _this$ = ecx

; 11224: {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 25					; 00000019H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 11225: #ifdef NSS
; 11226:     SEC_PKCS7ContentInfo *cinfo=NULL;

	mov	DWORD PTR _cinfo$[ebp], 0

; 11227:     SEC_PKCS7EncoderContext *ecx=NULL;

	mov	DWORD PTR _ecx$[ebp], 0

; 11228:     SECStatus rv;
; 11229:     CERTCertDBHandle *certHandle;
; 11230:     CERTCertificate **certs=NULL;

	mov	DWORD PTR _certs$[ebp], 0

; 11231: 	char **certArray = NULL;

	mov	DWORD PTR _certArray$[ebp], 0

; 11232: 	int certCount =0;

	mov	DWORD PTR _certCount$[ebp], 0

; 11233: 	int i=0,j=0;

	mov	DWORD PTR _i$[ebp], 0
	mov	DWORD PTR _j$[ebp], 0

; 11234: 	SECItem derCert;
; 11235: 	int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 11236: 	UINT encodedSize;
; 11237: 	unsigned char *encodedEncryptedData;
; 11238: 	DWORD cbRef = 0;

	mov	DWORD PTR _cbRef$[ebp], 0

; 11239: 	BYTE *pbRef = NULL;

	mov	DWORD PTR _pbRef$[ebp], 0

; 11240: 	FILE *outFile;
; 11241: 
; 11242: 	// NSS doesn't trust the root certificate in the chain.
; 11243: 	// This part requires additional attention - implement PKCS7 on our own.
; 11244: 	setError(SigHandle, NSS_NOT_SUPPORTED);

	push	127					; 0000007fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11245: 	return NULL;

	xor	eax, eax
	jmp	$L211848
$L211876:

; 11246: 
; 11247: 	EnterLog;
; 11248: 	certHandle = CERT_GetDefaultCertDB();
; 11249: 
; 11250: 	// get recipient certificate list or select one
; 11251: 	if (RecipientCertificateCount == 0)
; 11252: 	{
; 11253: 		certs = (CERTCertificate **) zMalloc(sizeof(CERTCertificate *));
; 11254: #ifdef WIN32
; 11255: 		char *certData = dlgRecipient->selectCertificate();
; 11256: #else
; 11257: 		char *certData = NULL;
; 11258: #endif
; 11259: 		if (certData) {
; 11260: 			certCount =1;
; 11261: 			certArray = (char **) zMalloc(sizeof (char *));
; 11262: 			certArray[0] = certData;
; 11263: 		}
; 11264: 	}else{
; 11265: 		certCount =RecipientCertificateCount;
; 11266: 		certArray = (char **) zMalloc(sizeof (char *) * certCount);
; 11267: 		for (i=0;i<RecipientCertificateCount;i++) {

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+48]
	jae	SHORT $L211872

; 11268: 			certArray[i] = (char *)zMalloc(strlen(RecipientCertificateList[i])+1);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 11269: 			strcpy(certArray[i],RecipientCertificateList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 11270: 		}

	jmp	SHORT $L211876
$L211872:

; 11271: 	}
; 11272: 
; 11273: 	if (certCount==0 || certArray==NULL) {

	cmp	DWORD PTR _certCount$[ebp], 0
	je	SHORT $L211880
	cmp	DWORD PTR _certArray$[ebp], 0
	jne	SHORT $L211879
$L211880:

; 11274: 		return NULL;

	xor	eax, eax
	jmp	$L211848
$L211879:

; 11275: 	}
; 11276: 	certs = (CERTCertificate **) zMalloc(sizeof(CERTCertificate *) * certCount);

	mov	ecx, DWORD PTR _certCount$[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certs$[ebp], eax

; 11277: 	memset(certs,0,sizeof(CERTCertificate *) * certCount);

	mov	edx, DWORD PTR _certCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certs$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 11278: 
; 11279: 
; 11280: 	for (i=0;i<certCount;i++) {	

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211884
$L211885:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L211884:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certCount$[ebp]
	jge	$L211886

; 11281: 		derCert.len = base64decodeSize(strlen(certArray[i]));

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _derCert$[ebp+8], eax

; 11282: 		// allocate memory
; 11283: 		derCert.data = NULL;

	mov	DWORD PTR _derCert$[ebp+4], 0

; 11284: 		if(!(derCert.data = (BYTE*)zMalloc(derCert.len+1))){

	mov	eax, DWORD PTR _derCert$[ebp+8]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _derCert$[ebp+4], eax
	cmp	DWORD PTR _derCert$[ebp+4], 0
	jne	$L211888

; 11285: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11286: 			for (j=0;j<certCount;j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L211889
$L211890:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L211889:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211891

; 11287: 				if (certArray[j]) zFree(certArray[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L211892
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L211892:

; 11288: 				if (certs[j]) CERT_DestroyCertificate(certs[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certs$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L211893
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L211893:

; 11289: 			}

	jmp	SHORT $L211890
$L211891:

; 11290: 			zFree(certArray);

	mov	eax, DWORD PTR _certArray$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11291: 			zFree(certs);

	mov	ecx, DWORD PTR _certs$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11292: 			return NULL;

	xor	eax, eax
	jmp	$L211848
$L211888:

; 11293: 		}
; 11294: 		if ((derCert.len = base64decode((unsigned char*)certArray[i],
; 11295: 									derCert.data,
; 11296: 									derCert.len))==-1) 

	mov	edx, DWORD PTR _derCert$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _derCert$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _derCert$[ebp+8], eax
	cmp	DWORD PTR _derCert$[ebp+8], -1
	jne	$L211895

; 11297: 		{
; 11298: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11299: 			for (j=0;j<certCount;j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L211896
$L211897:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L211896:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211898

; 11300: 				if (certArray[j]) zFree(certArray[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L211899
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L211899:

; 11301: 				if (certs[j]) CERT_DestroyCertificate(certs[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certs$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L211900
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L211900:

; 11302: 			}			

	jmp	SHORT $L211897
$L211898:

; 11303: 			zFree(derCert.data);

	mov	eax, DWORD PTR _derCert$[ebp+4]
	push	eax
	call	_rFree
	add	esp, 4

; 11304: 			zFree(certArray);

	mov	ecx, DWORD PTR _certArray$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11305: 			zFree(certs);

	mov	edx, DWORD PTR _certs$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11306: 			return NULL;

	xor	eax, eax
	jmp	$L211848
$L211895:

; 11307: 		}
; 11308: 
; 11309: 		CERTCertificate *cert = DecodeDERCertificate(&derCert);

	lea	eax, DWORD PTR _derCert$[ebp]
	push	eax
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _cert$211901[ebp], eax

; 11310: 		if (!cert) {

	cmp	DWORD PTR _cert$211901[ebp], 0
	jne	$L211902

; 11311: 			setError(SigHandle, CAPI_CREATE_CERT_CNTX);

	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11312: 			for (j=0;j<certCount;j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L211903
$L211904:
	mov	eax, DWORD PTR _j$[ebp]
	add	eax, 1
	mov	DWORD PTR _j$[ebp], eax
$L211903:
	mov	ecx, DWORD PTR _j$[ebp]
	cmp	ecx, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211905

; 11313: 				if (certArray[j]) zFree(certArray[j]);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L211906
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L211906:

; 11314: 				if (certs[j]) CERT_DestroyCertificate(certs[j]);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _certs$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L211907
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L211907:

; 11315: 			}			

	jmp	SHORT $L211904
$L211905:

; 11316: 			zFree(derCert.data);

	mov	eax, DWORD PTR _derCert$[ebp+4]
	push	eax
	call	_rFree
	add	esp, 4

; 11317: 			zFree(certArray);

	mov	ecx, DWORD PTR _certArray$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11318: 			zFree(certs);

	mov	edx, DWORD PTR _certs$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11319: 			return NULL;

	xor	eax, eax
	jmp	$L211848
$L211902:

; 11320: 		}
; 11321: 		certs[i] = cert;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR _cert$211901[ebp]
	mov	DWORD PTR [ecx+eax*4], edx

; 11322: 		zFree(derCert.data);

	mov	eax, DWORD PTR _derCert$[ebp+4]
	push	eax
	call	_rFree
	add	esp, 4

; 11323: 	}

	jmp	$L211885
$L211886:

; 11324: 
; 11325: 	// clean helper array
; 11326: 	for (j=0;j<certCount;j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L211908
$L211909:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L211908:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211910

; 11327: 		if (certArray[j]) zFree(certArray[j]);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _certArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L211911
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _certArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L211911:

; 11328: 	}			

	jmp	SHORT $L211909
$L211910:

; 11329: 	zFree(certArray);

	mov	edx, DWORD PTR _certArray$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11330: 	certArray=NULL;

	mov	DWORD PTR _certArray$[ebp], 0

; 11331: 
; 11332: 	// at this point certs has all recipient certificates.
; 11333: 	// start PKCS7 message
; 11334: 	// bug in NSS - must fake key usage in order to go through
; 11335: 	certs[0]->keyUsage = KU_DIGITAL_SIGNATURE | KU_KEY_AGREEMENT_OR_ENCIPHERMENT | KU_KEY_CERT_SIGN;

	mov	eax, DWORD PTR _certs$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+304], 16516		; 00004084H

; 11336:     cinfo = SEC_PKCS7CreateEnvelopedData (certs[0],
; 11337: 					  certUsageEmailSigner,
; 11338: 					  NULL, SEC_OID_RC4, 0, 
; 11339: 					  (SECKEYGetPasswordKey) password_hardcode, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	push	OFFSET FLAT:?password_hardcode@@YAPAUSECItemStr@@PAX0@Z ; password_hardcode
	push	0
	push	6
	push	0
	push	4
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SEC_PKCS7CreateEnvelopedData
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _cinfo$[ebp], eax

; 11340: 	if (cinfo == NULL) {

	cmp	DWORD PTR _cinfo$[ebp], 0
	jne	SHORT $L211913

; 11341: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11342: 		goto retLabel;

	jmp	$retLabel$211914
$L211913:

; 11343: 	}
; 11344: 
; 11345: 	// add all recipients if we have more than 1	
; 11346:     for (i=1; i<certCount; i++) {

	mov	DWORD PTR _i$[ebp], 1
	jmp	SHORT $L211916
$L211917:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L211916:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211918

; 11347: 		// bug in NSS - must fake key usage in order to go through
; 11348: 		certs[i]->keyUsage = KU_DIGITAL_SIGNATURE | KU_KEY_AGREEMENT_OR_ENCIPHERMENT | KU_KEY_CERT_SIGN;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certs$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [ecx+304], 16516		; 00004084H

; 11349: 		rv = SEC_PKCS7AddRecipient (cinfo, certs[i], certUsageEmailSigner,
; 11350: 				    NULL); // default db handle

	push	0
	push	4
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certs$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _cinfo$[ebp]
	push	edx
	call	_SEC_PKCS7AddRecipient
	add	esp, 16					; 00000010H
	mov	DWORD PTR _rv$[ebp], eax

; 11351: 		if (rv != SECSuccess) {

	cmp	DWORD PTR _rv$[ebp], 0
	je	SHORT $L211919

; 11352: 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11353: 			goto retLabel;

	jmp	$retLabel$211914
$L211919:

; 11354: 		}
; 11355:     }

	jmp	SHORT $L211917
$L211918:

; 11356: 
; 11357: 	// passing callback function to perform writing and parameter for it
; 11358: 	// for now using file.
; 11359: #ifdef WIN32
; 11360: 	outFile = fopen("c:\\temp\\pkcs7.tmp","wb");

	push	OFFSET FLAT:$SG211921
	push	OFFSET FLAT:$SG211922
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outFile$[ebp], eax

; 11361: #else
; 11362: 	outFile = fopen("/tmp/SecureXML/pkcs7.tmp", "wb");
; 11363: #endif
; 11364:     ecx = SEC_PKCS7EncoderStart (cinfo, EncryptOut, outFile, NULL);

	push	0
	mov	eax, DWORD PTR _outFile$[ebp]
	push	eax
	push	OFFSET FLAT:?EncryptOut@@YAXPAXPBDK@Z	; EncryptOut
	mov	ecx, DWORD PTR _cinfo$[ebp]
	push	ecx
	call	_SEC_PKCS7EncoderStart
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ecx$[ebp], eax

; 11365: 	if (ecx == NULL) {

	cmp	DWORD PTR _ecx$[ebp], 0
	jne	SHORT $L211923

; 11366: 		fclose(outFile);

	mov	edx, DWORD PTR _outFile$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 11367: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11368: 		goto retLabel;

	jmp	$retLabel$211914
$L211923:

; 11369: 	}
; 11370: 
; 11371: 	rv = SEC_PKCS7EncoderUpdate(ecx, (const char *)blobPtr->pbData, blobPtr->cbData);

	mov	eax, DWORD PTR _blobPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _blobPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _ecx$[ebp]
	push	ecx
	call	_SEC_PKCS7EncoderUpdate
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _rv$[ebp], eax

; 11372: 	if (rv != SECSuccess){

	cmp	DWORD PTR _rv$[ebp], 0
	je	SHORT $L211926

; 11373: 		fclose(outFile);

	mov	edx, DWORD PTR _outFile$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 11374: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11375: 		goto retLabel;

	jmp	$retLabel$211914
$L211926:

; 11376:     }
; 11377: 
; 11378: 	if (SEC_PKCS7EncoderFinish(ecx, NULL, NULL) != SECSuccess) {

	push	0
	push	0
	mov	eax, DWORD PTR _ecx$[ebp]
	push	eax
	call	_SEC_PKCS7EncoderFinish
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L211928

; 11379: 		fclose(outFile);

	mov	ecx, DWORD PTR _outFile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 11380: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11381: 		goto retLabel;

	jmp	$retLabel$211914
$L211928:

; 11382: 	}
; 11383: 
; 11384:     SEC_PKCS7DestroyContentInfo (cinfo);

	mov	edx, DWORD PTR _cinfo$[ebp]
	push	edx
	call	_SEC_PKCS7DestroyContentInfo
	add	esp, 4

; 11385: 	fclose(outFile);

	mov	eax, DWORD PTR _outFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 11386: 	//--TODO: delete file
; 11387: 
; 11388: 	// read encrypted data from the file
; 11389: 	cbRef = 0;

	mov	DWORD PTR _cbRef$[ebp], 0

; 11390: #ifdef WIN32
; 11391: 	pbRef = xsDereferenceURI ("c:\\temp\\pkcs7.tmp",&cbRef);

	lea	ecx, DWORD PTR _cbRef$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG211930
	call	_xsDereferenceURI
	add	esp, 8
	mov	DWORD PTR _pbRef$[ebp], eax

; 11392: #else
; 11393: 	pbRef = xsDereferenceURI("/tmp/SecureXML/pkcs7.tmp", &cbRef);
; 11394: #endif
; 11395: 	
; 11396: 	// base64 encode data
; 11397: 	encodedSize = base64encodeSize(cbRef);

	mov	edx, DWORD PTR _cbRef$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _encodedSize$[ebp], eax

; 11398: 	if(!(encodedEncryptedData = (unsigned char*)zMalloc(encodedSize+1)))

	mov	eax, DWORD PTR _encodedSize$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _encodedEncryptedData$[ebp], eax
	cmp	DWORD PTR _encodedEncryptedData$[ebp], 0
	jne	SHORT $L211932

; 11399: 	{
; 11400: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11401: 		zFree(pbRef);

	mov	eax, DWORD PTR _pbRef$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11402: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11403: 		goto retLabel;

	jmp	SHORT $retLabel$211914
$L211932:

; 11404: 	}
; 11405: 	if ((encodedSize = base64encode(	(unsigned char *)pbRef,
; 11406: 						cbRef,
; 11407: 						(unsigned char*)encodedEncryptedData,
; 11408: 						encodedSize))==-1) 

	mov	ecx, DWORD PTR _encodedSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _encodedEncryptedData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cbRef$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbRef$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _encodedSize$[ebp], eax
	cmp	DWORD PTR _encodedSize$[ebp], -1
	jne	SHORT $L211936

; 11409: 	{
; 11410: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11411: 		zFree(pbRef);

	mov	ecx, DWORD PTR _pbRef$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11412: 		zFree(encodedEncryptedData);

	mov	edx, DWORD PTR _encodedEncryptedData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11413: 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 11414: 		goto retLabel;

	jmp	SHORT $retLabel$211914
$L211936:

; 11415: 	}
; 11416: 
; 11417: 	*(encodedEncryptedData+encodedSize)='\0';

	mov	eax, DWORD PTR _encodedEncryptedData$[ebp]
	add	eax, DWORD PTR _encodedSize$[ebp]
	mov	BYTE PTR [eax], 0

; 11418: 	zFree(pbRef);

	mov	ecx, DWORD PTR _pbRef$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11419: 	*encryptedSize = encodedSize + 1;

	mov	edx, DWORD PTR _encodedSize$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _encryptedSize$[ebp]
	mov	DWORD PTR [eax], edx
$retLabel$211914:

; 11420: 
; 11421: retLabel:
; 11422: 
; 11423: 	if (cinfo) SEC_PKCS7DestroyContentInfo (cinfo);

	cmp	DWORD PTR _cinfo$[ebp], 0
	je	SHORT $L211938
	mov	ecx, DWORD PTR _cinfo$[ebp]
	push	ecx
	call	_SEC_PKCS7DestroyContentInfo
	add	esp, 4
$L211938:

; 11424:     if ( certs ) {

	cmp	DWORD PTR _certs$[ebp], 0
	je	SHORT $L211939

; 11425: 		for ( i = 0; i < certCount; i++ ) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211940
$L211941:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L211940:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _certCount$[ebp]
	jge	SHORT $L211939

; 11426: 		    if ( certs[i] ) {

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certs$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L211943

; 11427: 				CERT_DestroyCertificate(certs[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L211943:

; 11428: 			}
; 11429: 		}

	jmp	SHORT $L211941
$L211939:

; 11430: 	}
; 11431: 
; 11432: 	zFree(certs);

	mov	eax, DWORD PTR _certs$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11433: 	ExitLog;
; 11434: 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L211944

; 11435: 		return NULL;

	xor	eax, eax
	jmp	SHORT $L211848
$L211944:

; 11436: 	}else{
; 11437: 		return encodedEncryptedData;

	mov	eax, DWORD PTR _encodedEncryptedData$[ebp]
$L211848:

; 11438: 	}
; 11439: #else
; 11440: 	PCCERT_CONTEXT pCertContext = NULL; 
; 11441: 	HCRYPTPROV hCryptProv=0;
; 11442: 	PCCERT_CONTEXT *RecipientCertContextArray;
; 11443: 	CRYPT_ALGORITHM_IDENTIFIER EncryptAlgorithm;
; 11444: 	CRYPT_ENCRYPT_MESSAGE_PARA EncryptParams;
; 11445: 	CMSG_RC4_AUX_INFO	RC4AuxInfo;
; 11446: 
; 11447: 	BSTR bstrCertData=NULL;
; 11448: 	DWORD dwBufferSize = 0;
; 11449: 	int cbCert=0;
; 11450: 	BYTE *pbCert=NULL;
; 11451: 	char *certData;
; 11452: 	BYTE *pbContent;
; 11453: 	DWORD cbContent;
; 11454: 	LPSTR *curRecipientCertificateList;
; 11455: 	UINT  curRecipientCertificateCount;
; 11456: 	DWORD EncryptAlgSize;
; 11457: 	DWORD EncryptParamsSize;
; 11458: 	BYTE*    pbEncryptedBlob;
; 11459: 	DWORD    cbEncryptedBlob;
; 11460: 	UINT i,j;
; 11461: 
; 11462: 	USES_CONVERSION;
; 11463: 	EnterLog;
; 11464: 	pbContent = (BYTE *)blobPtr->pbData;
; 11465: 	cbContent = blobPtr->cbData;
; 11466: 	*encryptedSize = 0;
; 11467: 	if (RecipientCertificateCount == 0)
; 11468: 	{
; 11469: 		curRecipientCertificateList = (LPSTR *)zMalloc(sizeof(LPSTR *));
; 11470: 		RecipientCertContextArray = (PCCERT_CONTEXT *)zMalloc(sizeof(PCCERT_CONTEXT *));
; 11471: 		if ((RecipientCertContextArray == NULL) || 
; 11472: 			(curRecipientCertificateList == NULL))
; 11473: 		{
; 11474: 			setError(SigHandle, MEMORY_FAULT);
; 11475: 			return NULL;
; 11476: 		}
; 11477: #ifdef WIN32
; 11478: 		if (RecipientCertCount != 0)
; 11479: 			curRecipientCertificateList[0]=	dlgRecipient->selectCertificate();
; 11480: 		else
; 11481: #elif LINUX
; 11482: 		if (RecipientCertCount == 0)
; 11483: #endif
; 11484: 		{
; 11485: 			zFree(curRecipientCertificateList);
; 11486: 			zFree(RecipientCertContextArray);
; 11487: 			setError(SigHandle, NO_CERTIFICATE);
; 11488: 			return NULL;
; 11489: 		}
; 11490: 
; 11491: 		if (curRecipientCertificateList[0] == NULL)
; 11492: 		{
; 11493: 			zFree(curRecipientCertificateList);
; 11494: 			zFree(RecipientCertContextArray);
; 11495: 			setError(SigHandle, NO_CERTIFICATE);
; 11496: 			return NULL;
; 11497: 		}
; 11498: 		curRecipientCertificateCount = 1;
; 11499: 	}
; 11500: 	else
; 11501: 	{
; 11502: 		curRecipientCertificateCount = RecipientCertificateCount;
; 11503: 		curRecipientCertificateList  = RecipientCertificateList;
; 11504: 		RecipientCertContextArray = (PCCERT_CONTEXT *)zMalloc(sizeof(PCCERT_CONTEXT *) * curRecipientCertificateCount);
; 11505: 		if (RecipientCertContextArray == NULL)
; 11506: 		{
; 11507: 			setError(SigHandle, MEMORY_FAULT);
; 11508: 			return NULL;
; 11509: 		}
; 11510: 
; 11511: 	}
; 11512: 
; 11513: 	//--------------------------------------------------------------------
; 11514: 	// Get a handle to a cryptographic provider.
; 11515: 	//--------------------------------------------------------------------
; 11516: 	// Attempt to acquire a context and a key
; 11517: 	// container. The context will use the default CSP
; 11518: 	// for the RSA_FULL provider type. DwFlags is set to 0
; 11519: 	// to attempt to open an existing key container.
; 11520: 
; 11521: 	if(!(CryptAcquireContext(
; 11522: 				&hCryptProv,           // Handle to the CSP
; 11523: 				NULL,                  // Container name 
; 11524: 				MS_ENHANCED_PROV,      // Use the default provider
; 11525: 				PROV_RSA_FULL,         // Provider type
; 11526: 				CRYPT_MACHINE_KEYSET )))				   // Flag values
; 11527: 	{ // Keyset does not exist. lets create one
; 11528: 		if(!(CryptAcquireContext(
; 11529: 				&hCryptProv,         // Address for handle to be returned.
; 11530: 				NULL,                // Use the current user's logon name.
; 11531: 				MS_ENHANCED_PROV,    // Use the default provider.
; 11532: 				PROV_RSA_FULL,       // Need to both encrypt and sign.
; 11533: 				CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET )))   // No flags needed.
; 11534: 		{
; 11535: 			setError(SigHandle, CAPI_ACQUIRE_CNTX);
; 11536: 			return NULL;
; 11537: 		}
; 11538: 	}
; 11539: 
; 11540: 	for (i=0; i<curRecipientCertificateCount; i++)
; 11541: 	{
; 11542: 		certData = (char *)curRecipientCertificateList[i];
; 11543: 		cbCert = base64decodeSize(strlen(certData));
; 11544: 		// allocate memory
; 11545: 		pbCert = NULL;
; 11546: 		if(!(pbCert = (BYTE*)zMalloc(cbCert+1)))
; 11547: 		{
; 11548: 			setError(SigHandle, MEMORY_FAULT);
; 11549: 			if (RecipientCertificateCount == 0)
; 11550: 				zFree(curRecipientCertificateList);
; 11551: 			for (j=0; j<i; i++)
; 11552: 			{
; 11553: 				CertFreeCertificateContext(RecipientCertContextArray[j]);
; 11554: 			}
; 11555: 			zFree(RecipientCertContextArray);
; 11556: 			return NULL;
; 11557: 		}
; 11558: 
; 11559: 		if ((cbCert = base64decode((unsigned char*)certData,
; 11560: 									pbCert,
; 11561: 									cbCert))==-1) 
; 11562: 		{
; 11563: 			setError(SigHandle, MEMORY_FAULT);
; 11564: 			zFree(pbCert);
; 11565: 			if (RecipientCertificateCount == 0)
; 11566: 				zFree(curRecipientCertificateList);
; 11567: 			for (j=0; j<i; i++)
; 11568: 			{
; 11569: 				CertFreeCertificateContext(RecipientCertContextArray[j]);
; 11570: 			}
; 11571: 			zFree(RecipientCertContextArray);
; 11572: 			return NULL;
; 11573: 		}
; 11574: 
; 11575: 		if(!(pCertContext = (CERT_CONTEXT *) CertCreateCertificateContext(
; 11576: 			MY_ENCODING_TYPE  ,            // The encoding type
; 11577: 			pbCert,   // The encoded data from the certificate retrieved
; 11578: 			cbCert)))  // The length of the encoded data
; 11579: 		{
; 11580: 			setError(SigHandle, CAPI_CREATE_CERT_CNTX);
; 11581: 			zFree(pbCert);
; 11582: 			if (RecipientCertificateCount == 0)
; 11583: 				zFree(curRecipientCertificateList);
; 11584: 			for (j=0; j<i; i++)
; 11585: 			{
; 11586: 				CertFreeCertificateContext(RecipientCertContextArray[j]);
; 11587: 			}
; 11588: 			zFree(RecipientCertContextArray);
; 11589: 			return NULL;
; 11590: 		}
; 11591: 		zFree(pbCert);
; 11592: 		
; 11593: 		DWORD pkalgid = CertOIDToAlgId(pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId);
; 11594: 
; 11595: 	// what type of algorithm?
; 11596: 		switch(GET_ALG_TYPE(pkalgid)) 
; 11597: 		{
; 11598: 			case ALG_TYPE_DSS:
; 11599: 				setError(SigHandle, INVALID_ENC_ALG);
; 11600: 				if (RecipientCertificateCount == 0)
; 11601: 					zFree(curRecipientCertificateList);
; 11602: 				for (j=0; j<i; i++)
; 11603: 				{
; 11604: 					CertFreeCertificateContext(RecipientCertContextArray[j]);
; 11605: 				}
; 11606: 				zFree(RecipientCertContextArray);
; 11607: 				return NULL;
; 11608: 				break;
; 11609: 			case ALG_TYPE_RSA:
; 11610: 				break;
; 11611: 			default:
; 11612: 				setError(SigHandle, INVALID_ENC_ALG);
; 11613: 				if (RecipientCertificateCount == 0)
; 11614: 					zFree(curRecipientCertificateList);
; 11615: 				for (j=0; j<i; i++)
; 11616: 				{
; 11617: 					CertFreeCertificateContext(RecipientCertContextArray[j]);
; 11618: 				}
; 11619: 				zFree(RecipientCertContextArray);
; 11620: 				return NULL;
; 11621: 		}
; 11622: 
; 11623: 		//--------------------------------------------------------------------
; 11624: 		// Create a RecipientCertArray.
; 11625: 
; 11626: 		RecipientCertContextArray[i] = pCertContext;
; 11627: 	}
; 11628: 	if (RecipientCertificateCount == 0)
; 11629: 		zFree(curRecipientCertificateList);
; 11630: 
; 11631: 	//--------------------------------------------------------------------
; 11632: 	// Initialize the algorithm identifier structure.
; 11633: 
; 11634: 	EncryptAlgSize = sizeof(EncryptAlgorithm);
; 11635: 
; 11636: 	//--------------------------------------------------------------------
; 11637: 	// Initialize the structure to zero.
; 11638: 
; 11639: 	memset(&EncryptAlgorithm, 0, EncryptAlgSize);
; 11640: 
; 11641: 	//--------------------------------------------------------------------
; 11642: 	// Set the necessary member.
; 11643: 	EncryptAlgorithm.pszObjId = szOID_RSA_RC4;  
; 11644: 
; 11645: 	//--------------------------------------------------------------------
; 11646: 	// Initialize the CRYPT_ENCRYPT_MESSAGE_PARA structure. 
; 11647: 
; 11648: 	EncryptParamsSize = sizeof(EncryptParams);
; 11649: 	memset(&EncryptParams, 0, EncryptParamsSize);
; 11650: 	EncryptParams.cbSize =  EncryptParamsSize;
; 11651: 	EncryptParams.dwMsgEncodingType = MY_ENCODING_TYPE;
; 11652: 	EncryptParams.hCryptProv = hCryptProv;
; 11653: 	EncryptParams.ContentEncryptionAlgorithm = EncryptAlgorithm;
; 11654: 	RC4AuxInfo.cbSize = sizeof(CMSG_RC4_AUX_INFO);
; 11655: 	RC4AuxInfo.dwBitLen = 20;
; 11656: 	EncryptParams.pvEncryptionAuxInfo = &RC4AuxInfo;
; 11657: 
; 11658: 	//--------------------------------------------------------------------
; 11659: 	// Call CryptEncryptMessage.
; 11660: 
; 11661: 	if(!(CryptEncryptMessage(
; 11662: 			&EncryptParams,
; 11663: 			curRecipientCertificateCount,
; 11664: 			RecipientCertContextArray,
; 11665: 			pbContent,
; 11666: 			cbContent,
; 11667: 			NULL,
; 11668: 			&cbEncryptedBlob)))
; 11669: 	{
; 11670: 		setError(SigHandle, CAPI_ENCRYPT_MSG);
; 11671: 		for (i=0; i<curRecipientCertificateCount; i++)
; 11672: 		{
; 11673: 			CertFreeCertificateContext(RecipientCertContextArray[i]);
; 11674: 		}
; 11675: 		zFree(RecipientCertContextArray);
; 11676: 		return NULL;
; 11677: 	}
; 11678: 
; 11679: 	//--------------------------------------------------------------------
; 11680: 	// Allocate memory for the returned BLOB.
; 11681: 
; 11682: 	if(!(pbEncryptedBlob = (BYTE*)zMalloc(cbEncryptedBlob)))
; 11683: 	{
; 11684: 		setError(SigHandle, MEMORY_FAULT);
; 11685: 		for (i=0; i<curRecipientCertificateCount; i++)
; 11686: 		{
; 11687: 			CertFreeCertificateContext(RecipientCertContextArray[i]);
; 11688: 		}
; 11689: 		zFree(RecipientCertContextArray);
; 11690: 		return NULL;
; 11691: 	}
; 11692: 
; 11693: 	//--------------------------------------------------------------------
; 11694: 	// Call CryptEncryptMessage again to encrypt the content.
; 11695: 
; 11696: 	if(!(CryptEncryptMessage(
; 11697: 			&EncryptParams,
; 11698: 			curRecipientCertificateCount,
; 11699: 			RecipientCertContextArray,
; 11700: 			pbContent,
; 11701: 			cbContent,
; 11702: 			pbEncryptedBlob,
; 11703: 			&cbEncryptedBlob)))
; 11704: 	{
; 11705: 		setError(SigHandle, CAPI_ENCRYPT_MSG);
; 11706: 		for (i=0; i<curRecipientCertificateCount; i++)
; 11707: 		{
; 11708: 			CertFreeCertificateContext(RecipientCertContextArray[i]);
; 11709: 		}
; 11710: 		zFree(RecipientCertContextArray);
; 11711: 		zFree(pbEncryptedBlob);
; 11712: 		return NULL;
; 11713: 	}
; 11714: 	for (i=0; i<curRecipientCertificateCount; i++)
; 11715: 	{
; 11716: 		CertFreeCertificateContext(RecipientCertContextArray[i]);
; 11717: 	}
; 11718: 	zFree(RecipientCertContextArray);
; 11719: 
; 11720: 	UINT encodedSize;
; 11721: 	unsigned char *encodedEncryptedData;
; 11722: 
; 11723: 	// Base64 encode
; 11724: 	encodedSize = base64encodeSize(cbEncryptedBlob);
; 11725: 	if(!(encodedEncryptedData = (unsigned char*)zMalloc(encodedSize+1)))
; 11726: 	{
; 11727: 		setError(SigHandle, MEMORY_FAULT);
; 11728: 		zFree(pbEncryptedBlob);
; 11729: 		return NULL;
; 11730: 	}
; 11731: 	if ((encodedSize = base64encode(	(unsigned char *)pbEncryptedBlob,
; 11732: 						cbEncryptedBlob,
; 11733: 						(unsigned char*)encodedEncryptedData,
; 11734: 						encodedSize))==-1) 
; 11735: 	{
; 11736: 		setError(SigHandle, MEMORY_FAULT);
; 11737: 		zFree(encodedEncryptedData);
; 11738: 		zFree(pbEncryptedBlob);
; 11739: 		return NULL;
; 11740: 	}
; 11741: 	*(encodedEncryptedData+encodedSize)='\0';
; 11742: 	zFree(pbEncryptedBlob);
; 11743: 	*encryptedSize = encodedSize + 1;
; 11744: 	ExitLog;
; 11745: 	return encodedEncryptedData;
; 11746: #endif
; 11747: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221991
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L221991:
	DD	2
	DD	$L221990
$L221990:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$L221988
	DD	-80					; ffffffb0H
	DD	4
	DD	$L221989
$L221989:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	102					; 00000066H
	DB	0
$L221988:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
?EncryptBlob@CSignature@@QAEPAEPAU_DS_DATA_BLOB@@PAK@Z ENDP ; CSignature::EncryptBlob
; Function compile flags: /Odt /RTCsu
_out$ = -4						; size = 4
_arg$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
?EncryptOut@@YAXPAXPBDK@Z PROC NEAR			; EncryptOut

; 11198: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 11199:    FILE *out;
; 11200:    out = (FILE *)arg; 

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 11201:    fwrite (buf, len, 1, out);

	mov	ecx, DWORD PTR _out$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _len$[ebp]
	push	edx
	mov	eax, DWORD PTR _buf$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H

; 11202: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?EncryptOut@@YAXPAXPBDK@Z ENDP				; EncryptOut
_TEXT	ENDS
EXTRN	_PORT_Alloc:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pass$211839 = -12					; size = 4
_pg_sig$ = -8						; size = 4
_pw$ = -4						; size = 4
_arg$ = 8						; size = 4
_handle$ = 12						; size = 4
?password_hardcode@@YAPAUSECItemStr@@PAX0@Z PROC NEAR	; password_hardcode

; 11206: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 11207:   SECItem *pw = NULL;

	mov	DWORD PTR _pw$[ebp], 0

; 11208:   PGLOBAL_SIG pg_sig = (PGLOBAL_SIG) arg;

	mov	eax, DWORD PTR _arg$[ebp]
	mov	DWORD PTR _pg_sig$[ebp], eax

; 11209:   if (pg_sig->certStorePassword) {

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	cmp	DWORD PTR [ecx+48], 0
	je	SHORT $L211836

; 11210: 	pw = (SECItem *) zMalloc(sizeof(SECItem));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pw$[ebp], eax

; 11211: 	char *pass = (char *) PORT_Alloc( (strlen((char *) pg_sig->certStorePassword))*2 + 1);

	mov	edx, DWORD PTR _pg_sig$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR [eax+eax+1]
	push	ecx
	call	_PORT_Alloc
	add	esp, 4
	mov	DWORD PTR _pass$211839[ebp], eax

; 11212: 	strcpy(pass,(const char *) pg_sig->certStorePassword);

	mov	edx, DWORD PTR _pg_sig$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	mov	ecx, DWORD PTR _pass$211839[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 11213: 	pw->data = (BYTE*) pass;

	mov	edx, DWORD PTR _pw$[ebp]
	mov	eax, DWORD PTR _pass$211839[ebp]
	mov	DWORD PTR [edx+4], eax

; 11214: 	pw->len = strlen(pass); //--!! do we need +1 here???

	mov	ecx, DWORD PTR _pass$211839[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _pw$[ebp]
	mov	DWORD PTR [edx+8], eax
$L211836:

; 11215:   }
; 11216:   return pw;

	mov	eax, DWORD PTR _pw$[ebp]

; 11217: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?password_hardcode@@YAPAUSECItemStr@@PAX0@Z ENDP	; password_hardcode
_TEXT	ENDS
PUBLIC	?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_TrustedRoots
EXTRN	_strchr:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$211966 = -80						; size = 4
__lpa$ = -76						; size = 4
__lpw$ = -72						; size = 4
__acp$ = -68						; size = 4
__convert$ = -64					; size = 4
_encodedDataPtr$ = -60					; size = 4
_encodedDataSize$ = -56					; size = 4
_rootCertData$ = -52					; size = 4
_dataPtr$ = -44						; size = 4
_dataSize$ = -32					; size = 4
_bstrList$ = -24					; size = 4
_i$ = -20						; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_TrustedRoots

; 11750: {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11751: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 11752: 	UINT itemCount=0,i;

	mov	DWORD PTR _itemCount$[ebp], 0

; 11753: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 11754: 	DWORD dataSize;
; 11755: 	BYTE *dataPtr, *rootCertData;
; 11756: 	DWORD encodedDataSize;
; 11757: 	BYTE *encodedDataPtr;
; 11758: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 11759: 	EnterLog;
; 11760: 	if ((newVal.vt != VT_BSTR) &&
; 11761: 		(newVal.vt != VT_DISPATCH) &&
; 11762: 		!(newVal.vt & VT_ARRAY) && 
; 11763: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L211963
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L211963
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L211963
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L211963

; 11764: 	{
; 11765: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11766: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211949
$L211963:

; 11767: 	}
; 11768: 	if (CertVerifyParams.trustRootCertCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1864], 0
	je	SHORT $L211965

; 11769: 	{
; 11770: 		for (unsigned int i=0; i < CertVerifyParams.trustRootCertCount; i++)

	mov	DWORD PTR _i$211966[ebp], 0
	jmp	SHORT $L211967
$L211968:
	mov	ecx, DWORD PTR _i$211966[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$211966[ebp], ecx
$L211967:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$211966[ebp]
	cmp	eax, DWORD PTR [edx+1864]
	jae	SHORT $L211969

; 11771: 			zFree(CertVerifyParams.trustRootCerts[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1860]
	mov	eax, DWORD PTR _i$211966[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L211968
$L211969:

; 11772: 		zFree(CertVerifyParams.trustRootCerts);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	push	eax
	call	_rFree
	add	esp, 4

; 11773: 		CertVerifyParams.trustRootCertCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], 0
$L211965:

; 11774: 	}
; 11775: 
; 11776: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	edx, DWORD PTR _itemCount$[ebp]
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 11777: 
; 11778: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L211971
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L211970
$L211971:

; 11779: 	{
; 11780: 		CertVerifyParams.trustRootCerts = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1860], 0

; 11781: 		CertVerifyParams.trustRootCertCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1864], 0

; 11782: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11783: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211949
$L211970:

; 11784: 	}
; 11785: 
; 11786: 	CertVerifyParams.trustRootCertCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+1864], edx

; 11787: 	CertVerifyParams.trustRootCerts = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1860], eax

; 11788: 	if (CertVerifyParams.trustRootCerts == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1860], 0
	jne	SHORT $L211975

; 11789: 	{
; 11790: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11791: 		CertVerifyParams.trustRootCertCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1864], 0

; 11792: 		for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211976
$L211977:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L211976:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211978

; 11793: 			if (bstrList[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L211979

; 11794: 				SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L211979:

; 11795: 		zFree(bstrList);

	jmp	SHORT $L211977
$L211978:
	mov	ecx, DWORD PTR _bstrList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11796: 		return S_FALSE;

	mov	eax, 1
	jmp	$L211949
$L211975:

; 11797: 	}
; 11798: 	memset(CertVerifyParams.trustRootCerts, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 11799: 
; 11800: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L211982
$L211983:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L211982:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	$L211984

; 11801: 	{
; 11802: 		//char *aBstrList = (char *)HeapW2A(bstrList[elementCount]);
; 11803: 		//dataPtr = xsDereferenceURI(aBstrList, &dataSize);
; 11804: 		//zFree(aBstrList);
; 11805: 		if (ReadAllBin(bstrList[elementCount], &dataPtr, &dataSize) != S_FALSE)

	lea	ecx, DWORD PTR _dataSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	je	$L211986

; 11806: 		{
; 11807: 			rootCertData = (BYTE *)zMalloc(dataSize + 1);

	mov	eax, DWORD PTR _dataSize$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _rootCertData$[ebp], eax

; 11808: 			if (rootCertData == NULL)

	cmp	DWORD PTR _rootCertData$[ebp], 0
	jne	$L211988

; 11809: 			{
; 11810: 				setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11811: 				for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211989
$L211990:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L211989:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L211991

; 11812: 					if (bstrList[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L211992

; 11813: 						SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L211992:

; 11814: 				zFree(bstrList);

	jmp	SHORT $L211990
$L211991:
	mov	ecx, DWORD PTR _bstrList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11815: 				zFree(dataPtr);

	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11816: 				for (i=0; i < elementCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211993
$L211994:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L211993:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _elementCount$[ebp]
	jae	SHORT $L211995

; 11817: 				{
; 11818: 					if (CertVerifyParams.trustRootCerts[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L211996

; 11819: 					{
; 11820: 						zFree(CertVerifyParams.trustRootCerts[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 11821: 						CertVerifyParams.trustRootCerts[i] = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L211996:

; 11822: 					}
; 11823: 				}

	jmp	SHORT $L211994
$L211995:

; 11824: 				zFree(CertVerifyParams.trustRootCerts);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1860]
	push	ecx
	call	_rFree
	add	esp, 4

; 11825: 				CertVerifyParams.trustRootCerts = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1860], 0

; 11826: 				CertVerifyParams.trustRootCertCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1864], 0

; 11827: 				return S_FALSE;

	mov	eax, 1
	jmp	$L211949
$L211988:

; 11828: 			}
; 11829: 			memcpy(rootCertData, dataPtr, dataSize);

	mov	ecx, DWORD PTR _dataSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootCertData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 11830: 			*(rootCertData + dataSize) = '\0';

	mov	ecx, DWORD PTR _rootCertData$[ebp]
	add	ecx, DWORD PTR _dataSize$[ebp]
	mov	BYTE PTR [ecx], 0

; 11831: 			for (i=0; i < dataSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L211998
$L211999:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L211998:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _dataSize$[ebp]
	jae	$L212000

; 11832: 			{
; 11833: 				if (strchr((const char *)Base64Chars, *(rootCertData + i)) == NULL)

	mov	ecx, DWORD PTR _rootCertData$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	push	OFFSET FLAT:?Base64Chars@@3PAEA		; Base64Chars
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L212002

; 11834: 				{
; 11835: 					if ((*(rootCertData + i) == 0x0d) ||
; 11836: 						(*(rootCertData + i) == 0x0a) ||
; 11837: 						(*(rootCertData + i) == 0x20))

	mov	eax, DWORD PTR _rootCertData$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $L212004
	mov	edx, DWORD PTR _rootCertData$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $L212004
	mov	ecx, DWORD PTR _rootCertData$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $L212003
$L212004:

; 11838: 						continue;

	jmp	SHORT $L211999
$L212003:

; 11839: 					// The data is not base64 encoded, so lets encode it now
; 11840: 					encodedDataSize = base64encodeSize(dataSize);

	mov	eax, DWORD PTR _dataSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 11841: 					encodedDataPtr = (BYTE *)zMalloc(encodedDataSize + 1);

	mov	ecx, DWORD PTR _encodedDataSize$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _encodedDataPtr$[ebp], eax

; 11842: 					encodedDataSize = base64encode(rootCertData, dataSize, encodedDataPtr, encodedDataSize + 1);

	mov	edx, DWORD PTR _encodedDataSize$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _encodedDataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootCertData$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 11843: 					zFree(rootCertData);

	mov	eax, DWORD PTR _rootCertData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11844: 					rootCertData = encodedDataPtr;

	mov	ecx, DWORD PTR _encodedDataPtr$[ebp]
	mov	DWORD PTR _rootCertData$[ebp], ecx

; 11845: 					break;

	jmp	SHORT $L212000
$L212002:

; 11846: 				}
; 11847: 			}

	jmp	$L211999
$L212000:

; 11848: 			CertVerifyParams.trustRootCerts[elementCount] = (LPSTR)rootCertData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _rootCertData$[ebp]
	mov	DWORD PTR [eax+ecx*4], edx

; 11849: 			zFree(dataPtr);

	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11850: 		}
; 11851: 		else

	jmp	$L212007
$L211986:

; 11852: 		{
; 11853: 			setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11854: 			for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212008
$L212009:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L212008:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212010

; 11855: 				if (bstrList[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L212011

; 11856: 					SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212011:

; 11857: 			zFree(bstrList);

	jmp	SHORT $L212009
$L212010:
	mov	ecx, DWORD PTR _bstrList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11858: 			for (i=0; i < elementCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212012
$L212013:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L212012:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _elementCount$[ebp]
	jae	SHORT $L212014

; 11859: 			{
; 11860: 				if (CertVerifyParams.trustRootCerts[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1860]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L212015

; 11861: 				{
; 11862: 					zFree(CertVerifyParams.trustRootCerts[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1860]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 11863: 					CertVerifyParams.trustRootCerts[i] = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L212015:

; 11864: 				}
; 11865: 			}

	jmp	SHORT $L212013
$L212014:

; 11866: 			zFree(CertVerifyParams.trustRootCerts);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1860]
	push	eax
	call	_rFree
	add	esp, 4

; 11867: 			CertVerifyParams.trustRootCerts = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1860], 0

; 11868: 			CertVerifyParams.trustRootCertCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1864], 0

; 11869: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L211949
$L212007:

; 11870: 		}
; 11871: 	}

	jmp	$L211983
$L211984:

; 11872: 	for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212017
$L212018:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L212017:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212019

; 11873: 		if (bstrList[i] != NULL)

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L212020

; 11874: 			SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212020:

; 11875: 	zFree(bstrList);

	jmp	SHORT $L212018
$L212019:
	mov	ecx, DWORD PTR _bstrList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11876: 	ExitLog;
; 11877: 	return S_OK;

	xor	eax, eax
$L211949:

; 11878: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L221999
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L221999:
	DD	3
	DD	$L221998
$L221998:
	DD	-12					; fffffff4H
	DD	4
	DD	$L221995
	DD	-32					; ffffffe0H
	DD	4
	DD	$L221996
	DD	-44					; ffffffd4H
	DD	4
	DD	$L221997
$L221997:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L221996:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L221995:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z ENDP	; CSignature::put_TrustedRoots
_TEXT	ENDS
PUBLIC	?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_RecipientCertificateFiles
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$212042 = -80						; size = 4
__lpa$ = -76						; size = 4
__lpw$ = -72						; size = 4
__acp$ = -68						; size = 4
__convert$ = -64					; size = 4
_encodedDataPtr$ = -60					; size = 4
_encodedDataSize$ = -56					; size = 4
_recpCertData$ = -52					; size = 4
_dataPtr$ = -44						; size = 4
_dataSize$ = -32					; size = 4
_bstrList$ = -24					; size = 4
_itemCount$ = -16					; size = 4
_i$ = -8						; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_RecipientCertificateFiles

; 11881: {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 11882: 	UINT elementCount=0,i;

	mov	DWORD PTR _elementCount$[ebp], 0

; 11883: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 11884: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 11885: 	DWORD dataSize;
; 11886: 	BYTE *dataPtr, *recpCertData;
; 11887: 	DWORD encodedDataSize;
; 11888: 	BYTE *encodedDataPtr;
; 11889: 
; 11890: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 11891: 	EnterLog;
; 11892: 	if ((newVal.vt != VT_BSTR) &&
; 11893: 		(newVal.vt != VT_DISPATCH) &&
; 11894: 		!(newVal.vt & VT_ARRAY) && 
; 11895: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L212039
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L212039
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L212039
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L212039

; 11896: 	{
; 11897: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11898: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212025
$L212039:

; 11899: 	}
; 11900: 	if (RecipientCertificateCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L212041

; 11901: 	{
; 11902: 		for (unsigned int i=0; i < RecipientCertificateCount; i++)

	mov	DWORD PTR _i$212042[ebp], 0
	jmp	SHORT $L212043
$L212044:
	mov	ecx, DWORD PTR _i$212042[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$212042[ebp], ecx
$L212043:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$212042[ebp]
	cmp	eax, DWORD PTR [edx+48]
	jae	SHORT $L212045

; 11903: 			zFree(RecipientCertificateList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _i$212042[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L212044
$L212045:

; 11904: 		zFree(RecipientCertificateList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_rFree
	add	esp, 4

; 11905: 		RecipientCertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 11906: 		RecipientCertificateList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$L212041:

; 11907: 	}
; 11908: 
; 11909: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	eax, DWORD PTR _itemCount$[ebp]
	push	eax
	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	edx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 11910: 
; 11911: 
; 11912: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L212047
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L212046
$L212047:

; 11913: 	{
; 11914: 		RecipientCertificateList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 11915: 		RecipientCertificateCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+48], 0

; 11916: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 11917: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212025
$L212046:

; 11918: 	}
; 11919: 
; 11920: 	RecipientCertificateCount = itemCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [edx+48], eax

; 11921: 	RecipientCertificateList = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	ecx, DWORD PTR _itemCount$[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], eax

; 11922: 	if (RecipientCertificateList == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $L212051

; 11923: 	{
; 11924: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 11925: 		RecipientCertificateCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 11926: 		for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212052
$L212053:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L212052:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212054

; 11927: 			if (bstrList[i] != NULL)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L212055

; 11928: 				SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212055:

; 11929: 		zFree(bstrList);

	jmp	SHORT $L212053
$L212054:
	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11930: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212025
$L212051:

; 11931: 	}
; 11932: 	memset(RecipientCertificateList, 0, sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 11933: 
; 11934: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L212058
$L212059:
	mov	eax, DWORD PTR _elementCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _elementCount$[ebp], eax
$L212058:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	cmp	ecx, DWORD PTR _itemCount$[ebp]
	jae	$L212060

; 11935: 	{
; 11936: 		//char *aBstrList = (char *)HeapW2A(bstrList[elementCount]);
; 11937: 		//dataPtr = xsDereferenceURI(aBstrList, &dataSize);
; 11938: 		//zFree(aBstrList);
; 11939: 		if (ReadAllBin(bstrList[elementCount], &dataPtr, &dataSize) != S_FALSE)

	lea	edx, DWORD PTR _dataSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	je	$L212062

; 11940: 		{
; 11941: 			recpCertData = (BYTE *)zMalloc(dataSize + 1);

	mov	ecx, DWORD PTR _dataSize$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _recpCertData$[ebp], eax

; 11942: 			if (recpCertData == NULL)

	cmp	DWORD PTR _recpCertData$[ebp], 0
	jne	$L212064

; 11943: 			{
; 11944: 				setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11945: 				for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212065
$L212066:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L212065:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212067

; 11946: 					if (bstrList[i] != NULL)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L212068

; 11947: 						SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212068:

; 11948: 				zFree(bstrList);

	jmp	SHORT $L212066
$L212067:
	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11949: 				zFree(dataPtr);

	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 11950: 				for (i=0; i < elementCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212069
$L212070:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L212069:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _elementCount$[ebp]
	jae	SHORT $L212071

; 11951: 				{
; 11952: 					if (RecipientCertificateList[i] != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L212072

; 11953: 					{
; 11954: 						zFree(RecipientCertificateList[i]);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 11955: 						RecipientCertificateList[i] = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], 0
$L212072:

; 11956: 					}
; 11957: 				}

	jmp	SHORT $L212070
$L212071:

; 11958: 				zFree(RecipientCertificateList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_rFree
	add	esp, 4

; 11959: 				RecipientCertificateList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 11960: 				RecipientCertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 11961: 				return S_FALSE;

	mov	eax, 1
	jmp	$L212025
$L212064:

; 11962: 			}
; 11963: 			memcpy(recpCertData, dataPtr, dataSize);

	mov	edx, DWORD PTR _dataSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _recpCertData$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 11964: 			*(recpCertData + dataSize) = '\0';

	mov	edx, DWORD PTR _recpCertData$[ebp]
	add	edx, DWORD PTR _dataSize$[ebp]
	mov	BYTE PTR [edx], 0

; 11965: 			for (i=0; i < dataSize; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212074
$L212075:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L212074:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _dataSize$[ebp]
	jae	$L212076

; 11966: 			{
; 11967: 				if (strchr((const char *)Base64Chars, *(recpCertData + i)) == NULL)

	mov	edx, DWORD PTR _recpCertData$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	push	OFFSET FLAT:?Base64Chars@@3PAEA		; Base64Chars
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L212078

; 11968: 				{
; 11969: 					if ((*(recpCertData + i) == 0x0d) ||
; 11970: 						(*(recpCertData + i) == 0x0a) ||
; 11971: 						(*(recpCertData + i) == 0x20))

	mov	ecx, DWORD PTR _recpCertData$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $L212080
	mov	eax, DWORD PTR _recpCertData$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $L212080
	mov	edx, DWORD PTR _recpCertData$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $L212079
$L212080:

; 11972: 						continue;

	jmp	SHORT $L212075
$L212079:

; 11973: 					// The data is not base64 encoded, so lets encode it now
; 11974: 					encodedDataSize = base64encodeSize(dataSize);

	mov	ecx, DWORD PTR _dataSize$[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 11975: 					encodedDataPtr = (BYTE *)zMalloc(encodedDataSize + 1);

	mov	edx, DWORD PTR _encodedDataSize$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _encodedDataPtr$[ebp], eax

; 11976: 					encodedDataSize = base64encode(recpCertData, dataSize, encodedDataPtr, encodedDataSize + 1);

	mov	eax, DWORD PTR _encodedDataSize$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _encodedDataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _recpCertData$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 11977: 					zFree(recpCertData);

	mov	ecx, DWORD PTR _recpCertData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11978: 					recpCertData = encodedDataPtr;

	mov	edx, DWORD PTR _encodedDataPtr$[ebp]
	mov	DWORD PTR _recpCertData$[ebp], edx

; 11979: 					break;

	jmp	SHORT $L212076
$L212078:

; 11980: 				}
; 11981: 			}

	jmp	$L212075
$L212076:

; 11982: 			RecipientCertificateList[elementCount] = (LPSTR)recpCertData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _recpCertData$[ebp]
	mov	DWORD PTR [ecx+edx*4], eax

; 11983: 			zFree(dataPtr);

	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 11984: 		}
; 11985: 		else

	jmp	$L212083
$L212062:

; 11986: 		{
; 11987: 			setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 11988: 			for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212084
$L212085:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L212084:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212086

; 11989: 				if (bstrList[i] != NULL)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L212087

; 11990: 					SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212087:

; 11991: 			zFree(bstrList);

	jmp	SHORT $L212085
$L212086:
	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 11992: 			for (i=0; i < elementCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212088
$L212089:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L212088:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _elementCount$[ebp]
	jae	SHORT $L212090

; 11993: 			{
; 11994: 				if (RecipientCertificateList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L212091

; 11995: 				{
; 11996: 					zFree(RecipientCertificateList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 11997: 					RecipientCertificateList[i] = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L212091:

; 11998: 				}
; 11999: 			}

	jmp	SHORT $L212089
$L212090:

; 12000: 			zFree(RecipientCertificateList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_rFree
	add	esp, 4

; 12001: 			RecipientCertificateList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 12002: 			RecipientCertificateCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 12003: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L212025
$L212083:

; 12004: 		}
; 12005: 	}

	jmp	$L212059
$L212060:

; 12006: 	for (i =0; i < itemCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L212093
$L212094:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L212093:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212095

; 12007: 		if (bstrList[i] != NULL)

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L212096

; 12008: 			SysFreeString(bstrList[i]);

	mov	esi, esp
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212096:

; 12009: 	zFree(bstrList);

	jmp	SHORT $L212094
$L212095:
	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12010: 	ExitLog;
; 12011: 	return S_OK;

	xor	eax, eax
$L212025:

; 12012: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222005
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222005:
	DD	3
	DD	$L222004
$L222004:
	DD	-16					; fffffff0H
	DD	4
	DD	$L222001
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222002
	DD	-44					; ffffffd4H
	DD	4
	DD	$L222003
$L222003:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222002:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222001:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_RecipientCertificateFiles
_TEXT	ENDS
EXTRN	_crIsPFX:NEAR
EXTRN	_cleanupError:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
$T222007 = -109						; size = 1
_i$212152 = -108					; size = 4
_cdes$212139 = -100					; size = 4
_X509Cert$212133 = -92					; size = 4
_PfxCertDataBlob$212132 = -84				; size = 8
_spwd$ = -68						; size = 12
_i$212117 = -52						; size = 4
_s$ = -44						; size = 12
_pwd$ = -28						; size = 4
_result$ = -24						; size = 4
_certificateCount$ = -16				; size = 4
_certificateList$ = -8					; size = 4
_this$ = -4						; size = 4
_certData$ = 8						; size = 4
_pSysTime$ = 12						; size = 4
_password$ = 16						; size = 4
_certVerParams$ = 20					; size = 4
_pg_sig$ = 24						; size = 4
?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CSignature::CheckCertificateValidity
; _this$ = ecx

; 12015: {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	BYTE PTR $T222007[ebp], 0

; 12016: 	BYTE **certificateList;
; 12017: 	UINT certificateCount;
; 12018: 	BOOL result;
; 12019: 	EnterLog;
; 12020: 
; 12021: 	LPWSTR pwd = NULL;

	mov	DWORD PTR _pwd$[ebp], 0

; 12022: 	if (password) {

	cmp	DWORD PTR _password$[ebp], 0
	je	SHORT $L212110

; 12023: 		pwd = (LPWSTR) password->pbData;

	mov	eax, DWORD PTR _password$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pwd$[ebp], ecx
$L212110:

; 12024: 	}
; 12025: #ifdef NSS
; 12026: 	// password is big endian, swap bytes
; 12027: 	SECItem s;
; 12028: 	s.len=0;

	mov	DWORD PTR _s$[ebp+8], 0

; 12029: 	if (password) {

	cmp	DWORD PTR _password$[ebp], 0
	je	SHORT $L212113

; 12030: 		s.data = (BYTE *) zMalloc(password->cbData);

	mov	edx, DWORD PTR _password$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T222007[ebp], 1
	mov	DWORD PTR _s$[ebp+4], eax

; 12031: 		s.len  = password->cbData;

	mov	ecx, DWORD PTR _password$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _s$[ebp+8], edx

; 12032: 		memcpy(s.data,password->pbData,s.len);

	cmp	BYTE PTR $T222007[ebp], 0
	jne	SHORT $L222008
	push	OFFSET FLAT:$L222009
	call	__RTC_UninitUse
	add	esp, 4
$L222008:
	mov	eax, DWORD PTR _s$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _password$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _s$[ebp+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 12033: 		SwapUnicodeBytes(&s);

	mov	BYTE PTR $T222007[ebp], 1
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	?SwapUnicodeBytes@CSignature@@SAHPAUSECItemStr@@@Z ; CSignature::SwapUnicodeBytes
	add	esp, 4

; 12034: 		pwd = (LPWSTR) s.data;

	cmp	BYTE PTR $T222007[ebp], 0
	jne	SHORT $L222010
	push	OFFSET FLAT:$L222009
	call	__RTC_UninitUse
	add	esp, 4
$L222010:
	mov	edx, DWORD PTR _s$[ebp+4]
	mov	DWORD PTR _pwd$[ebp], edx
$L212113:

; 12035: 	}
; 12036: #endif
; 12037: 
; 12038: 	if ((CertVerifyParams.usedCrlCount != 0) &&
; 12039: 		(CertVerifyParams.usedCrlList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1888], 0
	je	$L212116
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1892], 0
	je	SHORT $L212116

; 12040: 	{
; 12041: 		for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$212117[ebp], 0
	jmp	SHORT $L212118
$L212119:
	mov	edx, DWORD PTR _i$212117[ebp]
	add	edx, 1
	mov	DWORD PTR _i$212117[ebp], edx
$L212118:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$212117[ebp]
	cmp	ecx, DWORD PTR [eax+1888]
	jae	SHORT $L212120

; 12042: 		{
; 12043: 			if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$212117[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L212121

; 12044: 				zFree(CertVerifyParams.usedCrlList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$212117[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L212121:

; 12045: 		}

	jmp	SHORT $L212119
$L212120:

; 12046: 		zFree(CertVerifyParams.usedCrlList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	push	ecx
	call	_rFree
	add	esp, 4

; 12047: 		CertVerifyParams.usedCrlList = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1892], 0

; 12048: 		CertVerifyParams.usedCrlCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1888], 0
$L212116:

; 12049: 	}
; 12050: #ifdef NSS
; 12051: 	SECItem spwd;
; 12052: 	if (password && password->cbData) {

	cmp	DWORD PTR _password$[ebp], 0
	je	SHORT $L212123
	mov	ecx, DWORD PTR _password$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L212123

; 12053: 		spwd.len = password->cbData;

	mov	edx, DWORD PTR _password$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _spwd$[ebp+8], eax

; 12054: 		spwd.data = password->pbData;

	mov	ecx, DWORD PTR _password$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _spwd$[ebp+4], edx

; 12055: 	}else{

	jmp	SHORT $L212124
$L212123:

; 12056: 		spwd.data = (BYTE *) zMalloc(sizeof(char));

	push	1
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _spwd$[ebp+4], eax

; 12057: 		spwd.data[0] = '\0';

	mov	eax, DWORD PTR _spwd$[ebp+4]
	mov	BYTE PTR [eax], 0

; 12058: 		spwd.len = 1;

	mov	DWORD PTR _spwd$[ebp+8], 1
$L212124:

; 12059: 	}
; 12060: 	certificateList = crGetSignerCertChain(	certData,
; 12061: 											&spwd,
; 12062: 											&certificateCount,
; 12063: 											pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	lea	edx, DWORD PTR _certificateCount$[ebp]
	push	edx
	lea	eax, DWORD PTR _spwd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_crGetSignerCertChain
	add	esp, 16					; 00000010H
	mov	DWORD PTR _certificateList$[ebp], eax

; 12064: #else
; 12065: 	certificateList = crGetSignerCertChain(	certData,
; 12066: 											pwd,
; 12067: 											&certificateCount,
; 12068: 											pg_sig);
; 12069: #endif
; 12070: 	if (certificateList == NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	jne	$L212127

; 12071: 	{
; 12072: 		// use just this certificate
; 12073: 		if (useCam) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	$L212128

; 12074: 			cleanupError(pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 12075: 			// if this is PFX, convert it to X509
; 12076: 			certificateList = (BYTE **) zMalloc(sizeof(BYTE *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certificateList$[ebp], eax

; 12077: 			if (crIsPFX(certData,password,pg_sig)) {

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _password$[ebp]
	push	edx
	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	call	_crIsPFX
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$L212131

; 12078: 				DS_DATA_BLOB PfxCertDataBlob;
; 12079: 				BYTE *X509Cert=NULL;

	mov	DWORD PTR _X509Cert$212133[ebp], 0

; 12080: 				PfxCertDataBlob.cbData = base64decodeSize((DWORD)strlen((const char *)certData));

	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _PfxCertDataBlob$212132[ebp+4], eax

; 12081: 				PfxCertDataBlob.pbData = (BYTE *)zMalloc (PfxCertDataBlob.cbData+1);

	mov	edx, DWORD PTR _PfxCertDataBlob$212132[ebp+4]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _PfxCertDataBlob$212132[ebp], eax

; 12082: 				memset(PfxCertDataBlob.pbData,0,PfxCertDataBlob.cbData+1);

	mov	eax, DWORD PTR _PfxCertDataBlob$212132[ebp+4]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _PfxCertDataBlob$212132[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 12083: 				PfxCertDataBlob.cbData = base64decode(certData,(unsigned char *)PfxCertDataBlob.pbData,PfxCertDataBlob.cbData); 

	mov	edx, DWORD PTR _PfxCertDataBlob$212132[ebp+4]
	push	edx
	mov	eax, DWORD PTR _PfxCertDataBlob$212132[ebp]
	push	eax
	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _PfxCertDataBlob$212132[ebp+4], eax

; 12084: 				if (PfxCertDataBlob.cbData==-1) {

	cmp	DWORD PTR _PfxCertDataBlob$212132[ebp+4], -1
	jne	SHORT $L212138

; 12085: 					zFree(PfxCertDataBlob.pbData);

	mov	edx, DWORD PTR _PfxCertDataBlob$212132[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12086: 					setError(pg_sig, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 12087: 					zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12088: 					return FALSE;

	xor	eax, eax
	jmp	$L212105
$L212138:

; 12089: 				}				
; 12090: 				PCERT_DESCR cdes[1];
; 12091: 				cdes[0]= NULL;

	mov	DWORD PTR _cdes$212139[ebp], 0

; 12092: #ifdef NSS				
; 12093: 				X509Cert	= crPFX2X509(&PfxCertDataBlob, &spwd, cdes, pg_sig);

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	lea	eax, DWORD PTR _cdes$212139[ebp]
	push	eax
	lea	ecx, DWORD PTR _spwd$[ebp]
	push	ecx
	lea	edx, DWORD PTR _PfxCertDataBlob$212132[ebp]
	push	edx
	call	_crPFX2X509
	add	esp, 16					; 00000010H
	mov	DWORD PTR _X509Cert$212133[ebp], eax

; 12094: #else
; 12095: 				X509Cert	= crPFX2X509(&PfxCertDataBlob, (LPCWSTR) pwd, cdes, pg_sig);
; 12096: #endif
; 12097: 				if (cdes[0] && cdes[0]->certificate) {

	cmp	DWORD PTR _cdes$212139[ebp], 0
	je	SHORT $L212140
	mov	eax, DWORD PTR _cdes$212139[ebp]
	cmp	DWORD PTR [eax+2048], 0
	je	SHORT $L212140

; 12098: 					zFree(cdes[0]->certificate);

	mov	ecx, DWORD PTR _cdes$212139[ebp]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	_rFree
	add	esp, 4
$L212140:

; 12099: 				}
; 12100: 				zFree(PfxCertDataBlob.pbData);

	mov	eax, DWORD PTR _PfxCertDataBlob$212132[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 12101: 				if (!X509Cert) {

	cmp	DWORD PTR _X509Cert$212133[ebp], 0
	jne	SHORT $L212141

; 12102: 					zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12103: 					return FALSE;

	xor	eax, eax
	jmp	$L212105
$L212141:

; 12104: 				}
; 12105: 				certificateList[0] = X509Cert;

	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR _X509Cert$212133[ebp]
	mov	DWORD PTR [edx], eax

; 12106: 				certificateCount=1;

	mov	DWORD PTR _certificateCount$[ebp], 1

; 12107: 			}else{

	jmp	SHORT $L212142
$L212131:

; 12108: 				certificateList[0] = (BYTE *) zMalloc(strlen((const char *)certData) +1);

	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	DWORD PTR [edx], eax

; 12109: 				strcpy((char *)certificateList[0],(const char *)certData);

	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 12110: 				certificateCount=1;

	mov	DWORD PTR _certificateCount$[ebp], 1
$L212142:

; 12111: 			}
; 12112: 		}else{

	jmp	SHORT $L212127
$L212128:

; 12113: 			return FALSE;

	xor	eax, eax
	jmp	$L212105
$L212127:

; 12114: 		}
; 12115: 	}
; 12116: 	if (useCam)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1908], 0
	je	SHORT $L212148

; 12117: 	{
; 12118: 		result = crVerifyCertificateUsingCam(certificateList,
; 12119: 								certificateCount,
; 12120: 								pSysTime, 
; 12121: 								pwd,
; 12122: 								&CertVerifyParams,
; 12123: 								pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _pwd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSysTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 12124: 	}
; 12125: 	else

	jmp	SHORT $L212149
$L212148:

; 12126: 	{
; 12127: 		if ((useOcsp) && (pOcspClient != NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1912], 0
	je	SHORT $L212150
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1916], 0
	je	SHORT $L212150

; 12128: 		{
; 12129: 			result = crVerifyCertificateUsingOcsp(certificateList,
; 12130: 								certificateCount,
; 12131: 								pSysTime, 
; 12132: 								pwd,
; 12133: 								&CertVerifyParams,
; 12134: 								pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	mov	edx, DWORD PTR _pwd$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 12135: 		}
; 12136: 		else

	jmp	SHORT $L212149
$L212150:

; 12137: #ifdef NSS
; 12138: 			result = crVerifyCertificate(certificateList,
; 12139: 									certificateCount,
; 12140: 									pSysTime, 
; 12141: 									&spwd,
; 12142: 									&CertVerifyParams,
; 12143: 									pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1828				; 00000724H
	push	ecx
	lea	edx, DWORD PTR _spwd$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSysTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L212149:

; 12144: #else
; 12145: 			result = crVerifyCertificate(certificateList,
; 12146: 									certificateCount,
; 12147: 									pSysTime, 
; 12148: 									pwd,
; 12149: 									&CertVerifyParams,
; 12150: 									pg_sig);
; 12151: #endif
; 12152: 	}
; 12153: 	for (UINT i=0; i < certificateCount; i++)

	mov	DWORD PTR _i$212152[ebp], 0
	jmp	SHORT $L212153
$L212154:
	mov	eax, DWORD PTR _i$212152[ebp]
	add	eax, 1
	mov	DWORD PTR _i$212152[ebp], eax
$L212153:
	mov	ecx, DWORD PTR _i$212152[ebp]
	cmp	ecx, DWORD PTR _certificateCount$[ebp]
	jae	SHORT $L212155

; 12154: 	{
; 12155: 		zFree(certificateList[i]);

	mov	edx, DWORD PTR _i$212152[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 12156: 	}

	jmp	SHORT $L212154
$L212155:

; 12157: 	zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12158: 
; 12159: #ifdef NSS
; 12160: 	if (s.len!=0) {

	cmp	DWORD PTR _s$[ebp+8], 0
	je	SHORT $L212156

; 12161: 		zFree(s.data);

	cmp	BYTE PTR $T222007[ebp], 0
	jne	SHORT $L222011
	push	OFFSET FLAT:$L222009
	call	__RTC_UninitUse
	add	esp, 4
$L222011:
	mov	eax, DWORD PTR _s$[ebp+4]
	push	eax
	call	_rFree
	add	esp, 4
$L212156:

; 12162: 	}
; 12163: #endif
; 12164: 	ExitLog;
; 12165: 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L212105:

; 12166: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222017
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 112				; 00000070H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222017:
	DD	5
	DD	$L222016
$L222016:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$L222009
	DD	-16					; fffffff0H
	DD	4
	DD	$L222012
	DD	-68					; ffffffbcH
	DD	12					; 0000000cH
	DD	$L222013
	DD	-84					; ffffffacH
	DD	8
	DD	$L222014
	DD	-100					; ffffff9cH
	DD	4
	DD	$L222015
$L222015:
	DB	99					; 00000063H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$L222014:
	DB	80					; 00000050H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L222013:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	0
$L222012:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222009:
	DB	115					; 00000073H
	DB	0
?CheckCertificateValidity@CSignature@@QAEHPAEPAU_SYSTEMTIME@@PAU_DS_DATA_BLOB@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; CSignature::CheckCertificateValidity
_TEXT	ENDS
PUBLIC	?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_DetachedObjects
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$212167 = -24						; size = 4
_bstrList$ = -20					; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_DetachedObjects

; 12169: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12170: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 12171: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 12172: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 12173: 
; 12174: 	EnterLog;
; 12175: 	if ((newVal.vt != VT_BSTR) &&
; 12176: 		(newVal.vt != VT_DISPATCH) &&
; 12177: 		!(newVal.vt & VT_ARRAY) && 
; 12178: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L212164
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L212164
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L212164
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L212164

; 12179: 	{
; 12180: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12181: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212160
$L212164:

; 12182: 	}
; 12183: 	if (DetachedObjectCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+72], 0
	je	SHORT $L212166

; 12184: 	{
; 12185: 		for (unsigned int i=0; i < DetachedObjectCount; i++)

	mov	DWORD PTR _i$212167[ebp], 0
	jmp	SHORT $L212168
$L212169:
	mov	ecx, DWORD PTR _i$212167[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$212167[ebp], ecx
$L212168:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$212167[ebp]
	cmp	eax, DWORD PTR [edx+72]
	jae	SHORT $L212170

; 12186: 			zFree(DetachedObjectList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	eax, DWORD PTR _i$212167[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L212169
$L212170:

; 12187: 		zFree(DetachedObjectList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	_rFree
	add	esp, 4

; 12188: 		DetachedObjectCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0
$L212166:

; 12189: 	}
; 12190: 
; 12191: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	edx, DWORD PTR _itemCount$[ebp]
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 12192: 
; 12193: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L212172
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L212171
$L212172:

; 12194: 	{
; 12195: 		DetachedObjectList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 12196: 		DetachedObjectCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 12197: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12198: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212160
$L212171:

; 12199: 	}
; 12200: 
; 12201: 	DetachedObjectCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+72], edx

; 12202: 	DetachedObjectList = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+76], eax

; 12203: 	if (DetachedObjectList == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	jne	SHORT $L212176

; 12204: 	{
; 12205: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 12206: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L212160
$L212176:

; 12207: 	}
; 12208: 	memset(DetachedObjectList, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 12209: 
; 12210: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L212179
$L212180:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L212179:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212181

; 12211: 	{
; 12212: 		DetachedObjectList[elementCount] = (char *)HeapW2A(bstrList[elementCount]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 12213: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12214: 	}

	jmp	SHORT $L212180
$L212181:

; 12215: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12216: 	ExitLog;
; 12217: 	return S_OK;

	xor	eax, eax
$L212160:

; 12218: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222021
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222021:
	DD	1
	DD	$L222020
$L222020:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222019
$L222019:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_DetachedObjects
_TEXT	ENDS
PUBLIC	?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_AttachedObjects
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$212194 = -16						; size = 4
_bstrList$ = -12					; size = 4
_itemCount$ = -8					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_AttachedObjects

; 12221: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12222: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 12223: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 12224: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 12225: 
; 12226: 	EnterLog;
; 12227: 	if ((newVal.vt != VT_BSTR) &&
; 12228: 		(newVal.vt != VT_DISPATCH) &&
; 12229: 		!(newVal.vt & VT_ARRAY) && 
; 12230: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L212191
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L212191
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L212191
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L212191

; 12231: 	{
; 12232: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12233: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212187
$L212191:

; 12234: 	}
; 12235: 	//if (AttachedObjectCount != 0)
; 12236: 	//{
; 12237: 	//	for (unsigned int i=0; i < AttachedObjectCount; i++)
; 12238: 	//		zFree(AttachedObjectList[i]);
; 12239: 	//	zFree(AttachedObjectList);
; 12240: 	//	AttachedObjectCount = 0;
; 12241: 	//}
; 12242: 
; 12243: 	if (AttachedObjectCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	je	SHORT $L212193

; 12244: 	{
; 12245: 		for (unsigned int i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$212194[ebp], 0
	jmp	SHORT $L212195
$L212196:
	mov	ecx, DWORD PTR _i$212194[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$212194[ebp], ecx
$L212195:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$212194[ebp]
	cmp	eax, DWORD PTR [edx+80]
	jae	SHORT $L212197

; 12246: 			SysFreeString(AttachedObjectList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	esi, esp
	mov	eax, DWORD PTR _i$212194[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L212196
$L212197:

; 12247: 		zFree(AttachedObjectList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	call	_rFree
	add	esp, 4

; 12248: 		AttachedObjectCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], 0
$L212193:

; 12249: 	}
; 12250: 	AttachedObjectList = GetBstrArrayFromVariant(newVal, &AttachedObjectCount);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax

; 12251: 
; 12252: //	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);
; 12253: 
; 12254: 	//if ((bstrList == NULL) || (itemCount == 0))
; 12255: 	//{
; 12256: 	//	AttachedObjectList = NULL;
; 12257: 	//	AttachedObjectCount = 0;
; 12258: 	//	setError(SigHandle, INVALID_VARIANT);
; 12259: 	//	return S_FALSE;
; 12260: 	//}
; 12261: 
; 12262: 	//AttachedObjectCount = itemCount;
; 12263: 	//AttachedObjectList = (char **) zMalloc(sizeof(char *) * itemCount);
; 12264: 	//if (AttachedObjectList == NULL)
; 12265: 	//{
; 12266: 	//	setError(SigHandle, MEMORY_FAULT);
; 12267: 	//	return S_FALSE;
; 12268: 	//}
; 12269: 	//memset(AttachedObjectList, 0, sizeof(char *) * itemCount);
; 12270: 
; 12271: 	//for (elementCount =0; elementCount < itemCount; elementCount++)
; 12272: 	//{
; 12273: 	//	AttachedObjectList[elementCount] = (char *)HeapW2A(bstrList[elementCount]);
; 12274: 	//	SysFreeString(bstrList[elementCount]);
; 12275: 	//}
; 12276: 	//zFree(bstrList);
; 12277: 	ExitLog;
; 12278: 	return S_OK;

	xor	eax, eax
$L212187:

; 12279: }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_AttachedObjects
_TEXT	ENDS
PUBLIC	?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z	; CSignature::ReadAllBase64
xdata$x	SEGMENT
$T222038 DD	0ffffffffH
	DD	FLAT:$L222029
$T222031 DD	019930520H
	DD	01H
	DD	FLAT:$T222038
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222028 = -92						; size = 4
$T222027 = -88						; size = 4
$T222026 = -84						; size = 4
$T222025 = -80						; size = 4
$T222024 = -76						; size = 4
__lpa$ = -72						; size = 4
__lpw$ = -68						; size = 4
__acp$ = -64						; size = 4
__convert$ = -60					; size = 4
_ccBstrUri$ = -52					; size = 4
_cbDocument$ = -40					; size = 4
_pbDocument$ = -28					; size = 4
_cbData$ = -20						; size = 4
_pbData$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_uri$ = 12						; size = 4
_base64EncodedData$ = 16				; size = 4
?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z PROC NEAR	; CSignature::ReadAllBase64

; 12282: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 80					; 00000050H
	push	edi
	lea	edi, DWORD PTR [ebp-92]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 12283: 	BYTE *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 12284: 	DWORD cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 12285: 	BYTE *pbDocument=NULL;		// Object BLOB to sign

	mov	DWORD PTR _pbDocument$[ebp], 0

; 12286: 	DWORD cbDocument=0;

	mov	DWORD PTR _cbDocument$[ebp], 0

; 12287: 	CComBSTR ccBstrUri;

	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 12288: 
; 12289: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 12290: 	EnterLog;
; 12291: 	ccBstrUri = uri;

	mov	eax, DWORD PTR _uri$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 12292: 
; 12293: 	if (ccBstrUri.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L212213

; 12294: 	{
; 12295: 		setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12296: 		return S_FALSE;

	mov	DWORD PTR $T222024[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222024[ebp]
	jmp	$L212203
$L212213:

; 12297: 	}
; 12298:     
; 12299: 	if (ReadAllBin(uri, &pbDocument, &cbDocument) == S_FALSE)

	lea	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uri$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L212217

; 12300: 	{ 
; 12301: 		setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 12302: 		return S_FALSE;

	mov	DWORD PTR $T222025[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222025[ebp]
	jmp	$L212203
$L212217:

; 12303: 	}
; 12304: 
; 12305: 	//charUri = (char *)HeapW2A(uri);
; 12306: 	//if ((pbDocument = xsDereferenceURI(
; 12307: 	//	(const char *)charUri,// file name or URI
; 12308: 	//	&cbDocument))==NULL) {		// (in/out) size of data
; 12309: 	//		setError(SigHandle, DEREF_URI_ERROR);
; 12310: 	//		zFree(charUri);
; 12311: 	//		return S_FALSE;
; 12312: 	//	}
; 12313: 	//zFree(charUri);
; 12314: 	// Base64 encode
; 12315: 	cbData = base64encodeSize(cbDocument);

	mov	edx, DWORD PTR _cbDocument$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 12316: 
; 12317: 	if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	eax, DWORD PTR _cbData$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax
	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L212221

; 12318: 	{
; 12319: 		zFree(pbDocument);

	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12320: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12321: 		return S_FALSE;

	mov	DWORD PTR $T222026[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222026[ebp]
	jmp	$L212203
$L212221:

; 12322: 	}
; 12323: 	if (base64encode(pbDocument,cbDocument,(unsigned char*)pbData,cbData)==-1) 

	mov	ecx, DWORD PTR _cbData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L212225

; 12324: 	{
; 12325: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12326: 		zFree(pbDocument);

	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12327: 		zFree(pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12328: 		return S_FALSE;

	mov	DWORD PTR $T222027[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222027[ebp]
	jmp	SHORT $L212203
$L212225:

; 12329: 	}
; 12330: 	*(pbData+cbData)='\0';

	mov	eax, DWORD PTR _pbData$[ebp]
	add	eax, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [eax], 0

; 12331: 	zFree(pbDocument);

	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12332: 	*base64EncodedData = A2WBSTR((LPCSTR)pbData);

	push	-1
	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _base64EncodedData$[ebp]
	mov	DWORD PTR [ecx], eax

; 12333: 	zFree(pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12334: 	ExitLog;
; 12335: 	return S_OK;

	mov	DWORD PTR $T222028[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222028[ebp]
$L212203:

; 12336: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222037
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 92					; 0000005cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222037:
	DD	3
	DD	$L222036
$L222036:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L222032
	DD	-40					; ffffffd8H
	DD	4
	DD	$L222033
	DD	-52					; ffffffccH
	DD	4
	DD	$L222034
$L222034:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	85					; 00000055H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	0
$L222033:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222032:
	DB	112					; 00000070H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222029:
	lea	ecx, DWORD PTR _ccBstrUri$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222031
	jmp	___CxxFrameHandler
text$x	ENDS
?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z ENDP		; CSignature::ReadAllBase64
PUBLIC	?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z ; CSignature::put_DecryptionPFXCertFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_DecryptionPFXCertFile

; 12339: {

	push	ebp
	mov	ebp, esp

; 12340: 	EnterLog;
; 12341: 	DecrytionPfxCertFile = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 12342: 	ExitLog;
; 12343: 	return S_OK;

	xor	eax, eax

; 12344: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_DecryptionPFXCertFile
_TEXT	ENDS
PUBLIC	?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z ; CSignature::put_DecryptUsingPFXFileCert
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_DecryptUsingPFXFileCert

; 12347: {

	push	ebp
	mov	ebp, esp

; 12348: 	EnterLog;
; 12349: 	DecryptUsingPfxFileCert = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 12350: 	ExitLog;
; 12351: 	return S_OK;

	xor	eax, eax

; 12352: }

	pop	ebp
	ret	8
?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z ENDP	; CSignature::put_DecryptUsingPFXFileCert
_TEXT	ENDS
PUBLIC	?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z ; CSignature::put_DecryptionPFXPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_sizeM$ = -12						; size = 4
_szPtr$ = -8						; size = 4
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_DecryptionPFXPassword

; 12355: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 12356: 	unsigned char *ptr;
; 12357: 	unsigned int *szPtr;
; 12358: 	unsigned int sizeM;
; 12359: 
; 12360: 	EnterLog;
; 12361: 	if (DecrytionPfxPassword.pbData != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+64], 0
	je	SHORT $L212248

; 12362: 	{
; 12363: 		zFree(DecrytionPfxPassword.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_rFree
	add	esp, 4

; 12364: 		DecrytionPfxPassword.pbData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0
$L212248:

; 12365: 	}
; 12366: 
; 12367: 	ptr = (unsigned char *)newVal;

	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 12368: 
; 12369: 	if (ptr != NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $L212250

; 12370: 	{
; 12371: 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _szPtr$[ebp], edx

; 12372: 		sizeM = *szPtr;

	mov	eax, DWORD PTR _szPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sizeM$[ebp], ecx

; 12373: 
; 12374: 		if (sizeM == 0)

	cmp	DWORD PTR _sizeM$[ebp], 0
	jne	SHORT $L212253

; 12375: 			DecrytionPfxPassword.pbData = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 12376: 		else

	jmp	SHORT $L212250
$L212253:

; 12377: 		{
; 12378: 			sizeM += 2; // BSTR size does not include the terminating null so add 2 to the size

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 2
	mov	DWORD PTR _sizeM$[ebp], eax

; 12379: 			DecrytionPfxPassword.pbData		= (unsigned char *) zMalloc(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], eax

; 12380: 			memcpy(DecrytionPfxPassword.pbData, ptr, sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$L212250:

; 12381: 		}
; 12382: 	}
; 12383: 	ExitLog;
; 12384: 	return S_OK;

	xor	eax, eax

; 12385: }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_DecryptionPFXPassword
_TEXT	ENDS
PUBLIC	?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_XpathNamespace
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$212267 = -24						; size = 4
_bstrList$ = -20					; size = 4
_itemCount$ = -12					; size = 4
_elementCount$ = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_XpathNamespace

; 12388: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12389: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 12390: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 12391: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 12392: 
; 12393: 	EnterLog;
; 12394: 	if ((newVal.vt != VT_BSTR) &&
; 12395: 		(newVal.vt != VT_DISPATCH) &&
; 12396: 		!(newVal.vt & VT_ARRAY) && 
; 12397: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L212264
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L212264
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L212264
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L212264

; 12398: 	{
; 12399: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12400: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212260
$L212264:

; 12401: 	}
; 12402: 	if (XpathNamespaceCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L212266

; 12403: 	{
; 12404: 		for (unsigned int i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$212267[ebp], 0
	jmp	SHORT $L212268
$L212269:
	mov	ecx, DWORD PTR _i$212267[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$212267[ebp], ecx
$L212268:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$212267[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	SHORT $L212270

; 12405: 			zFree(XpathNamespaceList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$212267[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
	jmp	SHORT $L212269
$L212270:

; 12406: 		zFree(XpathNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	push	eax
	call	_rFree
	add	esp, 4

; 12407: 		XpathNamespaceCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0
$L212266:

; 12408: 	}
; 12409: 
; 12410: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	edx, DWORD PTR _itemCount$[ebp]
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 12411: 
; 12412: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L212272
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L212271
$L212272:

; 12413: 	{
; 12414: 		XpathNamespaceList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 12415: 		XpathNamespaceCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 12416: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12417: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212260
$L212271:

; 12418: 	}
; 12419: 
; 12420: 	XpathNamespaceCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+88], edx

; 12421: 	XpathNamespaceList = (char **) zMalloc(sizeof(char *) * itemCount);

	mov	eax, DWORD PTR _itemCount$[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], eax

; 12422: 	if (XpathNamespaceList == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	jne	SHORT $L212276

; 12423: 	{
; 12424: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 12425: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L212260
$L212276:

; 12426: 	}
; 12427: 	memset(XpathNamespaceList, 0, sizeof(char *) * itemCount);

	mov	edx, DWORD PTR _itemCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 12428: 
; 12429: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L212279
$L212280:
	mov	edx, DWORD PTR _elementCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _elementCount$[ebp], edx
$L212279:
	mov	eax, DWORD PTR _elementCount$[ebp]
	cmp	eax, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L212281

; 12430: 	{
; 12431: 		XpathNamespaceList[elementCount] = (char *)HeapW2A(bstrList[elementCount]);

	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 12432: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	edx, DWORD PTR _elementCount$[ebp]
	mov	eax, DWORD PTR _bstrList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12433: 	}

	jmp	SHORT $L212280
$L212281:

; 12434: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12435: 	ExitLog;
; 12436: 	return S_OK;

	xor	eax, eax
$L212260:

; 12437: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222045
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222045:
	DD	1
	DD	$L222044
$L222044:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222043
$L222043:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_XpathNamespace
_TEXT	ENDS
PUBLIC	?get_CamServerHost@CSignature@@UAGJPAPAG@Z	; CSignature::get_CamServerHost
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CamServerHost@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_CamServerHost

; 12440: {

	push	ebp
	mov	ebp, esp

; 12441: 	EnterLog;
; 12442: 	*pVal = A2WBSTR((LPCSTR)camServerHost);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1896]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 12443: 	ExitLog;
; 12444: 	return S_OK;

	xor	eax, eax

; 12445: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_CamServerHost@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_CamServerHost
_TEXT	ENDS
PUBLIC	?put_CamServerHost@CSignature@@UAGJPAG@Z	; CSignature::put_CamServerHost
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CamServerHost@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_CamServerHost

; 12448: {

	push	ebp
	mov	ebp, esp

; 12449: 	EnterLog;
; 12450: 	if (camServerHost != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1896], 0
	je	SHORT $L212294

; 12451: 	{
; 12452: 		zFree(camServerHost);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1896]
	push	edx
	call	_rFree
	add	esp, 4

; 12453: 		camServerHost = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1896], 0
$L212294:

; 12454: 	}
; 12455: 	camServerHost = HeapW2A(newVal);

	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1896], eax

; 12456: 	ExitLog;
; 12457: 	return S_OK;

	xor	eax, eax

; 12458: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_CamServerHost@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_CamServerHost
_TEXT	ENDS
PUBLIC	?get_CamServerPort@CSignature@@UAGJPAG@Z	; CSignature::get_CamServerPort
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CamServerPort@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::get_CamServerPort

; 12461: {

	push	ebp
	mov	ebp, esp

; 12462: 	EnterLog;
; 12463:     *pVal = camServerPort;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+1900]
	mov	WORD PTR [eax], dx

; 12464: 	ExitLog;
; 12465: 	return S_OK;

	xor	eax, eax

; 12466: }

	pop	ebp
	ret	8
?get_CamServerPort@CSignature@@UAGJPAG@Z ENDP		; CSignature::get_CamServerPort
_TEXT	ENDS
PUBLIC	?put_CamServerPort@CSignature@@UAGJG@Z		; CSignature::put_CamServerPort
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 2
?put_CamServerPort@CSignature@@UAGJG@Z PROC NEAR	; CSignature::put_CamServerPort

; 12469: {

	push	ebp
	mov	ebp, esp

; 12470: 	EnterLog;
; 12471: 	camServerPort = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _newVal$[ebp]
	mov	WORD PTR [eax+1900], cx

; 12472: 	ExitLog;
; 12473: 	return S_OK;

	xor	eax, eax

; 12474: }

	pop	ebp
	ret	8
?put_CamServerPort@CSignature@@UAGJG@Z ENDP		; CSignature::put_CamServerPort
_TEXT	ENDS
PUBLIC	?get_UseCam@CSignature@@UAGJPAH@Z		; CSignature::get_UseCam
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UseCam@CSignature@@UAGJPAH@Z PROC NEAR		; CSignature::get_UseCam

; 12477: {

	push	ebp
	mov	ebp, esp

; 12478: 	EnterLog;
; 12479: 	*pVal = useCam;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1908]
	mov	DWORD PTR [eax], edx

; 12480: 	ExitLog;
; 12481: 	return S_OK;

	xor	eax, eax

; 12482: }

	pop	ebp
	ret	8
?get_UseCam@CSignature@@UAGJPAH@Z ENDP			; CSignature::get_UseCam
_TEXT	ENDS
PUBLIC	?put_UseCam@CSignature@@UAGJH@Z			; CSignature::put_UseCam
EXTRN	??0CCAMClient@@QAE@XZ:NEAR			; CCAMClient::CCAMClient
xdata$x	SEGMENT
$T222064 DD	0ffffffffH
	DD	FLAT:$L222060
$T222062 DD	019930520H
	DD	01H
	DD	FLAT:$T222064
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv74 = -32						; size = 4
$T222057 = -28						; size = 4
$T222056 = -24						; size = 4
$T222053 = -20						; size = 4
$T222052 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_UseCam@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_UseCam

; 12485: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_UseCam@CSignature@@UAGJH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax

; 12486: 	EnterLog;
; 12487: 	if (useCam) // Already enabled hence do nothing if newVal != 0

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1908], 0
	je	SHORT $L212315

; 12488: 	{
; 12489: 		if (newVal == 0)

	cmp	DWORD PTR _newVal$[ebp], 0
	jne	SHORT $L212316

; 12490: 		{
; 12491: 			if (pCamClient != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1904], 0
	je	SHORT $L212317

; 12492: 			{
; 12493: 				delete pCamClient;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1904]
	mov	DWORD PTR $T222053[ebp], eax
	mov	ecx, DWORD PTR $T222053[ebp]
	mov	DWORD PTR $T222052[ebp], ecx
	cmp	DWORD PTR $T222052[ebp], 0
	je	SHORT $L222054
	push	1
	mov	ecx, DWORD PTR $T222052[ebp]
	call	??_GCCAMClient@@QAEPAXI@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $L222055
$L222054:
	mov	DWORD PTR tv74[ebp], 0
$L222055:

; 12494: 				pCamClient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1904], 0
$L212317:

; 12495: 			}
; 12496: 			useCam = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1908], ecx

; 12497: 			ExitLog;
; 12498: 			return S_OK;

	xor	eax, eax
	jmp	$L212314
$L212316:

; 12499: 		}
; 12500: 		else
; 12501: 		{
; 12502: 			ExitLog;
; 12503: 			return S_OK;

	xor	eax, eax
	jmp	$L212314
$L212315:

; 12504: 		}
; 12505: 	}
; 12506: 	else 
; 12507: 		if (newVal)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	$L212323

; 12508: 		{
; 12509: 			put_UseOcsp(FALSE); // Disable OCSP based certificate validation

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+804]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12510: 			pCamClient = new CCAMClient();

	push	4108					; 0000100cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222057[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T222057[ebp], 0
	je	SHORT $L222058
	mov	ecx, DWORD PTR $T222057[ebp]
	call	??0CCAMClient@@QAE@XZ			; CCAMClient::CCAMClient
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $L222059
$L222058:
	mov	DWORD PTR tv90[ebp], 0
$L222059:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR $T222056[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222056[ebp]
	mov	DWORD PTR [eax+1904], ecx

; 12511: 			useCam = newVal;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [edx+1908], eax

; 12512: 			pCamClient->camServerPortNumber = camServerPort;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1904]
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+1900]
	mov	WORD PTR [edx], cx
$L212323:

; 12513: 		}
; 12514: 	ExitLog;
; 12515: 	return S_OK;

	xor	eax, eax
$L212314:

; 12516: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L222060:
	mov	eax, DWORD PTR $T222057[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?put_UseCam@CSignature@@UAGJH@Z:
	mov	eax, OFFSET FLAT:$T222062
	jmp	___CxxFrameHandler
text$x	ENDS
?put_UseCam@CSignature@@UAGJH@Z ENDP			; CSignature::put_UseCam
PUBLIC	?get_AgencyId@CSignature@@UAGJPAPAG@Z		; CSignature::get_AgencyId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_AgencyId@CSignature@@UAGJPAPAG@Z PROC NEAR		; CSignature::get_AgencyId

; 12519: {

	push	ebp
	mov	ebp, esp

; 12520: 	EnterLog;
; 12521: 	*pVal = A2WBSTR((LPCSTR)agencyId);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 1920				; 00000780H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 12522: 	ExitLog;
; 12523: 	return S_OK;

	xor	eax, eax

; 12524: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_AgencyId@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_AgencyId
_TEXT	ENDS
PUBLIC	?put_AgencyId@CSignature@@UAGJPAG@Z		; CSignature::put_AgencyId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_aNewVal$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_AgencyId@CSignature@@UAGJPAG@Z PROC NEAR		; CSignature::put_AgencyId

; 12527: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12528: 	EnterLog;
; 12529: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 12530: 	char *aNewVal = (char *)HeapW2A(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _aNewVal$[ebp], eax

; 12531: 	strcpy((char *)agencyId, aNewVal);

	mov	ecx, DWORD PTR _aNewVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1920				; 00000780H
	push	edx
	call	_strcpy
	add	esp, 8

; 12532: 	zFree(aNewVal);

	mov	eax, DWORD PTR _aNewVal$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 12533: 	ExitLog;
; 12534: 	return S_OK;

	xor	eax, eax

; 12535: }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_AgencyId@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_AgencyId
_TEXT	ENDS
EXTRN	?validate@CCAMClient@@QAEJPAE0H0PAHPAPAE121@Z:NEAR ; CCAMClient::validate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv146 = -40						; size = 4
_transIdPtr$212368 = -36				; size = 4
_certBufPtr$ = -32					; size = 4
_certBufSize$ = -28					; size = 4
_errorNum$ = -24					; size = 4
_status$ = -16						; size = 4
_result$ = -8						; size = 4
_this$ = -4						; size = 4
_certificateList$ = 8					; size = 4
_certificateCount$ = 12					; size = 4
_pSysTime$ = 16						; size = 4
_hKey$ = 20						; size = 4
_certVerParams$ = 24					; size = 4
_pg_sig$ = 28						; size = 4
?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CSignature::crVerifyCertificateUsingCam
; _this$ = ecx

; 12542: {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 12543: 	BOOL result;
; 12544: 	int status, errorNum;
; 12545: 	DWORD	certBufSize;
; 12546: 	unsigned char *certBufPtr;
; 12547: 
; 12548: 	EnterLog;
; 12549: 	result = TRUE;

	mov	DWORD PTR _result$[ebp], 1

; 12550: 	certBufSize = base64decodeSize((DWORD)strlen((const char *)certificateList[0]));

	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _certBufSize$[ebp], eax

; 12551: 	certBufPtr = (unsigned char *) zMalloc (certBufSize+1);

	mov	edx, DWORD PTR _certBufSize$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certBufPtr$[ebp], eax

; 12552: 	memset(certBufPtr,0,certBufSize+1);

	mov	eax, DWORD PTR _certBufSize$[ebp]
	add	eax, 1
	push	eax
	push	0
	mov	ecx, DWORD PTR _certBufPtr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 12553: 	if ((certBufSize = base64decode(certificateList[0],(unsigned char *)certBufPtr,certBufSize))==-1)

	mov	edx, DWORD PTR _certBufSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _certBufPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _certBufSize$[ebp], eax
	cmp	DWORD PTR _certBufSize$[ebp], -1
	jne	SHORT $L212366

; 12554: 	{
; 12555: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 12556: 		zFree(certBufPtr);

	mov	edx, DWORD PTR _certBufPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12557: 		return FALSE;

	xor	eax, eax
	jmp	$L212356
$L212366:

; 12558: 	}
; 12559: 
; 12560: 	pCamClient->validate(camServerHost, certBufPtr,
; 12561: 							certBufSize, agencyId, &status, 
; 12562: 							&CamResponseAsciiCert, 
; 12563: 							&CamResponseAsciiCertSize,
; 12564: 							&CamResponseCaSignedMsg, 
; 12565: 							&CamResponseCaSignedMsgSize);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2208				; 000008a0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2200				; 00000898H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 2204				; 0000089cH
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 2196				; 00000894H
	push	eax
	lea	ecx, DWORD PTR _status$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1920				; 00000780H
	push	edx
	mov	eax, DWORD PTR _certBufSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certBufPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1896]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1904]
	call	?validate@CCAMClient@@QAEJPAE0H0PAHPAPAE121@Z ; CCAMClient::validate

; 12566: 	zFree(certBufPtr);

	mov	edx, DWORD PTR _certBufPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12567: 	if (CamResponseAsciiCert !=  NULL) //The response contains ASCII Certificate Information

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2196], 0
	je	SHORT $L212367

; 12568: 	{
; 12569: 		char * transIdPtr = strstr((const char *)CamResponseAsciiCert, "TransID: ");

	push	OFFSET FLAT:$SG212370
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2196]
	push	edx
	call	_strstr
	add	esp, 8
	mov	DWORD PTR _transIdPtr$212368[ebp], eax

; 12570: 		if (transIdPtr != NULL)

	cmp	DWORD PTR _transIdPtr$212368[ebp], 0
	je	SHORT $L212371

; 12571: 			CamResponseTransactionId = (unsigned char *)(transIdPtr + 9);

	mov	eax, DWORD PTR _transIdPtr$212368[ebp]
	add	eax, 9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+2212], eax

; 12572: 		else

	jmp	SHORT $L212367
$L212371:

; 12573: 			CamResponseTransactionId = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+2212], 0
$L212367:

; 12574: 	}
; 12575: 	if (status != 0)

	cmp	DWORD PTR _status$[ebp], 0
	je	$L212374

; 12576: 	{
; 12577: 		result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 12578: 		switch(status)

	mov	eax, DWORD PTR _status$[ebp]
	mov	DWORD PTR tv146[ebp], eax
	mov	ecx, DWORD PTR tv146[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv146[ebp], ecx
	cmp	DWORD PTR tv146[ebp], 254		; 000000feH
	ja	SHORT $L212391
	mov	edx, DWORD PTR tv146[ebp]
	movzx	eax, BYTE PTR $L222068[edx]
	jmp	DWORD PTR $L222072[eax*4]
$L212379:

; 12579: 		{
; 12580: 			case 1: errorNum = CAM_CERT_REVOKED;

	mov	DWORD PTR _errorNum$[ebp], 93		; 0000005dH

; 12581: 				break;

	jmp	SHORT $L212376
$L212380:

; 12582: 			case 2: errorNum = CAM_CERT_EXPIRED;

	mov	DWORD PTR _errorNum$[ebp], 94		; 0000005eH

; 12583: 				break;

	jmp	SHORT $L212376
$L212381:

; 12584: 			case 3: errorNum = CAM_CERT_SUSPENDED;

	mov	DWORD PTR _errorNum$[ebp], 95		; 0000005fH

; 12585: 				break;

	jmp	SHORT $L212376
$L212382:

; 12586: 			case 4: errorNum = CAM_CERT_FAILED_VERIFICATION;

	mov	DWORD PTR _errorNum$[ebp], 96		; 00000060H

; 12587: 				break;

	jmp	SHORT $L212376
$L212383:

; 12588: 			case 5: errorNum = CAM_CERT_ISSUER_NOT_FOUND;

	mov	DWORD PTR _errorNum$[ebp], 97		; 00000061H

; 12589: 				break;

	jmp	SHORT $L212376
$L212384:

; 12590: 			case 6: errorNum = CAM_CERT_NOT_PARSABLE;

	mov	DWORD PTR _errorNum$[ebp], 98		; 00000062H

; 12591: 				break;

	jmp	SHORT $L212376
$L212385:

; 12592: 			case 7: errorNum = CAM_CA_SYSTEM_BUSY;

	mov	DWORD PTR _errorNum$[ebp], 99		; 00000063H

; 12593: 				break;

	jmp	SHORT $L212376
$L212386:

; 12594: 			case 8: errorNum = CAM_CA_TIMEOUT;

	mov	DWORD PTR _errorNum$[ebp], 100		; 00000064H

; 12595: 				break;

	jmp	SHORT $L212376
$L212387:

; 12596: 			case 9: errorNum = CAM_CA_CERT_UNKNOWN;

	mov	DWORD PTR _errorNum$[ebp], 101		; 00000065H

; 12597: 				break;

	jmp	SHORT $L212376
$L212388:

; 12598: 			case 10: errorNum = CAM_CA_REQ_BAD;

	mov	DWORD PTR _errorNum$[ebp], 102		; 00000066H

; 12599: 				break;

	jmp	SHORT $L212376
$L212389:

; 12600: 			case 11: errorNum = CAM_CA_BAD_RESP_SIG;

	mov	DWORD PTR _errorNum$[ebp], 103		; 00000067H

; 12601: 				break;

	jmp	SHORT $L212376
$L212390:

; 12602: 			case 0xFF: errorNum = CAM_INTERNAL_ERROR;

	mov	DWORD PTR _errorNum$[ebp], 104		; 00000068H

; 12603: 				break;

	jmp	SHORT $L212376
$L212391:

; 12604: 			default: errorNum = CAM_INTERNAL_ERROR;

	mov	DWORD PTR _errorNum$[ebp], 104		; 00000068H
$L212376:

; 12605: 				break;
; 12606: 		}
; 12607: 		setError(SigHandle, errorNum);

	mov	ecx, DWORD PTR _errorNum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8
$L212374:

; 12608: 	}
; 12609: 	ExitLog;
; 12610: 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L212356:

; 12611: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222071
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L222071:
	DD	1
	DD	$L222070
$L222070:
	DD	-16					; fffffff0H
	DD	4
	DD	$L222069
$L222069:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$L222072:
	DD	$L212379
	DD	$L212380
	DD	$L212381
	DD	$L212382
	DD	$L212383
	DD	$L212384
	DD	$L212385
	DD	$L212386
	DD	$L212387
	DD	$L212388
	DD	$L212389
	DD	$L212390
	DD	$L212391
$L222068:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	11					; 0000000bH
?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; CSignature::crVerifyCertificateUsingCam
_TEXT	ENDS
PUBLIC	?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z ; CSignature::get_CamValidationResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_CamValidationResponse

; 12613: {

	push	ebp
	mov	ebp, esp

; 12614: 	EnterLog;
; 12615: 	if (CamResponseCaSignedMsg != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2200], 0
	je	SHORT $L212396

; 12616: 		*pVal = A2WBSTR((LPCSTR)CamResponseCaSignedMsg, CamResponseCaSignedMsgSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2208]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+2200]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax
$L212396:

; 12617: 	ExitLog;
; 12618: 	return S_OK;

	xor	eax, eax

; 12619: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_CamValidationResponse
_TEXT	ENDS
PUBLIC	??0_bstr_t@@QAE@XZ				; _bstr_t::_bstr_t
PUBLIC	?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z	; ocspAX::IOcspClient::verify
PUBLIC	?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetTextResponse
PUBLIC	?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetBase64Response
PUBLIC	?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetRevocationTime
PUBLIC	?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetRevocationReason
PUBLIC	?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetOcspNonce
PUBLIC	?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutOcspNonce
PUBLIC	?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutResponderCAFileName
PUBLIC	?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutCheckCertificate
PUBLIC	?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutIssuerCertificate
PUBLIC	?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutSignerPFXCertificate
PUBLIC	?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutSignerPFXPassword
PUBLIC	?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetresponderUrl
PUBLIC	?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyHost
PUBLIC	?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z	; ocspAX::IOcspClient::PutproxyPort
PUBLIC	?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyUsername
PUBLIC	?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyPassword
xdata$x	SEGMENT
$T222114 DD	0ffffffffH
	DD	FLAT:$L222105
	DD	0ffffffffH
	DD	FLAT:$L222106
	DD	0ffffffffH
	DD	FLAT:$L222107
	DD	0ffffffffH
	DD	FLAT:$L222108
	DD	0ffffffffH
	DD	FLAT:$L222109
	DD	0ffffffffH
	DD	FLAT:$L222110
$T222112 DD	019930520H
	DD	06H
	DD	FLAT:$T222114
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv477 = -196						; size = 4
tv483 = -192						; size = 4
tv475 = -188						; size = 4
tv482 = -184						; size = 4
tv473 = -180						; size = 4
tv481 = -176						; size = 4
tv471 = -172						; size = 4
tv480 = -168						; size = 4
tv469 = -164						; size = 4
tv479 = -160						; size = 4
tv467 = -156						; size = 4
tv478 = -152						; size = 4
tv465 = -146						; size = 2
tv464 = -144						; size = 4
tv462 = -140						; size = 4
tv460 = -136						; size = 4
tv458 = -132						; size = 4
tv456 = -128						; size = 4
tv454 = -124						; size = 4
tv452 = -120						; size = 4
tv450 = -116						; size = 4
tv448 = -112						; size = 4
tv446 = -108						; size = 4
tv444 = -104						; size = 4
tv442 = -100						; size = 4
$T222092 = -96						; size = 4
$T222091 = -92						; size = 4
$T222090 = -88						; size = 4
$T222089 = -84						; size = 4
$T222088 = -80						; size = 4
$T222087 = -76						; size = 4
$T222086 = -72						; size = 4
$T222085 = -68						; size = 4
$T222084 = -64						; size = 4
$T222083 = -60						; size = 4
$T222082 = -56						; size = 4
$T222081 = -52						; size = 4
$T222080 = -48						; size = 4
$T222079 = -44						; size = 4
$T222078 = -40						; size = 4
$T222077 = -36						; size = 4
$T222076 = -32						; size = 4
$T222075 = -28						; size = 4
_status$ = -24						; size = 4
_result$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_certificateList$ = 8					; size = 4
_certificateCount$ = 12					; size = 4
_pSysTime$ = 16						; size = 4
_hKey$ = 20						; size = 4
_certVerParams$ = 24					; size = 4
_pg_sig$ = 28						; size = 4
?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CSignature::crVerifyCertificateUsingOcsp
; _this$ = ecx

; 12627: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 184				; 000000b8H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-196]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 12628: 	BOOL result;
; 12629: 	int status;
; 12630: 
; 12631: 	EnterLog;
; 12632: 
; 12633: 	if (certificateCount < 2)

	cmp	DWORD PTR _certificateCount$[ebp], 2
	jae	SHORT $L212410

; 12634: 	{
; 12635: 		setError(pg_sig, CERT_CHAIN_ERROR);

	push	1
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 12636: 		return FALSE;

	xor	eax, eax
	jmp	$L212407
$L212410:

; 12637: 	}
; 12638: 
; 12639: 	if (!useOcsp || (pOcspClient == NULL))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1912], 0
	je	SHORT $L212412
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1916], 0
	jne	SHORT $L212411
$L212412:

; 12640: 	{
; 12641: 		setError(pg_sig, OCSP_ERROR);

	push	123					; 0000007bH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 12642: 		return FALSE;

	xor	eax, eax
	jmp	$L212407
$L212411:

; 12643: 	}
; 12644: 
; 12645: 	result = TRUE;

	mov	DWORD PTR _result$[ebp], 1

; 12646: 
; 12647: #ifdef WIN32
; 12648: 	if (ocspInputNonce.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L212413

; 12649: 		pOcspClient->OcspNonce = _bstr_t(ocspInputNonce);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222075[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv442[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1916]
	call	?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutOcspNonce

; 12650: 	else

	jmp	SHORT $L212416
$L212413:

; 12651: 		pOcspClient->OcspNonce = _bstr_t();

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222076[ebp], esp
	call	??0_bstr_t@@QAE@XZ			; _bstr_t::_bstr_t
	mov	DWORD PTR tv444[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1916]
	call	?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutOcspNonce
$L212416:

; 12652: 
; 12653: 	pOcspClient->CheckCertificate = _bstr_t((const char *)certificateList[0]);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222077[ebp], esp
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv446[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutCheckCertificate

; 12654: 	pOcspClient->IssuerCertificate = _bstr_t((const char *)certificateList[1]);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222078[ebp], esp
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv448[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1916]
	call	?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutIssuerCertificate

; 12655: 	//pOcspClient->CheckCertificateFormat = FORMAT_BASE64;
; 12656: 	//pOcspClient->IssuerCertificateFormat = FORMAT_BASE64;
; 12657: 	pOcspClient->SignerPFXCertificate = 	_bstr_t(ocspRequestSignerB64PfxCert);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222079[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv450[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1916]
	call	?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutSignerPFXCertificate

; 12658: 	pOcspClient->SignerPFXPassword  =		_bstr_t(ocspRequestSignerB64PfxCertPassword);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222080[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv452[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutSignerPFXPassword

; 12659: 	pOcspClient->ResponderCAFileName  = _bstr_t(ocspResponseCACertPath);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222081[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv454[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1916]
	call	?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutResponderCAFileName

; 12660: 
; 12661: 	if (proxyHost.Length() != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L212431

; 12662: 	{
; 12663: 		pOcspClient->proxyHost = _bstr_t(proxyHost);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222082[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv456[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1916]
	call	?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyHost

; 12664: 		pOcspClient->proxyPort = proxyPort;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+2272]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1916]
	call	?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z ; ocspAX::IOcspClient::PutproxyPort

; 12665: 		pOcspClient->proxyUsername = _bstr_t(proxyUserName);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222083[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv458[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyUsername

; 12666: 		pOcspClient->proxyPassword = _bstr_t(proxyPassword);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222084[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv460[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1916]
	call	?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyPassword

; 12667: 	}
; 12668: 	else

	jmp	SHORT $L212438
$L212431:

; 12669: 		pOcspClient->proxyHost = _bstr_t();

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222085[ebp], esp
	call	??0_bstr_t@@QAE@XZ			; _bstr_t::_bstr_t
	mov	DWORD PTR tv462[ebp], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1916]
	call	?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ; ocspAX::IOcspClient::PutproxyHost
$L212438:

; 12670: 
; 12671: 	status = pOcspClient->verify(_bstr_t(ocspResponderUrl));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222086[ebp], esp
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv464[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z ; ocspAX::IOcspClient::verify
	mov	WORD PTR tv465[ebp], ax
	movzx	ecx, WORD PTR tv465[ebp]
	mov	DWORD PTR _status$[ebp], ecx

; 12672: 
; 12673: 	ocspTextResponse = (BSTR)pOcspClient->TextResponse;

	lea	edx, DWORD PTR $T222087[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetTextResponse
	mov	DWORD PTR tv478[ebp], eax
	mov	ecx, DWORD PTR tv478[ebp]
	mov	DWORD PTR tv467[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv467[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222087[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12674: 	ocspB64Response = (BSTR)pOcspClient->Base64Response;

	lea	edx, DWORD PTR $T222088[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetBase64Response
	mov	DWORD PTR tv479[ebp], eax
	mov	ecx, DWORD PTR tv479[ebp]
	mov	DWORD PTR tv469[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv469[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222088[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12675: 	ocspRevocationReason = (BSTR)pOcspClient->RevocationReason;

	lea	edx, DWORD PTR $T222089[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetRevocationReason
	mov	DWORD PTR tv480[ebp], eax
	mov	ecx, DWORD PTR tv480[ebp]
	mov	DWORD PTR tv471[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv471[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2224				; 000008b0H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222089[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12676: 	ocspRevocationTime = (BSTR)pOcspClient->RevocationTime;

	lea	edx, DWORD PTR $T222090[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetRevocationTime
	mov	DWORD PTR tv481[ebp], eax
	mov	ecx, DWORD PTR tv481[ebp]
	mov	DWORD PTR tv473[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv473[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222090[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12677: 	ocspOutputResponderUrl = (BSTR)pOcspClient->responderUrl;

	lea	edx, DWORD PTR $T222091[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetresponderUrl
	mov	DWORD PTR tv482[ebp], eax
	mov	ecx, DWORD PTR tv482[ebp]
	mov	DWORD PTR tv475[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv475[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222091[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12678: 	ocspOutputNonce = (BSTR)pOcspClient->OcspNonce;

	lea	edx, DWORD PTR $T222092[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	call	?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ; ocspAX::IOcspClient::GetOcspNonce
	mov	DWORD PTR tv483[ebp], eax
	mov	ecx, DWORD PTR tv483[ebp]
	mov	DWORD PTR tv477[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR tv477[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T222092[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 12679: 	ocspInputNonce.Empty(); // reset the value for the input Nonce so that it not reused

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	?Empty@CComBSTR@ATL@@QAEXXZ		; ATL::CComBSTR::Empty

; 12680: 
; 12681: #elif LINUX
; 12682: 
; 12683: 	if (ocspInputNonce.Length() != 0)
; 12684: 		pOcspClient->SetOcspNonce(nsString((PRUnichar *)((BSTR)ocspInputNonce)));
; 12685: 	else
; 12686: 		pOcspClient->SetOcspNonce(nsString(NULL));
; 12687: 	pOcspClient->SetCheckCertificate(nsString((PRUnichar *)((BSTR)CComBSTR((const char *)certificateList[0]))));
; 12688: 	pOcspClient->SetIssuerCertificate(nsString((PRUnichar *)((BSTR)CComBSTR((const char *)certificateList[1]))));
; 12689: 	pOcspClient->SetSignerPFXCertificate(nsString((PRUnichar *)((BSTR)CComBSTR(ocspRequestSignerB64PfxCert))));
; 12690: 	pOcspClient->SetSignerPFXPassword(nsString((PRUnichar *)((BSTR)CComBSTR(ocspRequestSignerB64PfxCertPassword))));
; 12691: 	pOcspClient->SetResponderCAFileName(nsString((PRUnichar *)((BSTR)CComBSTR(ocspResponseCACertPath))));
; 12692: 
; 12693: 	if (proxyHost.Length() != 0)
; 12694: 	{
; 12695: 		pOcspClient->SetProxyHost(nsString((PRUnichar *)((BSTR)CComBSTR(proxyHost))));
; 12696: 		pOcspClient->SetProxyPort(proxyPort);
; 12697: 		pOcspClient->SetProxyUsername(nsString((PRUnichar *)((BSTR)CComBSTR(proxyUserName))));
; 12698: 		pOcspClient->SetProxyPassword(nsString((PRUnichar *)((BSTR)CComBSTR(proxyPassword))));
; 12699: 	}
; 12700: 	else
; 12701: 		pOcspClient->SetProxyHost(nsString(NULL));
; 12702: 
; 12703: 	PRUint16 prStatus;
; 12704: 	pOcspClient->Verify(nsString((PRUnichar *)((BSTR)CComBSTR(ocspResponderUrl))), &prStatus);
; 12705: 	status = prStatus;
; 12706: 
; 12707: 	nsString temp;
; 12708: 	pOcspClient->GetTextResponse(temp);
; 12709: 	ocspTextResponse = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12710: 	pOcspClient->GetBase64Response(temp);
; 12711: 	ocspB64Response = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12712: 	pOcspClient->GetRevocationReason(temp);
; 12713: 	ocspRevocationReason = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12714: 	pOcspClient->GetRevocationTime(temp);
; 12715: 	ocspRevocationTime = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12716: 	pOcspClient->GetResponderURL(temp);
; 12717: 	ocspOutputResponderUrl = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12718: 	pOcspClient->GetOcspNonce(temp);
; 12719: 	ocspOutputNonce = (BSTR)CComBSTR((LPCOLESTR)temp.get());
; 12720: 	ocspInputNonce.Empty(); // reset the value for the input Nonce so that it not reused
; 12721: 
; 12722: #endif
; 12723: 
; 12724: 	if ((status & CERT_GOOD) == 0)

	mov	edx, DWORD PTR _status$[ebp]
	and	edx, 1
	jne	SHORT $L212455

; 12725: 	{
; 12726: 		if (status & CERT_UNKNOWN)

	mov	eax, DWORD PTR _status$[ebp]
	and	eax, 2
	je	SHORT $L212456

; 12727:             setError(pg_sig, OCSP_CERT_UNKNOWN);

	push	124					; 0000007cH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 12728: 		else if (status & CERT_REVOKED)

	jmp	SHORT $L212457
$L212456:
	mov	edx, DWORD PTR _status$[ebp]
	and	edx, 4
	je	SHORT $L212458

; 12729: 			setError(pg_sig, OCSP_CERT_REVOKED);

	push	125					; 0000007dH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 12730: 		else

	jmp	SHORT $L212457
$L212458:

; 12731: 			setError(pg_sig, OCSP_ERROR);

	push	123					; 0000007bH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8
$L212457:

; 12732: 		result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 12733: 	}
; 12734: 	else // Certificate validated successfully

	jmp	SHORT $L212460
$L212455:

; 12735: 	{
; 12736: 		if ((ocspResponseCACertPath.Length() != 0) &&	// The trusted response signer cert is given and 
; 12737: 			((status & RESPONSE_VERIFIED) == 0))		// hence should be enforced

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L212461
	mov	edx, DWORD PTR _status$[ebp]
	and	edx, 16					; 00000010H
	jne	SHORT $L212461

; 12738: 		{
; 12739: 			result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 12740: 			setError(pg_sig, OCSP_CA_UNTRUSTED);

	push	126					; 0000007eH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 12741: 		}
; 12742: 		else

	jmp	SHORT $L212460
$L212461:

; 12743: 			result = TRUE;

	mov	DWORD PTR _result$[ebp], 1
$L212460:

; 12744: 	}
; 12745: 
; 12746: 	ExitLog;
; 12747: 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L212407:

; 12748: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 196				; 000000c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
$L222105:
	lea	ecx, DWORD PTR $T222087[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222106:
	lea	ecx, DWORD PTR $T222088[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222107:
	lea	ecx, DWORD PTR $T222089[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222108:
	lea	ecx, DWORD PTR $T222090[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222109:
	lea	ecx, DWORD PTR $T222091[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222110:
	lea	ecx, DWORD PTR $T222092[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T222112
	jmp	___CxxFrameHandler
text$x	ENDS
?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; CSignature::crVerifyCertificateUsingOcsp
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\comutil.h
;	COMDAT ??0_bstr_t@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_bstr_t@@QAE@XZ PROC NEAR				; _bstr_t::_bstr_t, COMDAT
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 237  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_bstr_t@@QAE@XZ ENDP					; _bstr_t::_bstr_t
_TEXT	ENDS
PUBLIC	__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
;	COMDAT xdata$x
; File c:\activex\xmlsign\nssdebug\ocspax.tli
xdata$x	SEGMENT
$T222126 DD	0ffffffffH
	DD	FLAT:$L222119
$T222121 DD	019930520H
	DD	01H
	DD	FLAT:$T222126
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __GUID_c8be4864_227a_4a1b_84ee_473681bd4872
CONST	SEGMENT
__GUID_c8be4864_227a_4a1b_84ee_473681bd4872 DD 0c8be4864H
	DW	0227aH
	DW	04a1bH
	DB	084H
	DB	0eeH
	DB	047H
	DB	036H
	DB	081H
	DB	0bdH
	DB	048H
	DB	072H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z
_TEXT	SEGMENT
$T222118 = -34						; size = 2
__hr$ = -32						; size = 4
__result$ = -24						; size = 2
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_responderUrl$ = 8					; size = 4
?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z PROC NEAR	; ocspAX::IOcspClient::verify, COMDAT
; _this$ = ecx

; 14   : inline unsigned short IOcspClient::verify ( _bstr_t responderUrl ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15   :     unsigned short _result = 0;

	mov	WORD PTR __result$[ebp], 0

; 16   :     HRESULT _hr = raw_verify(responderUrl, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	lea	ecx, DWORD PTR _responderUrl$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 17   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201435
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201435:

; 18   :     return _result;

	mov	ax, WORD PTR __result$[ebp]
	mov	WORD PTR $T222118[ebp], ax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _responderUrl$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ax, WORD PTR $T222118[ebp]

; 19   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222125
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222125:
	DD	1
	DD	$L222124
$L222124:
	DD	-24					; ffffffe8H
	DD	2
	DD	$L222122
$L222122:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222119:
	lea	ecx, DWORD PTR _responderUrl$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222121
	jmp	___CxxFrameHandler
text$x	ENDS
?verify@IOcspClient@ocspAX@@QAEGV_bstr_t@@@Z ENDP	; ocspAX::IOcspClient::verify
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222132 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetTextResponse, COMDAT
; _this$ = ecx

; 21   : inline _bstr_t IOcspClient::GetTextResponse ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222132[ebp], 0

; 22   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 23   :     HRESULT _hr = get_TextResponse(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 24   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201444
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201444:

; 25   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222132[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222132[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 26   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222136
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222136:
	DD	1
	DD	$L222135
$L222135:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222134
$L222134:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetTextResponse@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetTextResponse
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222140 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetBase64Response, COMDAT
; _this$ = ecx

; 35   : inline _bstr_t IOcspClient::GetBase64Response ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222140[ebp], 0

; 36   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 37   :     HRESULT _hr = get_Base64Response(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+40]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 38   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201462
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201462:

; 39   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222140[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222140[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 40   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222144
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222144:
	DD	1
	DD	$L222143
$L222143:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222142
$L222142:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetBase64Response@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetBase64Response
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222148 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetRevocationTime, COMDAT
; _this$ = ecx

; 42   : inline _bstr_t IOcspClient::GetRevocationTime ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222148[ebp], 0

; 43   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 44   :     HRESULT _hr = get_RevocationTime(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+44]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 45   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201471
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201471:

; 46   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222148[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222148[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 47   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222152
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222152:
	DD	1
	DD	$L222151
$L222151:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222150
$L222150:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetRevocationTime@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetRevocationTime
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222156 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetRevocationReason, COMDAT
; _this$ = ecx

; 49   : inline _bstr_t IOcspClient::GetRevocationReason ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222156[ebp], 0

; 50   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 51   :     HRESULT _hr = get_RevocationReason(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+48]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 52   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201480
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201480:

; 53   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222156[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222156[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 54   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222160
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222160:
	DD	1
	DD	$L222159
$L222159:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222158
$L222158:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetRevocationReason@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetRevocationReason
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222164 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetOcspNonce, COMDAT
; _this$ = ecx

; 56   : inline _bstr_t IOcspClient::GetOcspNonce ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222164[ebp], 0

; 57   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 58   :     HRESULT _hr = get_OcspNonce(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+52]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 59   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201489
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201489:

; 60   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222164[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222164[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 61   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222168
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222168:
	DD	1
	DD	$L222167
$L222167:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222166
$L222166:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetOcspNonce@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetOcspNonce
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222175 DD	0ffffffffH
	DD	FLAT:$L222171
$T222173 DD	019930520H
	DD	01H
	DD	FLAT:$T222175
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pVal$ = 8						; size = 4
?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutOcspNonce, COMDAT
; _this$ = ecx

; 63   : inline void IOcspClient::PutOcspNonce ( _bstr_t pVal ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 64   :     HRESULT _hr = put_OcspNonce(pVal);

	lea	ecx, DWORD PTR _pVal$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+56]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 65   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201497
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201497:

; 66   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pVal$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222171:
	lea	ecx, DWORD PTR _pVal$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222173
	jmp	___CxxFrameHandler
text$x	ENDS
?PutOcspNonce@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP	; ocspAX::IOcspClient::PutOcspNonce
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222184 DD	0ffffffffH
	DD	FLAT:$L222180
$T222182 DD	019930520H
	DD	01H
	DD	FLAT:$T222184
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutResponderCAFileName, COMDAT
; _this$ = ecx

; 68   : inline void IOcspClient::PutResponderCAFileName ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 69   :     HRESULT _hr = put_ResponderCAFileName(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+60]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 70   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201504
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201504:

; 71   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222180:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222182
	jmp	___CxxFrameHandler
text$x	ENDS
?PutResponderCAFileName@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutResponderCAFileName
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222193 DD	0ffffffffH
	DD	FLAT:$L222189
$T222191 DD	019930520H
	DD	01H
	DD	FLAT:$T222193
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutCheckCertificate, COMDAT
; _this$ = ecx

; 73   : inline void IOcspClient::PutCheckCertificate ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 74   :     HRESULT _hr = put_CheckCertificate(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+64]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 75   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201511
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201511:

; 76   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222189:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222191
	jmp	___CxxFrameHandler
text$x	ENDS
?PutCheckCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutCheckCertificate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222202 DD	0ffffffffH
	DD	FLAT:$L222198
$T222200 DD	019930520H
	DD	01H
	DD	FLAT:$T222202
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutIssuerCertificate, COMDAT
; _this$ = ecx

; 78   : inline void IOcspClient::PutIssuerCertificate ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 79   :     HRESULT _hr = put_IssuerCertificate(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+68]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 80   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201518
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201518:

; 81   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222198:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222200
	jmp	___CxxFrameHandler
text$x	ENDS
?PutIssuerCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutIssuerCertificate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222211 DD	0ffffffffH
	DD	FLAT:$L222207
$T222209 DD	019930520H
	DD	01H
	DD	FLAT:$T222211
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutSignerPFXCertificate, COMDAT
; _this$ = ecx

; 103  : inline void IOcspClient::PutSignerPFXCertificate ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 104  :     HRESULT _hr = put_SignerPFXCertificate(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+88]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 105  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201553
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201553:

; 106  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222207:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222209
	jmp	___CxxFrameHandler
text$x	ENDS
?PutSignerPFXCertificate@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutSignerPFXCertificate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222220 DD	0ffffffffH
	DD	FLAT:$L222216
$T222218 DD	019930520H
	DD	01H
	DD	FLAT:$T222220
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutSignerPFXPassword, COMDAT
; _this$ = ecx

; 108  : inline void IOcspClient::PutSignerPFXPassword ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 109  :     HRESULT _hr = put_SignerPFXPassword(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+92]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 110  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201560
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201560:

; 111  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222216:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222218
	jmp	___CxxFrameHandler
text$x	ENDS
?PutSignerPFXPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutSignerPFXPassword
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T222226 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ PROC NEAR ; ocspAX::IOcspClient::GetresponderUrl, COMDAT
; _this$ = ecx

; 118  : inline _bstr_t IOcspClient::GetresponderUrl ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222226[ebp], 0

; 119  :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 120  :     HRESULT _hr = get_responderUrl(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+100]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 121  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201575
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201575:

; 122  :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222226[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222226[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 123  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222230
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222230:
	DD	1
	DD	$L222229
$L222229:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222228
$L222228:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetresponderUrl@IOcspClient@ocspAX@@QAE?AV_bstr_t@@XZ ENDP ; ocspAX::IOcspClient::GetresponderUrl
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222237 DD	0ffffffffH
	DD	FLAT:$L222233
$T222235 DD	019930520H
	DD	01H
	DD	FLAT:$T222237
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutproxyHost, COMDAT
; _this$ = ecx

; 130  : inline void IOcspClient::PutproxyHost ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 131  :     HRESULT _hr = put_proxyHost(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+108]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 132  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201590
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201590:

; 133  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222233:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222235
	jmp	___CxxFrameHandler
text$x	ENDS
?PutproxyHost@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP	; ocspAX::IOcspClient::PutproxyHost
; Function compile flags: /Odt /RTCsu
;	COMDAT ?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z
_TEXT	SEGMENT
__hr$ = -8						; size = 4
_this$ = -4						; size = 4
__arg1$ = 8						; size = 2
?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z PROC NEAR	; ocspAX::IOcspClient::PutproxyPort, COMDAT
; _this$ = ecx

; 135  : inline void IOcspClient::PutproxyPort ( unsigned short _arg1 ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 136  :     HRESULT _hr = put_proxyPort(_arg1);

	mov	esi, esp
	mov	ax, WORD PTR __arg1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+112]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 137  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201594
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201594:

; 138  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?PutproxyPort@IOcspClient@ocspAX@@QAEXG@Z ENDP		; ocspAX::IOcspClient::PutproxyPort
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222248 DD	0ffffffffH
	DD	FLAT:$L222244
$T222246 DD	019930520H
	DD	01H
	DD	FLAT:$T222248
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutproxyUsername, COMDAT
; _this$ = ecx

; 140  : inline void IOcspClient::PutproxyUsername ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 141  :     HRESULT _hr = put_proxyUsername(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+116]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 142  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201604
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201604:

; 143  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222244:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222246
	jmp	___CxxFrameHandler
text$x	ENDS
?PutproxyUsername@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutproxyUsername
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222257 DD	0ffffffffH
	DD	FLAT:$L222253
$T222255 DD	019930520H
	DD	01H
	DD	FLAT:$T222257
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z PROC NEAR ; ocspAX::IOcspClient::PutproxyPassword, COMDAT
; _this$ = ecx

; 145  : inline void IOcspClient::PutproxyPassword ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 146  :     HRESULT _hr = put_proxyPassword(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+120]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 147  :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201611
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201611:

; 148  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222253:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222255
	jmp	___CxxFrameHandler
text$x	ENDS
?PutproxyPassword@IOcspClient@ocspAX@@QAEXV_bstr_t@@@Z ENDP ; ocspAX::IOcspClient::PutproxyPassword
PUBLIC	?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z ; CSignature::GetSigPropValueByName
EXTRN	_wcschr:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_propEntry$212482 = -28					; size = 4
_equalPtr$ = -20					; size = 4
_nameLength$ = -16					; size = 4
_charPropName$ = -12					; size = 4
_propIndex$ = -8					; size = 4
_maxPropCount$ = -4					; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_propName$ = 16						; size = 4
_propValue$ = 20					; size = 4
?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z PROC NEAR ; CSignature::GetSigPropValueByName

; 12750: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12751: 	int maxPropCount=0, propIndex=0;

	mov	DWORD PTR _maxPropCount$[ebp], 0
	mov	DWORD PTR _propIndex$[ebp], 0

; 12752: 	unsigned char *charPropName=NULL;

	mov	DWORD PTR _charPropName$[ebp], 0

; 12753: 	int nameLength=0;

	mov	DWORD PTR _nameLength$[ebp], 0

; 12754: 	WCHAR *equalPtr;
; 12755: 
; 12756: 	EnterLog;
; 12757: 	if (sgArr==NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $L212474

; 12758: 	{
; 12759: 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12760: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212468
$L212474:

; 12761: 	}
; 12762: 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+24]
	jge	SHORT $L212477
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L212476
$L212477:

; 12763: 	{
; 12764: 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12765: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212468
$L212476:

; 12766: 	}
; 12767: 	maxPropCount = sgArr[sigIndex]->propNumber;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _maxPropCount$[ebp], edx

; 12768: 	for (propIndex = 0; propIndex < maxPropCount; propIndex++)

	mov	DWORD PTR _propIndex$[ebp], 0
	jmp	SHORT $L212479
$L212480:
	mov	eax, DWORD PTR _propIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _propIndex$[ebp], eax
$L212479:
	mov	ecx, DWORD PTR _propIndex$[ebp]
	cmp	ecx, DWORD PTR _maxPropCount$[ebp]
	jge	$L212481

; 12769: 	{
; 12770: 		BSTR propEntry;
; 12771: 		get_Properties(sigIndex, propIndex, &propEntry);

	mov	esi, esp
	lea	edx, DWORD PTR _propEntry$212482[ebp]
	push	edx
	mov	eax, DWORD PTR _propIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+60]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12772: 		equalPtr = wcschr(propEntry, L'=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _propEntry$212482[ebp]
	push	edx
	call	_wcschr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 12773: 		*equalPtr = L'\0';

	mov	eax, DWORD PTR _equalPtr$[ebp]
	mov	WORD PTR [eax], 0

; 12774: 		if (wcscmp((const WCHAR *)propEntry, propName) == 0)

	mov	ecx, DWORD PTR _propName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _propEntry$212482[ebp]
	push	edx
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L212484

; 12775: 		{
; 12776: //			equalPtr = wcschr(propEntry, L'=');
; 12777: 			if (*(equalPtr+1) == L' ')

	mov	eax, DWORD PTR _equalPtr$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $L212485

; 12778: 				equalPtr++;

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 2
	mov	DWORD PTR _equalPtr$[ebp], edx
$L212485:

; 12779: 			*propValue = SysAllocString(equalPtr+1);

	mov	eax, DWORD PTR _equalPtr$[ebp]
	add	eax, 2
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _propValue$[ebp]
	mov	DWORD PTR [ecx], eax

; 12780: 			SysFreeString(propEntry);

	mov	esi, esp
	mov	edx, DWORD PTR _propEntry$212482[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12781: 			break;

	jmp	SHORT $L212481
$L212484:

; 12782: 		}
; 12783: 		SysFreeString(propEntry);

	mov	esi, esp
	mov	eax, DWORD PTR _propEntry$212482[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12784: 	}

	jmp	$L212480
$L212481:

; 12785: 	ExitLog;
; 12786: 	return S_OK;

	xor	eax, eax
$L212468:

; 12787: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222264
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222264:
	DD	1
	DD	$L222263
$L222263:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L222262
$L222262:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z ENDP	; CSignature::GetSigPropValueByName
_TEXT	ENDS
PUBLIC	?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::Base64DecodeBufferToFile
xdata$x	SEGMENT
$T222290 DD	0ffffffffH
	DD	FLAT:$L222276
	DD	00H
	DD	FLAT:$L222277
	DD	01H
	DD	FLAT:$L222278
$T222280 DD	019930520H
	DD	03H
	DD	FLAT:$T222290
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222275 = -452						; size = 4
$T222274 = -448						; size = 4
$T222273 = -444						; size = 4
$T222272 = -440						; size = 4
$T222271 = -436						; size = 4
$T222270 = -432						; size = 4
$T222269 = -428						; size = 4
$T222268 = -424						; size = 4
$T222267 = -420						; size = 4
_length2$212525 = -416					; size = 4
_length1$212523 = -412					; size = 4
_charOutFilePath$212522 = -408				; size = 4
_license_file$212519 = -400				; size = 28
_charSecureXMLPath$212518 = -368			; size = 4
__lpa$ = -364						; size = 4
__lpw$ = -360						; size = 4
__acp$ = -356						; size = 4
__convert$ = -352					; size = 4
_FILE_SEP_STR$ = -348					; size = 4
_createTempFile$ = -344					; size = 4
_bstrFileName$ = -340					; size = 4
_tmpFilePath$ = -332					; size = 4
_hFile$ = -324						; size = 4
_TempPath$ = -316					; size = 260
_ccBstrEncodedBuffer$ = -48				; size = 4
_ccBstrFileName$ = -36					; size = 4
_sizeM$ = -28						; size = 4
_newPtr$ = -24						; size = 4
_ptr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_encodedBuffer$ = 12					; size = 4
_outFilePath$ = 16					; size = 4
_decodedFilePath$ = 20					; size = 4
?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::Base64DecodeBufferToFile

; 12790: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 440				; 000001b8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 12791: 	unsigned char *ptr, *newPtr;
; 12792: 	DWORD sizeM;
; 12793: 	CComBSTR ccBstrFileName, ccBstrEncodedBuffer;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 12794: 	char TempPath[MAX_PATH];
; 12795: 	FILE *hFile;
; 12796: 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 12797: 	BSTR bstrFileName=NULL;

	mov	DWORD PTR _bstrFileName$[ebp], 0

; 12798: 	BOOL createTempFile = FALSE;

	mov	DWORD PTR _createTempFile$[ebp], 0

; 12799: #ifdef WIN32
; 12800: 	const char *FILE_SEP_STR = "\\";

	mov	DWORD PTR _FILE_SEP_STR$[ebp], OFFSET FLAT:$SG212504

; 12801: #else
; 12802: 	const char *FILE_SEP_STR = "/";
; 12803: #endif
; 12804: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 12805: 
; 12806: 	EnterLog;
; 12807: 	ccBstrEncodedBuffer = encodedBuffer;

	mov	eax, DWORD PTR _encodedBuffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 12808: 	if (ccBstrEncodedBuffer.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L212509

; 12809: 	{
; 12810: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12811: 		return S_FALSE;

	mov	DWORD PTR $T222267[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222267[ebp]
	jmp	$L212492
$L212509:

; 12812: 	}
; 12813: 	ptr = HeapW2A(encodedBuffer);

	mov	eax, DWORD PTR _encodedBuffer$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 12814: 	sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 12815: 	sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 12816: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 12817: 	if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L212514

; 12818: 	{
; 12819: 		zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12820: 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12821: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 12822: 		return S_FALSE;

	mov	DWORD PTR $T222268[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222268[ebp]
	jmp	$L212492
$L212514:

; 12823: 	}
; 12824: 	zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12825: 
; 12826: 	ccBstrFileName = outFilePath;

	mov	eax, DWORD PTR _outFilePath$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 12827: 
; 12828: 	if ((ccBstrFileName.Length() != 0) && (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	$L212517
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3364], 1
	jne	$L212517

; 12829: 	{
; 12830: 		unsigned char *charSecureXMLPath = HeapW2A(SecureXMLPath.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSecureXMLPath$212518[ebp], eax

; 12831: 		string license_file = (char *)charSecureXMLPath;

	mov	ecx, DWORD PTR _charSecureXMLPath$212518[ebp]
	push	ecx
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 12832: 		license_file += FILE_SEP_STR;

	mov	edx, DWORD PTR _FILE_SEP_STR$[ebp]
	push	edx
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 12833: 		license_file += SECUREXML_LICENSE_FILENAME;

	push	OFFSET FLAT:$SG212521
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 12834: 		zFree(charSecureXMLPath);

	mov	eax, DWORD PTR _charSecureXMLPath$212518[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 12835: 		unsigned char *charOutFilePath = HeapW2A(outFilePath);

	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charOutFilePath$212522[ebp], eax

; 12836: 		int length1 = strlen((const char *)charOutFilePath);

	mov	edx, DWORD PTR _charOutFilePath$212522[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length1$212523[ebp], eax

; 12837: 		int length2 = strlen(license_file.c_str());

	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length2$212525[ebp], eax

; 12838: 		if (length1 != length2)

	mov	eax, DWORD PTR _length1$212523[ebp]
	cmp	eax, DWORD PTR _length2$212525[ebp]
	je	SHORT $L212526

; 12839: 			createTempFile = TRUE;

	mov	DWORD PTR _createTempFile$[ebp], 1

; 12840: 		else

	jmp	SHORT $L212527
$L212526:

; 12841: 			if (strnicmp(license_file.c_str(), (const char *)charOutFilePath, length1) == 0)

	mov	ecx, DWORD PTR _length1$212523[ebp]
	push	ecx
	mov	edx, DWORD PTR _charOutFilePath$212522[ebp]
	push	edx
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	_strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L212529

; 12842: 				createTempFile = FALSE;

	mov	DWORD PTR _createTempFile$[ebp], 0

; 12843: 			else

	jmp	SHORT $L212527
$L212529:

; 12844: 				createTempFile = TRUE;

	mov	DWORD PTR _createTempFile$[ebp], 1
$L212527:

; 12845: 		//if (stricmp(license_file.c_str(), (const char *)charOutFilePath) == 0)
; 12846: 		//	createTempFile = FALSE;
; 12847: 		//else
; 12848: 		//	createTempFile = TRUE;
; 12849: 		zFree(charOutFilePath);

	mov	eax, DWORD PTR _charOutFilePath$212522[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 12850: 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L212517:

; 12851: 
; 12852: 	if ((ccBstrFileName.Length() == 0) || (createTempFile == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L212532
	cmp	DWORD PTR _createTempFile$[ebp], 1
	jne	$L212531
$L212532:

; 12853: 	{
; 12854: 		// Create temporary file for saving decoded data
; 12855: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12856: 		GetTempFileName(TempPath, // dir. for temp. files 
; 12857: 			"INF",                // temp. file name prefix 
; 12858: 			0,                    // create unique name 
; 12859: 			szTempName);          // buffer for name

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG212534
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12860: 		bstrFileName = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 12861: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222269[ebp], eax
	mov	edx, DWORD PTR $T222269[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], edx

; 12862: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 12863: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T222270[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T222271[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 12864: 	}
; 12865: 	else

	jmp	SHORT $L212541
$L212531:

; 12866: 		bstrFileName = SysAllocString(outFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _outFilePath$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L212541:

; 12867: //		strcpy((char *)szTempName,(const char *)W2A(outFilePath));
; 12868: 	// open file in write mode 
; 12869: #ifdef WIN32
; 12870: 	if ((hFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG212543
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	$L212542

; 12871: #elif LINUX
; 12872: 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 12873: 	if ((hFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 12874: 			zFree(utf8FileName);
; 12875: #endif
; 12876: 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12877: 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12878: 			zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12879: 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L212544

; 12880: 			{
; 12881: 				tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L212544:

; 12882: 			}
; 12883: 			return S_FALSE;

	mov	DWORD PTR $T222272[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222272[ebp]
	jmp	$L212492
$L212542:

; 12884: 	}
; 12885: #ifdef LINUX
; 12886: 	zFree(utf8FileName);
; 12887: #endif
; 12888: 
; 12889: 	if (fwrite(newPtr, 1, sizeM, hFile) == 0)

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L212547

; 12890: 	{
; 12891: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 12892: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 12893: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L212548

; 12894: 		{
; 12895: 			tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L212548:

; 12896: 		}
; 12897: 		return S_FALSE;

	mov	DWORD PTR $T222273[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222273[ebp]
	jmp	$L212492
$L212547:

; 12898: 	}
; 12899: 	if (ferror(hFile))

	mov	eax, DWORD PTR _hFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 32					; 00000020H
	je	SHORT $L212551

; 12900: 	{
; 12901: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 12902: 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 12903: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L212552

; 12904: 		{
; 12905: 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L212552:

; 12906: 		}
; 12907: 		return S_FALSE;

	mov	DWORD PTR $T222274[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222274[ebp]
	jmp	SHORT $L212492
$L212551:

; 12908: 	}
; 12909: 	fclose(hFile);

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 12910: 	zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 12911: 	*decodedFilePath = bstrFileName;

	mov	eax, DWORD PTR _decodedFilePath$[ebp]
	mov	ecx, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [eax], ecx

; 12912: 	ExitLog;
; 12913: 	return S_OK;

	mov	DWORD PTR $T222275[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222275[ebp]
$L212492:

; 12914: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222289
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222289:
	DD	5
	DD	$L222288
$L222288:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L222281
	DD	-48					; ffffffd0H
	DD	4
	DD	$L222282
	DD	-316					; fffffec4H
	DD	260					; 00000104H
	DD	$L222283
	DD	-332					; fffffeb4H
	DD	4
	DD	$L222284
	DD	-400					; fffffe70H
	DD	28					; 0000001cH
	DD	$L222285
$L222285:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L222284:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222283:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222282:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L222281:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222276:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222277:
	lea	ecx, DWORD PTR _ccBstrEncodedBuffer$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222278:
	lea	ecx, DWORD PTR _license_file$212519[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222280
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z ENDP ; CSignature::Base64DecodeBufferToFile
PUBLIC	?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::Base64DecodeFileToFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -32						; size = 4
__lpw$ = -28						; size = 4
__acp$ = -24						; size = 4
__convert$ = -20					; size = 4
_readResult$ = -16					; size = 4
_bstrData$ = -8						; size = 4
_this$ = 8						; size = 4
_encodedFilePath$ = 12					; size = 4
_outFilePath$ = 16					; size = 4
_decodedFilePath$ = 20					; size = 4
?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::Base64DecodeFileToFile

; 12917: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 12918: 	BSTR bstrData;
; 12919: 	HRESULT readResult;
; 12920: 
; 12921: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 12922: 	EnterLog;    
; 12923: 	if ((readResult = ReadAll(encodedFilePath,&bstrData)) == S_FALSE)

	mov	esi, esp
	lea	eax, DWORD PTR _bstrData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _encodedFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+236]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _readResult$[ebp], eax
	cmp	DWORD PTR _readResult$[ebp], 1
	jne	SHORT $L212570

; 12924: 	{
; 12925: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L212562
$L212570:

; 12926: 	}
; 12927: 	Base64DecodeBufferToFile(bstrData, outFilePath, decodedFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _decodedFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _outFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+564]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12928: 	SysFreeString(bstrData);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrData$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 12929: 	ExitLog;
; 12930: 	return S_OK;

	xor	eax, eax
$L212562:

; 12931: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222294
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222294:
	DD	1
	DD	$L222293
$L222293:
	DD	-8					; fffffff8H
	DD	4
	DD	$L222292
$L222292:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z ENDP ; CSignature::Base64DecodeFileToFile
_TEXT	ENDS
PUBLIC	?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z		; CSignature::GunZipFile
EXTRN	_gzopen:NEAR
EXTRN	_gzread:NEAR
EXTRN	_gzclose:NEAR
xdata$x	SEGMENT
$T222315 DD	0ffffffffH
	DD	FLAT:$L222305
$T222307 DD	019930520H
	DD	01H
	DD	FLAT:$T222315
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222304 = -380						; size = 4
$T222303 = -376						; size = 4
$T222302 = -372						; size = 4
$T222301 = -368						; size = 4
$T222300 = -364						; size = 4
$T222299 = -360						; size = 4
$T222298 = -356						; size = 4
$T222297 = -352						; size = 4
_agUnZippedFile$212611 = -348				; size = 4
_agZippedFile$ = -344					; size = 4
__lpa$ = -340						; size = 4
__lpw$ = -336						; size = 4
__acp$ = -332						; size = 4
__convert$ = -328					; size = 4
_tmpFilePath$ = -320					; size = 4
_TempPath$ = -308					; size = 260
_ccBstrFileName$ = -40					; size = 4
_outFHandle$ = -32					; size = 4
_file$ = -28						; size = 4
_uncomprLen$ = -24					; size = 4
_uncompr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_gZippedFile$ = 12					; size = 4
_gUnZippedFile$ = 16					; size = 4
_gUnZippedFilePath$ = 20				; size = 4
?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR	; CSignature::GunZipFile

; 13041: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 368				; 00000170H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 13042:     Byte *uncompr;
; 13043:     uLong uncomprLen=GUNZIP_BLOCK_SIZE;

	mov	DWORD PTR _uncomprLen$[ebp], 16384	; 00004000H

; 13044: 	gzFile file;
; 13045: 	FILE *outFHandle;
; 13046: 	CComBSTR ccBstrFileName;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 13047: 	char TempPath[MAX_PATH];
; 13048: 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 13049: 
; 13050: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 13051: 	EnterLog;
; 13052: 	if (!LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L212590

; 13053: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 13054: 		return S_FALSE;

	mov	DWORD PTR $T222297[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222297[ebp]
	jmp	$L212578
$L212590:

; 13055: 	}
; 13056: 	if (!LicObj.getVerifyAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getVerifyAllowed@CLicense@@QAEHXZ	; CLicense::getVerifyAllowed
	test	eax, eax
	jne	SHORT $L212593

; 13057: 		setError(SigHandle, NO_VERIFICATION_LIC);

	push	44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13058: 		return S_FALSE;

	mov	DWORD PTR $T222298[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222298[ebp]
	jmp	$L212578
$L212593:

; 13059: 	}
; 13060: 
; 13061: 	char *agZippedFile = (char *)HeapW2A(gZippedFile);

	mov	ecx, DWORD PTR _gZippedFile$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _agZippedFile$[ebp], eax

; 13062: 	file = gzopen(agZippedFile, "rb");

	push	OFFSET FLAT:$SG212598
	mov	edx, DWORD PTR _agZippedFile$[ebp]
	push	edx
	call	_gzopen
	add	esp, 8
	mov	DWORD PTR _file$[ebp], eax

; 13063: 	zFree(agZippedFile);

	mov	eax, DWORD PTR _agZippedFile$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 13064:     if (file == NULL)

	cmp	DWORD PTR _file$[ebp], 0
	jne	SHORT $L212599

; 13065: 	{
; 13066: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 13067: 		return S_FALSE;

	mov	DWORD PTR $T222299[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222299[ebp]
	jmp	$L212578
$L212599:

; 13068: 	}
; 13069: 
; 13070: 	ccBstrFileName = gUnZippedFile;

	mov	eax, DWORD PTR _gUnZippedFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 13071: 
; 13072: 	if (ccBstrFileName.Length() == 0)

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	$L212602

; 13073: 	{
; 13074: 		// Create temporary file for saving decoded data
; 13075: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13076: 		GetTempFileName(TempPath, // dir. for temp. files 
; 13077: 			"INF",                // temp. file name prefix 
; 13078: 			0,                    // create unique name 
; 13079: 			szTempName);          // buffer for name 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG212604
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13080: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222300[ebp], eax
	mov	ecx, DWORD PTR $T222300[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 13081: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 13082: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222301[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T222302[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 13083: 	}
; 13084: 	else

	jmp	SHORT $L212610
$L212602:

; 13085: 	{
; 13086: 		char *agUnZippedFile = (char *)HeapW2A(gUnZippedFile);

	mov	ecx, DWORD PTR _gUnZippedFile$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _agUnZippedFile$212611[ebp], eax

; 13087: 		strcpy((char *)szTempName, agUnZippedFile);

	mov	edx, DWORD PTR _agUnZippedFile$212611[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	_strcpy
	add	esp, 8

; 13088: 		zFree(agUnZippedFile);

	mov	ecx, DWORD PTR _agUnZippedFile$212611[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L212610:

; 13089: 	}
; 13090: 
; 13091: 	outFHandle = fopen((const char*)szTempName, "wb");

	push	OFFSET FLAT:$SG212615
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _outFHandle$[ebp], eax

; 13092: 	if (outFHandle == NULL)

	cmp	DWORD PTR _outFHandle$[ebp], 0
	jne	SHORT $L212616

; 13093: 	{
; 13094: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 13095: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L212617

; 13096: 		{
; 13097: 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L212617:

; 13098: 		}
; 13099: 		return S_FALSE;

	mov	DWORD PTR $T222303[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222303[ebp]
	jmp	$L212578
$L212616:

; 13100: 	}
; 13101: 	uncompr = (Byte *)zMalloc(GUNZIP_BLOCK_SIZE);

	push	16384					; 00004000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _uncompr$[ebp], eax
$L212622:

; 13102: 	while (1)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $L212623

; 13103: 	{
; 13104: 		uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);

	mov	edx, DWORD PTR _uncomprLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _uncompr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_gzread
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uncomprLen$[ebp], eax

; 13105: 		if (uncomprLen > 0) {

	cmp	DWORD PTR _uncomprLen$[ebp], 0
	jbe	SHORT $L212625

; 13106: 			fwrite(uncompr, 1, uncomprLen,outFHandle);

	mov	edx, DWORD PTR _outFHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _uncomprLen$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _uncompr$[ebp]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 13107: 		}
; 13108: 		else

	jmp	SHORT $L212626
$L212625:

; 13109: 			break;

	jmp	SHORT $L212623
$L212626:

; 13110: 	}

	jmp	SHORT $L212622
$L212623:

; 13111: 	zFree(uncompr);

	mov	edx, DWORD PTR _uncompr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 13112: 	fclose(outFHandle);

	mov	eax, DWORD PTR _outFHandle$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 13113: 	gzclose(file);

	mov	ecx, DWORD PTR _file$[ebp]
	push	ecx
	call	_gzclose
	add	esp, 4

; 13114: 	*gUnZippedFilePath = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _gUnZippedFilePath$[ebp]
	mov	DWORD PTR [ecx], eax

; 13115: 	ExitLog;
; 13116: 	return S_OK;

	mov	DWORD PTR $T222304[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222304[ebp]
$L212578:

; 13117: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222314
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222314:
	DD	3
	DD	$L222313
$L222313:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L222308
	DD	-308					; fffffeccH
	DD	260					; 00000104H
	DD	$L222309
	DD	-320					; fffffec0H
	DD	4
	DD	$L222310
$L222310:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222309:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222308:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222305:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222307
	jmp	___CxxFrameHandler
text$x	ENDS
?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z ENDP		; CSignature::GunZipFile
PUBLIC	?FreeBufferLinkedList@CSignature@@QAEXPAUBufferLinkedList@@@Z ; CSignature::FreeBufferLinkedList
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_cur$ = -8						; size = 4
_this$ = -4						; size = 4
_listHeadPtr$ = 8					; size = 4
?FreeBufferLinkedList@CSignature@@QAEXPAUBufferLinkedList@@@Z PROC NEAR ; CSignature::FreeBufferLinkedList
; _this$ = ecx

; 13120: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 13121: 	BufferLinkedList *cur;
; 13122: 	cur = listHeadPtr;

	mov	eax, DWORD PTR _listHeadPtr$[ebp]
	mov	DWORD PTR _cur$[ebp], eax

; 13123: 	if (cur->next == NULL)

	mov	ecx, DWORD PTR _cur$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $L212635

; 13124: 	{
; 13125: 		zFree(cur->bufferPtr);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4

; 13126: 		zFree(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 13127: 	}
; 13128: 	else

	jmp	SHORT $L212633
$L212635:

; 13129: 	{
; 13130: 		FreeBufferLinkedList(cur->next);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeBufferLinkedList@CSignature@@QAEXPAUBufferLinkedList@@@Z ; CSignature::FreeBufferLinkedList

; 13131: 		cur->next = NULL;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 13132: 		zFree(cur->bufferPtr);

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_rFree
	add	esp, 4

; 13133: 		zFree(cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L212633:

; 13134: 	}
; 13135: }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FreeBufferLinkedList@CSignature@@QAEXPAUBufferLinkedList@@@Z ENDP ; CSignature::FreeBufferLinkedList
_TEXT	ENDS
PUBLIC	?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z ; CSignature::get_CertSerialNumberFormat
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z PROC NEAR ; CSignature::get_CertSerialNumberFormat

; 13137: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13138: 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 13139: 	EnterLog;
; 13140: 	*pVal = CertSerialNumberFormat;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3324]
	mov	DWORD PTR [eax], edx

; 13141: 	ExitLog;
; 13142: 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 13143: }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_CertSerialNumberFormat
_TEXT	ENDS
PUBLIC	?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z	; CSignature::put_CertSerialNumberFormat
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_hResult$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z PROC NEAR ; CSignature::put_CertSerialNumberFormat

; 13146: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13147: 	HRESULT hResult=S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 13148: 	EnterLog;
; 13149: 	CertSerialNumberFormat = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+3324], ecx

; 13150: 	ExitLog;
; 13151: 	return hResult;

	mov	eax, DWORD PTR _hResult$[ebp]

; 13152: }

	mov	esp, ebp
	pop	ebp
	ret	8
?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z ENDP	; CSignature::put_CertSerialNumberFormat
; Function compile flags: /Odt /RTCsu
_j$212663 = -64					; size = 4
_d$ = -60						; size = 4
_s$ = -52						; size = 30
_buff$ = -16						; size = 4
_dwSizeBuf$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_base64Bin$ = 8						; size = 4
?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z PROC NEAR	; CSignature::Base64BinToPlainHex
; _this$ = ecx

; 13154: {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 13155: 	DWORD dwSizeBuf=0;

	mov	DWORD PTR _dwSizeBuf$[ebp], 0

; 13156: 	BYTE *buff=NULL;

	mov	DWORD PTR _buff$[ebp], 0

; 13157: 	char s[30];
; 13158: 	unsigned char *d;
; 13159: 	
; 13160: 	EnterLog;
; 13161: 	if (base64Bin == NULL)

	cmp	DWORD PTR _base64Bin$[ebp], 0
	jne	SHORT $L212657

; 13162: 		return NULL;

	xor	eax, eax
	jmp	$L212652
$L212657:

; 13163: 
; 13164: 	dwSizeBuf = base64decodeSize(strlen((const char *)base64Bin));

	mov	eax, DWORD PTR _base64Bin$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _dwSizeBuf$[ebp], eax

; 13165: 	buff = (unsigned char *) zMalloc (dwSizeBuf);

	mov	ecx, DWORD PTR _dwSizeBuf$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buff$[ebp], eax

; 13166: 	memset(buff,0,dwSizeBuf);

	mov	edx, DWORD PTR _dwSizeBuf$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13167: 	if ((dwSizeBuf = base64decode(base64Bin,buff,dwSizeBuf))==-1) 

	mov	ecx, DWORD PTR _dwSizeBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	mov	eax, DWORD PTR _base64Bin$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwSizeBuf$[ebp], eax
	cmp	DWORD PTR _dwSizeBuf$[ebp], -1
	jne	SHORT $L212660

; 13168: 	{	
; 13169: 		if (buff) zFree (buff);		

	cmp	DWORD PTR _buff$[ebp], 0
	je	SHORT $L212660
	mov	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L212660:

; 13170: 	}
; 13171: 	
; 13172: 	d = (unsigned char *)zMalloc(256);

	push	256					; 00000100H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 13173: 	memset(d,0,256);

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 13174: 	for(int j=dwSizeBuf;j>0;j--){

	mov	eax, DWORD PTR _dwSizeBuf$[ebp]
	mov	DWORD PTR _j$212663[ebp], eax
	jmp	SHORT $L212664
$L212665:
	mov	ecx, DWORD PTR _j$212663[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$212663[ebp], ecx
$L212664:
	cmp	DWORD PTR _j$212663[ebp], 0
	jle	SHORT $L212666

; 13175: 		sprintf(s,"%02x",(int)buff[j-1]);

	mov	edx, DWORD PTR _buff$[ebp]
	add	edx, DWORD PTR _j$212663[ebp]
	movzx	eax, BYTE PTR [edx-1]
	push	eax
	push	OFFSET FLAT:$SG212668
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 13176: 		strcat((char *)d,s);

	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 13177: 		strcat((char *)d," ");

	push	OFFSET FLAT:$SG212671
	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 13178: 	}

	jmp	SHORT $L212665
$L212666:

; 13179: 	zFree (buff);

	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 13180: 	ExitLog;
; 13181: 	return d;

	mov	eax, DWORD PTR _d$[ebp]
$L212652:

; 13182: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222324
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222324:
	DD	1
	DD	$L222323
$L222323:
	DD	-52					; ffffffccH
	DD	30					; 0000001eH
	DD	$L222321
$L222321:
	DB	115					; 00000073H
	DB	0
?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ENDP	; CSignature::Base64BinToPlainHex
_TEXT	ENDS
PUBLIC	?HexToUnsignedChar@@YAEE@Z			; HexToUnsignedChar
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv65 = -4						; size = 4
_inputVal$ = 8						; size = 1
?HexToUnsignedChar@@YAEE@Z PROC NEAR			; HexToUnsignedChar

; 13185: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13186: 	switch (inputVal)

	movzx	eax, BYTE PTR _inputVal$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 54			; 00000036H
	ja	SHORT $L212701
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $L222326[edx]
	jmp	DWORD PTR $L222327[eax*4]
$L212679:

; 13187: 	{
; 13188: 		case '0': return 0;

	xor	al, al
	jmp	SHORT $L212674
$L212680:

; 13189: 		case '1': return 1;

	mov	al, 1
	jmp	SHORT $L212674
$L212681:

; 13190: 		case '2': return 2;

	mov	al, 2
	jmp	SHORT $L212674
$L212682:

; 13191: 		case '3': return 3;

	mov	al, 3
	jmp	SHORT $L212674
$L212683:

; 13192: 		case '4': return 4;

	mov	al, 4
	jmp	SHORT $L212674
$L212684:

; 13193: 		case '5': return 5;

	mov	al, 5
	jmp	SHORT $L212674
$L212685:

; 13194: 		case '6': return 6;

	mov	al, 6
	jmp	SHORT $L212674
$L212686:

; 13195: 		case '7': return 7;

	mov	al, 7
	jmp	SHORT $L212674
$L212687:

; 13196: 		case '8': return 8;

	mov	al, 8
	jmp	SHORT $L212674
$L212688:

; 13197: 		case '9': return 9;

	mov	al, 9
	jmp	SHORT $L212674
$L212689:

; 13198: 		case 'a': return 10;

	mov	al, 10					; 0000000aH
	jmp	SHORT $L212674
$L212690:

; 13199: 		case 'A': return 10;

	mov	al, 10					; 0000000aH
	jmp	SHORT $L212674
$L212691:

; 13200: 		case 'b': return 11;

	mov	al, 11					; 0000000bH
	jmp	SHORT $L212674
$L212692:

; 13201: 		case 'B': return 11;

	mov	al, 11					; 0000000bH
	jmp	SHORT $L212674
$L212693:

; 13202: 		case 'c': return 12;

	mov	al, 12					; 0000000cH
	jmp	SHORT $L212674
$L212694:

; 13203: 		case 'C': return 12;

	mov	al, 12					; 0000000cH
	jmp	SHORT $L212674
$L212695:

; 13204: 		case 'd': return 13;

	mov	al, 13					; 0000000dH
	jmp	SHORT $L212674
$L212696:

; 13205: 		case 'D': return 13;

	mov	al, 13					; 0000000dH
	jmp	SHORT $L212674
$L212697:

; 13206: 		case 'e': return 14;

	mov	al, 14					; 0000000eH
	jmp	SHORT $L212674
$L212698:

; 13207: 		case 'E': return 14;

	mov	al, 14					; 0000000eH
	jmp	SHORT $L212674
$L212699:

; 13208: 		case 'f': return 15;

	mov	al, 15					; 0000000fH
	jmp	SHORT $L212674
$L212700:

; 13209: 		case 'F': return 15;

	mov	al, 15					; 0000000fH
	jmp	SHORT $L212674
$L212701:

; 13210: 		default: return 0;

	xor	al, al
$L212674:

; 13211: 	}
; 13212: }

	mov	esp, ebp
	pop	ebp
	ret	0
$L222327:
	DD	$L212679
	DD	$L212680
	DD	$L212681
	DD	$L212682
	DD	$L212683
	DD	$L212684
	DD	$L212685
	DD	$L212686
	DD	$L212687
	DD	$L212688
	DD	$L212690
	DD	$L212692
	DD	$L212694
	DD	$L212696
	DD	$L212698
	DD	$L212700
	DD	$L212689
	DD	$L212691
	DD	$L212693
	DD	$L212695
	DD	$L212697
	DD	$L212699
	DD	$L212701
$L222326:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	6
	DB	7
	DB	8
	DB	9
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	22					; 00000016H
	DB	16					; 00000010H
	DB	17					; 00000011H
	DB	18					; 00000012H
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	21					; 00000015H
?HexToUnsignedChar@@YAEE@Z ENDP				; HexToUnsignedChar
_TEXT	ENDS
PUBLIC	?HexStrToUnsignedChar@@YAEPAE@Z			; HexStrToUnsignedChar
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_tensVal$ = -3						; size = 1
_unitsVal$ = -2						; size = 1
_outNum$ = -1						; size = 1
_hexStr$ = 8						; size = 4
?HexStrToUnsignedChar@@YAEPAE@Z PROC NEAR		; HexStrToUnsignedChar

; 13215: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13216: 	unsigned char outNum;
; 13217: 	unsigned char unitsVal;
; 13218: 	unsigned char tensVal;
; 13219: 
; 13220: 	unitsVal = HexToUnsignedChar(hexStr[1]);

	mov	eax, DWORD PTR _hexStr$[ebp]
	mov	cl, BYTE PTR [eax+1]
	push	ecx
	call	?HexToUnsignedChar@@YAEE@Z		; HexToUnsignedChar
	add	esp, 4
	mov	BYTE PTR _unitsVal$[ebp], al

; 13221: 	tensVal = HexToUnsignedChar(hexStr[0]);

	mov	edx, DWORD PTR _hexStr$[ebp]
	mov	al, BYTE PTR [edx]
	push	eax
	call	?HexToUnsignedChar@@YAEE@Z		; HexToUnsignedChar
	add	esp, 4
	mov	BYTE PTR _tensVal$[ebp], al

; 13222: 	outNum = 16 * tensVal + unitsVal;

	movzx	ecx, BYTE PTR _tensVal$[ebp]
	shl	ecx, 4
	movzx	edx, BYTE PTR _unitsVal$[ebp]
	add	ecx, edx
	mov	BYTE PTR _outNum$[ebp], cl

; 13223: 	return outNum;

	mov	al, BYTE PTR _outNum$[ebp]

; 13224: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?HexStrToUnsignedChar@@YAEPAE@Z ENDP			; HexStrToUnsignedChar
; Function compile flags: /Odt /RTCsu
_i$212722 = -40					; size = 4
_binLen$ = -36						; size = 4
_plainHexLen$ = -32					; size = 4
_d$ = -28						; size = 4
_s$ = -20						; size = 4
_buff$ = -12						; size = 4
_dwSizeBuf$ = -8					; size = 4
_this$ = -4						; size = 4
_plainHex$ = 8						; size = 4
?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z PROC NEAR	; CSignature::PlainHexToBase64Bin
; _this$ = ecx

; 13227: {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 13228: 	DWORD dwSizeBuf=0;

	mov	DWORD PTR _dwSizeBuf$[ebp], 0

; 13229: 	BYTE *buff=NULL;

	mov	DWORD PTR _buff$[ebp], 0

; 13230: 	unsigned char s[4];
; 13231: 	unsigned char *d=NULL;

	mov	DWORD PTR _d$[ebp], 0

; 13232: 	unsigned int plainHexLen=0, binLen=0;

	mov	DWORD PTR _plainHexLen$[ebp], 0
	mov	DWORD PTR _binLen$[ebp], 0

; 13233: 
; 13234: 	EnterLog;
; 13235: 	if (plainHex == NULL)

	cmp	DWORD PTR _plainHex$[ebp], 0
	jne	SHORT $L212718

; 13236: 		return NULL;

	xor	eax, eax
	jmp	$L212711
$L212718:

; 13237: 
; 13238: 	if ((plainHexLen = strlen((const char *)plainHex)) == 0)

	mov	eax, DWORD PTR _plainHex$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _plainHexLen$[ebp], eax
	cmp	DWORD PTR _plainHexLen$[ebp], 0
	jne	SHORT $L212720

; 13239: 		return NULL;

	xor	eax, eax
	jmp	$L212711
$L212720:

; 13240: 
; 13241: 	binLen = (plainHexLen + 1) / 3;

	mov	eax, DWORD PTR _plainHexLen$[ebp]
	add	eax, 1
	xor	edx, edx
	mov	ecx, 3
	div	ecx
	mov	DWORD PTR _binLen$[ebp], eax

; 13242: 
; 13243: 	buff = (BYTE *)zMalloc(binLen);

	mov	edx, DWORD PTR _binLen$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _buff$[ebp], eax

; 13244: 
; 13245: 	for (unsigned int i=0; i<binLen; i++)

	mov	DWORD PTR _i$212722[ebp], 0
	jmp	SHORT $L212723
$L212724:
	mov	eax, DWORD PTR _i$212722[ebp]
	add	eax, 1
	mov	DWORD PTR _i$212722[ebp], eax
$L212723:
	mov	ecx, DWORD PTR _i$212722[ebp]
	cmp	ecx, DWORD PTR _binLen$[ebp]
	jae	SHORT $L212725

; 13246: 	{
; 13247: 		memset(s,0,4);

	push	4
	push	0
	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 13248: 		memcpy(s, (const void *)(plainHex + (i*3)),2);

	push	2
	mov	eax, DWORD PTR _i$212722[ebp]
	imul	eax, 3
	add	eax, DWORD PTR _plainHex$[ebp]
	push	eax
	lea	ecx, DWORD PTR _s$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 13249: 		buff[binLen - i -1] = (BYTE)HexStrToUnsignedChar(s);

	lea	edx, DWORD PTR _s$[ebp]
	push	edx
	call	?HexStrToUnsignedChar@@YAEPAE@Z		; HexStrToUnsignedChar
	add	esp, 4
	mov	ecx, DWORD PTR _binLen$[ebp]
	sub	ecx, DWORD PTR _i$212722[ebp]
	mov	edx, DWORD PTR _buff$[ebp]
	mov	BYTE PTR [edx+ecx-1], al

; 13250: 	}

	jmp	SHORT $L212724
$L212725:

; 13251: 
; 13252: 	dwSizeBuf = base64encodeSize(binLen);

	mov	eax, DWORD PTR _binLen$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _dwSizeBuf$[ebp], eax

; 13253: 	d = (unsigned char *) zMalloc (dwSizeBuf+1);

	mov	ecx, DWORD PTR _dwSizeBuf$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _d$[ebp], eax

; 13254: 	memset(d,0,dwSizeBuf+1);

	mov	edx, DWORD PTR _dwSizeBuf$[ebp]
	add	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13255: 	if ((dwSizeBuf = base64encode(buff,binLen, d,dwSizeBuf+1))==-1) 

	mov	ecx, DWORD PTR _dwSizeBuf$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _d$[ebp]
	push	edx
	mov	eax, DWORD PTR _binLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dwSizeBuf$[ebp], eax
	cmp	DWORD PTR _dwSizeBuf$[ebp], -1
	jne	SHORT $L212729

; 13256: 	{	
; 13257: 		if (buff) zFree (buff);

	cmp	DWORD PTR _buff$[ebp], 0
	je	SHORT $L212730
	mov	edx, DWORD PTR _buff$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L212730:

; 13258: 		if (d) zFree (d);

	cmp	DWORD PTR _d$[ebp], 0
	je	SHORT $L212731
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L212731:

; 13259: 		return NULL;

	xor	eax, eax
	jmp	SHORT $L212711
$L212729:

; 13260: 	}
; 13261: 	zFree (buff);

	mov	ecx, DWORD PTR _buff$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 13262: 	ExitLog;
; 13263: 	return d;

	mov	eax, DWORD PTR _d$[ebp]
$L212711:

; 13264: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222332
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222332:
	DD	1
	DD	$L222331
$L222331:
	DD	-20					; ffffffecH
	DD	4
	DD	$L222330
$L222330:
	DB	115					; 00000073H
	DB	0
?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z ENDP	; CSignature::PlainHexToBase64Bin
_TEXT	ENDS
PUBLIC	?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z ; CSignature::SecureXMLVerifyFileToBuffer
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_signedXML$ = -8					; size = 4
_this$ = 8						; size = 4
_signedXMLFile$ = 12					; size = 4
_verificationResponse$ = 16				; size = 4
?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::SecureXMLVerifyFileToBuffer

; 13267: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13268: 	BSTR signedXML=NULL;

	mov	DWORD PTR _signedXML$[ebp], 0

; 13269: 	EnterLog;
; 13270: 	ReadAll(signedXMLFile, &signedXML);

	mov	esi, esp
	lea	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedXMLFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+236]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13271: 	if (signedXML != NULL)

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L212738

; 13272: 	{
; 13273: 		SecureXMLVerify(signedXML, verificationResponse);

	mov	esi, esp
	mov	edx, DWORD PTR _verificationResponse$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+248]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13274: 		SysFreeString(signedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212738:

; 13275: 	}
; 13276: 	ExitLog;
; 13277: 	return S_OK;

	xor	eax, eax

; 13278: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222336
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222336:
	DD	1
	DD	$L222335
$L222335:
	DD	-8					; fffffff8H
	DD	4
	DD	$L222334
$L222334:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z ENDP ; CSignature::SecureXMLVerifyFileToBuffer
_TEXT	ENDS
PUBLIC	?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::SecureXMLVerifyFileToFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_verificationResponse$ = -20				; size = 4
_signedXML$ = -8					; size = 4
_this$ = 8						; size = 4
_signedXMLFile$ = 12					; size = 4
_outFilePath$ = 16					; size = 4
_verificationResponseFilePath$ = 20			; size = 4
?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::SecureXMLVerifyFileToFile

; 13280: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 13281: 	BSTR signedXML=NULL, verificationResponse=NULL;

	mov	DWORD PTR _signedXML$[ebp], 0
	mov	DWORD PTR _verificationResponse$[ebp], 0

; 13282: 	EnterLog;
; 13283: 	ReadAll(signedXMLFile, &signedXML);

	mov	esi, esp
	lea	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedXMLFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+236]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13284: 	if (signedXML != NULL)

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L212748

; 13285: 	{
; 13286: 		SecureXMLVerify(signedXML, &verificationResponse);

	mov	esi, esp
	lea	edx, DWORD PTR _verificationResponse$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+248]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13287: 		SysFreeString(signedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13288: 		if (verificationResponse != NULL)

	cmp	DWORD PTR _verificationResponse$[ebp], 0
	je	SHORT $L212748

; 13289: 		{
; 13290: 			SaveXMLStr(verificationResponse, outFilePath, verificationResponseFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _verificationResponseFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _outFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _verificationResponse$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+240]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13291:             SysFreeString(verificationResponse);

	mov	esi, esp
	mov	edx, DWORD PTR _verificationResponse$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212748:

; 13292: 		}
; 13293: 	}
; 13294: 	ExitLog;
; 13295: 	return S_OK;

	xor	eax, eax

; 13296: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222341
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222341:
	DD	2
	DD	$L222340
$L222340:
	DD	-8					; fffffff8H
	DD	4
	DD	$L222338
	DD	-20					; ffffffecH
	DD	4
	DD	$L222339
$L222339:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	0
$L222338:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z ENDP ; CSignature::SecureXMLVerifyFileToFile
_TEXT	ENDS
PUBLIC	?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::DeleteSignatureFromXMLStr
EXTRN	_xmlUnlinkNode:NEAR
EXTRN	_xmlFreeNode:NEAR
EXTRN	_xmlDocDumpMemory:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_dataPtr$212808 = -112					; size = 4
_pbData$212800 = -108					; size = 4
_cbData$212799 = -104					; size = 4
_newXMLStr$ = -96					; size = 4
_sigNode$ = -88						; size = 4
_freeNewPtr$ = -84					; size = 4
__lpa$ = -80						; size = 4
__lpw$ = -76						; size = 4
__acp$ = -72						; size = 4
__convert$ = -68					; size = 4
_charSigId$ = -64					; size = 4
_sizeM$ = -60						; size = 4
_szPtr$ = -56						; size = 4
_curPtr$ = -52						; size = 4
_newPtr$ = -48						; size = 4
_ptr$ = -44						; size = 4
_xpathResultPtr$ = -40					; size = 4
_xpathPtr$ = -36					; size = 4
_iSize$ = -28						; size = 4
_mem$ = -20						; size = 4
_parent$ = -16						; size = 4
_rootNode$ = -12					; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_this$ = 8						; size = 4
_xmlStr$ = 12						; size = 4
_sigId$ = 16						; size = 4
_newSigXMLStr$ = 20					; size = 4
?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::DeleteSignatureFromXMLStr

; 13298: {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-112]
	mov	ecx, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13299: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 13300: 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 13301: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 13302: 	int iSize;
; 13303: 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 13304: 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 13305: 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 13306: 	unsigned int *szPtr;
; 13307: 	unsigned int sizeM;
; 13308: 	char *charSigId;
; 13309: 
; 13310: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 13311: 	EnterLog;
; 13312: 	BOOL freeNewPtr=FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 13313: 	if (Base64DecodeXML == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2184], 0
	jne	$L212776

; 13314: 	{
; 13315: 		ptr = (unsigned char *)xmlStr;

	mov	ecx, DWORD PTR _xmlStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], ecx

; 13316: 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	edx, DWORD PTR _ptr$[ebp]
	sub	edx, 4
	mov	DWORD PTR _szPtr$[ebp], edx

; 13317: 		sizeM = (*szPtr);

	mov	eax, DWORD PTR _szPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _sizeM$[ebp], ecx

; 13318: 
; 13319: 		if (((*ptr == 0xff) && (*(ptr + 1) == 0xfe)) ||
; 13320: 			((*ptr == 0xfe) && (*(ptr + 1) == 0xff)))

	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L212782
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 254				; 000000feH
	je	SHORT $L212781
$L212782:
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 254				; 000000feH
	jne	SHORT $L212780
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx+1]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $L212780
$L212781:

; 13321: 		{
; 13322: 			// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 13323: 			newPtr = ptr;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], ecx

; 13324: 		}
; 13325: 		else

	jmp	SHORT $L212783
$L212780:

; 13326: 		{
; 13327: 			newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 4
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 13328: 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 13329: 
; 13330: 			FileEncoding(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 13331: //			*newPtr = 0xFF;
; 13332: //			*(newPtr + 1) = 0xFE;
; 13333: 
; 13334: 			memcpy(newPtr+2, ptr, sizeM + 2);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	add	eax, 2
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 13335: 			sizeM += 4;

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	mov	DWORD PTR _sizeM$[ebp], ecx
$L212783:

; 13336: 		}
; 13337: 	}
; 13338: 	else

	jmp	$L212785
$L212776:

; 13339: 	{
; 13340: 		ptr = HeapW2A(xmlStr);

	mov	edx, DWORD PTR _xmlStr$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 13341: 		sizeM = strlen((const char *)ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 13342: 		sizeM = base64decodeSize(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 13343: 		newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 13344: 		freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 13345: 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L212788

; 13346: 		{
; 13347: 			zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 13348: 			zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 13349: 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13350: 			return S_FALSE;

	mov	eax, 1
	jmp	$L212756
$L212788:

; 13351: 		}
; 13352: 		zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L212785:

; 13353: 	}
; 13354: 
; 13355: 	// original document
; 13356: 	doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 13357: 	if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L212791

; 13358: 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L212791:

; 13359: 
; 13360: 	rootNode = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _rootNode$[ebp], eax

; 13361: 	charSigId = (char *)HeapW2A(sigId);

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 13362: 	xmlNodePtr sigNode = xsSigNodeById((const xmlNodePtr) rootNode, (const xmlChar *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 13363: 	zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 13364: 	if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L212796

; 13365: 	{
; 13366: 		xmlUnlinkNode(sigNode);

	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlUnlinkNode
	add	esp, 4

; 13367: 		xmlFreeNode(sigNode);

	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	call	_xmlFreeNode
	add	esp, 4
$L212796:

; 13368: 	}
; 13369: 
; 13370: 	xmlChar *newXMLStr;
; 13371: 	xmlDocDumpMemory(doc,&newXMLStr,&iSize);

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _newXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocDumpMemory
	add	esp, 12					; 0000000cH

; 13372: 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 13373: 
; 13374: 	if (Base64DecodeXML == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2184], 1
	jne	$L212798

; 13375: 	{
; 13376: 	// Base64 encode
; 13377: 		unsigned int cbData;
; 13378: 		unsigned char *pbData;
; 13379: 		cbData = base64encodeSize(iSize+1);

	mov	edx, DWORD PTR _iSize$[ebp]
	add	edx, 1
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$212799[ebp], eax

; 13380: 
; 13381: 		if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	eax, DWORD PTR _cbData$212799[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$212800[ebp], eax
	cmp	DWORD PTR _pbData$212800[ebp], 0
	jne	SHORT $L212802

; 13382: 		{
; 13383: 			xmlFree(newXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _newXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13384: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13385: 			return FALSE;

	xor	eax, eax
	jmp	$L212756
$L212802:

; 13386: 		}
; 13387: 		if ((cbData  = base64encode(newXMLStr,iSize,(unsigned char*)pbData,cbData+1))==-1) 

	mov	ecx, DWORD PTR _cbData$212799[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pbData$212800[ebp]
	push	edx
	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newXMLStr$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$212799[ebp], eax
	cmp	DWORD PTR _cbData$212799[ebp], -1
	jne	SHORT $L212804

; 13388: 		{
; 13389: 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13390: 			xmlFree(newXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _newXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13391: 			zFree(pbData);

	mov	edx, DWORD PTR _pbData$212800[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 13392: 			return FALSE;

	xor	eax, eax
	jmp	$L212756
$L212804:

; 13393: 		}
; 13394: 		*(pbData+cbData)='\0';

	mov	eax, DWORD PTR _pbData$212800[ebp]
	add	eax, DWORD PTR _cbData$212799[ebp]
	mov	BYTE PTR [eax], 0

; 13395: 		xmlFree(newXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _newXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13396: 		*newSigXMLStr = A2WBSTR((LPCSTR)pbData, (int)cbData);

	mov	edx, DWORD PTR _cbData$212799[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$212800[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _newSigXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 13397: 		zFree(pbData);

	mov	edx, DWORD PTR _pbData$212800[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 13398: 	}
; 13399: 	else

	jmp	$L212807
$L212798:

; 13400: 	{
; 13401: 		unsigned char *dataPtr = newXMLStr;

	mov	eax, DWORD PTR _newXMLStr$[ebp]
	mov	DWORD PTR _dataPtr$212808[ebp], eax

; 13402: 
; 13403: 		if (((*dataPtr == 0xff) && (*(dataPtr +1) == 0xfe)) ||
; 13404: 			((*dataPtr == 0xfe) && (*(dataPtr +1) == 0xff)))

	mov	ecx, DWORD PTR _dataPtr$212808[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L212811
	mov	eax, DWORD PTR _dataPtr$212808[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L212810
$L212811:
	mov	edx, DWORD PTR _dataPtr$212808[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L212809
	mov	ecx, DWORD PTR _dataPtr$212808[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L212809
$L212810:

; 13405: 		{
; 13406: 			// This is a UTF-16 file, so no need to do a char * to BSTR conversion
; 13407: 			// Just allocate memory and copy data and put the size information in front
; 13408: 			*newSigXMLStr = ::SysAllocStringByteLen((LPCSTR)dataPtr, (UINT)iSize);

	mov	esi, esp
	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dataPtr$212808[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocStringByteLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _newSigXMLStr$[ebp]
	mov	DWORD PTR [edx], eax

; 13409: 			xmlFree(dataPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _dataPtr$212808[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13410: 		}
; 13411: 		else

	jmp	SHORT $L212807
$L212809:

; 13412: 		{
; 13413: 			*newSigXMLStr = A2WBSTR((LPCSTR)dataPtr, iSize);

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$212808[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _newSigXMLStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 13414: 			xmlFree(dataPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _dataPtr$212808[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212807:

; 13415: 		}
; 13416: 	}
; 13417: 	ExitLog;
; 13418: 	return S_OK;

	xor	eax, eax
$L212756:

; 13419: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222346
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 112				; 00000070H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222346:
	DD	2
	DD	$L222345
$L222345:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L222343
	DD	-96					; ffffffa0H
	DD	4
	DD	$L222344
$L222344:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222343:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z ENDP ; CSignature::DeleteSignatureFromXMLStr
_TEXT	ENDS
PUBLIC	?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z ; CSignature::DeleteSignatureFromFile
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_newSigXMLStr$ = -20					; size = 4
_signedXML$ = -8					; size = 4
_this$ = 8						; size = 4
_signedXMLFile$ = 12					; size = 4
_sigId$ = 16						; size = 4
_outFilePath$ = 20					; size = 4
_newSigFilePath$ = 24					; size = 4
?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z PROC NEAR ; CSignature::DeleteSignatureFromFile

; 13422: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 13423: 	BSTR signedXML=NULL, newSigXMLStr=NULL;

	mov	DWORD PTR _signedXML$[ebp], 0
	mov	DWORD PTR _newSigXMLStr$[ebp], 0

; 13424: 	EnterLog;
; 13425: 	ReadAll(signedXMLFile, &signedXML);

	mov	esi, esp
	lea	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedXMLFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+236]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13426: 	if (signedXML != NULL)

	cmp	DWORD PTR _signedXML$[ebp], 0
	je	SHORT $L212826

; 13427: 	{
; 13428: 		DeleteSignatureFromXMLStr(signedXML, sigId, &newSigXMLStr);

	mov	esi, esp
	lea	edx, DWORD PTR _newSigXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedXML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+592]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13429: 		SysFreeString(signedXML);

	mov	esi, esp
	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13430: 		if (newSigXMLStr != NULL)

	cmp	DWORD PTR _newSigXMLStr$[ebp], 0
	je	SHORT $L212826

; 13431: 		{
; 13432: 			SaveXMLStr(newSigXMLStr, outFilePath, newSigFilePath);

	mov	esi, esp
	mov	eax, DWORD PTR _newSigFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newSigXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+240]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13433:             SysFreeString(newSigXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _newSigXMLStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212826:

; 13434: 		}
; 13435: 	}
; 13436: 	ExitLog;
; 13437: 	return S_OK;

	xor	eax, eax

; 13438: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222351
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222351:
	DD	2
	DD	$L222350
$L222350:
	DD	-8					; fffffff8H
	DD	4
	DD	$L222348
	DD	-20					; ffffffecH
	DD	4
	DD	$L222349
$L222349:
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222348:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z ENDP ; CSignature::DeleteSignatureFromFile
_TEXT	ENDS
PUBLIC	?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z ; NetscapeCert::ICertStore::GetCertificateList
PUBLIC	?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z ; NetscapeCert::ICertStore::PutNetscapeStorePassword
PUBLIC	?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_AllowedCertIssuerNames
PUBLIC	__GUID_0a06154b_8ff9_48b2_a819_b68c327fc773
xdata$x	SEGMENT
$T222372 DD	0ffffffffH
	DD	FLAT:$L222363
$T222365 DD	019930520H
	DD	01H
	DD	FLAT:$T222372
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __GUID_0a06154b_8ff9_48b2_a819_b68c327fc773
CONST	SEGMENT
__GUID_0a06154b_8ff9_48b2_a819_b68c327fc773 DD 0a06154bH
	DW	08ff9H
	DW	048b2H
	DB	0a8H
	DB	019H
	DB	0b6H
	DB	08cH
	DB	032H
	DB	07fH
	DB	0c7H
	DB	073H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv373 = -160						; size = 4
tv375 = -156						; size = 4
tv170 = -152						; size = 4
$T222359 = -148						; size = 4
$T222358 = -144						; size = 4
$T222357 = -140						; size = 4
$T222354 = -136						; size = 4
$T222353 = -132						; size = 4
_i$212922 = -128					; size = 4
_j$212913 = -124					; size = 4
_certificateAllowed$212912 = -120			; size = 4
_i$212908 = -116					; size = 4
_j$212901 = -112					; size = 4
_i$212897 = -108					; size = 4
_allowedCertCount$212896 = -104				; size = 4
_indexArray$212893 = -100				; size = 4
_certList$212886 = -96					; size = 4
_hr$212875 = -92					; size = 4
_pUnknown$212873 = -84					; size = 4
_tmpCharPtr$ = -76					; size = 4
_certPtr$ = -72						; size = 4
_numCerts$ = -64					; size = 4
_i$212853 = -56						; size = 4
_i$212843 = -52						; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_bstrList$ = -32					; size = 4
_itemCount$ = -24					; size = 4
_elementCount$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_AllowedCertIssuerNames

; 13440: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13441: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 13442: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 13443: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 13444: //	unsigned char  *charIssuerNamePtr;
; 13445: 
; 13446: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 13447: 	EnterLog;
; 13448: 	if ((newVal.vt != VT_BSTR) &&
; 13449: 		(newVal.vt != VT_DISPATCH) &&
; 13450: 		!(newVal.vt & VT_ARRAY) && 
; 13451: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L212840
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L212840
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L212840
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L212840

; 13452: 	{
; 13453: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 13454: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212832
$L212840:

; 13455: 	}
; 13456: 
; 13457: 	if (allowedCertIssuerCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3332], 0
	je	SHORT $L212842

; 13458: 	{
; 13459: 		for (unsigned int i=0; i < allowedCertIssuerCount; i++)

	mov	DWORD PTR _i$212843[ebp], 0
	jmp	SHORT $L212844
$L212845:
	mov	ecx, DWORD PTR _i$212843[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$212843[ebp], ecx
$L212844:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$212843[ebp]
	cmp	eax, DWORD PTR [edx+3332]
	jae	SHORT $L212846

; 13460: 			SysFreeString(allowedCertIssuerNames[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3328]
	mov	esi, esp
	mov	eax, DWORD PTR _i$212843[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L212845
$L212846:

; 13461: 		zFree(allowedCertIssuerNames);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3328]
	push	eax
	call	_rFree
	add	esp, 4

; 13462: 		allowedCertIssuerCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3332], 0
$L212842:

; 13463: 	}
; 13464: 
; 13465: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	edx, DWORD PTR _itemCount$[ebp]
	push	edx
	sub	esp, 16					; 00000010H
	mov	eax, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 13466: 
; 13467: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L212848
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L212847
$L212848:

; 13468: 	{
; 13469: 		allowedCertIssuerNames = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3328], 0

; 13470: 		allowedCertIssuerCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3332], 0

; 13471: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13472: 		return S_FALSE;

	mov	eax, 1
	jmp	$L212832
$L212847:

; 13473: 	}
; 13474: 
; 13475: 	allowedCertIssuerCount = itemCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _itemCount$[ebp]
	mov	DWORD PTR [ecx+3332], edx

; 13476: 	allowedCertIssuerNames = bstrList;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	DWORD PTR [eax+3328], ecx

; 13477: 	//allowedCertIssuerNames = (LPWSTR *) zMalloc(sizeof(LPWSTR *) * itemCount);
; 13478: 	//if (allowedCertIssuerNames == NULL)
; 13479: 	//{
; 13480: 	//	setError(SigHandle, MEMORY_FAULT);
; 13481: 	//	allowedCertIssuerCount = 0;
; 13482: 	//	for (i =0; i < itemCount; i++)
; 13483: 	//		if (bstrList[i] != NULL)
; 13484: 	//			SysFreeString(bstrList[i]);
; 13485: 	//	zFree(bstrList);
; 13486: 	//	return S_FALSE;
; 13487: 	//}
; 13488: 	//memset(allowedCertIssuerNames, 0, sizeof(char *) * itemCount);
; 13489: 
; 13490: 	//for (elementCount =0; elementCount < itemCount; elementCount++)
; 13491: 	//{
; 13492: 	//	charIssuerNamePtr = HeapW2A(bstrList[elementCount]);
; 13493: 	//	if (charIssuerNamePtr == NULL)
; 13494: 	//	{
; 13495: 	//		setError(SigHandle, MEMORY_FAULT);
; 13496: 	//		for (i =0; i < itemCount; i++)
; 13497: 	//			if (bstrList[i] != NULL)
; 13498: 	//				SysFreeString(bstrList[i]);
; 13499: 	//		zFree(bstrList);
; 13500: 	//		for (i=0; i < elementCount; i++)
; 13501: 	//		{
; 13502: 	//			if (allowedCertIssuerNames[i] != NULL)
; 13503: 	//			{
; 13504: 	//				zFree(allowedCertIssuerNames[i]);
; 13505: 	//				allowedCertIssuerNames[i] = NULL;
; 13506: 	//			}
; 13507: 	//		}
; 13508: 	//		zFree(allowedCertIssuerNames);
; 13509: 	//		allowedCertIssuerNames = NULL;
; 13510: 	//		allowedCertIssuerCount = 0;
; 13511: 	//		return S_FALSE;
; 13512: 	//	}
; 13513: 	//	allowedCertIssuerNames[elementCount] = (LPSTR)charIssuerNamePtr;
; 13514: 	//}
; 13515: 	//for (i =0; i < itemCount; i++)
; 13516: 	//	if (bstrList[i] != NULL)
; 13517: 	//		SysFreeString(bstrList[i]);
; 13518: 	//zFree(bstrList);
; 13519: 
; 13520: 	//free cV and SigHandle
; 13521: 	if ((UsingNetscape == FALSE) || (allowedCertIssuerCount != 0))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 0
	je	SHORT $L212851
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3332], 0
	je	$L212850
$L212851:

; 13522: 		if (cV != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $L212850

; 13523: 		{
; 13524: 			for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$212853[ebp], 0
	jmp	SHORT $L212854
$L212855:
	mov	edx, DWORD PTR _i$212853[ebp]
	add	edx, 1
	mov	DWORD PTR _i$212853[ebp], edx
$L212854:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$212853[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L212856

; 13525: 			{
; 13526: 				if (cV[i]->certificate != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _i$212853[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L212857

; 13527: 					zFree(cV[i]->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _i$212853[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	_rFree
	add	esp, 4
$L212857:

; 13528: 				zFree(cV[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _i$212853[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 13529: 			}

	jmp	SHORT $L212855
$L212856:

; 13530: 			zFree(cV);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	_rFree
	add	esp, 4

; 13531: 			cV = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0
$L212850:

; 13532: 		}
; 13533: #ifdef WIN32
; 13534: 	//free showselect cert obj
; 13535: 	if (CertificateCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 0
	je	SHORT $L212858

; 13536: 		delete dlg;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1808]
	mov	DWORD PTR $T222354[ebp], edx
	mov	eax, DWORD PTR $T222354[ebp]
	mov	DWORD PTR $T222353[ebp], eax
	cmp	DWORD PTR $T222353[ebp], 0
	je	SHORT $L222355
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T222353[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T222353[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $L212858
$L222355:
	mov	DWORD PTR tv170[ebp], 0
$L212858:

; 13537: #endif
; 13538: 	//do all initialization
; 13539: 	int numCerts;
; 13540: 	PCERT_DESCR *certPtr;
; 13541: 
; 13542: 	sgArr=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 13543: 	err=0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 13544: 	signum=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 13545: 	uriArr=NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 13546: 	failedUriArr=NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0

; 13547: 	failedUriCount=0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], 0

; 13548: 	totalUriCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 13549: 
; 13550: 	CertificateCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 13551: 	CurrentCertificate = NOT_INITIALIZED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], -1

; 13552: 
; 13553: 	unsigned char * tmpCharPtr = HeapW2A(StoreName.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+696]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 13554: 	if (strcmp((const char *)tmpCharPtr, NETSCAPESTORE))

	push	OFFSET FLAT:$SG212866
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L212865

; 13555: 	{
; 13556: #ifdef WIN32
; 13557: 		// Store name is not Netscape
; 13558: 		if ((UsingNetscape == TRUE) && (nsCertStoreObj != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3388], 1
	jne	SHORT $L212867
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3380], 0
	je	SHORT $L212867

; 13559: 		{
; 13560: 			nsCertStoreObj->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3380]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3380]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13561: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212867:

; 13562: 		}
; 13563: #endif
; 13564: 		UsingNetscape = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3388], 0

; 13565: 
; 13566: #ifdef NSS
; 13567: 		if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts, SigHandle )) != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _numCerts$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_axGetCertificateList
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _certPtr$[ebp], eax
	cmp	DWORD PTR _certPtr$[ebp], 0
	je	SHORT $L212868

; 13568: #else
; 13569: 		if ((certPtr = axGetCertificateList(tmpCharPtr, &numCerts )) != NULL)
; 13570: #endif
; 13571: 		{
; 13572: 			CertificateCount = (long) numCerts;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [eax+124], ecx

; 13573: 			if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L212870

; 13574: 				cVSigner = certPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _certPtr$[ebp]
	mov	DWORD PTR [edx+108], eax

; 13575: 			else

	jmp	SHORT $L212868
$L212870:

; 13576: 			{
; 13577: 				cVSigner = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0
$L212868:

; 13578: 			}
; 13579: 		}
; 13580: 	}
; 13581: 	else // The store name is Netscape hence do the netscape cert processing

	jmp	$L212872
$L212865:

; 13582: 	{
; 13583: 		IUnknown *pUnknown;
; 13584: #ifdef WIN32
; 13585: 		if ((UsingNetscape == TRUE) && (nsCertStoreObj != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 1
	jne	SHORT $L212874
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3380], 0
	je	SHORT $L212874

; 13586: 		{
; 13587: 			nsCertStoreObj->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3380]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3380]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13588: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212874:

; 13589: 		}
; 13590: 
; 13591: 		CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13592: 		HRESULT hr = CoCreateInstance(__uuidof(CCertStore), NULL, CLSCTX_INPROC_SERVER, 
; 13593: 							IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$212873[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_0a06154b_8ff9_48b2_a819_b68c327fc773
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$212875[ebp], eax

; 13594: 		if (FAILED(hr))

	cmp	DWORD PTR _hr$212875[ebp], 0
	jge	SHORT $L212879

; 13595: 		{
; 13596: 			UsingNetscape = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3388], 0

; 13597: 			return S_FALSE;

	mov	eax, 1
	jmp	$L212832
$L212879:

; 13598: 		}
; 13599: 
; 13600: 		hr = pUnknown->QueryInterface(__uuidof(ICertStore), (void **) &nsCertStoreObj);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 3380				; 00000d34H
	mov	esi, esp
	push	edx
	push	OFFSET FLAT:__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
	mov	eax, DWORD PTR _pUnknown$212873[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pUnknown$212873[ebp]
	push	edx
	call	DWORD PTR [ecx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$212875[ebp], eax

; 13601: 		if (FAILED(hr))

	cmp	DWORD PTR _hr$212875[ebp], 0
	jge	SHORT $L212883

; 13602: 		{
; 13603: 			pUnknown->Release();

	mov	eax, DWORD PTR _pUnknown$212873[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pUnknown$212873[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13604: 			UsingNetscape = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3388], 0

; 13605: 			return S_FALSE;

	mov	eax, 1
	jmp	$L212832
$L212883:

; 13606: 		}
; 13607: 		pUnknown->Release();

	mov	ecx, DWORD PTR _pUnknown$212873[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	eax, DWORD PTR _pUnknown$212873[ebp]
	push	eax
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13608: 		nsCertStoreObj->NetscapeStorePassword = nsStorePassword;

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222357[ebp], esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3384]
	push	eax
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv375[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3380]
	call	?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z ; NetscapeCert::ICertStore::PutNetscapeStorePassword

; 13609: 		char *certList = nsCertStoreObj->GetCertificateList((unsigned long *)&numCerts);

	lea	edx, DWORD PTR _numCerts$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3380]
	call	?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z ; NetscapeCert::ICertStore::GetCertificateList
	mov	DWORD PTR _certList$212886[ebp], eax

; 13610: 		CertificateCount = (long) numCerts;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _numCerts$[ebp]
	mov	DWORD PTR [ecx+124], edx

; 13611: 		if (numCerts > 0)

	cmp	DWORD PTR _numCerts$[ebp], 0
	jle	SHORT $L212889

; 13612: 		{
; 13613: 			UsingNetscape = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3388], 1

; 13614: 			cVSigner = (PCERT_DESCR *)certList;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _certList$212886[ebp]
	mov	DWORD PTR [ecx+108], edx

; 13615: 		}
; 13616: 		else

	jmp	SHORT $L212872
$L212889:

; 13617: 		{
; 13618: 			UsingNetscape = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3388], 0

; 13619: 			cVSigner = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0

; 13620: 			nsCertStoreObj->Release();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3380]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3380]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13621: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp
$L212872:

; 13622: 		}
; 13623: #endif
; 13624: 	}
; 13625: 	if ((allowedCertIssuerCount != 0) && (CertificateCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3332], 0
	je	$L212892
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	$L212892

; 13626: 	{
; 13627: 		int *indexArray = (int *)zMalloc(sizeof(int) * CertificateCount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _indexArray$212893[ebp], eax

; 13628: 		int allowedCertCount = 0;

	mov	DWORD PTR _allowedCertCount$212896[ebp], 0

; 13629: 
; 13630: 		for (unsigned int i=0; i < allowedCertIssuerCount; i++)

	mov	DWORD PTR _i$212897[ebp], 0
	jmp	SHORT $L212898
$L212899:
	mov	edx, DWORD PTR _i$212897[ebp]
	add	edx, 1
	mov	DWORD PTR _i$212897[ebp], edx
$L212898:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$212897[ebp]
	cmp	ecx, DWORD PTR [eax+3332]
	jae	SHORT $L212900

; 13631: 		{
; 13632: 			for(int j=0; j < CertificateCount; j++)

	mov	DWORD PTR _j$212901[ebp], 0
	jmp	SHORT $L212902
$L212903:
	mov	edx, DWORD PTR _j$212901[ebp]
	add	edx, 1
	mov	DWORD PTR _j$212901[ebp], edx
$L212902:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _j$212901[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L212904

; 13633: 			{
; 13634: 				if (!wcscmp((const WCHAR *)allowedCertIssuerNames[i], (const WCHAR *)cVSigner[j]->issuer))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _j$212901[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	add	edx, 256				; 00000100H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3328]
	mov	edx, DWORD PTR _i$212897[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L212907

; 13635: 				{
; 13636: 					indexArray[allowedCertCount] = j;

	mov	ecx, DWORD PTR _allowedCertCount$212896[ebp]
	mov	edx, DWORD PTR _indexArray$212893[ebp]
	mov	eax, DWORD PTR _j$212901[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 13637: 					allowedCertCount++;

	mov	ecx, DWORD PTR _allowedCertCount$212896[ebp]
	add	ecx, 1
	mov	DWORD PTR _allowedCertCount$212896[ebp], ecx
$L212907:

; 13638: 				}
; 13639: 			}

	jmp	SHORT $L212903
$L212904:

; 13640: 		}

	jmp	SHORT $L212899
$L212900:

; 13641: 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$212908[ebp], 0
	jmp	SHORT $L212909
$L212910:
	mov	edx, DWORD PTR _i$212908[ebp]
	add	edx, 1
	mov	DWORD PTR _i$212908[ebp], edx
$L212909:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$212908[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	$L212911

; 13642: 		{
; 13643: 			BOOL certificateAllowed = FALSE;

	mov	DWORD PTR _certificateAllowed$212912[ebp], 0

; 13644: 			for (int j=0; j<allowedCertCount; j++)

	mov	DWORD PTR _j$212913[ebp], 0
	jmp	SHORT $L212914
$L212915:
	mov	edx, DWORD PTR _j$212913[ebp]
	add	edx, 1
	mov	DWORD PTR _j$212913[ebp], edx
$L212914:
	mov	eax, DWORD PTR _j$212913[ebp]
	cmp	eax, DWORD PTR _allowedCertCount$212896[ebp]
	jge	SHORT $L212916

; 13645: 			{
; 13646: 				if (indexArray[j] == i)

	mov	ecx, DWORD PTR _j$212913[ebp]
	mov	edx, DWORD PTR _indexArray$212893[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	eax, DWORD PTR _i$212908[ebp]
	jne	SHORT $L212917

; 13647: 				{
; 13648: 					certificateAllowed = TRUE;

	mov	DWORD PTR _certificateAllowed$212912[ebp], 1

; 13649: 					break;

	jmp	SHORT $L212916
$L212917:

; 13650: 				}
; 13651: 			}

	jmp	SHORT $L212915
$L212916:

; 13652: 			if ((certificateAllowed == FALSE) && (UsingNetscape == FALSE))

	cmp	DWORD PTR _certificateAllowed$212912[ebp], 0
	jne	SHORT $L212918
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3388], 0
	jne	SHORT $L212918

; 13653: 			{
; 13654: 				if (cVSigner[i]->certificate != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$212908[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L212919

; 13655: 					zFree(cVSigner[i]->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR _i$212908[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	call	_rFree
	add	esp, 4
$L212919:

; 13656: 				zFree(cVSigner[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	ecx, DWORD PTR _i$212908[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4
$L212918:

; 13657: 			}
; 13658: 		}

	jmp	$L212910
$L212911:

; 13659: 		CertificateCount = allowedCertCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allowedCertCount$212896[ebp]
	mov	DWORD PTR [eax+124], ecx

; 13660: 		cV = (PCERT_DESCR *)zMalloc(sizeof(PCERT_DESCR *) * CertificateCount);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], eax

; 13661: 		for (int i=0; i<CertificateCount; i++)

	mov	DWORD PTR _i$212922[ebp], 0
	jmp	SHORT $L212923
$L212924:
	mov	edx, DWORD PTR _i$212922[ebp]
	add	edx, 1
	mov	DWORD PTR _i$212922[ebp], edx
$L212923:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$212922[ebp]
	cmp	ecx, DWORD PTR [eax+124]
	jge	SHORT $L212925

; 13662: 			cV[i] = cVSigner[indexArray[i]];

	mov	edx, DWORD PTR _i$212922[ebp]
	mov	eax, DWORD PTR _indexArray$212893[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+104]
	mov	esi, DWORD PTR _i$212922[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+esi*4], eax
	jmp	SHORT $L212924
$L212925:

; 13663: 		if (UsingNetscape == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3388], 0
	jne	SHORT $L212926

; 13664: 			zFree(cVSigner);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+108]
	push	eax
	call	_rFree
	add	esp, 4
$L212926:

; 13665: 		zFree(indexArray);

	mov	ecx, DWORD PTR _indexArray$212893[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 13666: 	}
; 13667: 	else

	jmp	SHORT $L212927
$L212892:

; 13668: 		cV = cVSigner;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+108]
	mov	DWORD PTR [edx+104], ecx
$L212927:

; 13669: #ifdef WIN32
; 13670: 	// initialise SelectCert
; 13671: 	if (CertificateCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+124], 0
	je	SHORT $L212928

; 13672: 	{
; 13673: 		dlg = new CShowSelectCert(/*this,*/ tmpCharPtr, cV, CertificateCount);	

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222359[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T222359[ebp], 0
	je	SHORT $L222360
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T222359[ebp]
	call	??0CShowSelectCert@@QAE@PAEPAPAU_CERT_DESCR@@J@Z ; CShowSelectCert::CShowSelectCert
	mov	DWORD PTR tv373[ebp], eax
	jmp	SHORT $L222361
$L222360:
	mov	DWORD PTR tv373[ebp], 0
$L222361:
	mov	edx, DWORD PTR tv373[ebp]
	mov	DWORD PTR $T222358[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T222358[ebp]
	mov	DWORD PTR [eax+1808], ecx
$L212928:

; 13674: //		dlg->Create(NULL);
; 13675: 	}
; 13676: #endif
; 13677: 	zFree(tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 13678: 	ExitLog;
; 13679: 	return S_OK;

	xor	eax, eax
$L212832:

; 13680: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222371
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 160				; 000000a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L222371:
	DD	3
	DD	$L222370
$L222370:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L222366
	DD	-64					; ffffffc0H
	DD	4
	DD	$L222367
	DD	-84					; ffffffacH
	DD	4
	DD	$L222368
$L222368:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
$L222367:
	DB	110					; 0000006eH
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$L222366:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222363:
	mov	eax, DWORD PTR $T222359[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z:
	mov	eax, OFFSET FLAT:$T222365
	jmp	___CxxFrameHandler
text$x	ENDS
?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_AllowedCertIssuerNames
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\nssdebug\netscapecert.tli
;	COMDAT ?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
_certCount$ = 8						; size = 4
?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z PROC NEAR ; NetscapeCert::ICertStore::GetCertificateList, COMDAT
; _this$ = ecx

; 14   : inline char * ICertStore::GetCertificateList ( unsigned long * certCount ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 15   :     char * _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 16   :     HRESULT _hr = raw_GetCertificateList(certCount, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 17   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201282
	push	OFFSET FLAT:__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __hr$[ebp]
	push	eax
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201282:

; 18   :     return _result;

	mov	eax, DWORD PTR __result$[ebp]

; 19   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222376
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222376:
	DD	1
	DD	$L222375
$L222375:
	DD	-12					; fffffff4H
	DD	4
	DD	$L222374
$L222374:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?GetCertificateList@ICertStore@NetscapeCert@@QAEPADPAK@Z ENDP ; NetscapeCert::ICertStore::GetCertificateList
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T222383 DD	0ffffffffH
	DD	FLAT:$L222379
$T222381 DD	019930520H
	DD	01H
	DD	FLAT:$T222383
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z PROC NEAR ; NetscapeCert::ICertStore::PutNetscapeStorePassword, COMDAT
; _this$ = ecx

; 21   : inline void ICertStore::PutNetscapeStorePassword ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 22   :     HRESULT _hr = put_NetscapeStorePassword(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 23   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L201289
	push	OFFSET FLAT:__GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L201289:

; 24   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222379:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T222381
	jmp	___CxxFrameHandler
text$x	ENDS
?PutNetscapeStorePassword@ICertStore@NetscapeCert@@QAEXV_bstr_t@@@Z ENDP ; NetscapeCert::ICertStore::PutNetscapeStorePassword
PUBLIC	?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z ; CSignature::get_CRLCacheDbConnectionString
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_CRLCacheDbConnectionString

; 13682: {

	push	ebp
	mov	ebp, esp

; 13683: 	EnterLog;
; 13684: #ifdef WIN32
; 13685: 	*pVal = CRLCacheDbConnectionString.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 13686: #endif
; 13687: 	ExitLog;
; 13688: 	return S_OK;

	xor	eax, eax

; 13689: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_CRLCacheDbConnectionString
_TEXT	ENDS
PUBLIC	?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z ; CSignature::put_CRLCacheDbConnectionString
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_CRLCacheDbConnectionString

; 13692: {

	push	ebp
	mov	ebp, esp

; 13693: 	EnterLog;
; 13694: #ifdef WIN32
; 13695: 	CRLCacheDbConnectionString = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3372				; 00000d2cH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 13696: #endif
; 13697: 	ExitLog;
; 13698: 	return S_OK;

	xor	eax, eax

; 13699: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_CRLCacheDbConnectionString
_TEXT	ENDS
PUBLIC	?get_UseCRLCache@CSignature@@UAGJPAH@Z		; CSignature::get_UseCRLCache
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UseCRLCache@CSignature@@UAGJPAH@Z PROC NEAR	; CSignature::get_UseCRLCache

; 13702: {

	push	ebp
	mov	ebp, esp

; 13703: 	EnterLog;
; 13704: #ifdef WIN32
; 13705: 	if (CertVerifyParams.pCrlCache != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1828], 0
	je	SHORT $L212948

; 13706: 		*pVal = TRUE;

	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], 1

; 13707: 	else

	jmp	SHORT $L212949
$L212948:

; 13708: 		*pVal = FALSE;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 0
$L212949:

; 13709: #endif
; 13710: 	ExitLog;
; 13711: 	return S_OK;

	xor	eax, eax

; 13712: }

	pop	ebp
	ret	8
?get_UseCRLCache@CSignature@@UAGJPAH@Z ENDP		; CSignature::get_UseCRLCache
_TEXT	ENDS
PUBLIC	?SetCRLTimeOut@CRLCache@@QAEXK@Z		; CRLCache::SetCRLTimeOut
PUBLIC	??_GCRLCache@@QAEPAXI@Z				; CRLCache::`scalar deleting destructor'
PUBLIC	?put_UseCRLCache@CSignature@@UAGJH@Z		; CSignature::put_UseCRLCache
EXTRN	??0CRLCache@@QAE@PAGPAU_GLOBAL_SIG@@@Z:NEAR	; CRLCache::CRLCache
xdata$x	SEGMENT
$T222408 DD	0ffffffffH
	DD	FLAT:$L222403
	DD	0ffffffffH
	DD	FLAT:$L222404
$T222406 DD	019930520H
	DD	02H
	DD	FLAT:$T222408
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv144 = -48						; size = 4
tv91 = -44						; size = 4
tv73 = -40						; size = 4
$T222400 = -36						; size = 4
$T222399 = -32						; size = 4
$T222396 = -28						; size = 4
$T222395 = -24						; size = 4
$T222392 = -20						; size = 4
$T222391 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_UseCRLCache@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_UseCRLCache

; 13715: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_UseCRLCache@CSignature@@UAGJH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax

; 13716: 	EnterLog;
; 13717: #ifdef WIN32
; 13718: 	if (CertVerifyParams.pCrlCache != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1828], 0
	je	$L212955

; 13719: 	{
; 13720: 		delete CertVerifyParams.pCrlCache;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1828]
	mov	DWORD PTR $T222392[ebp], edx
	mov	eax, DWORD PTR $T222392[ebp]
	mov	DWORD PTR $T222391[ebp], eax
	cmp	DWORD PTR $T222391[ebp], 0
	je	SHORT $L222393
	push	1
	mov	ecx, DWORD PTR $T222391[ebp]
	call	??_GCRLCache@@QAEPAXI@Z
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $L222394
$L222393:
	mov	DWORD PTR tv73[ebp], 0
$L222394:

; 13721: 		if (newVal == FALSE)

	cmp	DWORD PTR _newVal$[ebp], 0
	jne	SHORT $L212958

; 13722: 		{
; 13723: 			CertVerifyParams.pCrlCache = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1828], 0

; 13724: 		}
; 13725: 		else

	jmp	SHORT $L212959
$L212958:

; 13726: 		{
; 13727: 			CertVerifyParams.pCrlCache = new CRLCache(CRLCacheDbConnectionString.m_str, SigHandle);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222396[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T222396[ebp], 0
	je	SHORT $L222397
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3372]
	push	edx
	mov	ecx, DWORD PTR $T222396[ebp]
	call	??0CRLCache@@QAE@PAGPAU_GLOBAL_SIG@@@Z	; CRLCache::CRLCache
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $L222398
$L222397:
	mov	DWORD PTR tv91[ebp], 0
$L222398:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR $T222395[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T222395[ebp]
	mov	DWORD PTR [ecx+1828], edx

; 13728: 			CertVerifyParams.pCrlCache->SetCRLTimeOut(crlCacheTimeoutInMinutes);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3376]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1828]
	call	?SetCRLTimeOut@CRLCache@@QAEXK@Z	; CRLCache::SetCRLTimeOut
$L212959:

; 13729: 		}
; 13730: 	}
; 13731: 	else

	jmp	SHORT $L212964
$L212955:

; 13732: 		if (newVal != FALSE)

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L212964

; 13733: 		{
; 13734: 			CertVerifyParams.pCrlCache = new CRLCache(CRLCacheDbConnectionString.m_str, SigHandle);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222400[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T222400[ebp], 0
	je	SHORT $L222401
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3372]
	push	eax
	mov	ecx, DWORD PTR $T222400[ebp]
	call	??0CRLCache@@QAE@PAGPAU_GLOBAL_SIG@@@Z	; CRLCache::CRLCache
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $L222402
$L222401:
	mov	DWORD PTR tv144[ebp], 0
$L222402:
	mov	ecx, DWORD PTR tv144[ebp]
	mov	DWORD PTR $T222399[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T222399[ebp]
	mov	DWORD PTR [edx+1828], eax

; 13735: 			CertVerifyParams.pCrlCache->SetCRLTimeOut(crlCacheTimeoutInMinutes);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3376]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1828]
	call	?SetCRLTimeOut@CRLCache@@QAEXK@Z	; CRLCache::SetCRLTimeOut
$L212964:

; 13736: 		}
; 13737: #endif
; 13738: 	ExitLog;
; 13739: 	return S_OK;

	xor	eax, eax

; 13740: }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
$L222403:
	mov	eax, DWORD PTR $T222396[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L222404:
	mov	eax, DWORD PTR $T222400[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?put_UseCRLCache@CSignature@@UAGJH@Z:
	mov	eax, OFFSET FLAT:$T222406
	jmp	___CxxFrameHandler
text$x	ENDS
?put_UseCRLCache@CSignature@@UAGJH@Z ENDP		; CSignature::put_UseCRLCache
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\crlcache.h
;	COMDAT ?SetCRLTimeOut@CRLCache@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_timeInMinutes$ = 8					; size = 4
?SetCRLTimeOut@CRLCache@@QAEXK@Z PROC NEAR		; CRLCache::SetCRLTimeOut, COMDAT
; _this$ = ecx

; 85   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 		crlTimeoutInMinutes = timeInMinutes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _timeInMinutes$[ebp]
	mov	DWORD PTR [eax], ecx

; 87   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetCRLTimeOut@CRLCache@@QAEXK@Z ENDP			; CRLCache::SetCRLTimeOut
_TEXT	ENDS
EXTRN	??1CRLCache@@QAE@XZ:NEAR			; CRLCache::~CRLCache
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCRLCache@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRLCache@@QAEPAXI@Z PROC NEAR			; CRLCache::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRLCache@@QAE@XZ			; CRLCache::~CRLCache
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L212974
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L212974:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCRLCache@@QAEPAXI@Z ENDP				; CRLCache::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z ; CSignature::put_CRLCacheTimeoutInMinutes
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z PROC NEAR ; CSignature::put_CRLCacheTimeoutInMinutes

; 13743: {

	push	ebp
	mov	ebp, esp

; 13744: #ifdef WIN32
; 13745: 	crlCacheTimeoutInMinutes = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+3376], ecx

; 13746: 	EnterLog;
; 13747: 	if (CertVerifyParams.pCrlCache != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1828], 0
	je	SHORT $L212979

; 13748: 		CertVerifyParams.pCrlCache->SetCRLTimeOut(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+1828]
	call	?SetCRLTimeOut@CRLCache@@QAEXK@Z	; CRLCache::SetCRLTimeOut
$L212979:

; 13749: 	ExitLog;
; 13750: #endif
; 13751: 	return S_OK;

	xor	eax, eax

; 13752: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z ENDP	; CSignature::put_CRLCacheTimeoutInMinutes
_TEXT	ENDS
PUBLIC	?put_CanonicalizationMethod@CSignature@@UAGJK@Z	; CSignature::put_CanonicalizationMethod
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CanonicalizationMethod@CSignature@@UAGJK@Z PROC NEAR ; CSignature::put_CanonicalizationMethod

; 13755: {

	push	ebp
	mov	ebp, esp

; 13756: 	EnterLog;
; 13757: 	CanonicalizationMethod = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+3336], ecx

; 13758: 	if (newVal>1) {

	cmp	DWORD PTR _newVal$[ebp], 1
	jbe	SHORT $L212985

; 13759: 		SigHandle->useFastC14N = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	DWORD PTR [eax+44], 0
$L212985:

; 13760: 	}
; 13761: 	ExitLog;
; 13762: 	return S_OK;

	xor	eax, eax

; 13763: }

	pop	ebp
	ret	8
?put_CanonicalizationMethod@CSignature@@UAGJK@Z ENDP	; CSignature::put_CanonicalizationMethod
_TEXT	ENDS
PUBLIC	?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z ; CSignature::get_NetscapeStorePassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_NetscapeStorePassword

; 13766: {

	push	ebp
	mov	ebp, esp
	push	esi

; 13767: 	EnterLog;
; 13768: 	*pVal = SysAllocString(nsStorePassword);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3384]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], eax

; 13769: 	ExitLog;
; 13770: 	return S_OK;

	xor	eax, eax

; 13771: }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_NetscapeStorePassword
_TEXT	ENDS
PUBLIC	?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z ; CSignature::put_NetscapeStorePassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_nsp$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_NetscapeStorePassword

; 13774: {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 13775: 	EnterLog;
; 13776: 	nsStorePassword = SysAllocString(newVal);

	mov	esi, esp
	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3384], eax

; 13777: #ifdef NSS
; 13778: 	unsigned char *nsp = (unsigned char *)HeapW2A(nsStorePassword);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3384]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _nsp$[ebp], eax

; 13779: 	if (!nsp) {

	cmp	DWORD PTR _nsp$[ebp], 0
	jne	SHORT $L212998

; 13780: 		nsp = (unsigned char *)zMalloc(sizeof(char));

	push	1
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _nsp$[ebp], eax

; 13781: 		*nsp = '\0';

	mov	ecx, DWORD PTR _nsp$[ebp]
	mov	BYTE PTR [ecx], 0
$L212998:

; 13782: 	}
; 13783: 	if (SigHandle->certStorePassword) {

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L213001

; 13784: 		zFree(SigHandle->certStorePassword);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_rFree
	add	esp, 4
$L213001:

; 13785: 	}
; 13786: 	SigHandle->certStorePassword = nsp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _nsp$[ebp]
	mov	DWORD PTR [edx+48], eax

; 13787: #endif
; 13788: 	ExitLog;
; 13789: 	return S_OK;

	xor	eax, eax

; 13790: }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_NetscapeStorePassword
_TEXT	ENDS
PUBLIC	__GUID_d8f3211f_302f_45db_8187_cdf6b7677d90
PUBLIC	?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::SetActivePEMFileCert
PUBLIC	__GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777
PUBLIC	?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z ; PemUtil::IPemObject::CovertToPFX
xdata$x	SEGMENT
$T222431 DD	0ffffffffH
	DD	FLAT:$L222421
$T222425 DD	019930520H
	DD	01H
	DD	FLAT:$T222431
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT __GUID_d8f3211f_302f_45db_8187_cdf6b7677d90
CONST	SEGMENT
__GUID_d8f3211f_302f_45db_8187_cdf6b7677d90 DD 0d8f3211fH
	DW	0302fH
	DW	045dbH
	DB	081H
	DB	087H
	DB	0cdH
	DB	0f6H
	DB	0b7H
	DB	067H
	DB	07dH
	DB	090H
CONST	ENDS
;	COMDAT __GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777
CONST	SEGMENT
__GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777 DD 012f2bf07H
	DW	0dc45H
	DW	04684H
	DB	0a4H
	DB	0bcH
	DB	08aH
	DB	05fH
	DB	044H
	DB	098H
	DB	047H
	DB	077H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
tv176 = -96						; size = 4
tv171 = -92						; size = 4
tv174 = -88						; size = 4
tv170 = -84						; size = 4
tv177 = -80						; size = 4
$T222420 = -76						; size = 4
$T222419 = -72						; size = 4
$T222418 = -68						; size = 4
_abstrPfxFileName$ = -64				; size = 4
_hr$ = -60						; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_bstrPfxFileName$ = -40					; size = 4
_pemObject$ = -32					; size = 4
_pUnknown$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_pemFileName$ = 12					; size = 4
_pemPassword$ = 16					; size = 4
_pemX509Cert$ = 20					; size = 4
?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::SetActivePEMFileCert

; 13794: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13795: 	IUnknown *pUnknown;
; 13796: 	IPemObject *pemObject;
; 13797: 	BSTR bstrPfxFileName;
; 13798: 
; 13799: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 13800: 	EnterLog;
; 13801: 	CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13802: 	HRESULT hr = CoCreateInstance(__uuidof(CPemObject), NULL, CLSCTX_INPROC_SERVER, 
; 13803: 						IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_d8f3211f_302f_45db_8187_cdf6b7677d90
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 13804: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L213020

; 13805: 	{
; 13806: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13807: 		return S_FALSE;

	mov	eax, 1
	jmp	$L213008
$L213020:

; 13808: 	}
; 13809: 
; 13810: 	hr = pUnknown->QueryInterface(__uuidof(IPemObject), (void **) &pemObject);

	mov	esi, esp
	lea	ecx, DWORD PTR _pemObject$[ebp]
	push	ecx
	push	OFFSET FLAT:__GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777
	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 13811: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L213024

; 13812: 	{
; 13813: 		pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13814: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13815: 		return S_FALSE;

	mov	eax, 1
	jmp	$L213008
$L213024:

; 13816: 	}
; 13817: 	pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13818: 
; 13819: 	bstrPfxFileName = pemObject->CovertToPFX(pemFileName, pemPassword);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222418[ebp], esp
	mov	edx, DWORD PTR _pemPassword$[ebp]
	push	edx
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv177[ebp], eax
	mov	eax, DWORD PTR tv177[ebp]
	mov	DWORD PTR tv170[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222419[ebp], esp
	mov	edx, DWORD PTR _pemFileName$[ebp]
	push	edx
	call	??0_bstr_t@@QAE@PBG@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv174[ebp], eax
	lea	eax, DWORD PTR $T222420[ebp]
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _pemObject$[ebp]
	call	?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z ; PemUtil::IPemObject::CovertToPFX
	mov	DWORD PTR tv171[ebp], eax
	mov	ecx, DWORD PTR tv171[ebp]
	mov	DWORD PTR tv176[ebp], ecx
	mov	ecx, DWORD PTR tv176[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	DWORD PTR _bstrPfxFileName$[ebp], eax
	lea	ecx, DWORD PTR $T222420[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 13820: 	pemObject->Release();

	mov	edx, DWORD PTR _pemObject$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pemObject$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13821: 	CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13822: 
; 13823: 	if (bstrPfxFileName == NULL)

	cmp	DWORD PTR _bstrPfxFileName$[ebp], 0
	jne	SHORT $L213029

; 13824: 	{
; 13825: 		setError(SigHandle, PFX_BAD_PASSWORD);

	push	57					; 00000039H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13826: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L213008
$L213029:

; 13827: 	}
; 13828: 	SetActivePFXFileCert(bstrPfxFileName, pemPassword, pemX509Cert);

	mov	esi, esp
	mov	ecx, DWORD PTR _pemX509Cert$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pemPassword$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrPfxFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+304]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13829: 	unsigned char *abstrPfxFileName = HeapW2A(bstrPfxFileName);

	mov	ecx, DWORD PTR _bstrPfxFileName$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _abstrPfxFileName$[ebp], eax

; 13830: #ifdef WIN32
; 13831: 	DeleteFile((LPCTSTR)(abstrPfxFileName));

	mov	esi, esp
	mov	edx, DWORD PTR _abstrPfxFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13832: #else
; 13833: 	unlink(abstrPfxFileName);
; 13834: #endif
; 13835: 	zFree(abstrPfxFileName);

	mov	eax, DWORD PTR _abstrPfxFileName$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 13836: 	ExitLog;
; 13837: 	return S_OK;

	xor	eax, eax
$L213008:

; 13838: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222430
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222430:
	DD	2
	DD	$L222429
$L222429:
	DD	-20					; ffffffecH
	DD	4
	DD	$L222426
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222427
$L222427:
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$L222426:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222421:
	mov	ecx, DWORD PTR $T222418[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222425
	jmp	___CxxFrameHandler
text$x	ENDS
?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::SetActivePEMFileCert
;	COMDAT xdata$x
; File c:\activex\xmlsign\nssdebug\pemutil.tli
xdata$x	SEGMENT
$T222444 DD	0ffffffffH
	DD	FLAT:$L222433
	DD	00H
	DD	FLAT:$L222434
$T222439 DD	019930520H
	DD	02H
	DD	FLAT:$T222444
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z
_TEXT	SEGMENT
$T222436 = -36						; size = 4
__hr$ = -32						; size = 4
__result$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_pemFileName$ = 12					; size = 4
_pemPassword$ = 16					; size = 4
?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z PROC NEAR ; PemUtil::IPemObject::CovertToPFX, COMDAT
; _this$ = ecx

; 14   : inline _bstr_t IPemObject::CovertToPFX ( _bstr_t pemFileName, _bstr_t pemPassword ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T222436[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 15   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 16   :     HRESULT _hr = raw_CovertToPFX(pemFileName, pemPassword, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pemPassword$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	lea	ecx, DWORD PTR _pemFileName$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 17   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L204754
	push	OFFSET FLAT:__GUID_12f2bf07_dc45_4684_a4bc_8a5f44984777
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L204754:

; 18   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T222436[ebp]
	or	ecx, 1
	mov	DWORD PTR $T222436[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pemFileName$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pemPassword$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 19   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222443
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222443:
	DD	1
	DD	$L222442
$L222442:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L222440
$L222440:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L222433:
	lea	ecx, DWORD PTR _pemPassword$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L222434:
	lea	ecx, DWORD PTR _pemFileName$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z:
	mov	eax, OFFSET FLAT:$T222439
	jmp	___CxxFrameHandler
text$x	ENDS
?CovertToPFX@IPemObject@PemUtil@@QAE?AV_bstr_t@@V3@0@Z ENDP ; PemUtil::IPemObject::CovertToPFX
PUBLIC	?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z	; CSignature::get_SecureXMLPath
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_SecureXMLPath

; 13842: {

	push	ebp
	mov	ebp, esp

; 13843: 	EnterLog;
; 13844: 	*pVal = SecureXMLPath.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3392				; 00000d40H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 13845: 	ExitLog;
; 13846: 	return S_OK;

	xor	eax, eax

; 13847: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z ENDP		; CSignature::get_SecureXMLPath
_TEXT	ENDS
PUBLIC	?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z	; CSignature::get_SignedDocumentCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_pVal$ = 16						; size = 4
?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z PROC NEAR ; CSignature::get_SignedDocumentCount

; 13850: {

	push	ebp
	mov	ebp, esp

; 13851: 	*pVal = 0;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax], 0

; 13852: 	EnterLog;
; 13853: 	if (sgArr==NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $L213044

; 13854: 	{
; 13855: 		setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13856: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L213043
$L213044:

; 13857: 	}
; 13858: 	if ((sigIndex >= signum) || (sigIndex < 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	SHORT $L213047
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L213046
$L213047:

; 13859: 	{
; 13860: 		setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 13861: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L213043
$L213046:

; 13862: 	}
; 13863: 	*pVal = sgArr[sigIndex]->refNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax], ecx

; 13864: 	ExitLog;
; 13865: 	return S_OK;

	xor	eax, eax
$L213043:

; 13866: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z ENDP	; CSignature::get_SignedDocumentCount
_TEXT	ENDS
PUBLIC	??0CBufferVariant@@QAE@XZ			; CBufferVariant::CBufferVariant
PUBLIC	??1CBufferVariant@@UAE@XZ			; CBufferVariant::~CBufferVariant
PUBLIC	??BCBufferVariant@@QBEPAXXZ			; CBufferVariant::operator void *
PUBLIC	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z	; CBufferVariant::operator=
PUBLIC	?AssignData@CBufferVariant@@QAEXPBXJ@Z		; CBufferVariant::AssignData
PUBLIC	?SetLength@CBufferVariant@@QAEXJ@Z		; CBufferVariant::SetLength
PUBLIC	?GetLength@CBufferVariant@@QAEJXZ		; CBufferVariant::GetLength
PUBLIC	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ	; CBufferVariant::Copy
PUBLIC	?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z ; CSignature::SignXMLByteArray
xdata$x	SEGMENT
$T222479 DD	0ffffffffH
	DD	FLAT:$L222462
	DD	00H
	DD	FLAT:$L222463
	DD	01H
	DD	FLAT:$L222464
$T222466 DD	019930520H
	DD	03H
	DD	FLAT:$T222479
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv259 = -380						; size = 4
$T222461 = -376						; size = 4
$T222460 = -372						; size = 16
$T222459 = -356						; size = 4
$T222458 = -352						; size = 16
$T222457 = -336						; size = 4
$T222456 = -332						; size = 16
$T222455 = -316						; size = 4
$T222454 = -312						; size = 16
$T222453 = -296						; size = 4
$T222452 = -292						; size = 16
_tmpEnvFlag$ = -276					; size = 2
_freeCharSigId$ = -272					; size = 4
__lpa$ = -268						; size = 4
__lpw$ = -264						; size = 4
__acp$ = -260						; size = 4
__convert$ = -256					; size = 4
_inputByteArray$ = -252					; size = 4
_m_binaryData$ = -244					; size = 48
_templateFound$ = -192					; size = 4
_guidStr$ = -184					; size = 50
_sigGuid$ = -124					; size = 16
_newPtr$ = -104						; size = 4
_tmpXmlStr$ = -96					; size = 4
_sigId$ = -84						; size = 4
_iSize$ = -72						; size = 4
_mem$ = -64						; size = 4
_signedInfoNode$ = -60					; size = 4
_sigNode$ = -56						; size = 4
_parent$ = -52						; size = 4
_cur$ = -48						; size = 4
_root$ = -44						; size = 4
_doc$ = -40						; size = 4
_charSignedXMLStr$ = -32				; size = 4
_curCharSigId$ = -24					; size = 4
_charSigId$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_xmlByteArray$ = 12					; size = 16
_signatureId$ = 28					; size = 4
_signedXmlByteArray$ = 32				; size = 4
?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z PROC NEAR ; CSignature::SignXMLByteArray

; 13869: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 368				; 00000170H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-380]
	mov	ecx, 92					; 0000005cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 13870: 	char *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 13871: 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 13872: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 13873: 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 13874: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 13875: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 13876: 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 13877: 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 13878: 	unsigned char *newPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0

; 13879: #ifdef WIN32
; 13880: 	GUID sigGuid;
; 13881: #else
; 13882: 	uuid_t sigGuid;
; 13883: #endif
; 13884: 	char guidStr[50];
; 13885: 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 13886: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 13887: 	VARIANT *inputByteArray;
; 13888: #ifdef LOGGING
; 13889: 	char buffer[200];
; 13890: #endif
; 13891: 
; 13892: 	EnterLog;
; 13893: 	if (xmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _xmlByteArray$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L213075

; 13894: 	{
; 13895: 		inputByteArray = xmlByteArray.pvarVal;

	mov	ecx, DWORD PTR _xmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 13896: 	}
; 13897: 	else

	jmp	SHORT $L213076
$L213075:

; 13898: 		inputByteArray = &xmlByteArray;

	lea	edx, DWORD PTR _xmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L213076:

; 13899: 
; 13900: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	$L213077

; 13901: 	{
; 13902: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 13903: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 13904: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222452[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 13905: 		return S_FALSE;

	mov	DWORD PTR $T222453[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222453[ebp]
	jmp	$L213055
$L213077:

; 13906: 	}
; 13907: 	//if (! LicObj.checkLicense()) {
; 13908: 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 13909: 	//	m_binaryData.SetLength(0);
; 13910: 	//	*signedXmlByteArray = m_binaryData.Copy();
; 13911: 	//	return S_FALSE;
; 13912: 	//}
; 13913: #ifdef LOGGING
; 13914: 	sprintf((char *)buffer, "Variant type = %x", xmlByteArray.vt);
; 13915: 	DebugLog((const char *)buffer);
; 13916: #endif
; 13917: 
; 13918: 	m_binaryData = xmlByteArray;

	lea	ecx, DWORD PTR _xmlByteArray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 13919: 
; 13920: #ifdef LOGGING
; 13921: 	sprintf((char *)buffer, "CBufferVariant size = %d", m_binaryData.GetLength());
; 13922: 	DebugLog((const char *)buffer);
; 13923: #endif
; 13924: 
; 13925: 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L213081

; 13926: 	{
; 13927: 		if (!LicObj.getFormSignAllowed((unsigned char *)((void *)m_binaryData), m_binaryData.GetLength(), SigHandle))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	$L213081

; 13928: 		{
; 13929: 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 13930: 			m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 13931: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222454[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 13932: 			return S_FALSE;

	mov	DWORD PTR $T222455[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222455[ebp]
	jmp	$L213055
$L213081:

; 13933: 		}
; 13934: 	}
; 13935: 	// original document
; 13936: 	doc = xmlParseMemory((const char *)((void *)m_binaryData), m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 13937: 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	$L213090

; 13938: 	{
; 13939: 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 13940: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 13941: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222456[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 13942: 		return S_FALSE;

	mov	DWORD PTR $T222457[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222457[ebp]
	jmp	$L213055
$L213090:

; 13943: 	}
; 13944: 
; 13945: 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L213094

; 13946: 	{
; 13947: 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L213095

; 13948: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L213095:

; 13949: 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 13950: 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L213094:

; 13951: 	}
; 13952: 
; 13953: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 13954: 
; 13955: 
; 13956: 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 13957: 	sigId = signatureId;

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 13958: 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213101

; 13959: 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 13960: 	else

	jmp	SHORT $L213102
$L213101:

; 13961: 	{
; 13962: 		charSigId = (char *)HeapW2A(signatureId);

	mov	eax, DWORD PTR _signatureId$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 13963: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213102:

; 13964: 	}
; 13965: 
; 13966: 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L213104

; 13967: 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213105

; 13968: 		{
; 13969: #ifdef WIN32
; 13970: 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 13971: 			GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 13972: #else
; 13973: 			uuid_generate(sigGuid);
; 13974: 			uuid_unparse(sigGuid, guidStr);
; 13975: #endif
; 13976: 			charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 13977: 		}
; 13978: 		else

	jmp	SHORT $L213104
$L213105:

; 13979: 		{
; 13980: 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 13981: 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213104:

; 13982: 		}
; 13983: 
; 13984: 	root = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 13985: 	sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 13986: 	if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L213110

; 13987: 	{
; 13988: 		templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 13989: 		cur = sigNode->xmlChildrenNode;

	mov	ecx, DWORD PTR _sigNode$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx
$L213112:

; 13990: 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L213110

; 13991: 		{
; 13992: 				if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG213116
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L213115

; 13993: 				{
; 13994: 					signedInfoNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], edx

; 13995: 					break;

	jmp	SHORT $L213110
$L213115:

; 13996: 				}
; 13997: 				cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 13998: 		}  // end while cur != NULL

	jmp	SHORT $L213112
$L213110:

; 13999: 	}
; 14000: 	  if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L213117

; 14001: 	  {
; 14002: 		  // Add a new Signature element
; 14003: 
; 14004: 		/*
; 14005: 		* Signature
; 14006: 		*/
; 14007: 
; 14008: 		cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213119
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14009: 		sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 14010: 		if (charSigId != NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	je	SHORT $L213120

; 14011: 			xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG213123
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213120:

; 14012: 		cur = xmlAddChild(root,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14013: 
; 14014: 		xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG213126
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 14015: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14016: 
; 14017: 		/*
; 14018: 		* SignedInfo
; 14019: 		*/
; 14020: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213128
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14021: 		signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 14022: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14023: 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 14024: 
; 14025: 		/*
; 14026: 		 * Canonicalization Method
; 14027: 		*/
; 14028: 		cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG213130
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14029: 		switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv259[ebp], edx
	cmp	DWORD PTR tv259[ebp], 3
	ja	SHORT $L213155
	mov	eax, DWORD PTR tv259[ebp]
	jmp	DWORD PTR $L222478[eax*4]
$L213135:

; 14030: 		{
; 14031: 			case WITH_COMMENTS:
; 14032: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213138
	push	OFFSET FLAT:$SG213139
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14033: 				break;

	jmp	SHORT $L213132
$L213140:

; 14034: 			case WITHOUT_COMMENTS:
; 14035: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG213143
	push	OFFSET FLAT:$SG213144
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14036: 				break;

	jmp	SHORT $L213132
$L213145:

; 14037: 			case EXC_WITH_COMMENTS:
; 14038: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213148
	push	OFFSET FLAT:$SG213149
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14039: 				break;

	jmp	SHORT $L213132
$L213150:

; 14040: 			case EXC_WITHOUT_COMMENTS:
; 14041: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213153
	push	OFFSET FLAT:$SG213154
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14042: 				break;

	jmp	SHORT $L213132
$L213155:

; 14043: 			default:
; 14044: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213158
	push	OFFSET FLAT:$SG213159
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213132:

; 14045: 		}
; 14046: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14047: 		/*
; 14048: 		* Reference
; 14049: 		*/
; 14050: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213161
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14051: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14052: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG213164
	push	OFFSET FLAT:$SG213165
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14053: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14054: 
; 14055: 		/*
; 14056: 		* Transforms
; 14057: 		*/
; 14058: 	
; 14059: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG213167
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14060: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14061: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14062: 
; 14063: 		/*
; 14064: 		* Transform
; 14065: 		*/
; 14066: 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 14067: 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L213169
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L213168
$L213169:

; 14068: 		{
; 14069: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213171
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14070: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L213172

; 14071: 			{
; 14072: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213175
	push	OFFSET FLAT:$SG213176
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14073: 			}
; 14074: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213177
$L213172:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L213177

; 14075: 			{
; 14076: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213181
	push	OFFSET FLAT:$SG213182
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213177:

; 14077: 			}
; 14078: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14079: 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14080: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L213183

; 14081: 			{
; 14082: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213185
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14083: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213188
	push	OFFSET FLAT:$SG213189
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 14084: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG213192
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14085: 			}
; 14086: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213193
$L213183:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L213193

; 14087: 			{
; 14088: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213196
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14089: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213199
	push	OFFSET FLAT:$SG213200
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 14090: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG213203
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213193:

; 14091: 			}
; 14092: 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14093: 			parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx
$L213168:

; 14094: 		}
; 14095: 		/*
; 14096: 		* Transform
; 14097: 		*/
; 14098: 
; 14099: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213205
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14100: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG213208
	push	OFFSET FLAT:$SG213209
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14101: 		cur = xmlAddChild(parent,cur);		

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L213117:

; 14102: 	  }
; 14103: 
; 14104: #ifdef WIN32
; 14105: 	  if (AddWindowImageFlag == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1796], 1
	jne	SHORT $L213210

; 14106: 		  AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L213210:

; 14107: 
; 14108: 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $L213211

; 14109: 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L213211:

; 14110: #endif
; 14111: 	/*
; 14112: 	 * init Signature. crBlob contains XML - envelope document
; 14113: 	 */
; 14114: 	short tmpEnvFlag = EnvelopingFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], dx

; 14115: 	EnvelopingFlag = ENVELOPED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+688], 2

; 14116: 
; 14117: 	if (!(CreateSigFromTmplBlob(
; 14118: 								doc,
; 14119: 								charSigId, &charSignedXMLStr, &iSize)))

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	$L213213

; 14120: 	{
; 14121: 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L213214

; 14122: 		{
; 14123: 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213214:

; 14124: 		}
; 14125: 		EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 14126: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14127: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222458[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14128: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213216

; 14129: 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L213216:

; 14130: 		return S_FALSE;

	mov	DWORD PTR $T222459[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222459[ebp]
	jmp	$L213055
$L213213:

; 14131: 	}
; 14132: 	else
; 14133: 	{
; 14134: 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L213219

; 14135: 		{
; 14136: #ifdef WIN32
; 14137: 			m_binaryData.AssignData((const void *)charSignedXMLStr, (long) iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 14138: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222460[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 14139: #else		
; 14140: 			VARIANT v;
; 14141: 			VariantInit(&v);
; 14142: 			*signedXmlByteArray = v;
; 14143: 			VariantFromByteArray(signedXmlByteArray,(const char *)charSignedXMLStr, (long) iSize);
; 14144: #endif
; 14145: 			if (Base64EncodeXML == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 1
	jne	SHORT $L213224

; 14146: 				zFree(charSignedXMLStr);

	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 14147: 			else

	jmp	SHORT $L213219
$L213224:

; 14148: 				xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213219:

; 14149: 		}
; 14150: 	}
; 14151: 	EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 14152: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213226

; 14153: 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L213226:

; 14154: 	ExitLog;
; 14155: 	return S_OK;

	mov	DWORD PTR $T222461[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222461[ebp]
$L213055:

; 14156: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222477
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 380				; 0000017cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222477:
	DD	7
	DD	$L222476
$L222476:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222467
	DD	-72					; ffffffb8H
	DD	4
	DD	$L222468
	DD	-84					; ffffffacH
	DD	4
	DD	$L222469
	DD	-96					; ffffffa0H
	DD	4
	DD	$L222470
	DD	-124					; ffffff84H
	DD	16					; 00000010H
	DD	$L222471
	DD	-184					; ffffff48H
	DD	50					; 00000032H
	DD	$L222472
	DD	-244					; ffffff0cH
	DD	48					; 00000030H
	DD	$L222473
$L222473:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222472:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222471:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L222470:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222469:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L222468:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222467:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222478:
	DD	$L213140
	DD	$L213135
	DD	$L213150
	DD	$L213145
_TEXT	ENDS
text$x	SEGMENT
$L222462:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222463:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222464:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z:
	mov	eax, OFFSET FLAT:$T222466
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z ENDP ; CSignature::SignXMLByteArray
PUBLIC	??_7CBufferVariant@@6B@				; CBufferVariant::`vftable'
PUBLIC	??_GCBufferVariant@@UAEPAXI@Z			; CBufferVariant::`scalar deleting destructor'
EXTRN	??_ECBufferVariant@@UAEPAXI@Z:NEAR		; CBufferVariant::`vector deleting destructor'
;	COMDAT ??_7CBufferVariant@@6B@
; File c:\activex\xmlsign\buffervariant.h
CONST	SEGMENT
??_7CBufferVariant@@6B@ DD FLAT:??_ECBufferVariant@@UAEPAXI@Z ; CBufferVariant::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0CBufferVariant@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CBufferVariant@@QAE@XZ PROC NEAR			; CBufferVariant::CBufferVariant, COMDAT
; _this$ = ecx

; 87   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBufferVariant@@6B@

; 88   : 	::VariantInit(&m_varData);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 89   : 	SetLength(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 90   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CBufferVariant@@QAE@XZ ENDP				; CBufferVariant::CBufferVariant
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GCBufferVariant@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCBufferVariant@@UAEPAXI@Z PROC NEAR			; CBufferVariant::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L189227
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L189227:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCBufferVariant@@UAEPAXI@Z ENDP			; CBufferVariant::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__SafeArrayUnaccessData@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1CBufferVariant@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CBufferVariant@@UAE@XZ PROC NEAR			; CBufferVariant::~CBufferVariant, COMDAT
; _this$ = ecx

; 98   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CBufferVariant@@6B@

; 99   : 	SafeArrayUnaccessData(m_varData.parray);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR __imp__SafeArrayUnaccessData@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 100  : 	::VariantClear(&m_varData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 101  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CBufferVariant@@UAE@XZ ENDP				; CBufferVariant::~CBufferVariant
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCBufferVariant@@QBEPAXXZ PROC NEAR			; CBufferVariant::operator void *, COMDAT
; _this$ = ecx

; 160  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 	return const_cast<void *>(m_pBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 162  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCBufferVariant@@QBEPAXXZ ENDP			; CBufferVariant::operator void *
_TEXT	ENDS
PUBLIC	?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z ; CBufferVariant::BuildByteArrayFromVariant
; Function compile flags: /Odt /RTCsu
;	COMDAT ??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_varSrc$ = 8						; size = 4
??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z PROC NEAR	; CBufferVariant::operator=, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 	BuildByteArrayFromVariant(&varSrc);

	mov	eax, DWORD PTR _varSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z ; CBufferVariant::BuildByteArrayFromVariant

; 199  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 200  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ENDP	; CBufferVariant::operator=
_TEXT	ENDS
PUBLIC	?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z ; CBufferVariant::BuildByteArrayFromData
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AssignData@CBufferVariant@@QAEXPBXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
_nLength$ = 12						; size = 4
?AssignData@CBufferVariant@@QAEXPBXJ@Z PROC NEAR	; CBufferVariant::AssignData, COMDAT
; _this$ = ecx

; 235  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 	BuildByteArrayFromData( pSrc, nLength);

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z ; CBufferVariant::BuildByteArrayFromData

; 237  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AssignData@CBufferVariant@@QAEXPBXJ@Z ENDP		; CBufferVariant::AssignData
_TEXT	ENDS
EXTRN	__imp__SafeArrayRedim@8:NEAR
EXTRN	__imp__SafeArrayAccessData@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?SetLength@CBufferVariant@@QAEXJ@Z
_TEXT	SEGMENT
_pSafeArrayBound$ = -16					; size = 8
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?SetLength@CBufferVariant@@QAEXJ@Z PROC NEAR		; CBufferVariant::SetLength, COMDAT
; _this$ = ecx

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 	//+ Ensure that we initialise the variant 
; 299  : 	SAFEARRAYBOUND pSafeArrayBound[1];
; 300  : 	
; 301  : 	pSafeArrayBound[0].lLbound = 0;

	mov	DWORD PTR _pSafeArrayBound$[ebp+4], 0

; 302  : //	pSafeArrayBound[0].cElements = nLength+1; //Why??
; 303  : 	pSafeArrayBound[0].cElements = nLength;

	mov	eax, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _pSafeArrayBound$[ebp], eax

; 304  : 
; 305  : 	if(V_VT(&m_varData) != VT_EMPTY)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+24]
	test	edx, edx
	je	SHORT $L189328

; 306  : 	{
; 307  : 		SafeArrayUnaccessData(m_varData.parray);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__SafeArrayUnaccessData@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 308  : 		SafeArrayRedim( m_varData.parray ,pSafeArrayBound);

	mov	esi, esp
	lea	edx, DWORD PTR _pSafeArrayBound$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__SafeArrayRedim@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 309  : 	}
; 310  : 	else

	jmp	SHORT $L189329
$L189328:

; 311  : 	{
; 312  : 		V_VT(&m_varData) = VT_ARRAY | VT_UI1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+24], 8209			; 00002011H

; 313  : 		//+ Create the array 
; 314  : 		m_varData.parray = SafeArrayCreate(VT_UI1, 1, pSafeArrayBound);

	mov	esi, esp
	lea	eax, DWORD PTR _pSafeArrayBound$[ebp]
	push	eax
	push	1
	push	17					; 00000011H
	call	DWORD PTR __imp__SafeArrayCreate@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax
$L189329:

; 315  : 	}
; 316  : 
; 317  : 	
; 318  : 	// Lock and access the memory
; 319  : 	//+ Access the data  
; 320  : 	SafeArrayAccessData(m_varData.parray, (void HUGEP**)&m_pBuffer);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__SafeArrayAccessData@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 321  : 
; 322  : //	char *p=(char *)m_pBuffer;
; 323  : //	p[nLength]=0; // Why??
; 324  : 	return;
; 325  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222495
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222495:
	DD	1
	DD	$L222494
$L222494:
	DD	-16					; fffffff0H
	DD	8
	DD	$L222493
$L222493:
	DB	112					; 00000070H
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?SetLength@CBufferVariant@@QAEXJ@Z ENDP			; CBufferVariant::SetLength
_TEXT	ENDS
PUBLIC	?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z ; CBufferVariant::MyVariantCopy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ
_TEXT	SEGMENT
_vNew$ = -24						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ PROC NEAR	; CBufferVariant::Copy, COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	VARIANT vNew;
; 330  : 	::VariantInit(&vNew);

	mov	esi, esp
	lea	eax, DWORD PTR _vNew$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 331  : //	::VariantCopy(&vNew, &m_varData);
; 332  : 	MyVariantCopy(&vNew, &m_varData);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	lea	edx, DWORD PTR _vNew$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z ; CBufferVariant::MyVariantCopy

; 333  : 	return vNew;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _vNew$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _vNew$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _vNew$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _vNew$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 334  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222500
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L222500:
	DD	1
	DD	$L222499
$L222499:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$L222498
$L222498:
	DB	118					; 00000076H
	DB	78					; 0000004eH
	DB	101					; 00000065H
	DB	119					; 00000077H
	DB	0
?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ENDP		; CBufferVariant::Copy
_TEXT	ENDS
EXTRN	__imp__SafeArrayCopy@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vDest$ = 8						; size = 4
_vSrc$ = 12						; size = 4
?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z PROC NEAR ; CBufferVariant::MyVariantCopy, COMDAT
; _this$ = ecx

; 337  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 	if (vDest == vSrc)

	mov	eax, DWORD PTR _vDest$[ebp]
	cmp	eax, DWORD PTR _vSrc$[ebp]
	jne	SHORT $L189341

; 339  : 		return;

	jmp	SHORT $L189340
$L189341:

; 340  : 	VariantClear(vDest);

	mov	esi, esp
	mov	ecx, DWORD PTR _vDest$[ebp]
	push	ecx
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 341  : 
; 342  : 	*vDest = *vSrc;

	mov	edx, DWORD PTR _vSrc$[ebp]
	mov	eax, DWORD PTR _vDest$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx

; 343  : 	vDest->vt = VT_ARRAY | VT_UI1;

	mov	eax, DWORD PTR _vDest$[ebp]
	mov	WORD PTR [eax], 8209			; 00002011H

; 344  : 	SafeArrayCopy(vSrc->parray, &vDest->parray);

	mov	ecx, DWORD PTR _vDest$[ebp]
	add	ecx, 8
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _vSrc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__SafeArrayCopy@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$L189340:

; 345  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z ENDP ; CBufferVariant::MyVariantCopy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetLength@CBufferVariant@@QAEJXZ
_TEXT	SEGMENT
_uBound$ = -28						; size = 4
_lBound$ = -16						; size = 4
_nLength$ = -8						; size = 4
_this$ = -4						; size = 4
?GetLength@CBufferVariant@@QAEJXZ PROC NEAR		; CBufferVariant::GetLength, COMDAT
; _this$ = ecx

; 349  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 350  : 	// TODO: Add your implementation code here
; 351  : 	if(V_VT(&m_varData) == VT_EMPTY)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+24]
	test	ecx, ecx
	jne	SHORT $L189345

; 352  : 		return 0;

	xor	eax, eax
	jmp	SHORT $L189344
$L189345:

; 353  : 
; 354  : 	// Determine the size of the array 
; 355  : 	long nLength, lBound, uBound;
; 356  : 	SafeArrayGetUBound(m_varData.parray, 1, &uBound);

	mov	esi, esp
	lea	edx, DWORD PTR _uBound$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetUBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 357  : 	SafeArrayGetLBound(m_varData.parray, 1, &lBound);

	mov	esi, esp
	lea	edx, DWORD PTR _lBound$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetLBound@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 358  : 	nLength = uBound - lBound + 1; // For C#

	mov	edx, DWORD PTR _uBound$[ebp]
	sub	edx, DWORD PTR _lBound$[ebp]
	add	edx, 1
	mov	DWORD PTR _nLength$[ebp], edx

; 359  : //	if (builtFromVariant) nLength++;
; 360  : 	return nLength;

	mov	eax, DWORD PTR _nLength$[ebp]
$L189344:

; 361  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222508
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L222508:
	DD	2
	DD	$L222507
$L222507:
	DD	-16					; fffffff0H
	DD	4
	DD	$L222505
	DD	-28					; ffffffe4H
	DD	4
	DD	$L222506
$L222506:
	DB	117					; 00000075H
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$L222505:
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?GetLength@CBufferVariant@@QAEJXZ ENDP			; CBufferVariant::GetLength
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT
_ppSrc$189359 = -8					; size = 4
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z PROC NEAR ; CBufferVariant::BuildByteArrayFromVariant, COMDAT
; _this$ = ecx

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 	//+ Ensure that we initialise the variant 
; 371  : 	if(V_VT(&m_varData) != VT_EMPTY)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+24]
	test	ecx, ecx
	je	SHORT $L189353

; 372  : 	{
; 373  : 		SafeArrayUnaccessData(m_varData.parray);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__SafeArrayUnaccessData@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 374  : 		::VariantClear(&m_varData);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	esi, esp
	push	ecx
	call	DWORD PTR __imp__VariantClear@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 375  : 		::VariantInit(&m_varData);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	mov	esi, esp
	push	edx
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L189353:

; 376  : 	}
; 377  : 	
; 378  : 	if ((V_VT(pSrc) == (VT_ARRAY | VT_UI1)) && SafeArrayGetDim(pSrc->parray) == 1)

	mov	eax, DWORD PTR _pSrc$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	jne	SHORT $L189354
	mov	esi, esp
	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__SafeArrayGetDim@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $L189354

; 379  : 	{
; 380  : 		::VariantCopy(&m_varData, const_cast<VARIANT*>(pSrc));

	mov	esi, esp
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 24					; 00000018H
	push	edx
	call	DWORD PTR __imp__VariantCopy@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 381  : 		// Lock and access the memory
; 382  : 		//+ Access the data  
; 383  : 		SafeArrayAccessData(m_varData.parray, (void HUGEP**)&m_pBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR __imp__SafeArrayAccessData@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 384  : //		builtFromVariant = true;
; 385  : 	}
; 386  : 	else

	jmp	$L189352
$L189354:

; 387  : 		if (V_VT(pSrc) == (VT_VARIANT | VT_BYREF))

	mov	eax, DWORD PTR _pSrc$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 16396				; 0000400cH
	jne	SHORT $L189358

; 388  : 		{
; 389  : 			VARIANT *ppSrc = pSrc->pvarVal;

	mov	edx, DWORD PTR _pSrc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _ppSrc$189359[ebp], eax

; 390  : 			if ((V_VT(ppSrc) == (VT_ARRAY | VT_UI1)) && SafeArrayGetDim(ppSrc->parray) == 1)

	mov	ecx, DWORD PTR _ppSrc$189359[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 8209				; 00002011H
	jne	SHORT $L189360
	mov	esi, esp
	mov	eax, DWORD PTR _ppSrc$189359[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__SafeArrayGetDim@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $L189360

; 391  : 			{
; 392  : 				::VariantCopy(&m_varData, const_cast<VARIANT*>(ppSrc));

	mov	esi, esp
	mov	edx, DWORD PTR _ppSrc$189359[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	call	DWORD PTR __imp__VariantCopy@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 393  : 				// Lock and access the memory
; 394  : 				//+ Access the data  
; 395  : 				SafeArrayAccessData(m_varData.parray, (void HUGEP**)&m_pBuffer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__SafeArrayAccessData@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 396  : //				builtFromVariant = false;
; 397  : 			}
; 398  : 			else

	jmp	SHORT $L189363
$L189360:

; 399  : 			{
; 400  : 				SetLength(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength
$L189363:

; 401  : 			}
; 402  : 		}
; 403  : 		else

	jmp	SHORT $L189352
$L189358:

; 404  : 		{
; 405  : 			SetLength(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength
$L189352:

; 406  : 		}
; 407  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z ENDP ; CBufferVariant::BuildByteArrayFromVariant
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pvData$ = 8						; size = 4
_nLength$ = 12						; size = 4
?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z PROC NEAR ; CBufferVariant::BuildByteArrayFromData, COMDAT
; _this$ = ecx

; 410  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 411  : //	builtFromVariant = false;
; 412  : 	SetLength(nLength);

	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 413  : 	//+ Copy the data 
; 414  : 	memcpy(m_pBuffer,pvData, nLength );

	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 415  : 	return;
; 416  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z ENDP	; CBufferVariant::BuildByteArrayFromData
_TEXT	ENDS
PUBLIC	??BCBufferVariant@@QBEPBXXZ			; CBufferVariant::operator void const *
PUBLIC	?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ; CSignature::SaveXMLByteArray
xdata$x	SEGMENT
$T222538 DD	0ffffffffH
	DD	FLAT:$L222524
	DD	00H
	DD	FLAT:$L222525
	DD	01H
	DD	FLAT:$L222526
$T222528 DD	019930520H
	DD	03H
	DD	FLAT:$T222538
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T222523 = -444						; size = 4
$T222522 = -440						; size = 4
$T222521 = -436						; size = 4
$T222520 = -432						; size = 4
$T222519 = -428						; size = 4
$T222518 = -424						; size = 4
$T222517 = -420						; size = 4
$T222516 = -416						; size = 4
__lpa$ = -412						; size = 4
__lpw$ = -408						; size = 4
__acp$ = -404						; size = 4
__convert$ = -400					; size = 4
_tmpFilePath$ = -392					; size = 4
_inputByteArray$ = -384					; size = 4
_m_binaryData$ = -376					; size = 48
_freeMemory$ = -324					; size = 4
_tmpXmlStr$ = -316					; size = 4
_TempPath$ = -304					; size = 260
_bstrFileName$ = -40					; size = 4
_ccBstrFileName$ = -32					; size = 4
_writeResult$ = -24					; size = 4
_hInFile$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputXmlByteArray$ = 12				; size = 16
_fileName$ = 28						; size = 4
_path$ = 32						; size = 4
?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z PROC NEAR ; CSignature::SaveXMLByteArray

; 14159: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 432				; 000001b0H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-444]
	mov	ecx, 108				; 0000006cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 14160: 	FILE *hInFile; 
; 14161: 	BOOL writeResult;
; 14162: 	CComBSTR ccBstrFileName;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 14163: 	BSTR bstrFileName;
; 14164: 	char TempPath[MAX_PATH];
; 14165: 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 14166: 	BOOL freeMemory=FALSE;

	mov	DWORD PTR _freeMemory$[ebp], 0

; 14167: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 14168: 	VARIANT *inputByteArray;
; 14169: 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 14170: #ifdef LOGGING
; 14171: 	char buffer[200];
; 14172: #endif
; 14173: 
; 14174: 	EnterLog;
; 14175: 	*path = A2WBSTR((const char *) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _path$[ebp]
	mov	DWORD PTR [ecx], eax

; 14176: 
; 14177: 	if (inputXmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	edx, WORD PTR _inputXmlByteArray$[ebp]
	cmp	edx, 16396				; 0000400cH
	jne	SHORT $L213246

; 14178: 	{
; 14179: 		inputByteArray = inputXmlByteArray.pvarVal;

	mov	eax, DWORD PTR _inputXmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], eax

; 14180: 	}
; 14181: 	else

	jmp	SHORT $L213247
$L213246:

; 14182: 		inputByteArray = &inputXmlByteArray;

	lea	ecx, DWORD PTR _inputXmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], ecx
$L213247:

; 14183: 
; 14184: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	edx, DWORD PTR _inputByteArray$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 8209				; 00002011H
	je	SHORT $L213248

; 14185: 	{
; 14186: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 14187: 		return S_FALSE;

	mov	DWORD PTR $T222516[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222516[ebp]
	jmp	$L213234
$L213248:

; 14188: 	}
; 14189: 	m_binaryData = inputXmlByteArray;

	lea	eax, DWORD PTR _inputXmlByteArray$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 14190: #ifdef LOGGING
; 14191: 	sprintf((char *)buffer, "Variant type = %x", inputXmlByteArray.vt);
; 14192: 	DebugLog((const char *)buffer);
; 14193: #endif
; 14194: 
; 14195: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 14196: 	ccBstrFileName = fileName;

	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 14197: 
; 14198: 	if ((ccBstrFileName.Length() == 0) || (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L213256
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3364], 1
	jne	$L213255
$L213256:

; 14199: 	{
; 14200: 		// Create temporary file for saving input XML String
; 14201: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14202: 		GetTempFileName(TempPath, // dir. for temp. files 
; 14203: 			"INF",                // temp. file name prefix 
; 14204: 			0,                    // create unique name 
; 14205: 			szTempName);          // buffer for name 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	mov	esi, esp
	push	ecx
	push	0
	push	OFFSET FLAT:$SG213258
	lea	edx, DWORD PTR _TempPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14206: 		bstrFileName = A2WBSTR(szTempName);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 14207: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222517[ebp], eax
	mov	ecx, DWORD PTR $T222517[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 14208: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 14209: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222518[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T222519[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 14210: 	}
; 14211: 	else

	jmp	SHORT $L213264
$L213255:

; 14212: 		bstrFileName = SysAllocString(fileName);

	mov	esi, esp
	mov	ecx, DWORD PTR _fileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L213264:

; 14213: 
; 14214: 	// open file in write mode 
; 14215: #ifdef WIN32
; 14216: 	if ((hInFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG213266
	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hInFile$[ebp], eax
	cmp	DWORD PTR _hInFile$[ebp], 0
	jne	$L213265

; 14217: #elif LINUX
; 14218: 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 14219: 	if ((hInFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 14220: 			zFree(utf8FileName);
; 14221: #endif
; 14222: 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14223: 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14224: 			DebugLog("Could not create file");
; 14225: 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L213267

; 14226: 			{
; 14227: 				tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L213267:

; 14228: 			}
; 14229: 			return S_FALSE;

	mov	DWORD PTR $T222520[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222520[ebp]
	jmp	$L213234
$L213265:

; 14230: 	}
; 14231: #ifdef LINUX
; 14232: 	zFree(utf8FileName);
; 14233: #endif
; 14234: #ifdef LOGGING
; 14235: 	sprintf((char *)buffer, "file %ws file size = %d", fileName, m_binaryData.GetLength());
; 14236: 	DebugLog((const char *)buffer);
; 14237: #endif
; 14238: 	if ((writeResult = fwrite((const void *)m_binaryData, m_binaryData.GetLength(), 1, hInFile)) == 0)

	mov	edx, DWORD PTR _hInFile$[ebp]
	push	edx
	push	1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBXXZ		; CBufferVariant::operator void const *
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _writeResult$[ebp], eax
	cmp	DWORD PTR _writeResult$[ebp], 0
	jne	SHORT $L213271

; 14239: 	{
; 14240: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14241: 		DebugLog("Could not write to file");
; 14242: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L213272

; 14243: 		{
; 14244: 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L213272:

; 14245: 		}
; 14246: 		return S_FALSE;

	mov	DWORD PTR $T222521[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222521[ebp]
	jmp	$L213234
$L213271:

; 14247: 	}
; 14248: 	if (ferror(hInFile))

	mov	ecx, DWORD PTR _hInFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 32					; 00000020H
	je	SHORT $L213275

; 14249: 	{
; 14250: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14251: 		DebugLog("Could not write to file");
; 14252: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L213276

; 14253: 		{
; 14254: 			tmpFileList->remove(tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L213276:

; 14255: 		}
; 14256: 		return S_FALSE;

	mov	DWORD PTR $T222522[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222522[ebp]
	jmp	SHORT $L213234
$L213275:

; 14257: 	}
; 14258: 
; 14259: 	fclose(hInFile);

	mov	ecx, DWORD PTR _hInFile$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 14260: 	//tmpXmlStr = bstrFileName;
; 14261: 	//*path = tmpXmlStr.Copy();
; 14262: 	*path = bstrFileName;

	mov	edx, DWORD PTR _path$[ebp]
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 14263: 	ExitLog;
; 14264: 	return S_OK;

	mov	DWORD PTR $T222523[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222523[ebp]
$L213234:

; 14265: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222537
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 444				; 000001bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222537:
	DD	5
	DD	$L222536
$L222536:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222529
	DD	-304					; fffffed0H
	DD	260					; 00000104H
	DD	$L222530
	DD	-316					; fffffec4H
	DD	4
	DD	$L222531
	DD	-376					; fffffe88H
	DD	48					; 00000030H
	DD	$L222532
	DD	-392					; fffffe78H
	DD	4
	DD	$L222533
$L222533:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222532:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222531:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222530:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222529:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222524:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222525:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222526:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222528
	jmp	___CxxFrameHandler
text$x	ENDS
?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ENDP ; CSignature::SaveXMLByteArray
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\buffervariant.h
;	COMDAT ??BCBufferVariant@@QBEPBXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCBufferVariant@@QBEPBXXZ PROC NEAR			; CBufferVariant::operator void const *, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 	return m_pBuffer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 156  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCBufferVariant@@QBEPBXXZ ENDP			; CBufferVariant::operator void const *
_TEXT	ENDS
PUBLIC	?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z ; CSignature::ReadAllByteArray
xdata$x	SEGMENT
$T222555 DD	0ffffffffH
	DD	FLAT:$L222546
$T222548 DD	019930520H
	DD	01H
	DD	FLAT:$T222555
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T222545 = -148						; size = 4
$T222544 = -144						; size = 16
$T222543 = -128						; size = 4
$T222542 = -124						; size = 16
__lpa$ = -108						; size = 4
__lpw$ = -104						; size = 4
__acp$ = -100						; size = 4
__convert$ = -96					; size = 4
_dwFileSize$ = -88					; size = 4
_m_binaryData$ = -76					; size = 48
_dataPtr$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_fileName$ = 12						; size = 4
_fileDataByteArray$ = 16				; size = 4
?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z PROC NEAR ; CSignature::ReadAllByteArray

; 14268: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 136				; 00000088H
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14269: 	unsigned char *dataPtr;
; 14270: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 14271: 	DWORD	dwFileSize;
; 14272: #ifdef LOGGING
; 14273: 	char buffer[200];
; 14274: #endif
; 14275: 
; 14276: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 14277: 	EnterLog;
; 14278: 
; 14279: 	//charFileName = HeapW2A(fileName);
; 14280: 	//if ((charFileName == NULL) || (strlen((const char *)charFileName) == 0))
; 14281: 	//{
; 14282: 	//	setError(SigHandle, DEREF_URI_ERROR);
; 14283: 	//	zFree(charFileName);
; 14284: 	//	return S_FALSE;
; 14285: 	//}
; 14286: 
; 14287: 	//dataPtr = xsDereferenceURI((URI)charFileName, &dwFileSize);
; 14288: 	if (ReadAllBin(fileName, &dataPtr, &dwFileSize) == S_FALSE)

	lea	eax, DWORD PTR _dwFileSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReadAllBin@CSignature@@QAEHPAGPAPAEPAK@Z ; CSignature::ReadAllBin
	cmp	eax, 1
	jne	SHORT $L213294

; 14289: 	{
; 14290: 		setError(SigHandle, FILE_NOT_FOUND);

	push	27					; 0000001bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14291: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14292: 		*fileDataByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222542[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _fileDataByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14293: //		zFree(charFileName);
; 14294: 		return S_FALSE;

	mov	DWORD PTR $T222543[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222543[ebp]
	jmp	SHORT $L213285
$L213294:

; 14295: 	}
; 14296: #ifdef LOGGING
; 14297: 	sprintf((char *)buffer, "file %ws file size = %d", fileName, dwFileSize);
; 14298: 	DebugLog((const char *)buffer);
; 14299: #endif
; 14300: 
; 14301: #ifdef WIN32
; 14302: 	m_binaryData.AssignData((const void *)dataPtr, (long) dwFileSize);

	mov	ecx, DWORD PTR _dwFileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 14303: 	*fileDataByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222544[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _fileDataByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14304: #else		
; 14305: 	VARIANT v;
; 14306: 	VariantInit(&v);
; 14307: 	*fileDataByteArray = v;
; 14308: 	VariantFromByteArray(fileDataByteArray,(const char *)dataPtr, (long) dwFileSize);
; 14309: #endif
; 14310: 
; 14311: #ifdef LOGGING
; 14312: 	sprintf((char *)buffer, "Variant type = %x", fileDataByteArray->vt);
; 14313: 	DebugLog((const char *)buffer);
; 14314: #endif
; 14315: 	zFree(dataPtr);

	mov	ecx, DWORD PTR _dataPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 14316: //	zFree(charFileName);
; 14317: 	ExitLog;
; 14318: 	return S_OK;

	mov	DWORD PTR $T222545[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222545[ebp]
$L213285:

; 14319: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222554
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222554:
	DD	3
	DD	$L222553
$L222553:
	DD	-20					; ffffffecH
	DD	4
	DD	$L222549
	DD	-76					; ffffffb4H
	DD	48					; 00000030H
	DD	$L222550
	DD	-88					; ffffffa8H
	DD	4
	DD	$L222551
$L222551:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222550:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222549:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	80					; 00000050H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222546:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z:
	mov	eax, OFFSET FLAT:$T222548
	jmp	___CxxFrameHandler
text$x	ENDS
?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z ENDP ; CSignature::ReadAllByteArray
PUBLIC	??BCBufferVariant@@QBEPBEXZ			; CBufferVariant::operator unsigned char const *
PUBLIC	?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z ; CSignature::VerifyXMLByteArray
xdata$x	SEGMENT
$T222567 DD	0ffffffffH
	DD	FLAT:$L222559
$T222561 DD	019930520H
	DD	01H
	DD	FLAT:$T222567
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222558 = -96						; size = 4
$T222557 = -92						; size = 4
_i$213328 = -88						; size = 4
_certStatus$ = -80					; size = 4
_inputByteArray$ = -72					; size = 4
_m_binaryData$ = -64					; size = 48
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_signedXmlByteArray$ = 12				; size = 16
_sigStatus$ = 28					; size = 4
?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z PROC NEAR ; CSignature::VerifyXMLByteArray

; 14322: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 84					; 00000054H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 21					; 00000015H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 14323: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 14324: 	VARIANT *inputByteArray;
; 14325: 	long certStatus=FALSE;

	mov	DWORD PTR _certStatus$[ebp], 0

; 14326: #ifdef LOGGING
; 14327: 	char buffer[200];
; 14328: #endif
; 14329: 
; 14330: 	EnterLog;
; 14331: 	if (signedXmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _signedXmlByteArray$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L213311

; 14332: 	{
; 14333: 		inputByteArray = signedXmlByteArray.pvarVal;

	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 14334: 	}
; 14335: 	else

	jmp	SHORT $L213312
$L213311:

; 14336: 		inputByteArray = &signedXmlByteArray;

	lea	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L213312:

; 14337: 
; 14338: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	SHORT $L213313

; 14339: 	{
; 14340: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 14341: 		return S_FALSE;

	mov	DWORD PTR $T222557[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222557[ebp]
	jmp	$L213307
$L213313:

; 14342: 	}
; 14343: #ifdef LOGGING
; 14344: 	sprintf((char *)buffer, "Variant type = %x", signedXmlByteArray.vt);
; 14345: 	DebugLog((const char *)buffer);
; 14346: #endif
; 14347: 	m_binaryData = signedXmlByteArray;

	lea	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 14348: 	*sigStatus = TRUE;

	mov	edx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [edx], 1

; 14349: 
; 14350: 	if (uriArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L213316

; 14351: 	{
; 14352: 		SigHandle->locArray = uriArr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+12], ecx

; 14353: 		SigHandle->locNumber = totalUriCount;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+16], edx
$L213316:

; 14354: 	}
; 14355: 
; 14356: 	if (HMACKey.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213317

; 14357: 		*sigStatus = (BOOL) axVerify((const unsigned char *)m_binaryData, m_binaryData.GetLength(), NULL, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3420]
	push	ecx
	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBEXZ		; CBufferVariant::operator unsigned char const *
	push	eax
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [edx], eax

; 14358: 	else

	jmp	SHORT $L213320
$L213317:

; 14359: 	{
; 14360: 		/*
; 14361: 		 * This might not work on Windows 95/98
; 14362: 		 */
; 14363: 		xsCoreSetCSP((unsigned char *)"Microsoft Enhanced Cryptographic Provider v1.0",SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	OFFSET FLAT:$SG213322
	call	_xsCoreSetCSP
	add	esp, 8

; 14364: 		*sigStatus = (BOOL) axVerify((const unsigned char *)m_binaryData, m_binaryData.GetLength(), &HMACPassword, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3424]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3420]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 908				; 0000038cH
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBEXZ		; CBufferVariant::operator unsigned char const *
	push	eax
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [edx], eax
$L213320:

; 14365: 	}
; 14366: 
; 14367: 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L213325

; 14368: 	{
; 14369: 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L213326

; 14370: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L213326:

; 14371: 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 14372: 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L213325:

; 14373: 	}
; 14374: 
; 14375: 	//if (DetailedVerificationReportFlag)
; 14376: 	//	FetchSignatureStatus(*sigStatus);
; 14377: 	//else
; 14378: 	//	sgArr = axGetSignature(&signum, SigHandle); // Get the full signature stats
; 14379: 	FetchSignatureStatus(*sigStatus, DetailedVerificationReportFlag);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _sigStatus$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FetchSignatureStatus@CSignature@@QAEXHH@Z ; CSignature::FetchSignatureStatus

; 14380: 
; 14381: 	if ((*sigStatus != FALSE)&&(CertVerifyParams.verificationOptions))

	mov	edx, DWORD PTR _sigStatus$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$L213327
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1856], 0
	je	SHORT $L213327

; 14382: 	{
; 14383: 		for (int i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$213328[ebp], 0
	jmp	SHORT $L213329
$L213330:
	mov	ecx, DWORD PTR _i$213328[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$213328[ebp], ecx
$L213329:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$213328[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L213327

; 14384: 		{
; 14385: 			// certificate is present in the signature, validate it
; 14386: 			if (sgArr[i]->certificatesCount != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$213328[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L213332

; 14387: 			{
; 14388: 				get_SigCertStatus(i, NULL, 0, &certStatus);

	mov	esi, esp
	lea	edx, DWORD PTR _certStatus$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _i$213328[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+344]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14389: 				if (certStatus != 0)

	cmp	DWORD PTR _certStatus$[ebp], 0
	je	SHORT $L213332

; 14390: 				{
; 14391: 					// Add signature status value of failed
; 14392: 					*sigStatus = FALSE;

	mov	ecx, DWORD PTR _sigStatus$[ebp]
	mov	DWORD PTR [ecx], 0

; 14393: 					sgArr[i]->status = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$213328[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+8], 0

; 14394: 					break;

	jmp	SHORT $L213327
$L213332:

; 14395: 				}
; 14396: 			}
; 14397: 		}

	jmp	SHORT $L213330
$L213327:

; 14398: 	}
; 14399: 
; 14400: 	ExitLog;
; 14401: 	return S_OK;

	mov	DWORD PTR $T222558[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222558[ebp]
$L213307:

; 14402: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222566
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 96					; 00000060H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L222566:
	DD	2
	DD	$L222565
$L222565:
	DD	-64					; ffffffc0H
	DD	48					; 00000030H
	DD	$L222562
	DD	-80					; ffffffb0H
	DD	4
	DD	$L222563
$L222563:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$L222562:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222559:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z:
	mov	eax, OFFSET FLAT:$T222561
	jmp	___CxxFrameHandler
text$x	ENDS
?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z ENDP ; CSignature::VerifyXMLByteArray
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\buffervariant.h
;	COMDAT ??BCBufferVariant@@QBEPBEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCBufferVariant@@QBEPBEXZ PROC NEAR			; CBufferVariant::operator unsigned char const *, COMDAT
; _this$ = ecx

; 178  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 	return (const unsigned char *)m_pBuffer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 180  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCBufferVariant@@QBEPBEXZ ENDP			; CBufferVariant::operator unsigned char const *
_TEXT	ENDS
PUBLIC	??4CBufferVariant@@QAEAAV0@PBD@Z		; CBufferVariant::operator=
PUBLIC	?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ; CSignature::SecureXMLVerifyByteArray
xdata$x	SEGMENT
$T222594 DD	0ffffffffH
	DD	FLAT:$L222580
$T222582 DD	019930520H
	DD	01H
	DD	FLAT:$T222594
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T222579 = -540						; size = 4
$T222578 = -536						; size = 16
$T222577 = -520						; size = 4
$T222576 = -516						; size = 16
$T222575 = -500						; size = 4
$T222574 = -496						; size = 16
$T222573 = -480						; size = 4
$T222572 = -476						; size = 16
_equalPtr$213545 = -460					; size = 4
_charTsProp$213544 = -456				; size = 4
_utf16StrByteLen$213475 = -448				; size = 4
_utf16CharStrLen$213474 = -440				; size = 4
_utf8CharStrLen$213473 = -432				; size = 4
_utf8CharStr$213472 = -424				; size = 4
_errStr$213462 = -420					; size = 4
_certStatus$213445 = -412				; size = 4
_tmpErr$213421 = -404					; size = 4
__lpa$ = -400						; size = 4
__lpw$ = -396						; size = 4
__acp$ = -392						; size = 4
__convert$ = -388					; size = 4
_plainTextHex$ = -384					; size = 4
_pbDocument$ = -380					; size = 4
_pbData$ = -376						; size = 4
_buffer$ = -368						; size = 200
_iSize$ = -160						; size = 4
_dtd$ = -152						; size = 4
_mem$ = -144						; size = 4
_curNs$ = -136						; size = 4
_commNode$ = -132					; size = 4
_parent$ = -128						; size = 4
_rootNode$ = -124					; size = 4
_cur$ = -120						; size = 4
_doc$ = -116						; size = 4
_sigStatus$ = -112					; size = 4
_uriPath$ = -108					; size = 4
_refArr$ = -104						; size = 4
_failedLocNum$ = -100					; size = 4
_totalLocNum$ = -96					; size = 4
_refNum$ = -92						; size = 4
_j$ = -88						; size = 4
_i$ = -84						; size = 4
_certStatus$ = -80					; size = 4
_inputByteArray$ = -76					; size = 4
_m_binaryData$ = -68					; size = 48
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_signedXmlByteArray$ = 12				; size = 16
_verificationResponseByteArray$ = 28			; size = 4
?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z PROC NEAR ; CSignature::SecureXMLVerifyByteArray

; 14405: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 528				; 00000210H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-540]
	mov	ecx, 132				; 00000084H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 14406: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 14407: 	VARIANT *inputByteArray;
; 14408: 	long certStatus=FALSE;

	mov	DWORD PTR _certStatus$[ebp], 0

; 14409: 	int i,j,refNum=0, totalLocNum=0, failedLocNum=0;

	mov	DWORD PTR _refNum$[ebp], 0
	mov	DWORD PTR _totalLocNum$[ebp], 0
	mov	DWORD PTR _failedLocNum$[ebp], 0

; 14410: 	PURI_STATUS *refArr=NULL;

	mov	DWORD PTR _refArr$[ebp], 0

; 14411: 	PURI_PATH uriPath=NULL;

	mov	DWORD PTR _uriPath$[ebp], 0

; 14412: 	long sigStatus;
; 14413: 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 14414: 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0

; 14415: 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 14416: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 14417: 	xmlDtdPtr dtd=NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 14418: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 14419: 	char buffer[200];
; 14420: 	unsigned char *pbData=NULL, *pbDocument=NULL, *plainTextHex=NULL;

	mov	DWORD PTR _pbData$[ebp], 0
	mov	DWORD PTR _pbDocument$[ebp], 0
	mov	DWORD PTR _plainTextHex$[ebp], 0

; 14421: 
; 14422: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 14423: 
; 14424: 	EnterLog;
; 14425: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L213369

; 14426: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14427: 		m_binaryData = "<?xml version=\"1.0\" ?>\n<Error>Invalid SecureXML License</Error>";

	push	OFFSET FLAT:$SG213370
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@PBD@Z	; CBufferVariant::operator=

; 14428: 		*verificationResponseByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222572[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _verificationResponseByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14429: 		return S_FALSE;

	mov	DWORD PTR $T222573[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222573[ebp]
	jmp	$L213340
$L213369:

; 14430: 	}
; 14431: 	if (!LicObj.getVerifyAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getVerifyAllowed@CLicense@@QAEHXZ	; CLicense::getVerifyAllowed
	test	eax, eax
	jne	SHORT $L213374

; 14432: 		setError(SigHandle, NO_VERIFICATION_LIC);

	push	44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 14433: 		m_binaryData = "<?xml version=\"1.0\" ?>\n<Error>No SecureXML Verification License</Error>";

	push	OFFSET FLAT:$SG213375
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@PBD@Z	; CBufferVariant::operator=

; 14434: 		*verificationResponseByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222574[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _verificationResponseByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14435: 		return S_FALSE;

	mov	DWORD PTR $T222575[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222575[ebp]
	jmp	$L213340
$L213374:

; 14436: 	}
; 14437: 
; 14438: 	if (signedXmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	ecx, WORD PTR _signedXmlByteArray$[ebp]
	cmp	ecx, 16396				; 0000400cH
	jne	SHORT $L213379

; 14439: 	{
; 14440: 		inputByteArray = signedXmlByteArray.pvarVal;

	mov	edx, DWORD PTR _signedXmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], edx

; 14441: 	}
; 14442: 	else

	jmp	SHORT $L213380
$L213379:

; 14443: 		inputByteArray = &signedXmlByteArray;

	lea	eax, DWORD PTR _signedXmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], eax
$L213380:

; 14444: 
; 14445: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	ecx, DWORD PTR _inputByteArray$[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 8209				; 00002011H
	je	SHORT $L213381

; 14446: 	{
; 14447: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14448: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14449: 		*verificationResponseByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222576[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _verificationResponseByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14450: 		return S_FALSE;

	mov	DWORD PTR $T222577[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222577[ebp]
	jmp	$L213340
$L213381:

; 14451: 	}
; 14452: #ifdef LOGGING
; 14453: 	sprintf((char *)buffer, "Variant type = %x", signedXmlByteArray.vt);
; 14454: 	DebugLog((const char *)buffer);
; 14455: #endif
; 14456: 	m_binaryData = signedXmlByteArray;

	lea	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 14457: 	sigStatus = TRUE;

	mov	DWORD PTR _sigStatus$[ebp], 1

; 14458: 
; 14459: 	SigHandle->locArray = uriArr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 14460: 	SigHandle->locNumber = totalUriCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+16], eax

; 14461: 
; 14462: 
; 14463: 	if (HMACKey.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1804				; 0000070cH
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213385

; 14464: 		sigStatus = (BOOL) axVerify((const unsigned char *)m_binaryData, m_binaryData.GetLength(), NULL, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1816]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3424]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3420]
	push	edx
	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBEXZ		; CBufferVariant::operator unsigned char const *
	push	eax
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _sigStatus$[ebp], eax

; 14465: 	else

	jmp	SHORT $L213388
$L213385:

; 14466: 	{
; 14467: 		/*
; 14468: 		 * This might not work on Windows 95/98
; 14469: 		 */
; 14470: 		xsCoreSetCSP((unsigned char *)"Microsoft Enhanced Cryptographic Provider v1.0",SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	OFFSET FLAT:$SG213390
	call	_xsCoreSetCSP
	add	esp, 8

; 14471: 		sigStatus = (BOOL) axVerify((const unsigned char *)m_binaryData, m_binaryData.GetLength(), &HMACPassword, IgnoreIncompleteSignature, SigIndexToVerify, DetailedVerificationReportFlag, SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1816]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3424]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3420]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 908				; 0000038cH
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBEXZ		; CBufferVariant::operator unsigned char const *
	push	eax
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _sigStatus$[ebp], eax
$L213388:

; 14472: 	}
; 14473: 
; 14474: 	//if (DetailedVerificationReportFlag == TRUE)
; 14475: 	//	FetchSignatureStatus(sigStatus);
; 14476: 	//else
; 14477: 	//	sgArr = axGetSignature(&signum, SigHandle); // Get the full signature stats
; 14478: 	FetchSignatureStatus(sigStatus, DetailedVerificationReportFlag);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1816]
	push	eax
	mov	ecx, DWORD PTR _sigStatus$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FetchSignatureStatus@CSignature@@QAEXHH@Z ; CSignature::FetchSignatureStatus

; 14479: 
; 14480: 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG213394
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 14481: 	// document, namespace, element name, element content
; 14482: 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"XMLSignatureVerificationResponse",NULL);

	push	0
	push	OFFSET FLAT:$SG213396
	push	0
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 14483: 
; 14484: 	// if you want any namespace definition here
; 14485: 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/XMLSign/VerifyResponse/DTD.htm",NULL/*(const unsigned char *)"infomosaic"*/);

	push	0
	push	OFFSET FLAT:$SG213398
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 14486: 	//xmlSetNs(cur,curNs);
; 14487: 
; 14488: 	// add root element
; 14489: 	xmlDocSetRootElement(doc,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocSetRootElement
	add	esp, 8

; 14490: 	rootNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], eax

; 14491: 
; 14492: 	// add some comment
; 14493: 	commNode = xmlNewDocComment(doc,(const unsigned char *)"1.2 Verified by Infomosaic SecureXML http://www.infomosaic.net");

	push	OFFSET FLAT:$SG213400
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 14494: 	cur = xmlAddChild(rootNode,commNode);

	mov	edx, DWORD PTR _commNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14495: 	/*
; 14496: 	 * SignatureCount
; 14497: 	*/
; 14498: 	cur = xmlNewNode(NULL,(const unsigned char *)"SignatureCount"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213402
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14499: 	cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14500: 	itoa(signum, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH

; 14501: 	xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14502: 
; 14503: 	if (signum == 0) // No signature was found or XML error

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	$L213405

; 14504: 	{
; 14505: 		/*
; 14506: 		* SignatureStatus
; 14507: 		*/
; 14508: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureStatus"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213407
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14509: 		cur = xmlAddChild(rootNode,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14510: 
; 14511: 		/*
; 14512: 		* subnodes of SignatureStatus
; 14513: 		*/
; 14514: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14515: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureId");

	push	OFFSET FLAT:$SG213409
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14516: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14517: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignatureAlgorithm");

	push	OFFSET FLAT:$SG213411
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14518: 		cur = xmlAddChild(parent,cur);	

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14519: 		cur = xmlNewNode(NULL,(const unsigned char *)"Status");

	push	OFFSET FLAT:$SG213413
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14520: 		// Add signature status value of failed
; 14521: 		itoa(FALSE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	0
	call	_itoa
	add	esp, 12					; 0000000cH

; 14522: 		xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 14523: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14524: 
; 14525: 		cur = xmlNewNode(NULL,(const unsigned char *)"LastError");

	push	OFFSET FLAT:$SG213417
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14526: 		// Add last error code
; 14527: 		itoa(axGetLastError(SigHandle), (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetLastError
	add	esp, 4
	push	eax
	call	_itoa
	add	esp, 12					; 0000000cH

; 14528: 		xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14529: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14530: 
; 14531: 		if (axGetLastError(SigHandle) != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetLastError
	add	esp, 4
	test	eax, eax
	je	SHORT $L213420

; 14532: 		{
; 14533: 			unsigned char *tmpErr=axGetError(SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_axGetError
	add	esp, 4
	mov	DWORD PTR _tmpErr$213421[ebp], eax

; 14534: 			// add comment with additional errors
; 14535: 			commNode = xmlNewDocComment(doc,(const unsigned char *)tmpErr);

	mov	edx, DWORD PTR _tmpErr$213421[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 14536: 			cur = xmlAddChild(parent,commNode);

	mov	ecx, DWORD PTR _commNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14537: 			zFree(tmpErr);

	mov	eax, DWORD PTR _tmpErr$213421[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L213420:

; 14538: 		}
; 14539: 
; 14540: 		
; 14541: 		cur = xmlNewNode(NULL,(const unsigned char *)"ReferenceCount");

	push	OFFSET FLAT:$SG213424
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14542: 		// Set reference count to zero
; 14543: 		xmlNodeSetContent(cur,(const unsigned char *)"0");

	push	OFFSET FLAT:$SG213426
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14544: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14545: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference");

	push	OFFSET FLAT:$SG213428
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14546: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14547: 	}
; 14548: 	else // There was at least one signature in the document

	jmp	$L213429
$L213405:

; 14549: 	{
; 14550: 		for (i=0; i<signum; i++) // For each signature in the document

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L213430
$L213431:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L213430:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L213429

; 14551: 		{
; 14552: 			refNum = sgArr[i]->refNumber; // Number of URI in this signature

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _refNum$[ebp], ecx

; 14553: 			refArr = sgArr[i]->refArray;  // The URI Array itself

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _refArr$[ebp], eax

; 14554: 
; 14555: 		    /*
; 14556: 			 * SignatureStatus
; 14557: 			 */
; 14558: 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureStatus"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213434
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14559: 			cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14560: 
; 14561: 			/*
; 14562: 			* subnodes of SignatureStatus
; 14563: 			*/
; 14564: 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 14565: 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureId");

	push	OFFSET FLAT:$SG213436
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14566: 
; 14567: 			if (sgArr[i]->sigId != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L213437

; 14568: 			{
; 14569: 				xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->sigId);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L213437:

; 14570: 			}
; 14571: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14572: 				
; 14573: 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureAlgorithm");

	push	OFFSET FLAT:$SG213440
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14574: 			if (sgArr[i]->sigMethod != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L213441

; 14575: 			{
; 14576: 				xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->sigMethod);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L213441:

; 14577: 			}
; 14578: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14579: 			
; 14580: 			cur = xmlNewNode(NULL,(const unsigned char *)"Status");

	push	OFFSET FLAT:$SG213444
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14581: 			long certStatus=0;

	mov	DWORD PTR _certStatus$213445[ebp], 0

; 14582: 
; 14583: 			if ((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 14584: 				(sgArr[i]->status != FALSE) && (sgArr[i]->certificatesCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1856]
	and	edx, -65				; ffffffbfH
	je	$L213446
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+8], 0
	je	$L213446
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L213446

; 14585: 			{
; 14586: 				sigStatus = 0;

	mov	DWORD PTR _sigStatus$[ebp], 0

; 14587: 				get_SigCertStatus(i, NULL, 0, &certStatus);

	mov	esi, esp
	lea	edx, DWORD PTR _certStatus$213445[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+344]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14588: 				if (certStatus != 0)

	cmp	DWORD PTR _certStatus$213445[ebp], 0
	je	SHORT $L213447

; 14589: 				{
; 14590: 					// Add signature status value of failed
; 14591: 					itoa(FALSE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	0
	call	_itoa
	add	esp, 12					; 0000000cH

; 14592: 					sgArr[i]->status = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx+8], 0

; 14593: 				}
; 14594: 				else

	jmp	SHORT $L213449
$L213447:

; 14595: 					itoa(TRUE, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	1
	call	_itoa
	add	esp, 12					; 0000000cH
$L213449:

; 14596: 			}
; 14597: 			else

	jmp	SHORT $L213451
$L213446:

; 14598: 				itoa(sgArr[i]->status, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_itoa
	add	esp, 12					; 0000000cH
$L213451:

; 14599: 
; 14600: 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 14601: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14602: 
; 14603: 			cur = xmlNewNode(NULL,(const unsigned char *)"LastError");

	push	OFFSET FLAT:$SG213455
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14604: 			if ((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 14605: 				(certStatus != 0))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1856]
	and	eax, -65				; ffffffbfH
	je	SHORT $L213456
	cmp	DWORD PTR _certStatus$213445[ebp], 0
	je	SHORT $L213456

; 14606: 			{
; 14607: 				itoa(certStatus, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certStatus$213445[ebp]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH

; 14608: 			}
; 14609: 			else

	jmp	SHORT $L213458
$L213456:

; 14610: 				itoa(sgArr[i]->lasterror, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH
$L213458:

; 14611: 
; 14612: 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14613: 			cur = xmlAddChild(parent,cur);	

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14614: 
; 14615: 			if ((axGetLastError(SigHandle) != 0) && (CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) &&
; 14616: 				(certStatus != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_axGetLastError
	add	esp, 4
	test	eax, eax
	je	SHORT $L213461
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	je	SHORT $L213461
	cmp	DWORD PTR _certStatus$213445[ebp], 0
	je	SHORT $L213461

; 14617: 			{
; 14618: 				// add comment with additional errors
; 14619: 				unsigned char * errStr = axGetError(SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_axGetError
	add	esp, 4
	mov	DWORD PTR _errStr$213462[ebp], eax

; 14620: 				commNode = xmlNewDocComment(doc,(const unsigned char *)errStr);

	mov	ecx, DWORD PTR _errStr$213462[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 14621: 				zFree(errStr);

	mov	eax, DWORD PTR _errStr$213462[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 14622: 				cur = xmlAddChild(parent,commNode);

	mov	ecx, DWORD PTR _commNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14623: 			}
; 14624: 			else

	jmp	SHORT $L213464
$L213461:

; 14625: 				if (sgArr[i]->lasterror != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L213464

; 14626: 				{
; 14627: 					commNode = xmlNewDocComment(doc,(const unsigned char *)errorMsgTable[sgArr[i]->lasterror]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _errorMsgTable[edx*4]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocComment
	add	esp, 8
	mov	DWORD PTR _commNode$[ebp], eax

; 14628: 					cur = xmlAddChild(parent,commNode);

	mov	edx, DWORD PTR _commNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L213464:

; 14629: 				}
; 14630: 					
; 14631: 			cur = xmlNewNode(NULL,(const unsigned char *)"ReferenceCount");

	push	OFFSET FLAT:$SG213468
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14632: 			itoa(refNum, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _refNum$[ebp]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH

; 14633: 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14634: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14635: 
; 14636: 			if (sgArr[i]->signerCert != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	cmp	DWORD PTR [ecx+24], 0
	je	$L213471

; 14637: 			{
; 14638: 				unsigned char *utf8CharStr=NULL;

	mov	DWORD PTR _utf8CharStr$213472[ebp], 0

; 14639: 				int	utf8CharStrLen=0, utf16CharStrLen=0, utf16StrByteLen=0;

	mov	DWORD PTR _utf8CharStrLen$213473[ebp], 0
	mov	DWORD PTR _utf16CharStrLen$213474[ebp], 0
	mov	DWORD PTR _utf16StrByteLen$213475[ebp], 0

; 14640: 
; 14641: 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateInfo");

	push	OFFSET FLAT:$SG213477
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14642: 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14643: 				// Adding subnodes of CertificateInfo
; 14644: 				parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 14645: 				cur = xmlNewNode(NULL,(const unsigned char *)"Subject");

	push	OFFSET FLAT:$SG213479
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14646: 				if (sgArr[i]->certificatesCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+40], 0
	je	$L213480

; 14647: 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->subject)) != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 768				; 00000300H
	push	ecx
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$213474[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$213474[ebp], 0
	je	$L213480

; 14648: 					{
; 14649: 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	edx, DWORD PTR _utf16CharStrLen$213474[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf16StrByteLen$213475[ebp], edx

; 14650: 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	eax, DWORD PTR _utf16StrByteLen$213475[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf8CharStrLen$213473[ebp], eax

; 14651: 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$213472[ebp], eax

; 14652: 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 14653: 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->subject, &utf16StrByteLen);

	lea	ecx, DWORD PTR _utf16StrByteLen$213475[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 768				; 00000300H
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 14654: 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14655: 						zFree(utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L213480:

; 14656: 					}
; 14657: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14658: 
; 14659: 				cur = xmlNewNode(NULL,(const unsigned char *)"ShortSubject");

	push	OFFSET FLAT:$SG213486
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14660: 				if (sgArr[i]->certificatesCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+40], 0
	je	$L213487

; 14661: 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->shortSubject)) != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1280				; 00000500H
	push	ecx
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$213474[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$213474[ebp], 0
	je	$L213487

; 14662: 					{
; 14663: 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	edx, DWORD PTR _utf16CharStrLen$213474[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf16StrByteLen$213475[ebp], edx

; 14664: 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	eax, DWORD PTR _utf16StrByteLen$213475[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf8CharStrLen$213473[ebp], eax

; 14665: 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$213472[ebp], eax

; 14666: 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 14667: 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->shortSubject, &utf16StrByteLen);

	lea	ecx, DWORD PTR _utf16StrByteLen$213475[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 1280				; 00000500H
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 14668: 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14669: 						zFree(utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L213487:

; 14670: 					}
; 14671: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14672: 
; 14673: 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateIssuer");

	push	OFFSET FLAT:$SG213493
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14674: 				if (sgArr[i]->certificatesCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+40], 0
	je	$L213494

; 14675: 					if ((utf16CharStrLen = wcslen(sgArr[i]->signerCert->issuer)) != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 256				; 00000100H
	push	ecx
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _utf16CharStrLen$213474[ebp], eax
	cmp	DWORD PTR _utf16CharStrLen$213474[ebp], 0
	je	$L213494

; 14676: 					{
; 14677: 						utf16StrByteLen = utf16CharStrLen * 2;

	mov	edx, DWORD PTR _utf16CharStrLen$213474[ebp]
	shl	edx, 1
	mov	DWORD PTR _utf16StrByteLen$213475[ebp], edx

; 14678: 						utf8CharStrLen = utf16StrByteLen * 2;

	mov	eax, DWORD PTR _utf16StrByteLen$213475[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf8CharStrLen$213473[ebp], eax

; 14679: 						utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$213472[ebp], eax

; 14680: 						memset(utf8CharStr, 0, utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 14681: 						UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)sgArr[i]->signerCert->issuer, &utf16StrByteLen);

	lea	ecx, DWORD PTR _utf16StrByteLen$213475[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	add	eax, 256				; 00000100H
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$213473[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 14682: 						xmlNodeSetContent(cur,(const unsigned char *)utf8CharStr);

	mov	eax, DWORD PTR _utf8CharStr$213472[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14683: 						zFree(utf8CharStr);

	mov	edx, DWORD PTR _utf8CharStr$213472[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L213494:

; 14684: 					}
; 14685: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14686: 				
; 14687: 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateSerialNumber");

	push	OFFSET FLAT:$SG213500
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14688: 				if (sgArr[i]->certificatesCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $L213501

; 14689: 					if (sgArr[i]->signerCert->serialNumber != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L213501

; 14690: 					{
; 14691: 						if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3324], 1
	jne	SHORT $L213503

; 14692: 						{
; 14693: 							plainTextHex = Base64BinToPlainHex(sgArr[i]->signerCert->serialNumber);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Base64BinToPlainHex@CSignature@@QAEPAEPAE@Z ; CSignature::Base64BinToPlainHex
	mov	DWORD PTR _plainTextHex$[ebp], eax

; 14694: 							xmlNodeSetContent(cur,(const unsigned char *)plainTextHex);

	mov	ecx, DWORD PTR _plainTextHex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 14695: 							zFree(plainTextHex);

	mov	eax, DWORD PTR _plainTextHex$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 14696: 						}
; 14697: 						else

	jmp	SHORT $L213501
$L213503:

; 14698: 							xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->serialNumber);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8
$L213501:

; 14699: 					}
; 14700: 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14701: 				
; 14702: 				cur = xmlNewNode(NULL,(const unsigned char *)"CertificateExpiration");

	push	OFFSET FLAT:$SG213508
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14703: 				if (sgArr[i]->certificatesCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $L213509

; 14704: 					if (sgArr[i]->signerCert->notAfter != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1792				; 00000700H
	je	SHORT $L213509

; 14705: 						xmlNodeSetContent(cur,(const unsigned char *)sgArr[i]->signerCert->notAfter);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1792				; 00000700H
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8
$L213509:

; 14706: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14707: 				parent = parent->parent;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _parent$[ebp], eax
$L213471:

; 14708: 			}
; 14709: 
; 14710: 
; 14711: 			for (j=0; j<refNum; j++) // for each reference that was signed

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L213512
$L213513:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L213512:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _refNum$[ebp]
	jge	$L213514

; 14712: 			{
; 14713: 
; 14714: 				cur = xmlNewNode(NULL,(const unsigned char *)"Reference");

	push	OFFSET FLAT:$SG213516
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14715: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14716: 
; 14717: 				// Add subnodes of Reference
; 14718: 				parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14719: 
; 14720: 				cur = xmlNewNode(NULL,(const unsigned char *)"URI");

	push	OFFSET FLAT:$SG213518
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14721: 				if (refArr[j]->URI != NULL)

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L213519

; 14722: 				{
; 14723: 					xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->URI);

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L213519:

; 14724: 				}
; 14725: 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14726: 
; 14727: 				cur = xmlNewNode(NULL,(const unsigned char *)"DigestMethod");

	push	OFFSET FLAT:$SG213522
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14728: 				if (refArr[j]->digestMethod != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L213523

; 14729: 				{
; 14730: 					xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->digestMethod);

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8
$L213523:

; 14731: 				}
; 14732: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14733: 				
; 14734: 				cur = xmlNewNode(NULL,(const unsigned char *)"DigestStatus");

	push	OFFSET FLAT:$SG213526
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14735: 				itoa(refArr[j]->status, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _refArr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_itoa
	add	esp, 12					; 0000000cH

; 14736: 				xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 14737: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14738: 
; 14739: 				
; 14740: 				cur = xmlNewNode(NULL,(const unsigned char *)"SignedObject");

	push	OFFSET FLAT:$SG213530
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14741: 				if (refArr[j]->refObject != NULL)

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L213531

; 14742: 				{
; 14743: 					if (refArr[j]->refObject->encoding != NULL)

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L213532

; 14744: 						xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)refArr[j]->refObject->encoding);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	OFFSET FLAT:$SG213535
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213532:

; 14745: 					if (refArr[j]->refObject->encodedData != NULL)

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _refArr$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx+256], 0
	je	SHORT $L213531

; 14746: 					{
; 14747: 						xmlNodeSetContent(cur,(const unsigned char *)refArr[j]->refObject->encodedData);

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _refArr$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8
$L213531:

; 14748: 					}
; 14749: 				}
; 14750: 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14751: 				parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx

; 14752: 			} // end for each reference

	jmp	$L213513
$L213514:

; 14753: 
; 14754: 			cur = xmlNewNode(NULL,(const unsigned char *)"PropertyCount");

	push	OFFSET FLAT:$SG213539
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14755: 			itoa(sgArr[i]->propNumber, (char *)buffer, 10);

	push	10					; 0000000aH
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_itoa
	add	esp, 12					; 0000000cH

; 14756: 			xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 14757: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14758: 
; 14759: 			cur = xmlNewNode(NULL,(const unsigned char *)"SignatureProperties");

	push	OFFSET FLAT:$SG213543
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14760: 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14761: 
; 14762: 			// Add subnodes of SignatureProperties
; 14763: 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 14764: 
; 14765: 			char *charTsProp;
; 14766: 			char *equalPtr;
; 14767: 
; 14768: 			for (j = 0; j < sgArr[i]->propNumber;  j++)

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $L213546
$L213547:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$L213546:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jge	$L213548

; 14769: 			{
; 14770: 				// Adding Signature properties
; 14771: 				cur = xmlNewNode(NULL,(const unsigned char *)"Property");

	push	OFFSET FLAT:$SG213550
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14772: 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14773: 
; 14774: 				// Adding subnodes of Property
; 14775: 				parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 14776: 				charTsProp = (char *)sgArr[i]->propArray[j];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _charTsProp$213544[ebp], ecx

; 14777: 
; 14778: 				equalPtr = StrChr(charTsProp, '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	edx, DWORD PTR _charTsProp$213544[ebp]
	push	edx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$213545[ebp], eax

; 14779: 				*equalPtr = '\0';

	mov	eax, DWORD PTR _equalPtr$213545[ebp]
	mov	BYTE PTR [eax], 0

; 14780: 
; 14781: 				cur = xmlNewNode(NULL,(const unsigned char *)"Name");

	push	OFFSET FLAT:$SG213553
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14782: 				xmlNodeSetContent(cur,(const unsigned char *)charTsProp);

	mov	ecx, DWORD PTR _charTsProp$213544[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 14783: 				cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14784: 
; 14785: 				cur = xmlNewNode(NULL,(const unsigned char *)"Value");

	push	OFFSET FLAT:$SG213556
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14786: 				xmlNodeSetContent(cur,(const unsigned char *)(equalPtr+1));

	mov	edx, DWORD PTR _equalPtr$213545[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 14787: 				*equalPtr = '='; //Restore the value

	mov	ecx, DWORD PTR _equalPtr$213545[ebp]
	mov	BYTE PTR [ecx], 61			; 0000003dH

; 14788: 
; 14789: 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14790: 				parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx

; 14791: 			}

	jmp	$L213547
$L213548:

; 14792: 
; 14793: 		} /* end for each signature in the document loop */

	jmp	$L213431
$L213429:

; 14794: 	}
; 14795: 	xmlDocDumpMemoryEnc(doc,&mem,&iSize, "UTF-16");

	push	OFFSET FLAT:$SG213558
	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocDumpMemoryEnc
	add	esp, 16					; 00000010H

; 14796: #ifdef WIN32
; 14797: 	m_binaryData.AssignData((const void *)mem, (long) iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 14798: 	*verificationResponseByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222578[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _verificationResponseByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14799: #else		
; 14800: 	VARIANT v;
; 14801: 	VariantInit(&v);
; 14802: 	*verificationResponseByteArray = v;
; 14803: 	VariantFromByteArray(verificationResponseByteArray,(const char *)mem, (long) iSize);
; 14804: #endif
; 14805: 
; 14806: 	xmlFree(mem);

	mov	esi, esp
	mov	ecx, DWORD PTR _mem$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14807: 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 14808: 	ExitLog;
; 14809: 	return S_OK;

	mov	DWORD PTR $T222579[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222579[ebp]
$L213340:

; 14810: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222593
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 540				; 0000021cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L222593:
	DD	7
	DD	$L222592
$L222592:
	DD	-68					; ffffffbcH
	DD	48					; 00000030H
	DD	$L222583
	DD	-144					; ffffff70H
	DD	4
	DD	$L222584
	DD	-160					; ffffff60H
	DD	4
	DD	$L222585
	DD	-368					; fffffe90H
	DD	200					; 000000c8H
	DD	$L222586
	DD	-412					; fffffe64H
	DD	4
	DD	$L222587
	DD	-432					; fffffe50H
	DD	4
	DD	$L222588
	DD	-448					; fffffe40H
	DD	4
	DD	$L222589
$L222589:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	49					; 00000031H
	DB	54					; 00000036H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L222588:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L222587:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	0
$L222586:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L222585:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222584:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	0
$L222583:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222580:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:
	mov	eax, OFFSET FLAT:$T222582
	jmp	___CxxFrameHandler
text$x	ENDS
?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ENDP ; CSignature::SecureXMLVerifyByteArray
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\buffervariant.h
;	COMDAT ??4CBufferVariant@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSrc$ = 8						; size = 4
??4CBufferVariant@@QAEAAV0@PBD@Z PROC NEAR		; CBufferVariant::operator=, COMDAT
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 228  : 	BuildByteArrayFromData( pSrc, strlen(pSrc));

	mov	eax, DWORD PTR _pSrc$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _pSrc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z ; CBufferVariant::BuildByteArrayFromData

; 229  : 	return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 230  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4CBufferVariant@@QAEAAV0@PBD@Z ENDP			; CBufferVariant::operator=
_TEXT	ENDS
PUBLIC	?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z ; CSignature::SignXMLXpathByteArray
xdata$x	SEGMENT
$T222630 DD	0ffffffffH
	DD	FLAT:$L222611
	DD	00H
	DD	FLAT:$L222612
	DD	01H
	DD	FLAT:$L222613
	DD	02H
	DD	FLAT:$L222614
$T222616 DD	019930520H
	DD	04H
	DD	FLAT:$T222630
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv265 = -416						; size = 4
$T222610 = -412						; size = 4
$T222609 = -408						; size = 16
$T222608 = -392						; size = 4
$T222607 = -388						; size = 16
$T222606 = -372						; size = 4
$T222605 = -368						; size = 4
$T222604 = -364						; size = 4
$T222603 = -360						; size = 16
$T222602 = -344						; size = 4
$T222601 = -340						; size = 16
$T222600 = -324						; size = 4
$T222599 = -320						; size = 16
_tmpEnvFlag$ = -304					; size = 2
_i$213778 = -300					; size = 4
_i$213702 = -296					; size = 4
_freeCharSigId$ = -292					; size = 4
__lpa$ = -288						; size = 4
__lpw$ = -284						; size = 4
__acp$ = -280						; size = 4
__convert$ = -276					; size = 4
_charTest$ = -272					; size = 4
_tmpXpathStr$ = -264					; size = 4
_equalPtr$ = -256					; size = 4
_inputByteArray$ = -252					; size = 4
_m_binaryData$ = -244					; size = 48
_templateFound$ = -192					; size = 4
_guidStr$ = -184					; size = 50
_sigGuid$ = -124					; size = 16
_newPtr$ = -104						; size = 4
_tmpXmlStr$ = -96					; size = 4
_sigId$ = -84						; size = 4
_iSize$ = -72						; size = 4
_mem$ = -64						; size = 4
_signedInfoNode$ = -60					; size = 4
_sigNode$ = -56						; size = 4
_parent$ = -52						; size = 4
_cur$ = -48						; size = 4
_root$ = -44						; size = 4
_doc$ = -40						; size = 4
_charSignedXMLStr$ = -32				; size = 4
_curCharSigId$ = -24					; size = 4
_charSigId$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputXmlByteArray$ = 12				; size = 16
_xpathExp$ = 28						; size = 4
_signatureId$ = 32					; size = 4
_signedXmlByteArray$ = 36				; size = 4
?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z PROC NEAR ; CSignature::SignXMLXpathByteArray

; 14813: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 404				; 00000194H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-416]
	mov	ecx, 101				; 00000065H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 14814: 	char *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 14815: 	unsigned char *charSignedXMLStr=NULL;

	mov	DWORD PTR _charSignedXMLStr$[ebp], 0

; 14816: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 14817: 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 14818: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 14819: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 14820: 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 14821: 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 14822: 	unsigned char *newPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0

; 14823: #ifdef WIN32
; 14824: 	GUID sigGuid;
; 14825: #else
; 14826: 	uuid_t sigGuid;
; 14827: #endif
; 14828: 	char guidStr[50];
; 14829: 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 14830: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 14831: 	VARIANT *inputByteArray;
; 14832: 	char *equalPtr;
; 14833: 	CComBSTR tmpXpathStr;

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 14834: 	char *charTest;
; 14835: #ifdef LOGGING
; 14836: 	char buffer[200];
; 14837: #endif
; 14838: 
; 14839: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 14840: 
; 14841: 	EnterLog;
; 14842: 	if (inputXmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _inputXmlByteArray$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L213597

; 14843: 	{
; 14844: 		inputByteArray = inputXmlByteArray.pvarVal;

	mov	ecx, DWORD PTR _inputXmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 14845: 	}
; 14846: 	else

	jmp	SHORT $L213598
$L213597:

; 14847: 		inputByteArray = &inputXmlByteArray;

	lea	edx, DWORD PTR _inputXmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L213598:

; 14848: 
; 14849: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	$L213599

; 14850: 	{
; 14851: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 14852: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14853: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222599[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 14854: 		return S_FALSE;

	mov	DWORD PTR $T222600[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222600[ebp]
	jmp	$L213570
$L213599:

; 14855: 	}
; 14856: 
; 14857: 	//if (! LicObj.checkLicense()) {
; 14858: 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 14859: 	//	m_binaryData.SetLength(0);
; 14860: 	//	*signedXmlByteArray = m_binaryData.Copy();
; 14861: 	//	return S_FALSE;
; 14862: 	//}
; 14863: 	//if (! LicObj.getSignAllowed()) 
; 14864: 	//{
; 14865: 	//	setError(SigHandle, NO_SIGNING_LIC);
; 14866: 	//	m_binaryData.SetLength(0);
; 14867: 	//	*signedXmlByteArray = m_binaryData.Copy();
; 14868: 	//	return S_FALSE;
; 14869: 	//}
; 14870: 
; 14871: 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 14872: 	sigId = signatureId;

	mov	ecx, DWORD PTR _signatureId$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 14873: 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213604

; 14874: 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 14875: 	else

	jmp	SHORT $L213605
$L213604:

; 14876: 	{
; 14877: 		charSigId = (char *)HeapW2A(signatureId);

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 14878: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213605:

; 14879: 	}
; 14880: #ifdef LOGGING
; 14881: 	sprintf((char *)buffer, "Variant type = %x", inputXmlByteArray.vt);
; 14882: 	DebugLog((const char *)buffer);
; 14883: #endif
; 14884: 	// original document
; 14885: 	m_binaryData = inputXmlByteArray;

	lea	eax, DWORD PTR _inputXmlByteArray$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 14886: 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L213607

; 14887: 	{
; 14888: 		if (!LicObj.getFormSignAllowed((unsigned char *)((void *)m_binaryData), m_binaryData.GetLength(), SigHandle))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	$L213607

; 14889: 		{
; 14890: 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 14891: 			m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14892: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222601[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 14893: 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213612

; 14894: 				zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L213612:

; 14895: 			return S_FALSE;

	mov	DWORD PTR $T222602[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222602[ebp]
	jmp	$L213570
$L213607:

; 14896: 		}
; 14897: 	}
; 14898: 	doc = xmlParseMemory((const char *)((void *)m_binaryData), m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 14899: 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	$L213617

; 14900: 	{
; 14901: 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 14902: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 14903: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222603[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 14904: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213619

; 14905: 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L213619:

; 14906: 		return S_FALSE;

	mov	DWORD PTR $T222604[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222604[ebp]
	jmp	$L213570
$L213617:

; 14907: 	}
; 14908: 	if (sgArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $L213622

; 14909: 	{
; 14910: 		if (uriArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $L213623

; 14911: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L213623:

; 14912: 		sgArr = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 14913: 		signum = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
$L213622:

; 14914: 	}
; 14915: 
; 14916: 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L213624

; 14917: 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213625

; 14918: 		{
; 14919: #ifdef WIN32
; 14920: 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 14921: 			GuidToString(&sigGuid, guidStr);

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 14922: #else
; 14923: 			uuid_generate(sigGuid);
; 14924: 			uuid_unparse(sigGuid, guidStr);
; 14925: #endif
; 14926: 			charSigId = guidStr;

	lea	eax, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], eax

; 14927: 		}
; 14928: 		else

	jmp	SHORT $L213624
$L213625:

; 14929: 		{
; 14930: 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 14931: 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213624:

; 14932: 		}
; 14933: 
; 14934: 	root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 14935: 	sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 14936: 	if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L213630

; 14937: 	{
; 14938: 		templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 14939: 		cur = sigNode->xmlChildrenNode;

	mov	eax, DWORD PTR _sigNode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$L213632:

; 14940: 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L213630

; 14941: 		{
; 14942: 				if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG213636
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L213635

; 14943: 				{
; 14944: 					signedInfoNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], ecx

; 14945: 					break;

	jmp	SHORT $L213630
$L213635:

; 14946: 				}
; 14947: 				cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 14948: 		}  // end while cur != NULL

	jmp	SHORT $L213632
$L213630:

; 14949: 	}
; 14950: 	  
; 14951: 	  if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L213637

; 14952: 	  {
; 14953: 		  // Add a new Signature element
; 14954: 		/*
; 14955: 		* Signature
; 14956: 		*/
; 14957: 
; 14958: 		cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213639
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14959: 		sigNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], ecx

; 14960: 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG213642
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14961: 		cur = xmlAddChild(root,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14962: 		//xmlNewNs(cur,(const unsigned char *)"http://www.w3.org/2000/09/xmldsig#",(const unsigned char *)NULL);
; 14963: 
; 14964: 		xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG213645
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 14965: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 14966: 
; 14967: 	
; 14968: 		/*
; 14969: 		* SignedInfo
; 14970: 		*/
; 14971: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213647
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14972: 		signedInfoNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], edx

; 14973: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14974: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 14975: 
; 14976: 		/*
; 14977: 		 * Canonicalization Method
; 14978: 		*/
; 14979: 		cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG213649
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14980: 		switch(CanonicalizationMethod)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3336]
	mov	DWORD PTR tv265[ebp], ecx
	cmp	DWORD PTR tv265[ebp], 3
	ja	SHORT $L213674
	mov	edx, DWORD PTR tv265[ebp]
	jmp	DWORD PTR $L222629[edx*4]
$L213654:

; 14981: 		{
; 14982: 			case WITH_COMMENTS:
; 14983: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213657
	push	OFFSET FLAT:$SG213658
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14984: 				break;

	jmp	SHORT $L213651
$L213659:

; 14985: 			case WITHOUT_COMMENTS:
; 14986: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG213662
	push	OFFSET FLAT:$SG213663
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14987: 				break;

	jmp	SHORT $L213651
$L213664:

; 14988: 			case EXC_WITH_COMMENTS:
; 14989: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213667
	push	OFFSET FLAT:$SG213668
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14990: 				break;

	jmp	SHORT $L213651
$L213669:

; 14991: 			case EXC_WITHOUT_COMMENTS:
; 14992: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213672
	push	OFFSET FLAT:$SG213673
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 14993: 				break;

	jmp	SHORT $L213651
$L213674:

; 14994: 			default:
; 14995: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213677
	push	OFFSET FLAT:$SG213678
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213651:

; 14996: 		}
; 14997: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 14998: 		/*
; 14999: 		* Reference
; 15000: 		*/
; 15001: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213680
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15002: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15003: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG213683
	push	OFFSET FLAT:$SG213684
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15004: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15005: 
; 15006: 		/*
; 15007: 		* Transforms
; 15008: 		*/
; 15009: 	
; 15010: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG213686
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15011: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15012: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15013: 
; 15014: 		/*
; 15015: 		* Transform
; 15016: 		*/
; 15017: 	
; 15018: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213688
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15019: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG213691
	push	OFFSET FLAT:$SG213692
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15020: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15021: 
; 15022: 		/*
; 15023: 		* Transform
; 15024: 		*/
; 15025: 		
; 15026: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213694
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15027: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_XPATH);

	push	OFFSET FLAT:$SG213697
	push	OFFSET FLAT:$SG213698
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15028: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15029: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15030: 
; 15031: 		cur = xmlNewNode(NULL,(const unsigned char *)"XPath");

	push	OFFSET FLAT:$SG213700
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15032: 		if (XpathNamespaceCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	$L213701

; 15033: 		{
; 15034: 			for (UINT i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$213702[ebp], 0
	jmp	SHORT $L213703
$L213704:
	mov	ecx, DWORD PTR _i$213702[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$213702[ebp], ecx
$L213703:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$213702[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	$L213701

; 15035: 			{
; 15036: 				equalPtr = StrChr(XpathNamespaceList[i], '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$213702[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$[ebp], eax

; 15037: 				if (equalPtr == NULL)

	cmp	DWORD PTR _equalPtr$[ebp], 0
	jne	SHORT $L213706

; 15038: 				{
; 15039: 					xmlNewNs(cur, (const unsigned char *)XpathNamespaceList[i], (const unsigned char *)NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$213702[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15040: 				}
; 15041: 				else

	jmp	SHORT $L213709
$L213706:

; 15042: 				{
; 15043: 					*equalPtr = '\0';

	mov	ecx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 15044: 					xmlNewNs(cur, (const unsigned char *)equalPtr+1, (const unsigned char *)XpathNamespaceList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$213702[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15045: 					*equalPtr = '=';

	mov	edx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [edx], 61			; 0000003dH
$L213709:

; 15046: 				}
; 15047: 			}

	jmp	$L213704
$L213701:

; 15048: 		}
; 15049: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15050: 		tmpXpathStr = xpathExp;

	mov	edx, DWORD PTR _xpathExp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15051: 		if (tmpXpathStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213712

; 15052: 		{
; 15053: 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 15054: 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213713

; 15055: 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L213713:

; 15056: 			return S_FALSE;

	mov	DWORD PTR $T222605[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222605[ebp]
	jmp	$L213570
$L213712:

; 15057: 		}
; 15058: 
; 15059: 		charTest = (char *)HeapW2A(xpathExp);

	mov	eax, DWORD PTR _xpathExp$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charTest$[ebp], eax

; 15060: 		xmlNodeSetContent(cur,(const unsigned char *)charTest);

	mov	ecx, DWORD PTR _charTest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 15061: 		zFree(charTest);

	mov	eax, DWORD PTR _charTest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15062: 	  }
; 15063: 	  else // A Signature element with matching Id was found

	jmp	$L213718
$L213637:

; 15064: 	  {
; 15065: 		parent = signedInfoNode;

	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15066: 		/*
; 15067: 		* Reference
; 15068: 		*/
; 15069: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213720
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15070: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15071: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG213723
	push	OFFSET FLAT:$SG213724
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15072: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15073: 
; 15074: 		/*
; 15075: 		* Transforms
; 15076: 		*/
; 15077: 	
; 15078: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG213726
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15079: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15080: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15081: 
; 15082: 		/*
; 15083: 		* Transform
; 15084: 		*/
; 15085: 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 15086: 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	je	SHORT $L213728
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	$L213727
$L213728:

; 15087: 		{
; 15088: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213730
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15089: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L213731

; 15090: 			{
; 15091: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213734
	push	OFFSET FLAT:$SG213735
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15092: 			}
; 15093: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213736
$L213731:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L213736

; 15094: 			{
; 15095: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213740
	push	OFFSET FLAT:$SG213741
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213736:

; 15096: 			}
; 15097: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15098: 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15099: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L213742

; 15100: 			{
; 15101: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213744
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15102: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213747
	push	OFFSET FLAT:$SG213748
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15103: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG213751
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15104: 			}
; 15105: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213752
$L213742:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L213752

; 15106: 			{
; 15107: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213755
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15108: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213758
	push	OFFSET FLAT:$SG213759
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15109: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG213762
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213752:

; 15110: 			}
; 15111: 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15112: 			parent = parent->parent;

	mov	eax, DWORD PTR _parent$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _parent$[ebp], ecx
$L213727:

; 15113: 		}
; 15114: 
; 15115: 		/*
; 15116: 		* Transform
; 15117: 		*/
; 15118: 	
; 15119: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213764
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15120: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG213767
	push	OFFSET FLAT:$SG213768
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15121: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15122: 
; 15123: 		/*
; 15124: 		* Transform
; 15125: 		*/
; 15126: 		
; 15127: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213770
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15128: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_XPATH);

	push	OFFSET FLAT:$SG213773
	push	OFFSET FLAT:$SG213774
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15129: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15130: 		parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15131: 
; 15132: 		cur = xmlNewNode(NULL,(const unsigned char *)"XPath");

	push	OFFSET FLAT:$SG213776
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15133: 		if (XpathNamespaceCount != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	$L213777

; 15134: 		{
; 15135: 			for (UINT i=0; i < XpathNamespaceCount; i++)

	mov	DWORD PTR _i$213778[ebp], 0
	jmp	SHORT $L213779
$L213780:
	mov	ecx, DWORD PTR _i$213778[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$213778[ebp], ecx
$L213779:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$213778[ebp]
	cmp	eax, DWORD PTR [edx+88]
	jae	$L213777

; 15136: 			{
; 15137: 				equalPtr = StrChr(XpathNamespaceList[i], '=');

	mov	esi, esp
	push	61					; 0000003dH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _i$213778[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__StrChrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _equalPtr$[ebp], eax

; 15138: 				if (equalPtr == NULL)

	cmp	DWORD PTR _equalPtr$[ebp], 0
	jne	SHORT $L213782

; 15139: 				{
; 15140: 					xmlNewNs(cur, (const unsigned char *)XpathNamespaceList[i], (const unsigned char *)NULL);

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$213778[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15141: 				}
; 15142: 				else

	jmp	SHORT $L213785
$L213782:

; 15143: 				{
; 15144: 					*equalPtr = '\0';

	mov	ecx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 15145: 					xmlNewNs(cur, (const unsigned char *)equalPtr+1, (const unsigned char *)XpathNamespaceList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _i$213778[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15146: 					*equalPtr = '=';

	mov	edx, DWORD PTR _equalPtr$[ebp]
	mov	BYTE PTR [edx], 61			; 0000003dH
$L213785:

; 15147: 				}
; 15148: 			}

	jmp	$L213780
$L213777:

; 15149: 		}
; 15150: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15151: 		tmpXpathStr = xpathExp;

	mov	edx, DWORD PTR _xpathExp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15152: 		if (tmpXpathStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213788

; 15153: 		{
; 15154: 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 15155: 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213789

; 15156: 				zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L213789:

; 15157: 			return S_FALSE;

	mov	DWORD PTR $T222606[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222606[ebp]
	jmp	$L213570
$L213788:

; 15158: 		}
; 15159: 
; 15160: 		charTest = (char *)HeapW2A(xpathExp);

	mov	eax, DWORD PTR _xpathExp$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charTest$[ebp], eax

; 15161: 		xmlNodeSetContent(cur,(const unsigned char *)charTest);

	mov	ecx, DWORD PTR _charTest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 15162: 		zFree(charTest);

	mov	eax, DWORD PTR _charTest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L213718:

; 15163: 	  }
; 15164: 
; 15165: #ifdef WIN32
; 15166: 	  if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L213794

; 15167: 		  AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L213794:

; 15168: 
; 15169: 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L213795

; 15170: 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L213795:

; 15171: #endif
; 15172: 	/*
; 15173: 	 * init Signature. crBlob contains XML - envelope document
; 15174: 	 */
; 15175: 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 15176: 	EnvelopingFlag = ENVELOPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+688], 2

; 15177: 
; 15178: 	if (!(CreateSigFromTmplBlob(doc,charSigId, &charSignedXMLStr, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	$L213797

; 15179: 	{
; 15180: 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L213798

; 15181: 			xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _charSignedXMLStr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213798:

; 15182: 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 15183: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15184: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222607[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15185: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213800

; 15186: 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L213800:

; 15187: 		return S_FALSE;

	mov	DWORD PTR $T222608[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222608[ebp]
	jmp	$L213570
$L213797:

; 15188: 	}
; 15189: 	else
; 15190: 	{
; 15191: 		if (charSignedXMLStr != NULL)

	cmp	DWORD PTR _charSignedXMLStr$[ebp], 0
	je	SHORT $L213803

; 15192: 		{
; 15193: #ifdef WIN32
; 15194: 			m_binaryData.AssignData((const void *)charSignedXMLStr, (long) iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 15195: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222609[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15196: #else		
; 15197: 			VARIANT v;
; 15198: 			VariantInit(&v);
; 15199: 			*signedXmlByteArray = v;
; 15200: 			VariantFromByteArray(signedXmlByteArray,(const char *)charSignedXMLStr, (long) iSize);
; 15201: #endif
; 15202: 			if (Base64EncodeXML == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 1
	jne	SHORT $L213808

; 15203: 				zFree(charSignedXMLStr);

	mov	edx, DWORD PTR _charSignedXMLStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 15204: 			else

	jmp	SHORT $L213803
$L213808:

; 15205: 				xmlFree(charSignedXMLStr);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXMLStr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213803:

; 15206: 		}
; 15207: 	}
; 15208: 	EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 15209: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213810

; 15210: 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L213810:

; 15211: 	ExitLog;
; 15212: 	return S_OK;

	mov	DWORD PTR $T222610[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222610[ebp]
$L213570:

; 15213: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222628
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 416				; 000001a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$L222628:
	DD	8
	DD	$L222627
$L222627:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222617
	DD	-72					; ffffffb8H
	DD	4
	DD	$L222618
	DD	-84					; ffffffacH
	DD	4
	DD	$L222619
	DD	-96					; ffffffa0H
	DD	4
	DD	$L222620
	DD	-124					; ffffff84H
	DD	16					; 00000010H
	DD	$L222621
	DD	-184					; ffffff48H
	DD	50					; 00000032H
	DD	$L222622
	DD	-244					; ffffff0cH
	DD	48					; 00000030H
	DD	$L222623
	DD	-264					; fffffef8H
	DD	4
	DD	$L222624
$L222624:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222623:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222622:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222621:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L222620:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222619:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L222618:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222617:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222629:
	DD	$L213659
	DD	$L213654
	DD	$L213669
	DD	$L213664
_TEXT	ENDS
text$x	SEGMENT
$L222611:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222612:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222613:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
$L222614:
	lea	ecx, DWORD PTR _tmpXpathStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z:
	mov	eax, OFFSET FLAT:$T222616
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z ENDP ; CSignature::SignXMLXpathByteArray
PUBLIC	?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z ; CSignature::SignXMLEnvelopedByteArray
xdata$x	SEGMENT
$T222659 DD	0ffffffffH
	DD	FLAT:$L222643
	DD	00H
	DD	FLAT:$L222644
$T222646 DD	019930520H
	DD	02H
	DD	FLAT:$T222659
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv242 = -388						; size = 4
$T222642 = -384						; size = 4
$T222641 = -380						; size = 16
$T222640 = -364						; size = 4
$T222639 = -360						; size = 16
$T222638 = -344						; size = 4
$T222637 = -340						; size = 16
$T222636 = -324						; size = 4
$T222635 = -320						; size = 16
$T222634 = -304						; size = 4
$T222633 = -300						; size = 16
_tmpEnvFlag$ = -284					; size = 2
_freeCharSigId$ = -280					; size = 4
_tmpInputXML$ = -272					; size = 4
_iSize$ = -260						; size = 4
_mem$ = -252						; size = 4
_curNs$ = -248						; size = 4
_signedInfoNode$ = -244					; size = 4
_sigNode$ = -240					; size = 4
_commNode$ = -236					; size = 4
_parent$ = -232						; size = 4
_rootNode$ = -228					; size = 4
_cur$ = -224						; size = 4
_doc$ = -220						; size = 4
__lpa$ = -216						; size = 4
__lpw$ = -212						; size = 4
__acp$ = -208						; size = 4
__convert$ = -204					; size = 4
_inputByteArray$ = -200					; size = 4
_m_binaryData$ = -192					; size = 48
_guidStr$ = -136					; size = 50
_sigGuid$ = -76						; size = 16
_charSigId$ = -56					; size = 4
_charSignedXML$ = -48					; size = 4
_ki$ = -40						; size = 4
_certData$ = -36					; size = 4
_crBlob$ = -28						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputXmlByteArray$ = 12				; size = 16
_sigId$ = 28						; size = 4
_signedXmlByteArray$ = 32				; size = 4
?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z PROC NEAR ; CSignature::SignXMLEnvelopedByteArray

; 15216: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 376				; 00000178H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-388]
	mov	ecx, 94					; 0000005eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 15217: 	DS_DATA_BLOB crBlob;
; 15218: 	unsigned char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 15219: 	keyinfo *ki=NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 15220: 	unsigned char *charSignedXML;
; 15221: 	char *charSigId;
; 15222: #ifdef WIN32
; 15223: 	GUID sigGuid;
; 15224: #else
; 15225: 	uuid_t sigGuid;
; 15226: #endif
; 15227: 	char guidStr[50];
; 15228: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15229: 	VARIANT *inputByteArray;
; 15230: #ifdef LOGGING
; 15231: 	char buffer[200];
; 15232: #endif
; 15233: 
; 15234: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15235: 	
; 15236: 	EnterLog;
; 15237: 	//if (! LicObj.checkLicense()) {
; 15238: 	//	setError(SigHandle, INVALID_SECUREXML_LIC);
; 15239: 	//	m_binaryData.SetLength(0);
; 15240: 	//	*signedXmlByteArray = m_binaryData.Copy();
; 15241: 	//	return S_FALSE;
; 15242: 	//}
; 15243: 	//if (!LicObj.getSignAllowed()) {
; 15244: 	//	setError(SigHandle, NO_SIGNING_LIC);
; 15245: 	//	m_binaryData.SetLength(0);
; 15246: 	//	*signedXmlByteArray = m_binaryData.Copy();
; 15247: 	//	return S_FALSE;
; 15248: 	//}
; 15249: 	if (inputXmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _inputXmlByteArray$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L213832

; 15250: 	{
; 15251: 		inputByteArray = inputXmlByteArray.pvarVal;

	mov	ecx, DWORD PTR _inputXmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 15252: 	}
; 15253: 	else

	jmp	SHORT $L213833
$L213832:

; 15254: 		inputByteArray = &inputXmlByteArray;

	lea	edx, DWORD PTR _inputXmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L213833:

; 15255: 
; 15256: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	SHORT $L213834

; 15257: 	{
; 15258: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15259: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15260: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222633[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15261: 		return S_FALSE;

	mov	DWORD PTR $T222634[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222634[ebp]
	jmp	$L213818
$L213834:

; 15262: 	}
; 15263: 
; 15264: 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L213838

; 15265: 	{
; 15266: 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L213839

; 15267: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L213839:

; 15268: 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 15269: 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L213838:

; 15270: 	}
; 15271: 
; 15272: 	xmlDocPtr doc= NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 15273: 	xmlNodePtr cur=NULL, rootNode=NULL, parent=NULL, commNode=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _commNode$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 15274: 	xmlNsPtr curNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0

; 15275: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 15276: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 15277: 	crBlob.cbData = 0;

	mov	DWORD PTR _crBlob$[ebp+4], 0

; 15278: 	crBlob.pbData = NULL;

	mov	DWORD PTR _crBlob$[ebp], 0

; 15279: 	CComBSTR tmpInputXML;

	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 15280: #ifdef LOGGING
; 15281: 	sprintf((char *)buffer, "Variant type = %x", inputXmlByteArray.vt);
; 15282: 	DebugLog((const char *)buffer);
; 15283: #endif
; 15284: 	// original document
; 15285: 	m_binaryData = inputXmlByteArray;

	lea	edx, DWORD PTR _inputXmlByteArray$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 15286: 
; 15287: 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L213851

; 15288: 	{
; 15289: 		if (!LicObj.getFormSignAllowed((unsigned char *)((void *)m_binaryData), m_binaryData.GetLength(), SigHandle))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	$L213851

; 15290: 		{
; 15291: 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15292: 			m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15293: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222635[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15294: 			return S_FALSE;

	mov	DWORD PTR $T222636[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222636[ebp]
	jmp	$L213818
$L213851:

; 15295: 		}
; 15296: 	}
; 15297: 
; 15298: 	doc = xmlParseMemory((const char *)((void *)m_binaryData), m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAXXZ		; CBufferVariant::operator void *
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 15299: 	if (!doc) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	$L213860

; 15300: 		setError(SigHandle,XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15301: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15302: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222637[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 15303: 		return S_FALSE;

	mov	DWORD PTR $T222638[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222638[ebp]
	jmp	$L213818
$L213860:

; 15304: 	}
; 15305: 	rootNode = xmlDocGetRootElement(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _rootNode$[ebp], eax

; 15306: 
; 15307: 	/*
; 15308: 	 * Signature
; 15309: 	*/
; 15310: 
; 15311: 	tmpInputXML = sigId;

	mov	edx, DWORD PTR _sigId$[ebp]
	push	edx
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15312: 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 15313: 	if (tmpInputXML.Length() == 0)

	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213865

; 15314: 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 15315: 	else

	jmp	SHORT $L213866
$L213865:

; 15316: 	{
; 15317: 		charSigId = (char *)HeapW2A(sigId);

	mov	eax, DWORD PTR _sigId$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 15318: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213866:

; 15319: 	}
; 15320: 
; 15321: 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L213868

; 15322: 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L213869

; 15323: 		{
; 15324: #ifdef WIN32
; 15325: 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15326: 			GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 15327: #else
; 15328: 			uuid_generate(sigGuid);
; 15329: 			uuid_unparse(sigGuid, guidStr);
; 15330: #endif
; 15331: 			charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 15332: 		}
; 15333: 		else

	jmp	SHORT $L213868
$L213869:

; 15334: 		{
; 15335: 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 15336: 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L213868:

; 15337: 		}
; 15338: 
; 15339: 
; 15340: 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213873
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15341: 	sigNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], ecx

; 15342: 	xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG213876
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15343: 	cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15344: 	xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG213879
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15345: 	parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15346: 
; 15347: 	/*
; 15348: 	 * SignedInfo
; 15349: 	*/
; 15350: 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213881
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15351: 	signedInfoNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], edx

; 15352: 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15353: 	parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 15354: 
; 15355: 	/*
; 15356: 	 * Canonicalization Method
; 15357: 	*/
; 15358: 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG213883
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15359: 	switch(CanonicalizationMethod)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3336]
	mov	DWORD PTR tv242[ebp], ecx
	cmp	DWORD PTR tv242[ebp], 3
	ja	SHORT $L213908
	mov	edx, DWORD PTR tv242[ebp]
	jmp	DWORD PTR $L222658[edx*4]
$L213888:

; 15360: 	{
; 15361: 		case WITH_COMMENTS:
; 15362: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213891
	push	OFFSET FLAT:$SG213892
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15363: 			break;

	jmp	SHORT $L213885
$L213893:

; 15364: 		case WITHOUT_COMMENTS:
; 15365: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG213896
	push	OFFSET FLAT:$SG213897
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15366: 			break;

	jmp	SHORT $L213885
$L213898:

; 15367: 		case EXC_WITH_COMMENTS:
; 15368: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213901
	push	OFFSET FLAT:$SG213902
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15369: 			break;

	jmp	SHORT $L213885
$L213903:

; 15370: 		case EXC_WITHOUT_COMMENTS:
; 15371: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213906
	push	OFFSET FLAT:$SG213907
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15372: 			break;

	jmp	SHORT $L213885
$L213908:

; 15373: 		default:
; 15374: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG213911
	push	OFFSET FLAT:$SG213912
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213885:

; 15375: 	}
; 15376: 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15377: 	/*
; 15378: 	 * Reference
; 15379: 	*/
; 15380: 	cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG213914
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15381: 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15382: 	xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG213917
	push	OFFSET FLAT:$SG213918
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15383: 	parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15384: 
; 15385: 	/*
; 15386: 	 * Transforms
; 15387: 	 */
; 15388: 	
; 15389: 	cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG213920
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15390: 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15391: 	parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15392: 
; 15393: 	/*
; 15394: 	* Transform
; 15395: 	*/
; 15396: 	if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 15397: 		(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	je	SHORT $L213922
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	$L213921
$L213922:

; 15398: 	{
; 15399: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213924
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15400: 		if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L213925

; 15401: 		{
; 15402: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG213928
	push	OFFSET FLAT:$SG213929
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15403: 		}
; 15404: 		else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213930
$L213925:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L213930

; 15405: 		{
; 15406: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG213934
	push	OFFSET FLAT:$SG213935
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213930:

; 15407: 		}
; 15408: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15409: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 15410: 		if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L213936

; 15411: 		{
; 15412: 			cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213938
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15413: 			xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213941
	push	OFFSET FLAT:$SG213942
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15414: 			xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG213945
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15415: 		}
; 15416: 		else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L213946
$L213936:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L213946

; 15417: 		{
; 15418: 			cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG213949
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15419: 			xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG213952
	push	OFFSET FLAT:$SG213953
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 15420: 			xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG213956
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L213946:

; 15421: 		}
; 15422: 		cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15423: 		parent = parent->parent;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _parent$[ebp], eax
$L213921:

; 15424: 	}
; 15425: 
; 15426: 	/*
; 15427: 	 * Transform
; 15428: 	 */
; 15429: 	
; 15430: 	cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG213958
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15431: 	xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG213961
	push	OFFSET FLAT:$SG213962
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 15432: 	cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 15433: #ifdef WIN32
; 15434: 	if (AddWindowImageFlag == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1796], 1
	jne	SHORT $L213963

; 15435: 		AddWindowImage(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddWindowImage@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddWindowImage
$L213963:

; 15436: 
; 15437: 	if (PhysicalSigUsage != NO_PHYSICAL_SIG)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+956], 0
	je	SHORT $L213964

; 15438: 		AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _signedInfoNode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sigNode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L213964:

; 15439: #endif
; 15440: 	short tmpEnvFlag = EnvelopingFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], cx

; 15441: 	EnvelopingFlag = ENVELOPED;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx+688], 2

; 15442: 
; 15443: 	if (!(CreateSigFromTmplBlob(doc, (char *)charSigId, &charSignedXML, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charSignedXML$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	$L213967

; 15444: 	{
; 15445: 		if (charSignedXML != NULL)

	cmp	DWORD PTR _charSignedXML$[ebp], 0
	je	SHORT $L213968

; 15446: 			xmlFree(charSignedXML);

	mov	esi, esp
	mov	ecx, DWORD PTR _charSignedXML$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213968:

; 15447: 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 15448: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15449: 		*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222639[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15450: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213970

; 15451: 			zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L213970:

; 15452: 		return S_FALSE;

	mov	DWORD PTR $T222640[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222640[ebp]
	jmp	$L213818
$L213967:

; 15453: 	}
; 15454: 	else
; 15455: 	{
; 15456: 		if (charSignedXML != NULL)

	cmp	DWORD PTR _charSignedXML$[ebp], 0
	je	SHORT $L213973

; 15457: 		{
; 15458: #ifdef WIN32
; 15459: 			m_binaryData.AssignData((const void *)charSignedXML, (long) iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSignedXML$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 15460: 			*signedXmlByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222641[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15461: #else		
; 15462: 			VARIANT v;
; 15463: 			VariantInit(&v);
; 15464: 			*signedXmlByteArray = v;
; 15465: 			VariantFromByteArray(signedXmlByteArray,(const char *)charSignedXML, (long) iSize);
; 15466: #endif
; 15467: 
; 15468: 			if (Base64EncodeXML == TRUE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 1
	jne	SHORT $L213978

; 15469: 				zFree(charSignedXML);

	mov	edx, DWORD PTR _charSignedXML$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 15470: 			else

	jmp	SHORT $L213973
$L213978:

; 15471: 				xmlFree(charSignedXML);

	mov	esi, esp
	mov	eax, DWORD PTR _charSignedXML$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L213973:

; 15472: 		}
; 15473: 	}
; 15474: 	EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 15475: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L213980

; 15476: 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L213980:

; 15477: 	ExitLog;
; 15478: 	return S_OK;

	mov	DWORD PTR $T222642[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222642[ebp]
$L213818:

; 15479: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222657
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 388				; 00000184H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222657:
	DD	7
	DD	$L222656
$L222656:
	DD	-28					; ffffffe4H
	DD	8
	DD	$L222647
	DD	-48					; ffffffd0H
	DD	4
	DD	$L222648
	DD	-76					; ffffffb4H
	DD	16					; 00000010H
	DD	$L222649
	DD	-136					; ffffff78H
	DD	50					; 00000032H
	DD	$L222650
	DD	-192					; ffffff40H
	DD	48					; 00000030H
	DD	$L222651
	DD	-260					; fffffefcH
	DD	4
	DD	$L222652
	DD	-272					; fffffef0H
	DD	4
	DD	$L222653
$L222653:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	112					; 00000070H
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L222652:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222651:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222650:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222649:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L222648:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	88					; 00000058H
	DB	77					; 0000004dH
	DB	76					; 0000004cH
	DB	0
$L222647:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L222658:
	DD	$L213893
	DD	$L213888
	DD	$L213903
	DD	$L213898
_TEXT	ENDS
text$x	SEGMENT
$L222643:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
$L222644:
	lea	ecx, DWORD PTR _tmpInputXML$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z:
	mov	eax, OFFSET FLAT:$T222646
	jmp	___CxxFrameHandler
text$x	ENDS
?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z ENDP ; CSignature::SignXMLEnvelopedByteArray
PUBLIC	??BCBufferVariant@@QBEPAEXZ			; CBufferVariant::operator unsigned char *
PUBLIC	?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ; CSignature::Base64DecodeByteArrayToFile
xdata$x	SEGMENT
$T222684 DD	0ffffffffH
	DD	FLAT:$L222672
	DD	00H
	DD	FLAT:$L222673
$T222675 DD	019930520H
	DD	02H
	DD	FLAT:$T222684
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222671 = -440						; size = 4
$T222670 = -436						; size = 4
$T222669 = -432						; size = 4
$T222668 = -428						; size = 4
$T222667 = -424						; size = 4
$T222666 = -420						; size = 4
$T222665 = -416						; size = 4
$T222664 = -412						; size = 4
$T222663 = -408						; size = 4
$T222662 = -404						; size = 4
__lpa$ = -400						; size = 4
__lpw$ = -396						; size = 4
__acp$ = -392						; size = 4
__convert$ = -388					; size = 4
_bstrFileName$ = -384					; size = 4
_tmpFilePath$ = -376					; size = 4
_inputByteArray$ = -368					; size = 4
_m_binaryData$ = -360					; size = 48
_hFile$ = -308						; size = 4
_TempPath$ = -300					; size = 260
_ccBstrFileName$ = -32					; size = 4
_sizeM$ = -24						; size = 4
_newPtr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_encodedBuffer$ = 12					; size = 16
_outFilePath$ = 28					; size = 4
_decodedFilePath$ = 32					; size = 4
?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z PROC NEAR ; CSignature::Base64DecodeByteArrayToFile

; 15482: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 428				; 000001acH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-440]
	mov	ecx, 107				; 0000006bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 15483: 	unsigned char *newPtr;
; 15484: 	DWORD sizeM;
; 15485: 	CComBSTR ccBstrFileName;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15486: 	char TempPath[MAX_PATH];
; 15487: 	FILE *hFile;
; 15488: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 15489: 	VARIANT *inputByteArray;
; 15490: 	TEMP_FILE_INFO *tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 15491: 	BSTR bstrFileName=NULL;

	mov	DWORD PTR _bstrFileName$[ebp], 0

; 15492: 
; 15493: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15494: 
; 15495: 	EnterLog;
; 15496: 	if (encodedBuffer.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _encodedBuffer$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L214002

; 15497: 	{
; 15498: 		inputByteArray = encodedBuffer.pvarVal;

	mov	ecx, DWORD PTR _encodedBuffer$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 15499: 	}
; 15500: 	else

	jmp	SHORT $L214003
$L214002:

; 15501: 		inputByteArray = &encodedBuffer;

	lea	edx, DWORD PTR _encodedBuffer$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L214003:

; 15502: 
; 15503: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	SHORT $L214004

; 15504: 	{
; 15505: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15506: 		return S_FALSE;

	mov	DWORD PTR $T222662[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222662[ebp]
	jmp	$L213988
$L214004:

; 15507: 	}
; 15508: 
; 15509: 	m_binaryData = encodedBuffer;

	lea	ecx, DWORD PTR _encodedBuffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 15510: 	if (m_binaryData.GetLength() == 0)

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	test	eax, eax
	jne	SHORT $L214007

; 15511: 	{
; 15512: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15513: 		return S_FALSE;

	mov	DWORD PTR $T222663[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222663[ebp]
	jmp	$L213988
$L214007:

; 15514: 	}
; 15515: 	sizeM = base64decodeSize(m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 15516: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 15517: 	if ((sizeM = base64decode((unsigned char*)m_binaryData,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAEXZ		; CBufferVariant::operator unsigned char *
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214012

; 15518: 	{
; 15519: 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15520: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15521: 		return S_FALSE;

	mov	DWORD PTR $T222664[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222664[ebp]
	jmp	$L213988
$L214012:

; 15522: 	}
; 15523: 
; 15524: 	ccBstrFileName = outFilePath;

	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15525: 
; 15526: 	if ((ccBstrFileName.Length() == 0) || (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L214016
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3364], 1
	jne	$L214015
$L214016:

; 15527: 	{
; 15528: 		// Create temporary file for saving decoded data
; 15529: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15530: 		GetTempFileName(TempPath, // dir. for temp. files 
; 15531: 			"INF",                // temp. file name prefix 
; 15532: 			0,                    // create unique name 
; 15533: 			szTempName);          // buffer for name 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	mov	esi, esp
	push	ecx
	push	0
	push	OFFSET FLAT:$SG214018
	lea	edx, DWORD PTR _TempPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15534: 		bstrFileName = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 15535: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222665[ebp], eax
	mov	ecx, DWORD PTR $T222665[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 15536: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 15537: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222666[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T222667[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 15538: 	}
; 15539: 	else

	jmp	SHORT $L214025
$L214015:

; 15540: 		bstrFileName = SysAllocString(outFilePath);

	mov	esi, esp
	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L214025:

; 15541: //		strcpy((char *)szTempName,(const char *)W2A(outFilePath));
; 15542: 	// open file in write mode 
; 15543: #ifdef WIN32
; 15544: 	if ((hFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG214027
	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	$L214026

; 15545: #elif LINUX
; 15546: 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 15547: 	if ((hFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 15548: 			zFree(utf8FileName);
; 15549: #endif
; 15550: 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 15551: 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 15552: 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15553: 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214028

; 15554: 			{
; 15555: 				tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214028:

; 15556: 			}
; 15557: 			return S_FALSE;

	mov	DWORD PTR $T222668[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222668[ebp]
	jmp	$L213988
$L214026:

; 15558: 	}
; 15559: #ifdef LINUX
; 15560: 	zFree(utf8FileName);
; 15561: #endif
; 15562: 
; 15563: 	if (fwrite(newPtr, 1, sizeM, hFile) == 0)

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L214031

; 15564: 	{
; 15565: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 15566: 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 15567: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214032

; 15568: 		{
; 15569: 			tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214032:

; 15570: 		}
; 15571: 		return S_FALSE;

	mov	DWORD PTR $T222669[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222669[ebp]
	jmp	$L213988
$L214031:

; 15572: 	}
; 15573: 	if (ferror(hFile))

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	je	SHORT $L214035

; 15574: 	{
; 15575: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15576: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15577: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214036

; 15578: 		{
; 15579: 			tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214036:

; 15580: 		}
; 15581: 		return S_FALSE;

	mov	DWORD PTR $T222670[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222670[ebp]
	jmp	SHORT $L213988
$L214035:

; 15582: 	}
; 15583: 	fclose(hFile);

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 15584: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15585: 	*decodedFilePath = bstrFileName;

	mov	edx, DWORD PTR _decodedFilePath$[ebp]
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 15586: 	ExitLog;
; 15587: 	return S_OK;

	mov	DWORD PTR $T222671[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222671[ebp]
$L213988:

; 15588: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222683
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 440				; 000001b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222683:
	DD	4
	DD	$L222682
$L222682:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222676
	DD	-300					; fffffed4H
	DD	260					; 00000104H
	DD	$L222677
	DD	-360					; fffffe98H
	DD	48					; 00000030H
	DD	$L222678
	DD	-376					; fffffe88H
	DD	4
	DD	$L222679
$L222679:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222678:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222677:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222676:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222672:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222673:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222675
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ENDP ; CSignature::Base64DecodeByteArrayToFile
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\buffervariant.h
;	COMDAT ??BCBufferVariant@@QBEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCBufferVariant@@QBEPAEXZ PROC NEAR			; CBufferVariant::operator unsigned char *, COMDAT
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 	return (unsigned char *)(m_pBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCBufferVariant@@QBEPAEXZ ENDP			; CBufferVariant::operator unsigned char *
_TEXT	ENDS
PUBLIC	?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ; CSignature::Base64DecodeByteArrayToByteArray
xdata$x	SEGMENT
$T222702 DD	0ffffffffH
	DD	FLAT:$L222695
$T222697 DD	019930520H
	DD	01H
	DD	FLAT:$T222702
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T222694 = -160						; size = 4
$T222693 = -156						; size = 16
$T222692 = -140						; size = 4
$T222691 = -136						; size = 16
$T222690 = -120						; size = 4
$T222689 = -116						; size = 4
$T222688 = -112						; size = 16
__lpa$ = -96						; size = 4
__lpw$ = -92						; size = 4
__acp$ = -88						; size = 4
__convert$ = -84					; size = 4
_inputByteArray$ = -80					; size = 4
_m_binaryData$ = -72					; size = 48
_sizeM$ = -20						; size = 4
_newPtr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_encodedBuffer$ = 12					; size = 16
_decodedBuffer$ = 28					; size = 4
?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z PROC NEAR ; CSignature::Base64DecodeByteArrayToByteArray

; 15591: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 15592: 	unsigned char *newPtr;
; 15593: 	DWORD sizeM;
; 15594: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15595: 	VARIANT *inputByteArray;
; 15596: 
; 15597: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15598: 
; 15599: 	EnterLog;
; 15600: 	if (encodedBuffer.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _encodedBuffer$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L214054

; 15601: 	{
; 15602: 		inputByteArray = encodedBuffer.pvarVal;

	mov	ecx, DWORD PTR _encodedBuffer$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 15603: 	}
; 15604: 	else

	jmp	SHORT $L214055
$L214054:

; 15605: 		inputByteArray = &encodedBuffer;

	lea	edx, DWORD PTR _encodedBuffer$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L214055:

; 15606: 
; 15607: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	SHORT $L214056

; 15608: 	{
; 15609: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15610: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15611: 		*decodedBuffer = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222688[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _decodedBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15612: 		return S_FALSE;

	mov	DWORD PTR $T222689[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222689[ebp]
	jmp	$L214045
$L214056:

; 15613: 	}
; 15614: 
; 15615: 	m_binaryData = encodedBuffer;

	lea	ecx, DWORD PTR _encodedBuffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 15616: 	if (m_binaryData.GetLength() == 0)

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	test	eax, eax
	jne	SHORT $L214060

; 15617: 	{
; 15618: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15619: 		return S_FALSE;

	mov	DWORD PTR $T222690[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222690[ebp]
	jmp	$L214045
$L214060:

; 15620: 	}
; 15621: 
; 15622: 	sizeM = base64decodeSize(m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 15623: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 15624: 	if ((sizeM = base64decode((unsigned char*)m_binaryData,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAEXZ		; CBufferVariant::operator unsigned char *
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214065

; 15625: 	{
; 15626: 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15627: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15628: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15629: 		*decodedBuffer = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222691[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _decodedBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15630: 		return S_FALSE;

	mov	DWORD PTR $T222692[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222692[ebp]
	jmp	SHORT $L214045
$L214065:

; 15631: 	}
; 15632: #ifdef WIN32
; 15633: 	m_binaryData.AssignData((const void *)newPtr, (long)sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 15634: 	*decodedBuffer = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222693[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _decodedBuffer$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 15635: #else		
; 15636: 	VARIANT v;
; 15637: 	VariantInit(&v);
; 15638: 	*decodedBuffer = v;
; 15639: 	VariantFromByteArray(decodedBuffer,(const char *)newPtr, (long) sizeM);
; 15640: #endif
; 15641: 
; 15642: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15643: 	ExitLog;
; 15644: 	return S_OK;

	mov	DWORD PTR $T222694[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222694[ebp]
$L214045:

; 15645: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222701
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 160				; 000000a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L222701:
	DD	1
	DD	$L222700
$L222700:
	DD	-72					; ffffffb8H
	DD	48					; 00000030H
	DD	$L222698
$L222698:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222695:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:
	mov	eax, OFFSET FLAT:$T222697
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ENDP ; CSignature::Base64DecodeByteArrayToByteArray
PUBLIC	?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ; CSignature::Base64EncodeByteArrayToByteArray
xdata$x	SEGMENT
$T222718 DD	0ffffffffH
	DD	FLAT:$L222711
$T222713 DD	019930520H
	DD	01H
	DD	FLAT:$T222718
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222710 = -160						; size = 4
$T222709 = -156						; size = 16
$T222708 = -140						; size = 4
$T222707 = -136						; size = 16
$T222706 = -120						; size = 4
$T222705 = -116						; size = 4
$T222704 = -112						; size = 16
__lpa$ = -96						; size = 4
__lpw$ = -92						; size = 4
__acp$ = -88						; size = 4
__convert$ = -84					; size = 4
_inputByteArray$ = -80					; size = 4
_m_binaryData$ = -72					; size = 48
_sizeM$ = -20						; size = 4
_newPtr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_inputBinary$ = 12					; size = 16
_encodedBuffer$ = 28					; size = 4
?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z PROC NEAR ; CSignature::Base64EncodeByteArrayToByteArray

; 15648: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 148				; 00000094H
	push	edi
	lea	edi, DWORD PTR [ebp-160]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 15649: 	unsigned char *newPtr;
; 15650: 	DWORD sizeM;
; 15651: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15652: 	VARIANT *inputByteArray;
; 15653: 
; 15654: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15655: 
; 15656: 	EnterLog;
; 15657: 	if (inputBinary.vt == (VT_VARIANT | VT_BYREF))

	movzx	eax, WORD PTR _inputBinary$[ebp]
	cmp	eax, 16396				; 0000400cH
	jne	SHORT $L214087

; 15658: 	{
; 15659: 		inputByteArray = inputBinary.pvarVal;

	mov	ecx, DWORD PTR _inputBinary$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], ecx

; 15660: 	}
; 15661: 	else

	jmp	SHORT $L214088
$L214087:

; 15662: 		inputByteArray = &inputBinary;

	lea	edx, DWORD PTR _inputBinary$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], edx
$L214088:

; 15663: 
; 15664: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	eax, DWORD PTR _inputByteArray$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 8209				; 00002011H
	je	SHORT $L214089

; 15665: 	{
; 15666: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15667: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15668: 		*encodedBuffer = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222704[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _encodedBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15669: 		return S_FALSE;

	mov	DWORD PTR $T222705[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222705[ebp]
	jmp	$L214078
$L214089:

; 15670: 	}
; 15671: 
; 15672: 	m_binaryData = inputBinary;

	lea	ecx, DWORD PTR _inputBinary$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 15673: 	if (m_binaryData.GetLength() == 0)

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	test	eax, eax
	jne	SHORT $L214093

; 15674: 	{
; 15675: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15676: 		return S_FALSE;

	mov	DWORD PTR $T222706[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222706[ebp]
	jmp	$L214078
$L214093:

; 15677: 	}
; 15678: 	sizeM = base64encodeSize(m_binaryData.GetLength());

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 15679: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 15680: 	if ((sizeM = base64encode((unsigned char*)m_binaryData,m_binaryData.GetLength(),newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPAEXZ		; CBufferVariant::operator unsigned char *
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214098

; 15681: 	{
; 15682: 		zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15683: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15684: 		m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 15685: 		*encodedBuffer = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T222707[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _encodedBuffer$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 15686: 		return S_FALSE;

	mov	DWORD PTR $T222708[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222708[ebp]
	jmp	SHORT $L214078
$L214098:

; 15687: 	}
; 15688: #ifdef WIN32
; 15689: 	m_binaryData.AssignData((const void *)newPtr, (long)sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 15690: 	*encodedBuffer = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222709[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _encodedBuffer$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 15691: #else		
; 15692: 	VARIANT v;
; 15693: 	VariantInit(&v);
; 15694: 	*encodedBuffer = v;
; 15695: 	VariantFromByteArray(encodedBuffer,(const char *)newPtr, (long) sizeM);
; 15696: #endif
; 15697: 
; 15698: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15699: 	ExitLog;
; 15700: 	return S_OK;

	mov	DWORD PTR $T222710[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222710[ebp]
$L214078:

; 15701: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222717
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 160				; 000000a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L222717:
	DD	1
	DD	$L222716
$L222716:
	DD	-72					; ffffffb8H
	DD	48					; 00000030H
	DD	$L222714
$L222714:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222711:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:
	mov	eax, OFFSET FLAT:$T222713
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z ENDP ; CSignature::Base64EncodeByteArrayToByteArray
PUBLIC	?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ; CSignature::Base64EncodeByteArrayToFile
xdata$x	SEGMENT
$T222743 DD	0ffffffffH
	DD	FLAT:$L222730
	DD	00H
	DD	FLAT:$L222731
$T222733 DD	019930520H
	DD	02H
	DD	FLAT:$T222743
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222729 = -452						; size = 4
$T222728 = -448						; size = 4
$T222727 = -444						; size = 4
$T222726 = -440						; size = 4
$T222725 = -436						; size = 4
$T222724 = -432						; size = 4
$T222723 = -428						; size = 4
$T222722 = -424						; size = 4
$T222721 = -420						; size = 4
__lpa$ = -416						; size = 4
__lpw$ = -412						; size = 4
__acp$ = -408						; size = 4
__convert$ = -404					; size = 4
_bstrFileName$ = -400					; size = 4
_tmpFilePath$ = -392					; size = 4
_m_binaryData$ = -380					; size = 48
_hFile$ = -328						; size = 4
_TempPath$ = -320					; size = 260
_ccBstrFileName$ = -52					; size = 4
_encodedBuffer$ = -40					; size = 16
_hr$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputBinary$ = 12					; size = 16
_outFilePath$ = 28					; size = 4
_encodedFilePath$ = 32					; size = 4
?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z PROC NEAR ; CSignature::Base64EncodeByteArrayToFile

; 15704: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 440				; 000001b8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 15705: 	HRESULT hr;
; 15706: 	VARIANT encodedBuffer;
; 15707: 	CComBSTR ccBstrFileName;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15708: 	char TempPath[MAX_PATH];
; 15709: 	FILE *hFile;
; 15710: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 15711: 	TEMP_FILE_INFO	*tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 15712: 	BSTR bstrFileName=NULL;

	mov	DWORD PTR _bstrFileName$[ebp], 0

; 15713: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15714: 
; 15715: 	::VariantInit(&encodedBuffer);

	mov	esi, esp
	lea	eax, DWORD PTR _encodedBuffer$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15716: 
; 15717: 	hr = Base64EncodeByteArrayToByteArray(inputBinary, &encodedBuffer);

	mov	esi, esp
	lea	ecx, DWORD PTR _encodedBuffer$[ebp]
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _inputBinary$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _inputBinary$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _inputBinary$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _inputBinary$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+684]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 15718: 	if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L214126

; 15719: 		return S_FALSE;

	mov	DWORD PTR $T222721[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222721[ebp]
	jmp	$L214112
$L214126:

; 15720: 	m_binaryData = encodedBuffer;

	lea	edx, DWORD PTR _encodedBuffer$[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 15721: 	if (m_binaryData.GetLength() == 0)

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	test	eax, eax
	jne	SHORT $L214129

; 15722: 	{
; 15723: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 15724: 		return S_FALSE;

	mov	DWORD PTR $T222722[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222722[ebp]
	jmp	$L214112
$L214129:

; 15725: 	}
; 15726: 
; 15727: 	ccBstrFileName = outFilePath;

	mov	edx, DWORD PTR _outFilePath$[ebp]
	push	edx
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15728: 
; 15729: 	if ((ccBstrFileName.Length() == 0) || (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L214133
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3364], 1
	jne	$L214132
$L214133:

; 15730: 	{
; 15731: 		// Create temporary file for saving decoded data
; 15732: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	ecx, DWORD PTR _TempPath$[ebp]
	push	ecx
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15733: 		GetTempFileName(TempPath, // dir. for temp. files 
; 15734: 			"INF",                // temp. file name prefix 
; 15735: 			0,                    // create unique name 
; 15736: 			szTempName);          // buffer for name 

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	mov	esi, esp
	push	edx
	push	0
	push	OFFSET FLAT:$SG214135
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15737: 		bstrFileName = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 15738: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222723[ebp], eax
	mov	edx, DWORD PTR $T222723[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], edx

; 15739: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	mov	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 15740: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	edx, DWORD PTR _tmpFilePath$[ebp]
	push	edx
	lea	eax, DWORD PTR $T222724[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T222725[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 15741: 	}
; 15742: 	else

	jmp	SHORT $L214142
$L214132:

; 15743: 		bstrFileName = SysAllocString(outFilePath);

	mov	esi, esp
	mov	edx, DWORD PTR _outFilePath$[ebp]
	push	edx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L214142:

; 15744: //		strcpy((char *)szTempName,(const char *)W2A(outFilePath));
; 15745: 	// open file in write mode 
; 15746: #ifdef WIN32
; 15747: 	if ((hFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG214144
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	SHORT $L214143

; 15748: #elif LINUX
; 15749: 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 15750: 	if ((hFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 15751: 			zFree(utf8FileName);
; 15752: #endif
; 15753: 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15754: 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15755: 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214145

; 15756: 			{
; 15757: 				tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214145:

; 15758: 			}
; 15759: 			return S_FALSE;

	mov	DWORD PTR $T222726[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222726[ebp]
	jmp	$L214112
$L214143:

; 15760: 	}
; 15761: #ifdef LINUX
; 15762: 	zFree(utf8FileName);
; 15763: #endif
; 15764: 
; 15765: 	if (fwrite((const void *)m_binaryData, 1, m_binaryData.GetLength(), hFile) == 0)

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	push	eax
	push	1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPBXXZ		; CBufferVariant::operator void const *
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L214149

; 15766: 	{
; 15767: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15768: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214150

; 15769: 		{
; 15770: 			tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214150:

; 15771: 		}
; 15772: 		return S_FALSE;

	mov	DWORD PTR $T222727[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222727[ebp]
	jmp	$L214112
$L214149:

; 15773: 	}
; 15774: 	if (ferror(hFile))

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	je	SHORT $L214153

; 15775: 	{
; 15776: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15777: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214154

; 15778: 		{
; 15779: 			tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214154:

; 15780: 		}
; 15781: 		return S_FALSE;

	mov	DWORD PTR $T222728[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222728[ebp]
	jmp	SHORT $L214112
$L214153:

; 15782: 	}
; 15783: 	fclose(hFile);

	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 15784: 	*encodedFilePath = bstrFileName;

	mov	eax, DWORD PTR _encodedFilePath$[ebp]
	mov	ecx, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [eax], ecx

; 15785: 	ExitLog;
; 15786: 	return S_OK;

	mov	DWORD PTR $T222729[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222729[ebp]
$L214112:

; 15787: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222742
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222742:
	DD	5
	DD	$L222741
$L222741:
	DD	-40					; ffffffd8H
	DD	16					; 00000010H
	DD	$L222734
	DD	-52					; ffffffccH
	DD	4
	DD	$L222735
	DD	-320					; fffffec0H
	DD	260					; 00000104H
	DD	$L222736
	DD	-380					; fffffe84H
	DD	48					; 00000030H
	DD	$L222737
	DD	-392					; fffffe78H
	DD	4
	DD	$L222738
$L222738:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222737:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222736:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222735:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L222734:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222730:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222731:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222733
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ENDP ; CSignature::Base64EncodeByteArrayToFile
PUBLIC	?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::Base64EncodeStrToFile
xdata$x	SEGMENT
$T222769 DD	0ffffffffH
	DD	FLAT:$L222757
	DD	00H
	DD	FLAT:$L222758
$T222760 DD	019930520H
	DD	02H
	DD	FLAT:$T222769
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222756 = -416						; size = 4
$T222755 = -412						; size = 4
$T222754 = -408						; size = 4
$T222753 = -404						; size = 4
$T222752 = -400						; size = 4
$T222751 = -396						; size = 4
$T222750 = -392						; size = 4
$T222749 = -388						; size = 4
$T222748 = -384						; size = 4
$T222747 = -380						; size = 4
$T222746 = -376						; size = 4
_outputBuffer$ = -372					; size = 4
_outputSize$ = -368					; size = 4
_inputSize$ = -364					; size = 4
_szPtr$ = -360						; size = 4
_ptr$ = -356						; size = 4
__lpa$ = -352						; size = 4
__lpw$ = -348						; size = 4
__acp$ = -344						; size = 4
__convert$ = -340					; size = 4
_bstrFileName$ = -336					; size = 4
_tmpFilePath$ = -328					; size = 4
_freeMemory$ = -320					; size = 4
_charInputStr$ = -316					; size = 4
_hFile$ = -312						; size = 4
_TempPath$ = -304					; size = 260
_tmpXmlStr$ = -36					; size = 4
_ccBstrFileName$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_inputStr$ = 12						; size = 4
_outFilePath$ = 16					; size = 4
_encodedFilePath$ = 20					; size = 4
?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::Base64EncodeStrToFile

; 15790: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 404				; 00000194H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-416]
	mov	ecx, 101				; 00000065H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 15791: 	CComBSTR ccBstrFileName, tmpXmlStr;

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 15792: 	char TempPath[MAX_PATH];
; 15793: 	FILE *hFile;
; 15794: 	char *charInputStr=NULL;

	mov	DWORD PTR _charInputStr$[ebp], 0

; 15795: 	BOOL freeMemory=FALSE;

	mov	DWORD PTR _freeMemory$[ebp], 0

; 15796: 	TEMP_FILE_INFO	*tmpFilePath = NULL;

	mov	DWORD PTR _tmpFilePath$[ebp], 0

; 15797: 	BSTR bstrFileName;
; 15798: 
; 15799: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15800: 
; 15801: 	EnterLog;
; 15802: 
; 15803: 	tmpXmlStr = inputStr;

	mov	eax, DWORD PTR _inputStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15804: 	if (tmpXmlStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214177

; 15805: 	{
; 15806: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15807: 		DebugLog("Input XML String is empty");
; 15808: 		return S_FALSE;

	mov	DWORD PTR $T222746[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222746[ebp]
	jmp	$L214164
$L214177:

; 15809: 	}
; 15810: 
; 15811: 	unsigned char *ptr = (unsigned char *)inputStr;

	mov	eax, DWORD PTR _inputStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 15812: 	unsigned int *szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 15813: 	unsigned int inputSize = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _inputSize$[ebp], eax

; 15814: 
; 15815: 	if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 15816: 		((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214188
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L214187
$L214188:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L214186
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214186
$L214187:

; 15817: 	{
; 15818: 		// The data is in utf-16 format so do not convert to char *
; 15819: 		charInputStr = (char *)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _charInputStr$[ebp], eax

; 15820: 	}
; 15821: 	else

	jmp	SHORT $L214190
$L214186:

; 15822: 	{
; 15823: 		charInputStr = (char *)HeapW2A(inputStr);

	mov	ecx, DWORD PTR _inputStr$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charInputStr$[ebp], eax

; 15824: 		if (charInputStr == NULL)

	cmp	DWORD PTR _charInputStr$[ebp], 0
	jne	SHORT $L214192

; 15825: 		{
; 15826: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15827: 			return S_FALSE;

	mov	DWORD PTR $T222747[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222747[ebp]
	jmp	$L214164
$L214192:

; 15828: 		}
; 15829: 		inputSize = strlen(charInputStr);

	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _inputSize$[ebp], eax

; 15830: 		freeMemory = TRUE;

	mov	DWORD PTR _freeMemory$[ebp], 1
$L214190:

; 15831: 	}
; 15832: 
; 15833: 	int outputSize = base64encodeSize(inputSize);

	mov	edx, DWORD PTR _inputSize$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _outputSize$[ebp], eax

; 15834: 	unsigned char *outputBuffer = (unsigned char *) zMalloc(outputSize + 1);

	mov	eax, DWORD PTR _outputSize$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outputBuffer$[ebp], eax

; 15835: 	if (outputBuffer == NULL)

	cmp	DWORD PTR _outputBuffer$[ebp], 0
	jne	SHORT $L214198

; 15836: 	{
; 15837: 		if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214199

; 15838: 			zFree(charInputStr);

	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L214199:

; 15839: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15840: 		return S_FALSE;

	mov	DWORD PTR $T222748[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222748[ebp]
	jmp	$L214164
$L214198:

; 15841: 	}
; 15842: 
; 15843: 	if ((outputSize = base64encode((unsigned char *)charInputStr, inputSize, outputBuffer, outputSize + 1)) == -1)

	mov	ecx, DWORD PTR _outputSize$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _outputBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outputSize$[ebp], eax
	cmp	DWORD PTR _outputSize$[ebp], -1
	jne	SHORT $L214203

; 15844: 	{
; 15845: 		if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214204

; 15846: 			zFree(charInputStr);

	mov	edx, DWORD PTR _charInputStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214204:

; 15847: 		zFree(outputBuffer);

	mov	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15848: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15849: 		return S_FALSE;

	mov	DWORD PTR $T222749[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222749[ebp]
	jmp	$L214164
$L214203:

; 15850: 	}
; 15851: 	if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214207

; 15852: 		zFree(charInputStr);

	mov	eax, DWORD PTR _charInputStr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214207:

; 15853: 
; 15854: 	ccBstrFileName = outFilePath;

	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15855: 
; 15856: 	if ((ccBstrFileName.Length() == 0) || (FileAccessRestricted == TRUE))

	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	je	SHORT $L214209
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3364], 1
	jne	$L214208
$L214209:

; 15857: 	{
; 15858: 		// Create temporary file for saving decoded data
; 15859: 		GetTempPath((DWORD)MAX_PATH, TempPath); 

	mov	esi, esp
	lea	eax, DWORD PTR _TempPath$[ebp]
	push	eax
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15860: 		GetTempFileName(TempPath, // dir. for temp. files 
; 15861: 			"INF",                // temp. file name prefix 
; 15862: 			0,                    // create unique name 
; 15863: 			szTempName);          // buffer for name 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	mov	esi, esp
	push	ecx
	push	0
	push	OFFSET FLAT:$SG214211
	lea	edx, DWORD PTR _TempPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetTempFileNameA@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15864: 		bstrFileName = A2WBSTR((LPCSTR)szTempName);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 416				; 000001a0H
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrFileName$[ebp], eax

; 15865: 		tmpFilePath = new (TEMP_FILE_INFO);

	push	520					; 00000208H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T222750[ebp], eax
	mov	ecx, DWORD PTR $T222750[ebp]
	mov	DWORD PTR _tmpFilePath$[ebp], ecx

; 15866: 		strcpy((char *)tmpFilePath->fileName, szTempName);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 416				; 000001a0H
	push	edx
	mov	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 15867: 		tmpFileList->insert(tmpFileList->begin(), tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T222751[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T222752[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+3400]
	call	?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert

; 15868: 	}
; 15869: 	else

	jmp	SHORT $L214218
$L214208:

; 15870: 		bstrFileName = SysAllocString(outFilePath);

	mov	esi, esp
	mov	ecx, DWORD PTR _outFilePath$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrFileName$[ebp], eax
$L214218:

; 15871: //		strcpy((char *)szTempName,(const char *)W2A(outFilePath));
; 15872: 	// open file in write mode 
; 15873: #ifdef WIN32
; 15874: 	if ((hFile = _wfopen(bstrFileName,L"wb"))==NULL) {

	push	OFFSET FLAT:$SG214220
	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	call	__wfopen
	add	esp, 8
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], 0
	jne	$L214219

; 15875: #elif LINUX
; 15876: 	unsigned char *utf8FileName = HeapW2A(bstrFileName);
; 15877: 	if ((hFile = fopen((const char *)utf8FileName, "wb")) == NULL) {
; 15878: 			zFree(utf8FileName);
; 15879: #endif
; 15880: 			zFree(outputBuffer);

	mov	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15881: 			setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15882: 			SysFreeString(bstrFileName);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 15883: 			if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214221

; 15884: 			{
; 15885: 				tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214221:

; 15886: 			}
; 15887: 			return S_FALSE;

	mov	DWORD PTR $T222753[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222753[ebp]
	jmp	$L214164
$L214219:

; 15888: 	}
; 15889: #ifdef LINUX
; 15890: 	zFree(utf8FileName);
; 15891: #endif
; 15892: 
; 15893: 	if (fwrite((const void *)outputBuffer, 1, outputSize, hFile) == 0)

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outputSize$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _outputBuffer$[ebp]
	push	edx
	call	_fwrite
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L214225

; 15894: 	{
; 15895: 		zFree(outputBuffer);

	mov	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15896: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15897: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214226

; 15898: 		{
; 15899: 			tmpFileList->remove(tmpFilePath);

	lea	eax, DWORD PTR _tmpFilePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214226:

; 15900: 		}
; 15901: 		return S_FALSE;

	mov	DWORD PTR $T222754[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222754[ebp]
	jmp	$L214164
$L214225:

; 15902: 	}
; 15903: 	if (ferror(hFile))

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	je	SHORT $L214229

; 15904: 	{
; 15905: 		zFree(outputBuffer);

	mov	ecx, DWORD PTR _outputBuffer$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15906: 		setError(SigHandle, IO_ERROR);

	push	12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15907: 		if (tmpFilePath != NULL)

	cmp	DWORD PTR _tmpFilePath$[ebp], 0
	je	SHORT $L214230

; 15908: 		{
; 15909: 			tmpFileList->remove(tmpFilePath);

	lea	ecx, DWORD PTR _tmpFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3400]
	call	?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
$L214230:

; 15910: 		}
; 15911: 		return S_FALSE;

	mov	DWORD PTR $T222755[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222755[ebp]
	jmp	SHORT $L214164
$L214229:

; 15912: 	}
; 15913: 	fclose(hFile);

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 15914: 	zFree(outputBuffer);

	mov	ecx, DWORD PTR _outputBuffer$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 15915: 	*encodedFilePath = bstrFileName;

	mov	edx, DWORD PTR _encodedFilePath$[ebp]
	mov	eax, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR [edx], eax

; 15916: 	ExitLog;
; 15917: 	return S_OK;

	mov	DWORD PTR $T222756[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222756[ebp]
$L214164:

; 15918: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222768
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 416				; 000001a0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222768:
	DD	4
	DD	$L222767
$L222767:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L222761
	DD	-36					; ffffffdcH
	DD	4
	DD	$L222762
	DD	-304					; fffffed0H
	DD	260					; 00000104H
	DD	$L222763
	DD	-328					; fffffeb8H
	DD	4
	DD	$L222764
$L222764:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222763:
	DB	84					; 00000054H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222762:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222761:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222757:
	lea	ecx, DWORD PTR _ccBstrFileName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222758:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222760
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::Base64EncodeStrToFile
PUBLIC	?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z ; CSignature::Base64EncodeStrToStr
xdata$x	SEGMENT
$T222783 DD	0ffffffffH
	DD	FLAT:$L222776
$T222778 DD	019930520H
	DD	01H
	DD	FLAT:$T222783
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222775 = -88						; size = 4
$T222774 = -84						; size = 4
$T222773 = -80						; size = 4
$T222772 = -76						; size = 4
$T222771 = -72						; size = 4
_outputBuffer$ = -68					; size = 4
_outputSize$ = -64					; size = 4
_inputSize$ = -60					; size = 4
_szPtr$ = -56						; size = 4
_ptr$ = -52						; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_freeMemory$ = -32					; size = 4
_charInputStr$ = -28					; size = 4
_tmpXmlStr$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_inputStr$ = 12						; size = 4
_encodedStr$ = 16					; size = 4
?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::Base64EncodeStrToStr

; 15921: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 15922: 	CComBSTR tmpXmlStr;

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15923: 	char *charInputStr=NULL;

	mov	DWORD PTR _charInputStr$[ebp], 0

; 15924: 	BOOL freeMemory=FALSE;

	mov	DWORD PTR _freeMemory$[ebp], 0

; 15925: 
; 15926: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15927: 
; 15928: 	EnterLog;
; 15929: 
; 15930: 	tmpXmlStr = inputStr;

	mov	eax, DWORD PTR _inputStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15931: 	if (tmpXmlStr.Length() == 0)

	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214247

; 15932: 	{
; 15933: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15934: 		DebugLog("Input XML String is empty");
; 15935: 		return S_FALSE;

	mov	DWORD PTR $T222771[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222771[ebp]
	jmp	$L214239
$L214247:

; 15936: 	}
; 15937: 
; 15938: 	unsigned char *ptr = (unsigned char *)inputStr;

	mov	eax, DWORD PTR _inputStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 15939: 	unsigned int *szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 15940: 	unsigned int inputSize = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _inputSize$[ebp], eax

; 15941: 
; 15942: 	if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 15943: 		((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214258
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L214257
$L214258:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L214256
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214256
$L214257:

; 15944: 	{
; 15945: 		// The data is in utf-16 format so do not convert to char *
; 15946: 		charInputStr = (char *)ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _charInputStr$[ebp], eax

; 15947: 	}
; 15948: 	else

	jmp	SHORT $L214260
$L214256:

; 15949: 	{
; 15950: 		charInputStr = (char *)HeapW2A(inputStr);

	mov	ecx, DWORD PTR _inputStr$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charInputStr$[ebp], eax

; 15951: 		if (charInputStr == NULL)

	cmp	DWORD PTR _charInputStr$[ebp], 0
	jne	SHORT $L214262

; 15952: 		{
; 15953: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15954: 			return S_FALSE;

	mov	DWORD PTR $T222772[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222772[ebp]
	jmp	$L214239
$L214262:

; 15955: 		}
; 15956: 		inputSize = strlen(charInputStr);

	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _inputSize$[ebp], eax

; 15957: 		freeMemory = TRUE;

	mov	DWORD PTR _freeMemory$[ebp], 1
$L214260:

; 15958: 	}
; 15959: 
; 15960: 	int outputSize = base64encodeSize(inputSize);

	mov	edx, DWORD PTR _inputSize$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _outputSize$[ebp], eax

; 15961: 	unsigned char *outputBuffer = (unsigned char *) zMalloc(outputSize + 1);

	mov	eax, DWORD PTR _outputSize$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outputBuffer$[ebp], eax

; 15962: 	if (outputBuffer == NULL)

	cmp	DWORD PTR _outputBuffer$[ebp], 0
	jne	SHORT $L214268

; 15963: 	{
; 15964: 		if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214269

; 15965: 			zFree(charInputStr);

	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L214269:

; 15966: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 15967: 		return S_FALSE;

	mov	DWORD PTR $T222773[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222773[ebp]
	jmp	$L214239
$L214268:

; 15968: 	}
; 15969: 
; 15970: 	if ((outputSize = base64encode((unsigned char *)charInputStr, inputSize, outputBuffer, outputSize + 1)) == -1)

	mov	ecx, DWORD PTR _outputSize$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _outputBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _inputSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charInputStr$[ebp]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _outputSize$[ebp], eax
	cmp	DWORD PTR _outputSize$[ebp], -1
	jne	SHORT $L214273

; 15971: 	{
; 15972: 		if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214274

; 15973: 			zFree(charInputStr);

	mov	edx, DWORD PTR _charInputStr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214274:

; 15974: 		zFree(outputBuffer);

	mov	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15975: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 15976: 		return S_FALSE;

	mov	DWORD PTR $T222774[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222774[ebp]
	jmp	SHORT $L214239
$L214273:

; 15977: 	}
; 15978: 	if (freeMemory)

	cmp	DWORD PTR _freeMemory$[ebp], 0
	je	SHORT $L214277

; 15979: 		zFree(charInputStr);

	mov	eax, DWORD PTR _charInputStr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214277:

; 15980: 	*encodedStr = A2WBSTR((LPCSTR)outputBuffer);

	push	-1
	mov	ecx, DWORD PTR _outputBuffer$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _encodedStr$[ebp]
	mov	DWORD PTR [edx], eax

; 15981: 	zFree(outputBuffer);

	mov	eax, DWORD PTR _outputBuffer$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 15982: 	ExitLog;
; 15983: 	return S_OK;

	mov	DWORD PTR $T222775[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222775[ebp]
$L214239:

; 15984: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222782
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222782:
	DD	1
	DD	$L222781
$L222781:
	DD	-20					; ffffffecH
	DD	4
	DD	$L222779
$L222779:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	88					; 00000058H
	DB	109					; 0000006dH
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222776:
	lea	ecx, DWORD PTR _tmpXmlStr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222778
	jmp	___CxxFrameHandler
text$x	ENDS
?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::Base64EncodeStrToStr
PUBLIC	?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::SetActivePFXB64Data
xdata$x	SEGMENT
$T222799 DD	0ffffffffH
	DD	FLAT:$L222791
$T222793 DD	019930520H
	DD	01H
	DD	FLAT:$T222799
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222790 = -116						; size = 4
$T222789 = -112						; size = 4
$T222788 = -108						; size = 4
$T222787 = -104						; size = 4
$T222786 = -100						; size = 4
$T222785 = -96						; size = 4
_spwd$ = -88						; size = 12
_inputSize$ = -72					; size = 4
_szPtr$ = -68						; size = 4
_ptr$ = -64						; size = 4
_tmpCcBstr$ = -56					; size = 4
__lpa$ = -48						; size = 4
__lpw$ = -44						; size = 4
__acp$ = -40						; size = 4
__convert$ = -36					; size = 4
_sizeM$ = -32						; size = 4
_charPfxB64Data$ = -28					; size = 4
_binFileData$ = -24					; size = 4
_certData$ = -20					; size = 4
_fileSize$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_b64PfxData$ = 12					; size = 4
_pfxPassword$ = 16					; size = 4
_pfxX509Cert$ = 20					; size = 4
?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::SetActivePFXB64Data

; 15987: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 104				; 00000068H
	push	edi
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 15988: 	DWORD fileSize;
; 15989: 	char *certData=NULL;

	mov	DWORD PTR _certData$[ebp], 0

; 15990: 	unsigned char *binFileData=NULL;

	mov	DWORD PTR _binFileData$[ebp], 0

; 15991: 	unsigned char *charPfxB64Data=NULL;

	mov	DWORD PTR _charPfxB64Data$[ebp], 0

; 15992: 	unsigned int sizeM;
; 15993: 
; 15994: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 15995: 	EnterLog;
; 15996: 	CComBSTR	tmpCcBstr;

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 15997: 
; 15998: 	tmpCcBstr = b64PfxData;

	mov	eax, DWORD PTR _b64PfxData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 15999: 	if (tmpCcBstr.Length() == 0)

	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214297

; 16000: 	{
; 16001: 		setError(SigHandle, PFX_INVALID_CERTIFICATE);

	push	59					; 0000003bH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16002: 		return S_FALSE;

	mov	DWORD PTR $T222785[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222785[ebp]
	jmp	$L214286
$L214297:

; 16003: 	}
; 16004: 
; 16005: 	unsigned char *ptr = (unsigned char *)b64PfxData;

	mov	eax, DWORD PTR _b64PfxData$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 16006: 	unsigned int *szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 16007: 	unsigned int inputSize = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _inputSize$[ebp], eax

; 16008: 
; 16009: 	if (((*ptr == 0xff) && (*(ptr +1) == 0xfe)) ||
; 16010: 		((*ptr == 0xfe) && (*(ptr +1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214308
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L214307
$L214308:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L214306
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214306
$L214307:

; 16011: 	{
; 16012: 		// The data is in utf-16 format so do not convert to char *
; 16013: 		charPfxB64Data = (unsigned char *)zMalloc(inputSize);

	mov	eax, DWORD PTR _inputSize$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _charPfxB64Data$[ebp], eax

; 16014: 		if (charPfxB64Data == NULL)

	cmp	DWORD PTR _charPfxB64Data$[ebp], 0
	jne	SHORT $L214310

; 16015: 		{
; 16016: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16017: 			return S_FALSE;

	mov	DWORD PTR $T222786[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222786[ebp]
	jmp	$L214286
$L214310:

; 16018: 		}
; 16019: 		memcpy(charPfxB64Data, (const char *)ptr, inputSize);

	mov	eax, DWORD PTR _inputSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charPfxB64Data$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 16020: 	}
; 16021: 	else

	jmp	SHORT $L214314
$L214306:

; 16022: 	{
; 16023: 		charPfxB64Data = HeapW2A(b64PfxData);

	mov	eax, DWORD PTR _b64PfxData$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charPfxB64Data$[ebp], eax

; 16024: 		if (charPfxB64Data == NULL)

	cmp	DWORD PTR _charPfxB64Data$[ebp], 0
	jne	SHORT $L214315

; 16025: 		{
; 16026: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16027: 			return S_FALSE;

	mov	DWORD PTR $T222787[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222787[ebp]
	jmp	$L214286
$L214315:

; 16028: 		}
; 16029: 		inputSize = strlen((const char *)charPfxB64Data);

	mov	eax, DWORD PTR _charPfxB64Data$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _inputSize$[ebp], eax
$L214314:

; 16030: 	}
; 16031: 
; 16032: 	fileSize = base64decodeSize(inputSize);

	mov	ecx, DWORD PTR _inputSize$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _fileSize$[ebp], eax

; 16033: 
; 16034: 	binFileData = (unsigned char *)zMalloc(fileSize+1);

	mov	edx, DWORD PTR _fileSize$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _binFileData$[ebp], eax

; 16035: 	if (binFileData == NULL)

	cmp	DWORD PTR _binFileData$[ebp], 0
	jne	SHORT $L214320

; 16036: 	{
; 16037: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16038: 		zFree(charPfxB64Data);

	mov	edx, DWORD PTR _charPfxB64Data$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16039: 		return S_FALSE;

	mov	DWORD PTR $T222788[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222788[ebp]
	jmp	$L214286
$L214320:

; 16040: 	}
; 16041: 
; 16042: 	if ((fileSize = base64decode(charPfxB64Data, binFileData, fileSize+1)) == -1)

	mov	eax, DWORD PTR _fileSize$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _binFileData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charPfxB64Data$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _fileSize$[ebp], eax
	cmp	DWORD PTR _fileSize$[ebp], -1
	jne	SHORT $L214323

; 16043: 	{
; 16044: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16045: 		zFree(charPfxB64Data);

	mov	edx, DWORD PTR _charPfxB64Data$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16046: 		zFree(binFileData);

	mov	eax, DWORD PTR _binFileData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16047: 		return S_FALSE;

	mov	DWORD PTR $T222789[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222789[ebp]
	jmp	$L214286
$L214323:

; 16048: 	}
; 16049: 
; 16050: 	if (PfxPassword.pbData != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+900], 0
	je	SHORT $L214326

; 16051: 	{
; 16052: 		zFree(PfxPassword.pbData);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+900]
	push	eax
	call	_rFree
	add	esp, 4

; 16053: 		PfxPassword.pbData = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+900], 0
$L214326:

; 16054: 	}
; 16055: 
; 16056: 	ptr = (unsigned char *)pfxPassword;

	mov	edx, DWORD PTR _pfxPassword$[ebp]
	mov	DWORD PTR _ptr$[ebp], edx

; 16057: 
; 16058: 	if (ptr != NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	je	SHORT $L214328

; 16059: 	{
; 16060: 		szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	eax, DWORD PTR _ptr$[ebp]
	sub	eax, 4
	mov	DWORD PTR _szPtr$[ebp], eax

; 16061: 		sizeM = *szPtr;

	mov	ecx, DWORD PTR _szPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _sizeM$[ebp], edx

; 16062: 
; 16063: 		if (sizeM == 0) {

	cmp	DWORD PTR _sizeM$[ebp], 0
	jne	SHORT $L214331

; 16064: 			PfxPassword.pbData = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+900], 0

; 16065: 			PfxPassword.cbData = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+904], 0

; 16066: 		}
; 16067: 		else

	jmp	SHORT $L214328
$L214331:

; 16068: 		{
; 16069: 			sizeM += 2; // BSTR size does not include the terminating null so add 2 to the size

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 2
	mov	DWORD PTR _sizeM$[ebp], edx

; 16070: 			PfxPassword.pbData		= (unsigned char *) zMalloc(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+900], eax

; 16071: 			memcpy(PfxPassword.pbData, ptr, sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 16072: 			PfxPassword.cbData = sizeM;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _sizeM$[ebp]
	mov	DWORD PTR [eax+904], ecx
$L214328:

; 16073: 		}
; 16074: 	}
; 16075: 
; 16076: 	if (B64PfxDataPtr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+920], 0
	je	SHORT $L214334

; 16077: 		zFree(B64PfxDataPtr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+920]
	push	ecx
	call	_rFree
	add	esp, 4
$L214334:

; 16078: 
; 16079: 	B64PfxDataPtr = charPfxB64Data;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _charPfxB64Data$[ebp]
	mov	DWORD PTR [edx+920], eax

; 16080: 	
; 16081: 	PfxCertDataBlob.cbData = fileSize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _fileSize$[ebp]
	mov	DWORD PTR [ecx+928], edx

; 16082: 	
; 16083: 	if (PfxCertDataBlob.pbData != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+924], 0
	je	SHORT $L214335

; 16084: 		zFree(PfxCertDataBlob.pbData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+924]
	push	edx
	call	_rFree
	add	esp, 4
$L214335:

; 16085: 	
; 16086: 	PfxCertDataBlob.pbData = binFileData; // Remember to free this memory in Empty()

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _binFileData$[ebp]
	mov	DWORD PTR [eax+924], ecx

; 16087: 
; 16088: 	if (PfxX509Cert != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+916], 0
	je	SHORT $L214336

; 16089: 		zFree(PfxX509Cert);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	push	ecx
	call	_rFree
	add	esp, 4
$L214336:

; 16090: 
; 16091: 	if (PfxCertInfo != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+932], 0
	je	SHORT $L214337

; 16092: 	{
; 16093: 		// Since PfxX509Cert and PfxCertInfo->certificate point to the same memory location
; 16094: 		// and we just freed PfxX509Cert above, we can't free PfxCertInfo->certificate as well
; 16095: 		zFree(PfxCertInfo);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+932]
	push	ecx
	call	_rFree
	add	esp, 4

; 16096: 		PfxCertInfo = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+932], 0
$L214337:

; 16097: 	}
; 16098: #ifdef NSS
; 16099: 	SECItem spwd;
; 16100: 	spwd.data = PfxPassword.pbData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	DWORD PTR _spwd$[ebp+4], ecx

; 16101: 	spwd.len = PfxPassword.cbData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+904]
	mov	DWORD PTR _spwd$[ebp+8], eax

; 16102: 	PfxX509Cert	= crPFX2X509(&PfxCertDataBlob, &spwd, &PfxCertInfo, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 932				; 000003a4H
	push	eax
	lea	ecx, DWORD PTR _spwd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 924				; 0000039cH
	push	edx
	call	_crPFX2X509
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+916], eax

; 16103: #else
; 16104: 	PfxX509Cert	= crPFX2X509(&PfxCertDataBlob, (LPCWSTR) PfxPassword.pbData, &PfxCertInfo, SigHandle);
; 16105: #endif
; 16106: 
; 16107: 	if (PfxX509Cert != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+916], 0
	je	SHORT $L214339

; 16108: 	{
; 16109: 		*pfxX509Cert	= A2WBSTR((LPCSTR) PfxX509Cert);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+916]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _pfxX509Cert$[ebp]
	mov	DWORD PTR [edx], eax

; 16110: 		CurrentCertificate = USE_PFX_CERT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], -2			; fffffffeH
$L214339:

; 16111: 	}
; 16112: 
; 16113: 	ExitLog;
; 16114: 	return S_OK;

	mov	DWORD PTR $T222790[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222790[ebp]
$L214286:

; 16115: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222798
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222798:
	DD	2
	DD	$L222797
$L222797:
	DD	-56					; ffffffc8H
	DD	4
	DD	$L222794
	DD	-88					; ffffffa8H
	DD	12					; 0000000cH
	DD	$L222795
$L222795:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	0
$L222794:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222791:
	lea	ecx, DWORD PTR _tmpCcBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222793
	jmp	___CxxFrameHandler
text$x	ENDS
?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::SetActivePFXB64Data
PUBLIC	?put_FloatingLicense@CSignature@@UAGJPAG@Z	; CSignature::put_FloatingLicense
EXTRN	?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z:NEAR ; CLicense::verifyFloatingLicense
xdata$x	SEGMENT
$T222813 DD	0ffffffffH
	DD	FLAT:$L222806
$T222808 DD	019930520H
	DD	01H
	DD	FLAT:$T222813
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222805 = -60						; size = 4
$T222804 = -56						; size = 4
$T222803 = -52						; size = 4
$T222802 = -48						; size = 4
$T222801 = -44						; size = 4
_osType$ = -40						; size = 4
_ccBstr$ = -32						; size = 4
_sizeM$ = -24						; size = 4
_newPtr$ = -20						; size = 4
_ptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_signedXML$ = 12					; size = 4
?put_FloatingLicense@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_FloatingLicense

; 16118: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_FloatingLicense@CSignature@@UAGJPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 16119: 	unsigned char *ptr, *newPtr=NULL;

	mov	DWORD PTR _newPtr$[ebp], 0

; 16120: 	unsigned int sizeM;
; 16121: 	CComBSTR ccBstr;

	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 16122: 
; 16123: 	long osType;
; 16124: 
; 16125: 	osType = CLicense::getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	DWORD PTR _osType$[ebp], eax

; 16126: 
; 16127: 	if ((osType != 0) && (osType != VER_NT_WORKSTATION))

	cmp	DWORD PTR _osType$[ebp], 0
	je	SHORT $L214352
	cmp	DWORD PTR _osType$[ebp], 1
	je	SHORT $L214352

; 16128: 		 // It is not a client machine as it is some sort of windows server product
; 16129: 		 // Floating license is not allowed on a server class machine
; 16130: 	{
; 16131: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16132: 		return S_FALSE;

	mov	DWORD PTR $T222801[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222801[ebp]
	jmp	$L214346
$L214352:

; 16133: 	}
; 16134: 
; 16135: 	ccBstr = signedXML;

	mov	edx, DWORD PTR _signedXML$[ebp]
	push	edx
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 16136: 	if (ccBstr.Length() == 0)

	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214355

; 16137: 		return S_FALSE;

	mov	DWORD PTR $T222802[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222802[ebp]
	jmp	$L214346
$L214355:

; 16138: 
; 16139: 	ptr = HeapW2A(signedXML);

	mov	eax, DWORD PTR _signedXML$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 16140: 	sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16141: 	sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16142: 	if(!(newPtr = (BYTE *)zMalloc(sizeM+1)))

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax
	cmp	DWORD PTR _newPtr$[ebp], 0
	jne	SHORT $L214360

; 16143: 	{
; 16144: 		zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16145: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 16146: 		return S_FALSE;

	mov	DWORD PTR $T222803[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222803[ebp]
	jmp	$L214346
$L214360:

; 16147: 	}
; 16148: 	if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214363

; 16149: 	{
; 16150: 		zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16151: 		zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16152: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16153: 		return S_FALSE;

	mov	DWORD PTR $T222804[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222804[ebp]
	jmp	SHORT $L214346
$L214363:

; 16154: 	}
; 16155: 	zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16156: 	LicObj.verifyFloatingLicense(newPtr, sizeM, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z ; CLicense::verifyFloatingLicense

; 16157: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16158: 	return S_OK;

	mov	DWORD PTR $T222805[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222805[ebp]
$L214346:

; 16159: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222812
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L222812:
	DD	1
	DD	$L222811
$L222811:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L222809
$L222809:
	DB	99					; 00000063H
	DB	99					; 00000063H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222806:
	lea	ecx, DWORD PTR _ccBstr$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?put_FloatingLicense@CSignature@@UAGJPAG@Z:
	mov	eax, OFFSET FLAT:$T222808
	jmp	___CxxFrameHandler
text$x	ENDS
?put_FloatingLicense@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_FloatingLicense
PUBLIC	?createSgts@CSignature@@QAEPAGXZ		; CSignature::createSgts
PUBLIC	?getLicensedUserCount@CLicense@@QBEHXZ		; CLicense::getLicensedUserCount
PUBLIC	?get_FloatingLicense@CSignature@@UAGJPAPAG@Z	; CSignature::get_FloatingLicense
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_floatingLicenseStr$ = 12				; size = 4
?get_FloatingLicense@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_FloatingLicense

; 16162: {

	push	ebp
	mov	ebp, esp

; 16163: //	DebugBreak();
; 16164: 	if (LicObj.getLicensedUserCount() == -1)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getLicensedUserCount@CLicense@@QBEHXZ	; CLicense::getLicensedUserCount
	cmp	eax, -1
	jne	SHORT $L214372

; 16165: 		*floatingLicenseStr = createSgts();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?createSgts@CSignature@@QAEPAGXZ	; CSignature::createSgts
	mov	ecx, DWORD PTR _floatingLicenseStr$[ebp]
	mov	DWORD PTR [ecx], eax
$L214372:

; 16166: 	return S_OK;

	xor	eax, eax

; 16167: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_FloatingLicense@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_FloatingLicense
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
_TEXT	ENDS
;	COMDAT ?getLicensedUserCount@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLicensedUserCount@CLicense@@QBEHXZ PROC NEAR	; CLicense::getLicensedUserCount, COMDAT
; _this$ = ecx

; 116  : 	int getLicensedUserCount() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		return num_of_lic;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+128]

; 118  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getLicensedUserCount@CLicense@@QBEHXZ ENDP		; CLicense::getLicensedUserCount
_TEXT	ENDS
EXTRN	??0CTimeSpan@ATL@@QAE@JHHH@Z:NEAR		; ATL::CTimeSpan::CTimeSpan
EXTRN	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z:NEAR	; ATL::CTime::operator+
EXTRN	?GetAsSystemTime@CTime@ATL@@QBE_NAAU_SYSTEMTIME@@@Z:NEAR ; ATL::CTime::GetAsSystemTime
EXTRN	__imp__GetTimeZoneInformation@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
tv69 = -280						; size = 4
$T222821 = -276						; size = 8
$T222820 = -268						; size = 8
$T222819 = -260						; size = 8
_dayLightAdjustment$214390 = -248			; size = 8
_bias$214389 = -232					; size = 8
_standardBias$214386 = -216				; size = 8
_timeZoneId$ = -204					; size = 4
_vbTime$ = -196						; size = 8
_timeZoneInformation$ = -180				; size = 172
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_localTime$ = 8						; size = 4
_localTimeToUtcTime PROC NEAR

; 16170: {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 70					; 00000046H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 16171: 	TIME_ZONE_INFORMATION timeZoneInformation;
; 16172: 	CTime vbTime(*localTime);

	push	-1
	mov	eax, DWORD PTR _localTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vbTime$[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 16173: 
; 16174: 	DWORD timeZoneId =  GetTimeZoneInformation(&timeZoneInformation);

	mov	esi, esp
	lea	ecx, DWORD PTR _timeZoneInformation$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetTimeZoneInformation@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _timeZoneId$[ebp], eax

; 16175: 	/*
; 16176: 	typedef struct _TIME_ZONE_INFORMATION { 
; 16177: 		LONG       Bias; 
; 16178: 		WCHAR      StandardName[ 32 ]; 
; 16179: 		SYSTEMTIME StandardDate; 
; 16180: 		LONG       StandardBias; 
; 16181: 		WCHAR      DaylightName[ 32 ]; 
; 16182: 		SYSTEMTIME DaylightDate; 
; 16183: 		LONG       DaylightBias; 
; 16184: 	} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION;
; 16185: 
; 16186: 	Members
; 16187: 	Bias 
; 16188: 	Current bias for local time translation on this computer, in minutes. The bias is the difference, 
; 16189: 	in minutes, between Coordinated Universal Time (UTC) and local time. All translations between UTC 
; 16190: 	and local time are based on the following formula: 
; 16191: 
; 16192: 	UTC = local time + bias 
; 16193: 	This member is required. 
; 16194: 
; 16195: 	StandardName 
; 16196: 	Pointer to a null-terminated string associated with standard time on this operating system. 
; 16197: 	For example, this member could contain "EST" to indicate Eastern Standard Time. This string 
; 16198: 	is not used by the operating system, so anything stored there using the SetTimeZoneInformation 
; 16199: 	function is returned unchanged by the GetTimeZoneInformation function. This string can be empty. 
; 16200: 
; 16201: 	StandardDate 
; 16202: 	A SYSTEMTIME structure that contains a date and local time when the transition from daylight 
; 16203: 	saving time to standard time occurs on this operating system. If this date is not specified, 
; 16204: 	the wMonth member in the SYSTEMTIME structure must be zero. If this date is specified, the 
; 16205: 	DaylightDate value in the TIME_ZONE_INFORMATION structure must also be specified.
; 16206: 	To select the correct day in the month, set the wYear member to zero, the wDayOfWeek member 
; 16207: 	to an appropriate weekday, and the wDay member to a value in the range 1 through 5. Using this 
; 16208: 	notation, the first Sunday in April can be specified, as can the last Thursday in October 
; 16209: 	(5 is equal to "the last"). 
; 16210: 
; 16211: 	StandardBias 
; 16212: 	Bias value to be used during local time translations that occur during standard time. This 
; 16213: 	member is ignored if a value for the StandardDate member is not supplied. 
; 16214: 	This value is added to the value of the Bias member to form the bias used during standard 
; 16215: 	time. In most time zones, the value of this member is zero. 
; 16216: 
; 16217: 	DaylightName 
; 16218: 	Pointer to a null-terminated string associated with daylight saving time on this operating 
; 16219: 	system. For example, this member could contain "PDT" to indicate Pacific Daylight Time. This 
; 16220: 	string is not used by the operating system, so anything stored there by using the 
; 16221: 	SetTimeZoneInformation function is returned unchanged by the GetTimeZoneInformation function. 
; 16222: 	This string can be empty. 
; 16223: 
; 16224: 	DaylightDate 
; 16225: 	A SYSTEMTIME structure that contains a date and local time when the transition from standard 
; 16226: 	time to daylight saving time occurs on this operating system. If this date is not specified, 
; 16227: 	the wMonth member in the SYSTEMTIME structure must be zero. If this date is specified, the 
; 16228: 	StandardDate value in the TIME_ZONE_INFORMATION structure must also be specified. 
; 16229: 	To select the correct day in the month, set the wYear member to zero, the wDayOfWeek member 
; 16230: 	to an appropriate weekday, and the wDay member to a value in the range 1 through 5. Using 
; 16231: 	this notation, the first Sunday in April can be specified, as can the last Thursday in 
; 16232: 	October (5 is equal to "the last"). 
; 16233: 
; 16234: 	DaylightBias 
; 16235: 	Bias value to be used during local time translations that occur during daylight saving time. 
; 16236: 	This member is ignored if a value for the DaylightDate member is not supplied. 
; 16237: 	This value is added to the value of the Bias member to form the bias used during daylight 
; 16238: 	saving time. In most time zones, the value of this member is  60. 
; 16239: 
; 16240: 
; 16241: 	*/
; 16242: 
; 16243: 		switch(timeZoneId)

	mov	edx, DWORD PTR _timeZoneId$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 1
	je	SHORT $L214385
	cmp	DWORD PTR tv69[ebp], 2
	je	SHORT $L214388
	jmp	$L214381
$L214385:

; 16244: 		{
; 16245: 			case TIME_ZONE_ID_UNKNOWN: 
; 16246: 		/* The system cannot determine the current time zone. 
; 16247: 		* This error is also returned if you call the SetTimeZoneInformation 
; 16248: 		* function and supply the bias values but no transition dates.
; 16249: 		* Windows NT/2000/XP: This value is returned if daylight saving time 
; 16250: 		* is not used in the current time zone, because there are no transition dates. 
; 16251: 		*/
; 16252: 				break;
; 16253: 			case TIME_ZONE_ID_STANDARD:
; 16254: 		/* The system is operating in the range covered by the StandardDate member of 
; 16255: 		* the TIME_ZONE_INFORMATION structure.
; 16256: 		* Windows 95/98/Me: This value is returned if daylight saving time is not 
; 16257: 		* used in the current time zone, because there are no transition dates.
; 16258: 		*/
; 16259: 				{
; 16260: 					CTimeSpan standardBias(0,0, timeZoneInformation.Bias, 0);

	push	0
	mov	eax, DWORD PTR _timeZoneInformation$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _standardBias$214386[ebp]
	call	??0CTimeSpan@ATL@@QAE@JHHH@Z		; ATL::CTimeSpan::CTimeSpan

; 16261: 					vbTime = vbTime + standardBias;

	mov	ecx, DWORD PTR _standardBias$214386[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _standardBias$214386[ebp]
	push	edx
	lea	eax, DWORD PTR $T222819[ebp]
	push	eax
	lea	ecx, DWORD PTR _vbTime$[ebp]
	call	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z	; ATL::CTime::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _vbTime$[ebp], ecx
	mov	DWORD PTR _vbTime$[ebp+4], edx

; 16262: 					break;

	jmp	SHORT $L214381
$L214388:

; 16263: 				}
; 16264: 
; 16265: 			case TIME_ZONE_ID_DAYLIGHT:
; 16266: 		/* The system is operating in the range covered by the DaylightDate member of 
; 16267: 		* the TIME_ZONE_INFORMATION structure.
; 16268: 		*/
; 16269: 				{
; 16270: 					CTimeSpan bias(0,0, timeZoneInformation.Bias, 0);

	push	0
	mov	eax, DWORD PTR _timeZoneInformation$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _bias$214389[ebp]
	call	??0CTimeSpan@ATL@@QAE@JHHH@Z		; ATL::CTimeSpan::CTimeSpan

; 16271: 					CTimeSpan dayLightAdjustment(0,0, timeZoneInformation.DaylightBias, 0);

	push	0
	mov	ecx, DWORD PTR _timeZoneInformation$[ebp+168]
	push	ecx
	push	0
	push	0
	lea	ecx, DWORD PTR _dayLightAdjustment$214390[ebp]
	call	??0CTimeSpan@ATL@@QAE@JHHH@Z		; ATL::CTimeSpan::CTimeSpan

; 16272: 					vbTime = vbTime + bias + dayLightAdjustment;

	mov	edx, DWORD PTR _dayLightAdjustment$214390[ebp+4]
	push	edx
	mov	eax, DWORD PTR _dayLightAdjustment$214390[ebp]
	push	eax
	lea	ecx, DWORD PTR $T222821[ebp]
	push	ecx
	mov	edx, DWORD PTR _bias$214389[ebp+4]
	push	edx
	mov	eax, DWORD PTR _bias$214389[ebp]
	push	eax
	lea	ecx, DWORD PTR $T222820[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vbTime$[ebp]
	call	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z	; ATL::CTime::operator+
	mov	ecx, eax
	call	??HCTime@ATL@@QBE?AV01@VCTimeSpan@1@@Z	; ATL::CTime::operator+
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _vbTime$[ebp], edx
	mov	DWORD PTR _vbTime$[ebp+4], eax
$L214381:

; 16273: 					break;
; 16274: 				}
; 16275: 			default:
; 16276: 				break;
; 16277: 		}
; 16278: 
; 16279: 		if (localTime) {

	cmp	DWORD PTR _localTime$[ebp], 0
	je	SHORT $L214394

; 16280: 			vbTime.GetAsSystemTime(*localTime);

	mov	ecx, DWORD PTR _localTime$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _vbTime$[ebp]
	call	?GetAsSystemTime@CTime@ATL@@QBE_NAAU_SYSTEMTIME@@@Z ; ATL::CTime::GetAsSystemTime
$L214394:

; 16281: 		}
; 16282: 		return localTime;

	mov	eax, DWORD PTR _localTime$[ebp]

; 16283: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222829
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L222829:
	DD	5
	DD	$L222828
$L222828:
	DD	-180					; ffffff4cH
	DD	172					; 000000acH
	DD	$L222822
	DD	-196					; ffffff3cH
	DD	8
	DD	$L222823
	DD	-216					; ffffff28H
	DD	8
	DD	$L222824
	DD	-232					; ffffff18H
	DD	8
	DD	$L222825
	DD	-248					; ffffff08H
	DD	8
	DD	$L222826
$L222826:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	104					; 00000068H
	DB	116					; 00000074H
	DB	65					; 00000041H
	DB	100					; 00000064H
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222825:
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	0
$L222824:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	0
$L222823:
	DB	118					; 00000076H
	DB	98					; 00000062H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L222822:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	90					; 0000005aH
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
_localTimeToUtcTime ENDP
_TEXT	ENDS
PUBLIC	?get_LicensedUserCount@CSignature@@UAGJPAJ@Z	; CSignature::get_LicensedUserCount
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_LicensedUserCount@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_LicensedUserCount

; 16286: {

	push	ebp
	mov	ebp, esp

; 16287: 	*pVal = LicObj.getLicensedUserCount();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getLicensedUserCount@CLicense@@QBEHXZ	; CLicense::getLicensedUserCount
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 16288: 	return S_OK;

	xor	eax, eax

; 16289: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_LicensedUserCount@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_LicensedUserCount
_TEXT	ENDS
PUBLIC	?put_IncludeCRLInSignature@CSignature@@UAGJH@Z	; CSignature::put_IncludeCRLInSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_IncludeCRLInSignature@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_IncludeCRLInSignature

; 16292: {

	push	ebp
	mov	ebp, esp

; 16293: 	IncludeCRLInSignature = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+2192], ecx

; 16294: 	return S_OK;

	xor	eax, eax

; 16295: }

	pop	ebp
	ret	8
?put_IncludeCRLInSignature@CSignature@@UAGJH@Z ENDP	; CSignature::put_IncludeCRLInSignature
_TEXT	ENDS
PUBLIC	?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z ; CSignature::get_UsedCRLList
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_arrElement$214428 = -60				; size = 4
_i$214423 = -52						; size = 4
__lpa$ = -44						; size = 4
__lpw$ = -40						; size = 4
__acp$ = -36						; size = 4
__convert$ = -32					; size = 4
_hr$ = -28						; size = 4
_rgsabound$ = -20					; size = 8
_outArray$ = -8						; size = 4
_outVariant$ = -4					; size = 4
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z PROC NEAR ; CSignature::get_UsedCRLList

; 16298: {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 16299: 	VARIANT *outVariant;
; 16300: 	SAFEARRAY *outArray;
; 16301: 	SAFEARRAYBOUND rgsabound[1];
; 16302: 	HRESULT hr;
; 16303: 	
; 16304: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 16305: 	EnterLog;
; 16306: 	outVariant = (VARIANT *)zMalloc(sizeof(VARIANT));

	push	16					; 00000010H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outVariant$[ebp], eax

; 16307: 	outArray = (SAFEARRAY *)zMalloc(sizeof(SAFEARRAY *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _outArray$[ebp], eax

; 16308: 
; 16309: 	VariantInit(outVariant);

	mov	esi, esp
	mov	eax, DWORD PTR _outVariant$[ebp]
	push	eax
	call	DWORD PTR __imp__VariantInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16310: 
; 16311: 	rgsabound[0].lLbound = 0;

	mov	DWORD PTR _rgsabound$[ebp+4], 0

; 16312: 	rgsabound[0].cElements = CertVerifyParams.usedCrlCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1888]
	mov	DWORD PTR _rgsabound$[ebp], edx

; 16313: 
; 16314: 	outArray = SafeArrayCreate(VT_BSTR, 
; 16315: 								1,
; 16316: 								rgsabound);

	mov	esi, esp
	lea	eax, DWORD PTR _rgsabound$[ebp]
	push	eax
	push	1
	push	8
	call	DWORD PTR __imp__SafeArrayCreate@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _outArray$[ebp], eax

; 16317: 	if (outArray == NULL)

	cmp	DWORD PTR _outArray$[ebp], 0
	jne	SHORT $L214421

; 16318: 	{
; 16319: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16320: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214408
$L214421:

; 16321: 	}
; 16322: 	for (long i=0; i<(long)CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$214423[ebp], 0
	jmp	SHORT $L214425
$L214426:
	mov	eax, DWORD PTR _i$214423[ebp]
	add	eax, 1
	mov	DWORD PTR _i$214423[ebp], eax
$L214425:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$214423[ebp]
	cmp	edx, DWORD PTR [ecx+1888]
	jge	SHORT $L214427

; 16323: 	{
; 16324: 		BSTR arrElement;
; 16325: 		arrElement = A2WBSTR(CertVerifyParams.usedCrlList[i]);

	push	-1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR _i$214423[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _arrElement$214428[ebp], eax

; 16326: 		hr = SafeArrayPutElement(outArray, &i, arrElement);

	mov	esi, esp
	mov	ecx, DWORD PTR _arrElement$214428[ebp]
	push	ecx
	lea	edx, DWORD PTR _i$214423[ebp]
	push	edx
	mov	eax, DWORD PTR _outArray$[ebp]
	push	eax
	call	DWORD PTR __imp__SafeArrayPutElement@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 16327: 		if (hr != S_OK)

	cmp	DWORD PTR _hr$[ebp], 0
	je	SHORT $L214430

; 16328: 		{
; 16329: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16330: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L214408
$L214430:

; 16331: 		}
; 16332: 	}

	jmp	SHORT $L214426
$L214427:

; 16333: 	(*outVariant).vt = (VT_ARRAY | VT_BSTR);

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	WORD PTR [eax], 8200			; 00002008H

; 16334: 	(*outVariant).parray = outArray;

	mov	ecx, DWORD PTR _outVariant$[ebp]
	mov	edx, DWORD PTR _outArray$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 16335: 	*pVal = *outVariant;

	mov	eax, DWORD PTR _outVariant$[ebp]
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 16336: 	ExitLog;
; 16337: 	return S_OK;

	xor	eax, eax
$L214408:

; 16338: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222836
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L222836:
	DD	2
	DD	$L222835
$L222835:
	DD	-20					; ffffffecH
	DD	8
	DD	$L222833
	DD	-52					; ffffffccH
	DD	4
	DD	$L222834
$L222834:
	DB	105					; 00000069H
	DB	0
$L222833:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	98					; 00000062H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z ENDP	; CSignature::get_UsedCRLList
_TEXT	ENDS
PUBLIC	?GetErrorDetail@CSignature@@UAGJJPAPAG@Z	; CSignature::GetErrorDetail
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_this$ = 8						; size = 4
_errorNum$ = 12						; size = 4
_errorDesc$ = 16					; size = 4
?GetErrorDetail@CSignature@@UAGJJPAPAG@Z PROC NEAR	; CSignature::GetErrorDetail

; 16341: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 16342: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 16343: 	*errorDesc = A2WBSTR((LPCSTR)errorMsgTable[errorNum]);

	push	-1
	mov	eax, DWORD PTR _errorNum$[ebp]
	mov	ecx, DWORD PTR _errorMsgTable[eax*4]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _errorDesc$[ebp]
	mov	DWORD PTR [edx], eax

; 16344: 	return S_OK;

	xor	eax, eax

; 16345: }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetErrorDetail@CSignature@@UAGJJPAPAG@Z ENDP		; CSignature::GetErrorDetail
_TEXT	ENDS
PUBLIC	?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z ; CSignature::put_PhysicalSignatureB64Str
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_PhysicalSignatureB64Str

; 16348: {

	push	ebp
	mov	ebp, esp
	push	esi

; 16349: 	if (PhysicalSignatureB64Str != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3404], 0
	je	SHORT $L214448

; 16350: 	{
; 16351: 		zFree(PhysicalSignatureB64Str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3404]
	push	edx
	call	_rFree
	add	esp, 4

; 16352: 		PhysicalSignatureB64Str = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3404], 0
$L214448:

; 16353: 	}
; 16354: 	if ((newVal != NULL) && (SysStringByteLen(newVal) != 0))

	cmp	DWORD PTR _newVal$[ebp], 0
	je	SHORT $L214449
	mov	esi, esp
	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L214449

; 16355: 		PhysicalSignatureB64Str = HeapW2A(newVal);

	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3404], eax
$L214449:

; 16356: 	return S_OK;

	xor	eax, eax

; 16357: }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_PhysicalSignatureB64Str
_TEXT	ENDS
PUBLIC	?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::GetSignedInfoDigest
xdata$x	SEGMENT
$T222865 DD	0ffffffffH
	DD	FLAT:$L222850
$T222852 DD	019930520H
	DD	01H
	DD	FLAT:$T222865
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv283 = -304						; size = 4
$T222849 = -300						; size = 4
$T222848 = -296						; size = 4
$T222847 = -292						; size = 4
$T222846 = -288						; size = 4
$T222845 = -284						; size = 4
$T222844 = -280						; size = 4
$T222843 = -276						; size = 4
$T222842 = -272						; size = 4
$T222841 = -268						; size = 4
_pbData$214657 = -264					; size = 4
_cbData$214656 = -260					; size = 4
_tmpEnvFlag$ = -256					; size = 2
_freeCharSigId$ = -252					; size = 4
__lpa$ = -248						; size = 4
__lpw$ = -244						; size = 4
__acp$ = -240						; size = 4
__convert$ = -236					; size = 4
_templateFound$ = -232					; size = 4
_guidStr$ = -224					; size = 50
_sigGuid$ = -164					; size = 16
_freeNewPtr$ = -144					; size = 4
_ptemp$ = -140						; size = 4
_xpathResultPtr$ = -136					; size = 4
_xpathPtr$ = -132					; size = 4
_sizeM$ = -128						; size = 4
_szPtr$ = -124						; size = 4
_curPtr$ = -120						; size = 4
_newPtr$ = -116						; size = 4
_ptr$ = -112						; size = 4
_sigId$ = -104						; size = 4
_iSize$ = -92						; size = 4
_mem$ = -84						; size = 4
_signedInfoNode$ = -76					; size = 4
_sigNode$ = -64						; size = 4
_parent$ = -56						; size = 4
_cur$ = -52						; size = 4
_root$ = -48						; size = 4
_doc$ = -44						; size = 4
_charSignedInfoDigest$ = -36				; size = 4
_curCharSigId$ = -28					; size = 4
_charSigId$ = -24					; size = 4
_charXMLStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_xmlStr$ = 12						; size = 4
_signatureId$ = 16					; size = 4
_signedInfoDigest$ = 20					; size = 4
?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::GetSignedInfoDigest

; 16360: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 292				; 00000124H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-304]
	mov	ecx, 73					; 00000049H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 16361: 	char *charXMLStr=NULL, *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charXMLStr$[ebp], 0
	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 16362: 	unsigned char *charSignedInfoDigest=NULL;

	mov	DWORD PTR _charSignedInfoDigest$[ebp], 0

; 16363: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 16364: 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 16365: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 16366: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 16367: 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 16368: 	unsigned char *ptr, *newPtr=NULL, *curPtr=NULL; 

	mov	DWORD PTR _newPtr$[ebp], 0
	mov	DWORD PTR _curPtr$[ebp], 0

; 16369: 	unsigned int *szPtr;
; 16370: 	unsigned int sizeM;
; 16371: 
; 16372: 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 16373: 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 16374: 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 16375: 	BOOL freeNewPtr = FALSE;

	mov	DWORD PTR _freeNewPtr$[ebp], 0

; 16376: 
; 16377: #ifdef WIN32
; 16378: 	GUID sigGuid;
; 16379: #else
; 16380: 	uuid_t sigGuid;
; 16381: #endif
; 16382: 	char guidStr[50];
; 16383: 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 16384: 
; 16385: 	EnterLog;
; 16386: 
; 16387: 	*signedInfoDigest = A2WBSTR((LPCSTR)NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [ecx], eax

; 16388: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L214483

; 16389: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 16390: 		return S_FALSE;

	mov	DWORD PTR $T222841[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222841[ebp]
	jmp	$L214456
$L214483:

; 16391: 	}
; 16392: 	if (sgArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L214486

; 16393: 	{
; 16394: 		if (uriArr != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $L214487

; 16395: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L214487:

; 16396: 		sgArr = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 16397: 		signum = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$L214486:

; 16398: 	}
; 16399: 
; 16400: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 16401: 
; 16402: 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 16403: 	sigId = signatureId;

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 16404: 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214493

; 16405: 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 16406: 	else

	jmp	SHORT $L214494
$L214493:

; 16407: 	{
; 16408: 		charSigId = (char *)HeapW2A(signatureId);

	mov	eax, DWORD PTR _signatureId$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 16409: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L214494:

; 16410: 	}
; 16411: 
; 16412: 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L214496

; 16413: 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214497

; 16414: 		{
; 16415: #ifdef WIN32
; 16416: 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	ecx, DWORD PTR _sigGuid$[ebp]
	push	ecx
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16417: 			GuidToString(&sigGuid, guidStr);

	lea	edx, DWORD PTR _guidStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 16418: #else
; 16419: 			uuid_generate(sigGuid);
; 16420: 			uuid_unparse(sigGuid, guidStr);
; 16421: #endif
; 16422: 			charSigId = guidStr;

	lea	ecx, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], ecx

; 16423: 		}
; 16424: 		else

	jmp	SHORT $L214496
$L214497:

; 16425: 		{
; 16426: 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+392]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 16427: 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L214496:

; 16428: 		}
; 16429: 
; 16430: 	if ((xmlStr != 0) && (SysStringByteLen(xmlStr) != 0))

	cmp	DWORD PTR _xmlStr$[ebp], 0
	je	$L214500
	mov	esi, esp
	mov	ecx, DWORD PTR _xmlStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$L214500

; 16431: 	{
; 16432: 		if (Base64DecodeXML == FALSE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+2184], 0
	jne	$L214501

; 16433: 		{
; 16434: 			ptr = (unsigned char *)xmlStr;

	mov	eax, DWORD PTR _xmlStr$[ebp]
	mov	DWORD PTR _ptr$[ebp], eax

; 16435: 			szPtr = (unsigned int *)(ptr - sizeof(int));

	mov	ecx, DWORD PTR _ptr$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _szPtr$[ebp], ecx

; 16436: 			sizeM = (*szPtr);

	mov	edx, DWORD PTR _szPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sizeM$[ebp], eax

; 16437: 
; 16438: 			if (((*ptr == 0xff) && (*(ptr + 1) == 0xfe)) ||
; 16439: 				((*ptr == 0xfe) && (*(ptr + 1) == 0xff)))

	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214507
	mov	eax, DWORD PTR _ptr$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 254				; 000000feH
	je	SHORT $L214506
$L214507:
	mov	edx, DWORD PTR _ptr$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 254				; 000000feH
	jne	SHORT $L214505
	mov	ecx, DWORD PTR _ptr$[ebp]
	movzx	edx, BYTE PTR [ecx+1]
	cmp	edx, 255				; 000000ffH
	jne	SHORT $L214505
$L214506:

; 16440: 			{
; 16441: 				// There is no need to put the UTF 16 header since the data is already in utf-16 format
; 16442: 				newPtr = ptr;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR _newPtr$[ebp], eax

; 16443: 			}
; 16444: 			else

	jmp	SHORT $L214508
$L214505:

; 16445: 			{
; 16446: 				newPtr = (unsigned char *)zMalloc(sizeM + 4);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 4
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 16447: 				freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 16448: 				FileEncoding(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	?FileEncoding@@YAXPAE@Z			; FileEncoding
	add	esp, 4

; 16449: 				memcpy(newPtr+2, ptr, sizeM + 2);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	add	edx, 2
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 16450: 				sizeM += 4;

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 4
	mov	DWORD PTR _sizeM$[ebp], eax
$L214508:

; 16451: 			}
; 16452: 		}
; 16453: 		else

	jmp	$L214510
$L214501:

; 16454: 		{
; 16455: 			ptr = HeapW2A(xmlStr);

	mov	ecx, DWORD PTR _xmlStr$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 16456: 			sizeM = strlen((const char *)ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16457: 			sizeM = base64decodeSize(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16458: 			newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 16459: 			freeNewPtr = TRUE;

	mov	DWORD PTR _freeNewPtr$[ebp], 1

; 16460: 			if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214513

; 16461: 			{
; 16462: 				zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16463: 				zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16464: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16465: 				return S_FALSE;

	mov	DWORD PTR $T222842[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222842[ebp]
	jmp	$L214456
$L214513:

; 16466: 			}
; 16467: 			zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214510:

; 16468: 		}
; 16469: 
; 16470: 		if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	$L214516

; 16471: 		{
; 16472: 			if (!LicObj.getFormSignAllowed(newPtr, sizeM, SigHandle))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	SHORT $L214516

; 16473: 			{
; 16474: 				setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 16475: 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214518

; 16476: 					zFree(charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L214518:

; 16477: 				if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L214519

; 16478: 					zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214519:

; 16479: 				return S_FALSE;

	mov	DWORD PTR $T222843[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222843[ebp]
	jmp	$L214456
$L214516:

; 16480: 			}
; 16481: 		}
; 16482: 
; 16483: 		// original document
; 16484: 		doc = xmlParseMemory((const char *)newPtr,sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 16485: 		if (freeNewPtr)

	cmp	DWORD PTR _freeNewPtr$[ebp], 0
	je	SHORT $L214523

; 16486: 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214523:

; 16487: 
; 16488: 		if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L214524

; 16489: 		{
; 16490: 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16491: 			return S_FALSE;

	mov	DWORD PTR $T222844[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222844[ebp]
	jmp	$L214456
$L214524:

; 16492: 		}
; 16493: 
; 16494: 		root = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 16495: 	//	  cur = root->xmlChildrenNode;
; 16496: 
; 16497: 		sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 16498: 		if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L214529

; 16499: 		{
; 16500: 			templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 16501: 			cur = sigNode->xmlChildrenNode;

	mov	edx, DWORD PTR _sigNode$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax
$L214531:

; 16502: 			while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L214529

; 16503: 			{
; 16504: 					if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG214535
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L214534

; 16505: 					{
; 16506: 						signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 16507: 						break;

	jmp	SHORT $L214529
$L214534:

; 16508: 					}
; 16509: 					cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 16510: 			}  // end while cur != NULL

	jmp	SHORT $L214531
$L214529:

; 16511: 		}
; 16512: 		cur = root->xmlChildrenNode;

	mov	eax, DWORD PTR _root$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx

; 16513: 		if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L214536

; 16514: 		{
; 16515: 			// Add a new Signature element
; 16516: 
; 16517: 			/*
; 16518: 			* Signature
; 16519: 			*/
; 16520: 
; 16521: 			cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG214538
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16522: 			sigNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], edx

; 16523: 			if (charSigId != NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	je	SHORT $L214539

; 16524: 				xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	push	OFFSET FLAT:$SG214542
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L214539:

; 16525: 			cur = xmlAddChild(root,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16526: 			//xmlNewNs(cur,(const unsigned char *)"http://www.w3.org/2000/09/xmldsig#",(const unsigned char *)NULL);
; 16527: 
; 16528: 			xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG214545
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 16529: 			parent = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], edx

; 16530: 
; 16531: 			/*
; 16532: 			* SignedInfo
; 16533: 			*/
; 16534: 			cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG214547
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16535: 			signedInfoNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], eax

; 16536: 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16537: 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 16538: 
; 16539: 			/*
; 16540: 			* Canonicalization Method
; 16541: 			*/
; 16542: 			cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG214549
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16543: 			switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv283[ebp], edx
	cmp	DWORD PTR tv283[ebp], 3
	ja	SHORT $L214574
	mov	eax, DWORD PTR tv283[ebp]
	jmp	DWORD PTR $L222864[eax*4]
$L214554:

; 16544: 			{
; 16545: 				case WITH_COMMENTS:
; 16546: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG214557
	push	OFFSET FLAT:$SG214558
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16547: 					break;

	jmp	SHORT $L214551
$L214559:

; 16548: 				case WITHOUT_COMMENTS:
; 16549: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG214562
	push	OFFSET FLAT:$SG214563
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16550: 					break;

	jmp	SHORT $L214551
$L214564:

; 16551: 				case EXC_WITH_COMMENTS:
; 16552: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG214567
	push	OFFSET FLAT:$SG214568
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16553: 					break;

	jmp	SHORT $L214551
$L214569:

; 16554: 				case EXC_WITHOUT_COMMENTS:
; 16555: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG214572
	push	OFFSET FLAT:$SG214573
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16556: 					break;

	jmp	SHORT $L214551
$L214574:

; 16557: 				default:
; 16558: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG214577
	push	OFFSET FLAT:$SG214578
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L214551:

; 16559: 			}
; 16560: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16561: 			if (signerCertChain == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3412], 0
	jne	SHORT $L214579

; 16562: 			{//We assume RSA Algorithm will be used if no signer certificate info is provided
; 16563: 				cur = xmlNewNode(NULL, (const unsigned char *)"SignatureMethod");

	push	OFFSET FLAT:$SG214581
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16564: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_RSAWITHSHA1);

	push	OFFSET FLAT:$SG214584
	push	OFFSET FLAT:$SG214585
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16565: 				cur = xmlAddChild(parent, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L214579:

; 16566: 			}
; 16567: 			/*
; 16568: 			* Reference
; 16569: 			*/
; 16570: 			cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG214587
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16571: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16572: 			xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG214590
	push	OFFSET FLAT:$SG214591
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16573: 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 16574: 
; 16575: 			/*
; 16576: 			* Transforms
; 16577: 			*/
; 16578: 		
; 16579: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG214593
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16580: 			cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16581: 			parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 16582: 
; 16583: 			/*
; 16584: 			* Transform
; 16585: 			*/
; 16586: 			if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 16587: 				(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	je	SHORT $L214595
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	$L214594
$L214595:

; 16588: 			{
; 16589: 				cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG214597
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16590: 				if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 3
	jne	SHORT $L214598

; 16591: 				{
; 16592: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG214601
	push	OFFSET FLAT:$SG214602
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16593: 				}
; 16594: 				else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L214603
$L214598:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 2
	jne	SHORT $L214603

; 16595: 				{
; 16596: 					xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG214607
	push	OFFSET FLAT:$SG214608
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L214603:

; 16597: 				}
; 16598: 				cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16599: 				parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 16600: 				if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L214609

; 16601: 				{
; 16602: 					cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG214611
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16603: 					xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG214614
	push	OFFSET FLAT:$SG214615
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 16604: 					xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG214618
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16605: 				}
; 16606: 				else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L214619
$L214609:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L214619

; 16607: 				{
; 16608: 					cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG214622
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16609: 					xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG214625
	push	OFFSET FLAT:$SG214626
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 16610: 					xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	push	OFFSET FLAT:$SG214629
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L214619:

; 16611: 				}
; 16612: 				cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16613: 				parent = parent->parent;

	mov	ecx, DWORD PTR _parent$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _parent$[ebp], edx
$L214594:

; 16614: 			}
; 16615: 			/*
; 16616: 			* Transform
; 16617: 			*/
; 16618: 
; 16619: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG214631
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16620: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG214634
	push	OFFSET FLAT:$SG214635
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16621: 			cur = xmlAddChild(parent,cur);		

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L214536:

; 16622: 		}
; 16623: 	}
; 16624: 	else

	jmp	$L214636
$L214500:

; 16625: 	{
; 16626: 		if ((AttachedObjectCount != 0) || (DetachedObjectCount !=0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	jne	SHORT $L214638
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $L214637
$L214638:

; 16627: 		{
; 16628: 			doc = PrepareSignatureEnvelopeFromObjects(charSigId, &sigNode, &signedInfoNode);

	lea	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	lea	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareSignatureEnvelopeFromObjects@CSignature@@QAEPAU_xmlDoc@@PADPAPAU_xmlNode@@1@Z ; CSignature::PrepareSignatureEnvelopeFromObjects
	mov	DWORD PTR _doc$[ebp], eax

; 16629: 			if (doc == NULL)

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L214639

; 16630: 			{
; 16631: 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214640

; 16632: 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214640:

; 16633: 				return S_FALSE;

	mov	DWORD PTR $T222845[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222845[ebp]
	jmp	$L214456
$L214639:

; 16634: 			}
; 16635: 		}
; 16636: 		else

	jmp	SHORT $L214636
$L214637:

; 16637: 		{
; 16638: 			if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214644

; 16639: 				zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214644:

; 16640: 			setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16641: 			return S_FALSE;

	mov	DWORD PTR $T222846[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222846[ebp]
	jmp	$L214456
$L214636:

; 16642: 		}
; 16643: 	}
; 16644: #ifdef WIN32
; 16645: 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+956], 0
	je	SHORT $L214647

; 16646: 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	push	edx
	mov	eax, DWORD PTR _sigNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L214647:

; 16647: #endif
; 16648: 	/*
; 16649: 	 * init Signature. crBlob contains XML - envelope document
; 16650: 	 */
; 16651: 	short tmpEnvFlag = EnvelopingFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], dx

; 16652: 	EnvelopingFlag = ENVELOPED;

	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+688], 2

; 16653: 
; 16654: 	calculateDigestOnly = TRUE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3408], 1

; 16655: 	if (!(CreateSigFromTmplBlob(doc, charSigId, &charSignedInfoDigest, &iSize)))

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _charSignedInfoDigest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	SHORT $L214649

; 16656: 	{
; 16657: 		if (charSignedInfoDigest != NULL)

	cmp	DWORD PTR _charSignedInfoDigest$[ebp], 0
	je	SHORT $L214650

; 16658: 		{
; 16659: 			zFree(charSignedInfoDigest);

	mov	eax, DWORD PTR _charSignedInfoDigest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214650:

; 16660: 		}
; 16661: 		EnvelopingFlag = tmpEnvFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [ecx+688], dx

; 16662: 		*signedInfoDigest = NULL;

	mov	eax, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [eax], 0

; 16663: 		calculateDigestOnly = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3408], 0

; 16664: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214651

; 16665: 			zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214651:

; 16666: 		return S_FALSE;

	mov	DWORD PTR $T222847[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222847[ebp]
	jmp	$L214456
$L214649:

; 16667: 	}
; 16668: 	else
; 16669: 	{
; 16670: 		if (charSignedInfoDigest != NULL)

	cmp	DWORD PTR _charSignedInfoDigest$[ebp], 0
	je	$L214654

; 16671: 		{
; 16672: 			unsigned int cbData;
; 16673: 			unsigned char *pbData;
; 16674: 			cbData = base64encodeSize(iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$214656[ebp], eax

; 16675: 			pbData = (unsigned char *)zMalloc(cbData+1);

	mov	ecx, DWORD PTR _cbData$214656[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$214657[ebp], eax

; 16676: 			if ((cbData = base64encode(charSignedInfoDigest, iSize, pbData, cbData+1)) == -1)

	mov	edx, DWORD PTR _cbData$214656[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbData$214657[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSignedInfoDigest$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$214656[ebp], eax
	cmp	DWORD PTR _cbData$214656[ebp], -1
	jne	SHORT $L214659

; 16677: 			{
; 16678: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16679: 				zFree(pbData);

	mov	edx, DWORD PTR _pbData$214657[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16680: 				zFree(charSignedInfoDigest);

	mov	eax, DWORD PTR _charSignedInfoDigest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16681: 				calculateDigestOnly = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3408], 0

; 16682: 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214660

; 16683: 					zFree(charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214660:

; 16684: 				return S_FALSE;

	mov	DWORD PTR $T222848[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222848[ebp]
	jmp	$L214456
$L214659:

; 16685: 			}
; 16686: 			zFree(charSignedInfoDigest);

	mov	eax, DWORD PTR _charSignedInfoDigest$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16687: 			*signedInfoDigest = A2WBSTR((LPCSTR) pbData, cbData);

	mov	ecx, DWORD PTR _cbData$214656[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbData$214657[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [ecx], eax

; 16688: 			zFree(pbData);

	mov	edx, DWORD PTR _pbData$214657[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214654:

; 16689: 		}
; 16690: 	}
; 16691: 	EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 16692: 	calculateDigestOnly = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3408], 0

; 16693: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L214664

; 16694: 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L214664:

; 16695: 	ExitLog;
; 16696: 	return S_OK;

	mov	DWORD PTR $T222849[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222849[ebp]
$L214456:

; 16697: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222863
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 304				; 00000130H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222863:
	DD	7
	DD	$L222862
$L222862:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L222853
	DD	-64					; ffffffc0H
	DD	4
	DD	$L222854
	DD	-76					; ffffffb4H
	DD	4
	DD	$L222855
	DD	-92					; ffffffa4H
	DD	4
	DD	$L222856
	DD	-104					; ffffff98H
	DD	4
	DD	$L222857
	DD	-164					; ffffff5cH
	DD	16					; 00000010H
	DD	$L222858
	DD	-224					; ffffff20H
	DD	50					; 00000032H
	DD	$L222859
$L222859:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222858:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L222857:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L222856:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222855:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$L222854:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	78					; 0000004eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
$L222853:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L222864:
	DD	$L214559
	DD	$L214554
	DD	$L214569
	DD	$L214564
_TEXT	ENDS
text$x	SEGMENT
$L222850:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222852
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::GetSignedInfoDigest
PUBLIC	?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z ; CSignature::GetX509CertificateChain
xdata$x	SEGMENT
$T222887 DD	0ffffffffH
	DD	FLAT:$L222874
$T222876 DD	019930520H
	DD	01H
	DD	FLAT:$T222887
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T222873 = -212						; size = 4
$T222872 = -208						; size = 4
$T222871 = -204						; size = 4
$T222870 = -200						; size = 4
$T222869 = -196						; size = 4
$T222868 = -192						; size = 4
_i$214731 = -188					; size = 4
_i$214724 = -184					; size = 4
_si$ = -176						; size = 12
_i$214699 = -160					; size = 4
_wCertID$214697 = -156					; size = 4
__lpa$ = -152						; size = 4
__lpw$ = -148						; size = 4
__acp$ = -144						; size = 4
__convert$ = -140					; size = 4
_pbData$ = -136						; size = 4
_cbData$ = -132						; size = 4
_buffer$ = -124						; size = 20
_iSize$ = -96						; size = 4
_mem$ = -84						; size = 4
_parent$ = -76						; size = 4
_rootNode$ = -72					; size = 4
_cur$ = -68						; size = 4
_root$ = -64						; size = 4
_doc$ = -60						; size = 4
_certificateListCount$ = -52				; size = 4
_certificateList$ = -44					; size = 4
_certificateFound$ = -40				; size = 4
_certData$ = -36					; size = 4
_base64CertId$ = -32					; size = 4
_tmpCertId$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_certID$ = 12						; size = 4
_certChainAsB64XmlStr$ = 16				; size = 4
?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::GetX509CertificateChain

; 16700: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 200				; 000000c8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 50					; 00000032H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 16701: 	CComBSTR tmpCertId;

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 16702: 	unsigned char *base64CertId=NULL, *certData=NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0
	mov	DWORD PTR _certData$[ebp], 0

; 16703: 	BOOL certificateFound = FALSE;

	mov	DWORD PTR _certificateFound$[ebp], 0

; 16704: 	unsigned char **certificateList=NULL;

	mov	DWORD PTR _certificateList$[ebp], 0

; 16705: 	UINT certificateListCount=0;

	mov	DWORD PTR _certificateListCount$[ebp], 0

; 16706: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 16707: 	xmlNodePtr root=NULL, cur=NULL, rootNode=NULL, parent=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 16708: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 16709: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 16710: 	char buffer[20];
; 16711: 	unsigned int cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 16712: 	unsigned char *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 16713: 
; 16714: 	EnterLog;
; 16715: 	tmpCertId = certID;

	mov	eax, DWORD PTR _certID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 16716: 
; 16717: 	*certChainAsB64XmlStr = A2WBSTR((LPCSTR) NULL);

	push	-1
	push	0
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _certChainAsB64XmlStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 16718: 
; 16719: 	if (tmpCertId.Length() == 0)

	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L214689

; 16720: 	{
; 16721: 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 16722: 		return S_FALSE;

	mov	DWORD PTR $T222868[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222868[ebp]
	jmp	$L214671
$L214689:

; 16723: 	}
; 16724: 
; 16725: USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 16726: 	if (CertSerialNumberFormat == CERT_SERIAL_PLAIN_HEX)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3324], 1
	jne	SHORT $L214696

; 16727: 	{
; 16728: 		unsigned char *wCertID = HeapW2A(certID);

	mov	edx, DWORD PTR _certID$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _wCertID$214697[ebp], eax

; 16729: 		base64CertId = PlainHexToBase64Bin(wCertID);

	mov	eax, DWORD PTR _wCertID$214697[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PlainHexToBase64Bin@CSignature@@QAEPAEPAE@Z ; CSignature::PlainHexToBase64Bin
	mov	DWORD PTR _base64CertId$[ebp], eax

; 16730: 		zFree(wCertID);

	mov	ecx, DWORD PTR _wCertID$214697[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16731: 	}
; 16732: 	else

	jmp	SHORT $L214698
$L214696:

; 16733: 		base64CertId = HeapW2A(certID);

	mov	edx, DWORD PTR _certID$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _base64CertId$[ebp], eax
$L214698:

; 16734: 
; 16735: 	for (int i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$214699[ebp], 0
	jmp	SHORT $L214700
$L214701:
	mov	eax, DWORD PTR _i$214699[ebp]
	add	eax, 1
	mov	DWORD PTR _i$214699[ebp], eax
$L214700:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$214699[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	SHORT $L214702

; 16736: 	{
; 16737: 		if (!(StrCmp((const char *)cV[i]->serialNumber, (const char *)base64CertId)))

	mov	esi, esp
	mov	eax, DWORD PTR _base64CertId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$214699[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L214705

; 16738: 		{
; 16739: 			certData = cV[i]->certificate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _i$214699[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+2048]
	mov	DWORD PTR _certData$[ebp], eax

; 16740: 			certificateFound = TRUE;

	mov	DWORD PTR _certificateFound$[ebp], 1

; 16741: 			break;

	jmp	SHORT $L214702
$L214705:

; 16742: 		}
; 16743: 	}

	jmp	SHORT $L214701
$L214702:

; 16744: 	if (base64CertId)

	cmp	DWORD PTR _base64CertId$[ebp], 0
	je	SHORT $L214706

; 16745: 	{
; 16746: 		zFree(base64CertId);

	mov	ecx, DWORD PTR _base64CertId$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16747: 		base64CertId = NULL;

	mov	DWORD PTR _base64CertId$[ebp], 0
$L214706:

; 16748: 	}
; 16749: 	if (certificateFound == FALSE)

	cmp	DWORD PTR _certificateFound$[ebp], 0
	jne	SHORT $L214707

; 16750: 	{
; 16751: 		setError(SigHandle, CERT_NOT_FOUND);

	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 16752: 		return S_FALSE;

	mov	DWORD PTR $T222869[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222869[ebp]
	jmp	$L214671
$L214707:

; 16753: 	}
; 16754: #ifdef NSS
; 16755: 	SECItem si;
; 16756: 	si.data = PfxPassword.pbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+900]
	mov	DWORD PTR _si$[ebp+4], edx

; 16757: 	si.len = PfxPassword.cbData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+904]
	mov	DWORD PTR _si$[ebp+8], ecx

; 16758: 	certificateList = crGetSignerCertChain(	certData,
; 16759: 										&si,
; 16760: 										&certificateListCount,
; 16761: 										SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	lea	ecx, DWORD PTR _certificateListCount$[ebp]
	push	ecx
	lea	edx, DWORD PTR _si$[ebp]
	push	edx
	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	call	_crGetSignerCertChain
	add	esp, 16					; 00000010H
	mov	DWORD PTR _certificateList$[ebp], eax

; 16762: #else
; 16763: 	certificateList = crGetSignerCertChain(	certData,
; 16764: 										(LPWSTR)PfxPassword.pbData,
; 16765: 										&certificateListCount,
; 16766: 										SigHandle);
; 16767: #endif
; 16768: 	if ((certificateList == NULL) || (certificateListCount == 0))

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L214712
	cmp	DWORD PTR _certificateListCount$[ebp], 0
	jne	SHORT $L214711
$L214712:

; 16769: 		return S_FALSE;

	mov	DWORD PTR $T222870[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222870[ebp]
	jmp	$L214671
$L214711:

; 16770: 
; 16771: 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG214716
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 16772: 	// document, namespace, element name, element content
; 16773: 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"CertificateChain",NULL);

	push	0
	push	OFFSET FLAT:$SG214718
	push	0
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 16774: 	sprintf((char *)buffer, "%d", certificateListCount);

	mov	edx, DWORD PTR _certificateListCount$[ebp]
	push	edx
	push	OFFSET FLAT:$SG214720
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 16775: 	xmlNewProp(cur, (const unsigned char *)"CertificateCount", (const unsigned char *)buffer);

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG214723
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 16776: 
; 16777: 	// add root element
; 16778: 	xmlDocSetRootElement(doc,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocSetRootElement
	add	esp, 8

; 16779: 	rootNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], edx

; 16780: 	for (UINT i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$214724[ebp], 0
	jmp	SHORT $L214725
$L214726:
	mov	eax, DWORD PTR _i$214724[ebp]
	add	eax, 1
	mov	DWORD PTR _i$214724[ebp], eax
$L214725:
	mov	ecx, DWORD PTR _i$214724[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L214727

; 16781: 	{
; 16782: 		cur = xmlNewNode(NULL,(const unsigned char *)"X509Certificate");

	push	OFFSET FLAT:$SG214729
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16783: 		xmlNodeSetContent(cur,(const unsigned char *)certificateList[i]);

	mov	edx, DWORD PTR _i$214724[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 16784: 		cur = xmlAddChild(rootNode, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 16785: 	}

	jmp	SHORT $L214726
$L214727:

; 16786: 	for (UINT i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$214731[ebp], 0
	jmp	SHORT $L214732
$L214733:
	mov	edx, DWORD PTR _i$214731[ebp]
	add	edx, 1
	mov	DWORD PTR _i$214731[ebp], edx
$L214732:
	mov	eax, DWORD PTR _i$214731[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L214734

; 16787: 		zFree(certificateList[i]);

	mov	ecx, DWORD PTR _i$214731[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
	jmp	SHORT $L214733
$L214734:

; 16788: 	zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16789: 	xmlDocDumpMemory(doc,&mem,(int *)&iSize);

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocDumpMemory
	add	esp, 12					; 0000000cH

; 16790: 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 16791: 
; 16792: 	cbData = base64encodeSize(iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 16793: 	if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax
	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L214737

; 16794: 	{
; 16795: 		xmlFree(mem);

	mov	esi, esp
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16796: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16797: 		return FALSE;

	mov	DWORD PTR $T222871[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222871[ebp]
	jmp	$L214671
$L214737:

; 16798: 	}
; 16799: 	if ((cbData  = base64encode(mem,iSize,(unsigned char*)pbData,cbData+1))==-1) 

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L214740

; 16800: 	{
; 16801: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16802: 		xmlFree(mem);

	mov	esi, esp
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16803: 		zFree(pbData);

	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16804: 		return FALSE;

	mov	DWORD PTR $T222872[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222872[ebp]
	jmp	SHORT $L214671
$L214740:

; 16805: 	}
; 16806: 	*(pbData+cbData)='\0';

	mov	ecx, DWORD PTR _pbData$[ebp]
	add	ecx, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [ecx], 0

; 16807: 	*certChainAsB64XmlStr = A2WBSTR((LPCSTR)pbData, cbData);

	mov	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _certChainAsB64XmlStr$[ebp]
	mov	DWORD PTR [ecx], eax

; 16808: 	zFree(pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16809: 	xmlFree(mem);

	mov	esi, esp
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16810: 	ExitLog;
; 16811: 	return S_OK;

	mov	DWORD PTR $T222873[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222873[ebp]
$L214671:

; 16812: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222886
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 212				; 000000d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222886:
	DD	6
	DD	$L222885
$L222885:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L222877
	DD	-52					; ffffffccH
	DD	4
	DD	$L222878
	DD	-84					; ffffffacH
	DD	4
	DD	$L222879
	DD	-96					; ffffffa0H
	DD	4
	DD	$L222880
	DD	-124					; ffffff84H
	DD	20					; 00000014H
	DD	$L222881
	DD	-176					; ffffff50H
	DD	12					; 0000000cH
	DD	$L222882
$L222882:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	0
$L222881:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L222880:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222879:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	0
$L222878:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222877:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222874:
	lea	ecx, DWORD PTR _tmpCertId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222876
	jmp	___CxxFrameHandler
text$x	ENDS
?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z ENDP ; CSignature::GetX509CertificateChain
EXTRN	_atoi:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_j$214782 = -32						; size = 4
_i$ = -28						; size = 4
_certList$ = -24					; size = 4
_tmpCharPtr$ = -20					; size = 4
_root$ = -16						; size = 4
_cur$ = -12						; size = 4
_doc$ = -8						; size = 4
_this$ = -4						; size = 4
_certificateCount$ = 8					; size = 4
?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z PROC NEAR	; CSignature::getSignerCertChain
; _this$ = ecx

; 16815: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 16816: 	xmlDocPtr doc;
; 16817: 	xmlNodePtr cur=NULL, root=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _root$[ebp], 0

; 16818: 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 16819: 	BYTE **certList=NULL;

	mov	DWORD PTR _certList$[ebp], 0

; 16820: 	UINT i=0;

	mov	DWORD PTR _i$[ebp], 0

; 16821: 
; 16822: 	*certificateCount = 0;

	mov	eax, DWORD PTR _certificateCount$[ebp]
	mov	DWORD PTR [eax], 0

; 16823: 
; 16824: 	if (signerCertChain == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3412], 0
	jne	SHORT $L214755

; 16825: 		return NULL;

	xor	eax, eax
	jmp	$L214748
$L214755:

; 16826: 
; 16827: 	if ((doc = xmlParseMemory((const char *)signerCertChain, signerCertChainSize)) == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3416]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3412]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax
	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L214757

; 16828: 		return NULL;

	xor	eax, eax
	jmp	$L214748
$L214757:

; 16829: 
; 16830: 	root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 16831: 	if ((tmpCharPtr = xmlGetProp(root, (const xmlChar *) "CertificateCount")) == NULL)

	push	OFFSET FLAT:$SG214760
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_xmlGetProp
	add	esp, 8
	mov	DWORD PTR _tmpCharPtr$[ebp], eax
	cmp	DWORD PTR _tmpCharPtr$[ebp], 0
	jne	SHORT $L214759

; 16832: 	{
; 16833: 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 16834: 		return NULL;

	xor	eax, eax
	jmp	$L214748
$L214759:

; 16835: 	}
; 16836: 	*certificateCount = (UINT)atoi((const char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _certificateCount$[ebp]
	mov	DWORD PTR [ecx], eax

; 16837: 	xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16838: 	certList = (BYTE **)zMalloc(sizeof(BYTE *) * (*certificateCount));

	mov	eax, DWORD PTR _certificateCount$[ebp]
	mov	ecx, DWORD PTR [eax]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certList$[ebp], eax

; 16839: 	memset(certList, 0, sizeof(BYTE *) * (*certificateCount));

	mov	edx, DWORD PTR _certificateCount$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _certList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 16840: 
; 16841: 	cur = root->xmlChildrenNode;

	mov	edx, DWORD PTR _root$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _cur$[ebp], eax

; 16842: 	for (i=0; i< *certificateCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L214766
$L214767:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L214766:
	mov	edx, DWORD PTR _certificateCount$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jae	$L214768

; 16843: 	{
; 16844: 		if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $L214771

; 16845: 			break;

	jmp	$L214768
$L214771:

; 16846: 		while (xmlStrcmp(cur->name, (const unsigned char *)"X509Certificate"))

	push	OFFSET FLAT:$SG214774
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	je	SHORT $L214772

; 16847: 		{
; 16848: 			cur = cur->next;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _cur$[ebp], ecx

; 16849: 			if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $L214775

; 16850: 				break;

	jmp	SHORT $L214772
$L214775:

; 16851: 		}

	jmp	SHORT $L214771
$L214772:

; 16852: 		if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $L214776

; 16853: 			break;

	jmp	SHORT $L214768
$L214776:

; 16854: 		tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 16855: 		certList[i] = (BYTE *)zMalloc(strlen((const char *)tmpCharPtr) + 1);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certList$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 16856: 		strcpy((char *)certList[i], (const char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 16857: 		xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16858: 		cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 16859: 	}

	jmp	$L214767
$L214768:

; 16860: 	xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 16861: 	if (i != *certificateCount) // Something was wrong

	mov	edx, DWORD PTR _certificateCount$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $L214781

; 16862: 	{
; 16863: 		for (UINT j=0; j<*certificateCount; j++)

	mov	DWORD PTR _j$214782[ebp], 0
	jmp	SHORT $L214783
$L214784:
	mov	ecx, DWORD PTR _j$214782[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$214782[ebp], ecx
$L214783:
	mov	edx, DWORD PTR _certificateCount$[ebp]
	mov	eax, DWORD PTR _j$214782[ebp]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $L214785

; 16864: 		{
; 16865: 			if (certList[j] != NULL)

	mov	ecx, DWORD PTR _j$214782[ebp]
	mov	edx, DWORD PTR _certList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L214786

; 16866: 				zFree(certList[j]);

	mov	eax, DWORD PTR _j$214782[ebp]
	mov	ecx, DWORD PTR _certList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4
$L214786:

; 16867: 		}

	jmp	SHORT $L214784
$L214785:

; 16868: 		zFree(certList);

	mov	eax, DWORD PTR _certList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 16869: 		certList = NULL;

	mov	DWORD PTR _certList$[ebp], 0

; 16870: 		setError(SigHandle, CERT_PARTIAL_CHAIN);

	push	80					; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8
$L214781:

; 16871: 	}
; 16872: 	return certList;

	mov	eax, DWORD PTR _certList$[ebp]
$L214748:

; 16873: }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z ENDP	; CSignature::getSignerCertChain
_TEXT	ENDS
PUBLIC	?put_SignerCertificateChain@CSignature@@UAGJPAG@Z ; CSignature::put_SignerCertificateChain
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_sizeM$ = -12						; size = 4
_newPtr$ = -8						; size = 4
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_SignerCertificateChain@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_SignerCertificateChain

; 16876: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 16877: 	unsigned char *ptr=NULL, *newPtr=NULL; 

	mov	DWORD PTR _ptr$[ebp], 0
	mov	DWORD PTR _newPtr$[ebp], 0

; 16878: 	unsigned int sizeM;
; 16879: 	if (signerCertChain != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	je	SHORT $L214794

; 16880: 	{
; 16881: 		zFree(signerCertChain);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3412]
	push	edx
	call	_rFree
	add	esp, 4

; 16882: 		signerCertChain = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+3412], 0

; 16883: 		signerCertChainSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+3416], 0
$L214794:

; 16884: 	}
; 16885: 	if ((newVal != NULL) && (SysStringByteLen(newVal) != 0))

	cmp	DWORD PTR _newVal$[ebp], 0
	je	$L214795
	mov	esi, esp
	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	$L214795

; 16886: 	{
; 16887: 		ptr = HeapW2A(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 16888: 		sizeM = strlen((const char *)ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16889: 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 16890: 		newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 16891: 		if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214798

; 16892: 		{
; 16893: 			zFree(ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 16894: 			zFree(newPtr);

	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16895: 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16896: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L214790
$L214798:

; 16897: 		}
; 16898: 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16899: 		signerCertChain = newPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newPtr$[ebp]
	mov	DWORD PTR [eax+3412], ecx

; 16900: 		signerCertChainSize = sizeM;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _sizeM$[ebp]
	mov	DWORD PTR [edx+3416], eax
$L214795:

; 16901: 	}
; 16902: 	return S_OK;

	xor	eax, eax
$L214790:

; 16903: }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_SignerCertificateChain@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_SignerCertificateChain
_TEXT	ENDS
PUBLIC	?get_SignatureImageId@CSignature@@UAGJPAPAG@Z	; CSignature::get_SignatureImageId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_SignatureImageId@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_SignatureImageId

; 16906: {

	push	ebp
	mov	ebp, esp

; 16907: 	*pVal = A2WBSTR((LPCSTR)SigImageGuid.c_str());

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 16908: 	return S_OK;

	xor	eax, eax

; 16909: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_SignatureImageId@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_SignatureImageId
_TEXT	ENDS
PUBLIC	?put_SignatureImageId@CSignature@@UAGJPAG@Z	; CSignature::put_SignatureImageId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_charGuid$ = -4						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_SignatureImageId@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_SignatureImageId

; 16912: {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 16913: 	char *charGuid=NULL;

	mov	DWORD PTR _charGuid$[ebp], 0

; 16914: 
; 16915: 	charGuid = (char *)HeapW2A(newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charGuid$[ebp], eax

; 16916: 	SigImageGuid = charGuid;

	mov	ecx, DWORD PTR _charGuid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1768				; 000006e8H
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 16917: 	zFree(charGuid);

	mov	edx, DWORD PTR _charGuid$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 16918: 	return S_OK;

	xor	eax, eax

; 16919: }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?put_SignatureImageId@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_SignatureImageId
_TEXT	ENDS
PUBLIC	?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z ; CSignature::SignSignedInfoDigest
EXTRN	_xsSignOnClient:NEAR
xdata$x	SEGMENT
$T222915 DD	0ffffffffH
	DD	FLAT:$L222896
	DD	00H
	DD	FLAT:$L222898
	DD	0ffffffffH
	DD	FLAT:$L222898
$T222900 DD	019930520H
	DD	03H
	DD	FLAT:$T222915
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv472 = -276						; size = 4
tv471 = -272						; size = 4
$T222895 = -268						; size = 16
$T222894 = -252						; size = 4
_i$214928 = -248					; size = 4
_si$ = -240						; size = 12
_b64HashSize$ = -224					; size = 4
_pfxFilePath$214868 = -216				; size = 4
_pfxX509Cert$214867 = -204				; size = 4
_i$214859 = -196					; size = 4
_freeSigningCert$ = -192				; size = 4
_certificateListCount$ = -184				; size = 4
_certificateList$ = -176				; size = 4
_result$ = -172						; size = 4
_buffer$ = -164						; size = 20
_cbData$ = -140						; size = 4
_pbData$ = -136						; size = 4
_b64Hash$ = -132					; size = 4
_b64SigVal$ = -128					; size = 4
_b64Pubkey$ = -124					; size = 4
_iSize$ = -116						; size = 4
_mem$ = -104						; size = 4
_parent$ = -96						; size = 4
_rootNode$ = -92					; size = 4
_cur$ = -88						; size = 4
_root$ = -84						; size = 4
_doc$ = -80						; size = 4
_certData$ = -76					; size = 4
_sigalgtype$ = -68					; size = 4
_dwKeyLen$ = -56					; size = 4
_pbPublicKey$ = -48					; size = 4
_dwSigLen$ = -40					; size = 4
_pbSignature$ = -32					; size = 4
_dwHashLen$ = -28					; size = 4
_pbHash$ = -24						; size = 4
_pcrBlob$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_b64CertData$ = 12					; size = 4
_b64SignedInfoDigest$ = 16				; size = 4
_b64SigValXml$ = 20					; size = 4
?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z PROC NEAR ; CSignature::SignSignedInfoDigest

; 16922: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 264				; 00000108H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-276]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 16923: 	PDS_DATA_BLOB pcrBlob=NULL;	// <SignedInfo> data

	mov	DWORD PTR _pcrBlob$[ebp], 0

; 16924: 	BYTE *pbHash;				// SHA1 hash
; 16925: 	DWORD dwHashLen=20;			// 

	mov	DWORD PTR _dwHashLen$[ebp], 20		; 00000014H

; 16926: 	PBYTE pbSignature=NULL;		// signature BLOB

	mov	DWORD PTR _pbSignature$[ebp], 0

; 16927: 	DWORD dwSigLen=0;			// signature BLOB

	mov	DWORD PTR _dwSigLen$[ebp], 0

; 16928: 	PBYTE pbPublicKey=NULL;		// (out) pub key BLOB

	mov	DWORD PTR _pbPublicKey$[ebp], 0

; 16929: 	DWORD dwKeyLen=0;			// (out) pub key BLOB

	mov	DWORD PTR _dwKeyLen$[ebp], 0

; 16930: 	DWORD sigalgtype=0;

	mov	DWORD PTR _sigalgtype$[ebp], 0

; 16931: 	unsigned char *certData=NULL;	// base64 encoded certData

	mov	DWORD PTR _certData$[ebp], 0

; 16932: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 16933: 	xmlNodePtr root=NULL, cur=NULL, rootNode=NULL, parent=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 16934: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 16935: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 16936: 	unsigned char *b64Pubkey=NULL, *b64SigVal=NULL, *b64Hash=NULL;

	mov	DWORD PTR _b64Pubkey$[ebp], 0
	mov	DWORD PTR _b64SigVal$[ebp], 0
	mov	DWORD PTR _b64Hash$[ebp], 0

; 16937: 	unsigned char *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 16938: 	unsigned int cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 16939: 	char buffer[20];
; 16940: 	HRESULT result = S_FALSE;

	mov	DWORD PTR _result$[ebp], 1

; 16941: 	unsigned char **certificateList=NULL;

	mov	DWORD PTR _certificateList$[ebp], 0

; 16942: 	UINT certificateListCount=0;

	mov	DWORD PTR _certificateListCount$[ebp], 0

; 16943: 	BOOL freeSigningCert=FALSE;

	mov	DWORD PTR _freeSigningCert$[ebp], 0

; 16944: 
; 16945: 	*b64SigValXml = NULL;

	mov	eax, DWORD PTR _b64SigValXml$[ebp]
	mov	DWORD PTR [eax], 0

; 16946: 
; 16947: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L214847

; 16948: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 16949: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214847:

; 16950: 	}
; 16951: 
; 16952: 	if (!LicObj.getSignAllowed()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L214849

; 16953: 		setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16954: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214849:

; 16955: 	}
; 16956: 
; 16957: 	if ((b64SignedInfoDigest == 0) ||
; 16958: 		(SysStringByteLen(b64SignedInfoDigest) == 0))

	cmp	DWORD PTR _b64SignedInfoDigest$[ebp], 0
	je	SHORT $L214852
	mov	esi, esp
	mov	edx, DWORD PTR _b64SignedInfoDigest$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L214851
$L214852:

; 16959: 	{
; 16960: 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 16961: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214851:

; 16962: 	}
; 16963: 
; 16964: 	if ((b64CertData == NULL) || 
; 16965: 		(SysStringByteLen(b64CertData) == 0))

	cmp	DWORD PTR _b64CertData$[ebp], 0
	je	SHORT $L214855
	mov	esi, esp
	mov	edx, DWORD PTR _b64CertData$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L214854
$L214855:

; 16966: 	{
; 16967: 		if ((CurrentCertificate == NOT_INITIALIZED)	&& (CertificateCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+120], -1
	jne	$L214856
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+124], 0
	je	$L214856

; 16968: 		{
; 16969: #ifdef WIN32
; 16970: 			certData = (unsigned char *)dlg->selectCertificate();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+1808]
	call	?selectCertificate@CShowSelectCert@@QAEPADXZ ; CShowSelectCert::selectCertificate
	mov	DWORD PTR _certData$[ebp], eax

; 16971: #endif
; 16972: 			if (certData != NULL)

	cmp	DWORD PTR _certData$[ebp], 0
	je	$L214858

; 16973: 			{
; 16974: 				for (int i=0;i<CertificateCount;i++)

	mov	DWORD PTR _i$214859[ebp], 0
	jmp	SHORT $L214860
$L214861:
	mov	eax, DWORD PTR _i$214859[ebp]
	add	eax, 1
	mov	DWORD PTR _i$214859[ebp], eax
$L214860:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$214859[ebp]
	cmp	edx, DWORD PTR [ecx+124]
	jge	SHORT $L214862

; 16975: 				{
; 16976: 					if (!(StrCmp((const char *)cV[i]->certificate, (const char *)certData)))

	mov	esi, esp
	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _i$214859[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	call	DWORD PTR __imp__lstrcmpA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L214865

; 16977: 					{
; 16978: 						CurrentCertificate = i;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$214859[ebp]
	mov	DWORD PTR [eax+120], ecx

; 16979: 						break;

	jmp	SHORT $L214862
$L214865:

; 16980: 					}
; 16981: 				}

	jmp	SHORT $L214861
$L214862:

; 16982: #ifdef WIN32
; 16983: 				if ((UsingNetscape) && (nsCertStoreObj != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3388], 0
	je	$L214858
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3380], 0
	je	$L214858

; 16984: 				{
; 16985: 					BSTR pfxX509Cert;
; 16986: 					_bstr_t pfxFilePath = nsCertStoreObj->ExportNetscapeCert(_bstr_t(cV[CurrentCertificate]->serialNumber));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	cmp	DWORD PTR [ecx+edx*4], 0
	setne	dl
	push	edx
	lea	ecx, DWORD PTR $T222895[ebp]
	call	??0_variant_t@@QAE@_N@Z			; _variant_t::_variant_t
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T222894[ebp], esp
	lea	eax, DWORD PTR $T222895[ebp]
	push	eax
	call	??0_bstr_t@@QAE@ABV_variant_t@@@Z	; _bstr_t::_bstr_t
	mov	DWORD PTR tv471[ebp], eax
	lea	ecx, DWORD PTR _pfxFilePath$214868[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+3380]
	call	?ExportNetscapeCert@ICertStore@NetscapeCert@@QAE?AV_bstr_t@@V3@@Z ; NetscapeCert::ICertStore::ExportNetscapeCert
	mov	DWORD PTR tv472[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T222895[ebp]
	call	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t

; 16987: 					SetActivePFXFileCert(pfxFilePath, nsStorePassword, &pfxX509Cert);

	mov	esi, esp
	lea	eax, DWORD PTR _pfxX509Cert$214867[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3384]
	push	edx
	lea	ecx, DWORD PTR _pfxFilePath$214868[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+304]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16988: 					certData = B64PfxDataPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+920]
	mov	DWORD PTR _certData$[ebp], ecx

; 16989: 					DeleteFile((LPCTSTR)(char *)pfxFilePath);

	lea	ecx, DWORD PTR _pfxFilePath$214868[ebp]
	call	??B_bstr_t@@QBEPADXZ			; _bstr_t::operator char *
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__DeleteFileA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 16990: 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pfxFilePath$214868[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
$L214858:

; 16991: #endif
; 16992: 			}
; 16993: 		}
; 16994: 		else

	jmp	SHORT $L214875
$L214856:

; 16995: 			if (CurrentCertificate == USE_PFX_CERT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -2			; fffffffeH
	jne	SHORT $L214876

; 16996: 				certData = B64PfxDataPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+920]
	mov	DWORD PTR _certData$[ebp], ecx

; 16997: 			else

	jmp	SHORT $L214875
$L214876:

; 16998: 				if (CurrentCertificate == USE_BASE64_CERT)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], -3			; fffffffdH
	jne	SHORT $L214878

; 16999: 				{
; 17000: 					freeSigningCert = TRUE;

	mov	DWORD PTR _freeSigningCert$[ebp], 1

; 17001: 					certData = (unsigned char *)HeapW2A(SignerCertificate.m_str);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+396]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _certData$[ebp], eax

; 17002: 				}
; 17003: 				else

	jmp	SHORT $L214875
$L214878:

; 17004: 					if ((CurrentCertificate >= 0) && (cV != NULL) && (cV[CurrentCertificate] != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+120], 0
	jl	SHORT $L214875
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+104], 0
	je	SHORT $L214875
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+120]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L214875

; 17005: 						certData = cV[CurrentCertificate]->certificate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+2048]
	mov	DWORD PTR _certData$[ebp], ecx
$L214875:

; 17006: 	}
; 17007: 	else

	jmp	SHORT $L214882
$L214854:

; 17008: 	{
; 17009: 		certData	= HeapW2A(b64CertData);

	mov	edx, DWORD PTR _b64CertData$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _certData$[ebp], eax

; 17010: 		if (certData != NULL)

	cmp	DWORD PTR _certData$[ebp], 0
	je	SHORT $L214882

; 17011: 			freeSigningCert = TRUE;

	mov	DWORD PTR _freeSigningCert$[ebp], 1
$L214882:

; 17012: 	}
; 17013: 
; 17014: 
; 17015: 	if (certData == NULL)

	cmp	DWORD PTR _certData$[ebp], 0
	jne	SHORT $L214884

; 17016: 	{
; 17017: 		setError(SigHandle, NO_CERTIFICATE);

	push	13					; 0000000dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17018: 		return FALSE;

	xor	eax, eax
	jmp	$L214819
$L214884:

; 17019: 	}
; 17020: 
; 17021: 	b64Hash		= HeapW2A(b64SignedInfoDigest);

	mov	edx, DWORD PTR _b64SignedInfoDigest$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _b64Hash$[ebp], eax

; 17022: 
; 17023: 	// Base64 decode b64Hash
; 17024: 	unsigned int b64HashSize = strlen((const char *)b64Hash);

	mov	eax, DWORD PTR _b64Hash$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _b64HashSize$[ebp], eax

; 17025: 	cbData = base64decodeSize(b64HashSize);

	mov	ecx, DWORD PTR _b64HashSize$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 17026: 	pbHash = (unsigned char *)zMalloc(cbData+1);

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbHash$[ebp], eax

; 17027: 	if ((cbData = base64decode(b64Hash, pbHash, cbData+1)) == -1)

	mov	eax, DWORD PTR _cbData$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pbHash$[ebp]
	push	ecx
	mov	edx, DWORD PTR _b64Hash$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L214888

; 17028: 	{
; 17029: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17030: 		if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L214889

; 17031: 			zFree(certData);

	mov	edx, DWORD PTR _certData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214889:

; 17032: 		zFree(b64Hash);

	mov	eax, DWORD PTR _b64Hash$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17033: 		zFree(pbHash);

	mov	ecx, DWORD PTR _pbHash$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17034: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214888:

; 17035: 	}
; 17036: 	zFree(b64Hash);

	mov	edx, DWORD PTR _b64Hash$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17037: 
; 17038: #ifdef NSS
; 17039: 	SECItem si;
; 17040: 	si.data = PfxPassword.pbData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	mov	DWORD PTR _si$[ebp+4], ecx

; 17041: 	si.len = PfxPassword.cbData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+904]
	mov	DWORD PTR _si$[ebp+8], eax

; 17042: 	certificateList = crGetSignerCertChain(	certData,
; 17043: 										&si,
; 17044: 										&certificateListCount,
; 17045: 										SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _si$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certData$[ebp]
	push	edx
	call	_crGetSignerCertChain
	add	esp, 16					; 00000010H
	mov	DWORD PTR _certificateList$[ebp], eax

; 17046: #else
; 17047: 	certificateList = crGetSignerCertChain(	certData,
; 17048: 										(LPWSTR)PfxPassword.pbData,
; 17049: 										&certificateListCount,
; 17050: 										SigHandle);
; 17051: #endif
; 17052: 	if ((certificateList == NULL) || (certificateListCount == 0))

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L214893
	cmp	DWORD PTR _certificateListCount$[ebp], 0
	jne	SHORT $L214892
$L214893:

; 17053: 	{
; 17054: 		setError(SigHandle, CERT_CHAIN_ERROR);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17055: 		if (freeSigningCert == TRUE)

	cmp	DWORD PTR _freeSigningCert$[ebp], 1
	jne	SHORT $L214894

; 17056: 			zFree(certData);

	mov	edx, DWORD PTR _certData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L214894:

; 17057: 		zFree(pbHash);

	mov	eax, DWORD PTR _pbHash$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17058: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214892:

; 17059: 	}
; 17060: 
; 17061:     /*
; 17062: 	 * Two steps Sign-On-Client. First call must return FALSE.
; 17063: 	 */
; 17064: 	xsSignOnClient(
; 17065: 		(const char *)certData,		// certificate to sign
; 17066: 		pbHash,				// <SignedInfo> hash
; 17067: 		pbSignature,		// (out) signature BLOB
; 17068: 		&dwSigLen,			// (out) signature BLOB
; 17069: 		pbPublicKey,		// (out) pub key BLOB
; 17070: 		&dwKeyLen,			// (out) pub key BLOB
; 17071: 		&PfxPassword,		// if signingCert is NULL, it is HMAC key, if certData is Pfx it is the password
; 17072: 		&sigalgtype,
; 17073: 		SigHandle
; 17074: 		);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	lea	eax, DWORD PTR _sigalgtype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 900				; 00000384H
	push	ecx
	lea	edx, DWORD PTR _dwKeyLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dwSigLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbHash$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_xsSignOnClient
	add	esp, 36					; 00000024H

; 17075: 	cleanupError(SigHandle);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_cleanupError
	add	esp, 4

; 17076: 	// allocate memory for signature and key
; 17077: 	pbSignature = (PBYTE)zMalloc(dwSigLen);

	mov	ecx, DWORD PTR _dwSigLen$[ebp]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbSignature$[ebp], eax

; 17078: 	pbPublicKey = (PBYTE)zMalloc(dwKeyLen);

	mov	edx, DWORD PTR _dwKeyLen$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbPublicKey$[ebp], eax

; 17079: 
; 17080: 	if (!xsSignOnClient(
; 17081: 		(const char *)certData,		// certificate to sign
; 17082: 		pbHash,				// <SignedInfo> hash
; 17083: 		pbSignature,		// (out) signature BLOB
; 17084: 		&dwSigLen,			// (out) signature BLOB
; 17085: 		pbPublicKey,		// (out) pub key BLOB
; 17086: 		&dwKeyLen,			// (out) pub key BLOB
; 17087: 		&PfxPassword,		// if signingCert is NULL, it is HMAC key, if certData is Pfx it is the password
; 17088: 		&sigalgtype,
; 17089: 		SigHandle
; 17090: 		))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	lea	edx, DWORD PTR _sigalgtype$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 900				; 00000384H
	push	eax
	lea	ecx, DWORD PTR _dwKeyLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	lea	eax, DWORD PTR _dwSigLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbHash$[ebp]
	push	edx
	mov	eax, DWORD PTR _certData$[ebp]
	push	eax
	call	_xsSignOnClient
	add	esp, 36					; 00000024H
	test	eax, eax
	jne	SHORT $L214900

; 17091: 	{
; 17092: 		zFree(certData);

	mov	ecx, DWORD PTR _certData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17093: 		zFree(pbHash);

	mov	edx, DWORD PTR _pbHash$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17094: 		zFree(pbSignature);

	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17095: 		zFree(pbPublicKey);

	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17096: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214900:

; 17097: 	}
; 17098: 
; 17099: 	zFree(pbHash);

	mov	edx, DWORD PTR _pbHash$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17100: 
; 17101: 	// Lets base64 encode the signature value and public key values
; 17102: 	cbData = base64encodeSize(dwSigLen);

	mov	eax, DWORD PTR _dwSigLen$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 17103: 	b64SigVal = (unsigned char *)zMalloc(cbData+1);

	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _b64SigVal$[ebp], eax

; 17104: 	if ((cbData = base64encode(pbSignature, dwSigLen, b64SigVal, cbData+1)) == -1)

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _b64SigVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSigLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L214903

; 17105: 	{
; 17106: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17107: 		zFree(pbSignature);

	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17108: 		zFree(pbPublicKey);

	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17109: 		zFree(b64SigVal);

	mov	ecx, DWORD PTR _b64SigVal$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17110: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214903:

; 17111: 	}
; 17112: 	*(b64SigVal + cbData) = '\0';

	mov	edx, DWORD PTR _b64SigVal$[ebp]
	add	edx, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [edx], 0

; 17113: 	zFree(pbSignature);

	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17114: 
; 17115: 	cbData = base64encodeSize(dwKeyLen);

	mov	ecx, DWORD PTR _dwKeyLen$[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 17116: 	b64Pubkey = (unsigned char *)zMalloc(cbData+1);

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _b64Pubkey$[ebp], eax

; 17117: 	if ((cbData = base64encode(pbPublicKey, dwKeyLen, b64Pubkey, cbData+1)) == -1)

	mov	eax, DWORD PTR _cbData$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _b64Pubkey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwKeyLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L214906

; 17118: 	{
; 17119: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17120: 		zFree(pbSignature);

	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17121: 		zFree(pbPublicKey);

	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17122: 		zFree(b64Pubkey);

	mov	edx, DWORD PTR _b64Pubkey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17123: 		zFree(b64SigVal);

	mov	eax, DWORD PTR _b64SigVal$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17124: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214819
$L214906:

; 17125: 	}
; 17126: 	*(b64Pubkey + cbData) = '\0';

	mov	ecx, DWORD PTR _b64Pubkey$[ebp]
	add	ecx, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [ecx], 0

; 17127: 	zFree(pbPublicKey);

	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17128: 
; 17129: 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG214909
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 17130: 	// document, namespace, element name, element content
; 17131: 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"SignedInfoSignature",NULL);

	push	0
	push	OFFSET FLAT:$SG214911
	push	0
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 17132: 
; 17133: 	// add root element
; 17134: 	xmlDocSetRootElement(doc,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocSetRootElement
	add	esp, 8

; 17135: 	rootNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], eax

; 17136: 	cur = xmlNewNode(NULL,(const unsigned char *)"SignatureValue");

	push	OFFSET FLAT:$SG214913
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17137: 	xmlNodeSetContent(cur,(const unsigned char *)b64SigVal);

	mov	ecx, DWORD PTR _b64SigVal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNodeSetContent
	add	esp, 8

; 17138: 	cur = xmlAddChild(rootNode, cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17139: 
; 17140: 	cur = xmlNewNode(NULL,(const unsigned char *)"PublicKeyValue");

	push	OFFSET FLAT:$SG214916
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17141: 	xmlNodeSetContent(cur,(const unsigned char *)b64Pubkey);

	mov	edx, DWORD PTR _b64Pubkey$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 17142: 	cur = xmlAddChild(rootNode, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17143: 
; 17144: 	cur = xmlNewNode(NULL,(const unsigned char *)"AlgorithmType");

	push	OFFSET FLAT:$SG214919
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17145: 	sprintf((char *)buffer, "%d", sigalgtype);

	mov	eax, DWORD PTR _sigalgtype$[ebp]
	push	eax
	push	OFFSET FLAT:$SG214921
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 17146: 	xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 17147: 	cur = xmlAddChild(rootNode, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17148: 
; 17149: 	cur = xmlNewNode(NULL,(const unsigned char *)"CertificateChainLength");

	push	OFFSET FLAT:$SG214924
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17150: 	sprintf((char *)buffer, "%d", certificateListCount);

	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	push	OFFSET FLAT:$SG214926
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 17151: 	xmlNodeSetContent(cur,(const unsigned char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 17152: 	cur = xmlAddChild(rootNode, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17153: 
; 17154: 	for (UINT i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$214928[ebp], 0
	jmp	SHORT $L214929
$L214930:
	mov	eax, DWORD PTR _i$214928[ebp]
	add	eax, 1
	mov	DWORD PTR _i$214928[ebp], eax
$L214929:
	mov	ecx, DWORD PTR _i$214928[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L214931

; 17155: 	{
; 17156: 		if (certificateList[i] != NULL)

	mov	edx, DWORD PTR _i$214928[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L214932

; 17157: 		{
; 17158: 			cur = xmlNewNode(NULL,(const unsigned char *)"X509Certificate");

	push	OFFSET FLAT:$SG214934
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17159: 			xmlNodeSetContent(cur,(const unsigned char *)certificateList[i]);

	mov	ecx, DWORD PTR _i$214928[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNodeSetContent
	add	esp, 8

; 17160: 			cur = xmlAddChild(rootNode, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _rootNode$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17161: 			zFree(certificateList[i]);

	mov	ecx, DWORD PTR _i$214928[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_rFree
	add	esp, 4
$L214932:

; 17162: 		}
; 17163: 	}

	jmp	$L214930
$L214931:

; 17164: 	zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17165: 
; 17166: 	xmlDocDumpMemory(doc,&mem,(int *)&iSize);

	lea	edx, DWORD PTR _iSize$[ebp]
	push	edx
	lea	eax, DWORD PTR _mem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocDumpMemory
	add	esp, 12					; 0000000cH

; 17167: 	xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 17168: 
; 17169: 	zFree(b64Pubkey);

	mov	eax, DWORD PTR _b64Pubkey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17170: 	zFree(b64SigVal);

	mov	ecx, DWORD PTR _b64SigVal$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17171: 	zFree(certData);

	mov	edx, DWORD PTR _certData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17172: 
; 17173: 	cbData = base64encodeSize(iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 17174: 	if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax
	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L214938

; 17175: 	{
; 17176: 		xmlFree(mem);

	mov	esi, esp
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17177: 		setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17178: 		return FALSE;

	xor	eax, eax
	jmp	$L214819
$L214938:

; 17179: 	}
; 17180: 	if ((cbData  = base64encode(mem,iSize,(unsigned char*)pbData,cbData+1))==-1) 

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L214940

; 17181: 	{
; 17182: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17183: 		xmlFree(mem);

	mov	esi, esp
	mov	edx, DWORD PTR _mem$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17184: 		zFree(pbData);

	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17185: 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L214819
$L214940:

; 17186: 	}
; 17187: 	*(pbData+cbData)='\0';

	mov	ecx, DWORD PTR _pbData$[ebp]
	add	ecx, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [ecx], 0

; 17188: 	*b64SigValXml = A2WBSTR((LPCSTR)pbData, cbData);

	mov	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _b64SigValXml$[ebp]
	mov	DWORD PTR [ecx], eax

; 17189: 	zFree(pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17190: 	xmlFree(mem);

	mov	esi, esp
	mov	eax, DWORD PTR _mem$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17191: 
; 17192: 	return S_OK;

	xor	eax, eax
$L214819:

; 17193: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222914
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 276				; 00000114H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L222914:
	DD	10					; 0000000aH
	DD	$L222913
$L222913:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L222901
	DD	-56					; ffffffc8H
	DD	4
	DD	$L222902
	DD	-68					; ffffffbcH
	DD	4
	DD	$L222903
	DD	-104					; ffffff98H
	DD	4
	DD	$L222904
	DD	-116					; ffffff8cH
	DD	4
	DD	$L222905
	DD	-164					; ffffff5cH
	DD	20					; 00000014H
	DD	$L222906
	DD	-184					; ffffff48H
	DD	4
	DD	$L222907
	DD	-204					; ffffff34H
	DD	4
	DD	$L222908
	DD	-216					; ffffff28H
	DD	4
	DD	$L222909
	DD	-240					; ffffff10H
	DD	12					; 0000000cH
	DD	$L222910
$L222910:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	0
$L222909:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L222908:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L222907:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222906:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L222905:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222904:
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	0
$L222903:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	103					; 00000067H
	DB	116					; 00000074H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	0
$L222902:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L222901:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222896:
	lea	ecx, DWORD PTR $T222895[ebp]
	jmp	??1_variant_t@@QAE@XZ			; _variant_t::~_variant_t
$L222898:
	lea	ecx, DWORD PTR _pfxFilePath$214868[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z:
	mov	eax, OFFSET FLAT:$T222900
	jmp	___CxxFrameHandler
text$x	ENDS
?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z ENDP	; CSignature::SignSignedInfoDigest
PUBLIC	?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z	; CSignature::ApplySignatureValue
EXTRN	_xsAcceptSignature:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_pbData$215138 = -228					; size = 4
_cbData$215137 = -224					; size = 4
_srcSize$215136 = -220					; size = 4
_xsignature$ = -216					; size = 4
_i$215124 = -212					; size = 4
_i$215115 = -208					; size = 4
_j$215106 = -204					; size = 4
_crlData$215102 = -200					; size = 4
_j$215095 = -196					; size = 4
_crlData$215091 = -192					; size = 4
_s$215076 = -184					; size = 12
_tsSysTime$215069 = -164				; size = 16
_i$215062 = -144					; size = 4
_i$215052 = -140					; size = 4
_i$215047 = -136					; size = 4
_j$215041 = -132					; size = 4
_j$215033 = -128					; size = 4
_j$215028 = -124					; size = 4
_i$215021 = -120					; size = 4
_curX509Group$ = -116					; size = 4
_curX509Data$ = -112					; size = 4
_ki$ = -108						; size = 4
_result$ = -104						; size = 4
_oldCertificateListCount$ = -96				; size = 4
_certificateListCount$ = -88				; size = 4
_certListIndex$ = -84					; size = 4
_pbData$ = -80						; size = 4
_cbData$ = -76						; size = 4
_sigalgtype$ = -72					; size = 4
_dwKeyLen$ = -68					; size = 4
_pbPublicKey$ = -64					; size = 4
_dwSigLen$ = -60					; size = 4
_pbSignature$ = -56					; size = 4
_iSize$ = -48						; size = 4
_sizeM$ = -40						; size = 4
_newPtr$ = -36						; size = 4
_ptr$ = -32						; size = 4
_i$ = -28						; size = 4
_oldCertificateList$ = -24				; size = 4
_certificateList$ = -20					; size = 4
_tmpCharPtr$ = -16					; size = 4
_root$ = -12						; size = 4
_cur$ = -8						; size = 4
_doc$ = -4						; size = 4
_this$ = 8						; size = 4
_b64SigValXml$ = 12					; size = 4
_signedXML$ = 16					; size = 4
?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z PROC NEAR ; CSignature::ApplySignatureValue

; 17196: {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 17197: 	xmlDocPtr doc;
; 17198: 	xmlNodePtr cur=NULL, root=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _root$[ebp], 0

; 17199: 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 17200: 	BYTE **certificateList=NULL, **oldCertificateList=NULL;

	mov	DWORD PTR _certificateList$[ebp], 0
	mov	DWORD PTR _oldCertificateList$[ebp], 0

; 17201: 	UINT i=0;

	mov	DWORD PTR _i$[ebp], 0

; 17202: 	unsigned char *ptr=NULL, *newPtr=NULL; 

	mov	DWORD PTR _ptr$[ebp], 0
	mov	DWORD PTR _newPtr$[ebp], 0

; 17203: 	unsigned int sizeM;
; 17204: 	int iSize;
; 17205: 	PBYTE pbSignature=NULL;		// signature BLOB

	mov	DWORD PTR _pbSignature$[ebp], 0

; 17206: 	DWORD dwSigLen=0;			// signature BLOB

	mov	DWORD PTR _dwSigLen$[ebp], 0

; 17207: 	PBYTE pbPublicKey=NULL;		// (out) pub key BLOB

	mov	DWORD PTR _pbPublicKey$[ebp], 0

; 17208: 	DWORD dwKeyLen=0;			// (out) pub key BLOB

	mov	DWORD PTR _dwKeyLen$[ebp], 0

; 17209: 	DWORD sigalgtype=0;

	mov	DWORD PTR _sigalgtype$[ebp], 0

; 17210: //	unsigned char *certData=NULL;	// base64 encoded certData
; 17211: 	unsigned int cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 17212: 	unsigned char *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 17213: 	int certListIndex=0, certificateListCount=0, oldCertificateListCount=0;

	mov	DWORD PTR _certListIndex$[ebp], 0
	mov	DWORD PTR _certificateListCount$[ebp], 0
	mov	DWORD PTR _oldCertificateListCount$[ebp], 0

; 17214: 	BOOL result=0;

	mov	DWORD PTR _result$[ebp], 0

; 17215: 	keyinfo *ki = NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 17216: 	x509data *curX509Data = NULL;

	mov	DWORD PTR _curX509Data$[ebp], 0

; 17217: 	x509group *curX509Group = NULL;

	mov	DWORD PTR _curX509Group$[ebp], 0

; 17218: 	*signedXML = NULL;

	mov	eax, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [eax], 0

; 17219: 
; 17220: 
; 17221: 	if ((b64SigValXml == NULL) || 
; 17222: 		(SysStringByteLen(b64SigValXml) == 0))

	cmp	DWORD PTR _b64SigValXml$[ebp], 0
	je	SHORT $L214974
	mov	esi, esp
	mov	ecx, DWORD PTR _b64SigValXml$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L214973
$L214974:

; 17223: 	{
; 17224: 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 17225: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L214973:

; 17226: 	}
; 17227: 
; 17228: 	// Base64 decode b64SigValXml
; 17229: 	ptr = HeapW2A(b64SigValXml);

	mov	ecx, DWORD PTR _b64SigValXml$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 17230: 	sizeM = strlen((const char *)ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17231: 	sizeM = base64decodeSize(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17232: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 17233: 	if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L214978

; 17234: 	{
; 17235: 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17236: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17237: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17238: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L214978:

; 17239: 	}
; 17240: 	zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17241: 
; 17242: 	if ((doc = xmlParseMemory((const char *)newPtr, sizeM)) == NULL)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax
	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L214981

; 17243: 	{
; 17244: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17245: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L214981:

; 17246: 	}
; 17247: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17248: 
; 17249: 	root = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 17250: 	cur = root->xmlChildrenNode;

	mov	eax, DWORD PTR _root$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx

; 17251: 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $L214986

; 17252: 	{
; 17253: 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 17254: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L214986:

; 17255: 	}
; 17256: 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$L214987

; 17257: 	{
; 17258: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"SignatureValue"))

	push	OFFSET FLAT:$SG214990
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L214989

; 17259: 		{
; 17260: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17261: 			sizeM = strlen((const char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17262: 			sizeM  = base64decodeSize(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17263: 			pbSignature = (PBYTE)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbSignature$[ebp], eax

; 17264: 			if ((dwSigLen = base64decode(tmpCharPtr, pbSignature, sizeM+1)) == -1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwSigLen$[ebp], eax
	cmp	DWORD PTR _dwSigLen$[ebp], -1
	jne	SHORT $L214993

; 17265: 			{
; 17266: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 17267: 				zFree(pbSignature);

	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17268: 				xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17269: 				return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L214993:

; 17270: 			}
; 17271: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L214989:

; 17272: 		}
; 17273: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"PublicKeyValue"))

	push	OFFSET FLAT:$SG214997
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L214996

; 17274: 		{
; 17275: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17276: 			sizeM = strlen((const char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17277: 			sizeM  = base64decodeSize(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17278: 			pbPublicKey = (PBYTE)zMalloc(sizeM+1);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbPublicKey$[ebp], eax

; 17279: 			if ((dwKeyLen = base64decode(tmpCharPtr, pbPublicKey, sizeM+1)) == -1)

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwKeyLen$[ebp], eax
	cmp	DWORD PTR _dwKeyLen$[ebp], -1
	jne	SHORT $L215000

; 17280: 			{
; 17281: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17282: 				zFree(pbPublicKey);

	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17283: 				xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17284: 				return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215000:

; 17285: 			}
; 17286: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L214996:

; 17287: 		}
; 17288: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"AlgorithmType"))

	push	OFFSET FLAT:$SG215004
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215003

; 17289: 		{
; 17290: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17291: 			sigalgtype = (DWORD)atoi((const char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _sigalgtype$[ebp], eax

; 17292: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215003:

; 17293: 		}
; 17294: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"CertificateChainLength"))

	push	OFFSET FLAT:$SG215009
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215008

; 17295: 		{
; 17296: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17297: 			certificateListCount = (DWORD)atoi((const char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _certificateListCount$[ebp], eax

; 17298: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17299: 			certificateList = (BYTE **)zMalloc(sizeof(BYTE *) * certificateListCount);

	mov	ecx, DWORD PTR _certificateListCount$[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certificateList$[ebp], eax

; 17300: 			memset(certificateList, 0, certificateListCount * sizeof(BYTE *));

	mov	edx, DWORD PTR _certificateListCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 17301: 			certListIndex = 0;

	mov	DWORD PTR _certListIndex$[ebp], 0
$L215008:

; 17302: 		}
; 17303: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"X509Certificate"))

	push	OFFSET FLAT:$SG215017
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215016

; 17304: 		{
; 17305: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17306: 			certificateList[certListIndex++] = tmpCharPtr;

	mov	eax, DWORD PTR _certListIndex$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _certListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _certListIndex$[ebp], eax
$L215016:

; 17307: 		}
; 17308: 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 17309: 	}

	jmp	$L214986
$L214987:

; 17310: 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 17311: 	oldCertificateList = getSignerCertChain((UINT *)&oldCertificateListCount);

	lea	ecx, DWORD PTR _oldCertificateListCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z ; CSignature::getSignerCertChain
	mov	DWORD PTR _oldCertificateList$[ebp], eax

; 17312: 	if ((oldCertificateList != NULL) && (oldCertificateListCount != 0))

	cmp	DWORD PTR _oldCertificateList$[ebp], 0
	je	$L215019
	cmp	DWORD PTR _oldCertificateListCount$[ebp], 0
	je	$L215019

; 17313: 	{ // Make sure that the certificates used during signing are the same as the ones provided during digest calculation
; 17314: 		if  (oldCertificateListCount == certificateListCount)

	mov	edx, DWORD PTR _oldCertificateListCount$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jne	$L215020

; 17315: 		{
; 17316: 			for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215021[ebp], 0
	jmp	SHORT $L215022
$L215023:
	mov	eax, DWORD PTR _i$215021[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215021[ebp], eax
$L215022:
	mov	ecx, DWORD PTR _i$215021[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	$L215024

; 17317: 			{
; 17318: 				if (strcmp((const char *)oldCertificateList[i], (const char *)certificateList[i]))

	mov	edx, DWORD PTR _i$215021[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _i$215021[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L215027

; 17319: 				{// The chain provided during digest calculation != chain captured during signing
; 17320: 					for (int j=0; j<certificateListCount; j++)

	mov	DWORD PTR _j$215028[ebp], 0
	jmp	SHORT $L215029
$L215030:
	mov	edx, DWORD PTR _j$215028[ebp]
	add	edx, 1
	mov	DWORD PTR _j$215028[ebp], edx
$L215029:
	mov	eax, DWORD PTR _j$215028[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215031

; 17321: 						if (certificateList[j]) xmlFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$215028[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L215032
	mov	esi, esp
	mov	eax, DWORD PTR _j$215028[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215032:

; 17322: 					zFree(certificateList);

	jmp	SHORT $L215030
$L215031:
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17323: 					for (int j=0; j<oldCertificateListCount; j++)

	mov	DWORD PTR _j$215033[ebp], 0
	jmp	SHORT $L215034
$L215035:
	mov	ecx, DWORD PTR _j$215033[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215033[ebp], ecx
$L215034:
	mov	edx, DWORD PTR _j$215033[ebp]
	cmp	edx, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215036

; 17324: 						if (oldCertificateList[j]) xmlFree(oldCertificateList[j]);

	mov	eax, DWORD PTR _j$215033[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L215037
	mov	esi, esp
	mov	edx, DWORD PTR _j$215033[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215037:

; 17325: 					zFree(oldCertificateList);

	jmp	SHORT $L215035
$L215036:
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17326: 					setError(SigHandle, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17327: 					if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215038
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215038:

; 17328: 					if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215039
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215039:

; 17329: 					return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215027:

; 17330: 				}
; 17331: 			}

	jmp	$L215023
$L215024:

; 17332: 			// The chain is identical to the one provided during digest calculation so there is no need to process it again
; 17333: 			for (int j=0; j<oldCertificateListCount; j++)

	mov	DWORD PTR _j$215041[ebp], 0
	jmp	SHORT $L215042
$L215043:
	mov	ecx, DWORD PTR _j$215041[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215041[ebp], ecx
$L215042:
	mov	edx, DWORD PTR _j$215041[ebp]
	cmp	edx, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215044

; 17334: 				if (oldCertificateList[j]) xmlFree(oldCertificateList[j]);

	mov	eax, DWORD PTR _j$215041[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L215045
	mov	esi, esp
	mov	edx, DWORD PTR _j$215041[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215045:

; 17335: 			zFree(oldCertificateList);

	jmp	SHORT $L215043
$L215044:
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17336: 		}
; 17337: 		else

	jmp	$L215046
$L215020:

; 17338: 		{// The chain does not have the same number of cretificates as provided during digest calculation.
; 17339: 			for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215047[ebp], 0
	jmp	SHORT $L215048
$L215049:
	mov	eax, DWORD PTR _i$215047[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215047[ebp], eax
$L215048:
	mov	ecx, DWORD PTR _i$215047[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215050

; 17340: 				if (certificateList[i]) xmlFree(certificateList[i]);

	mov	edx, DWORD PTR _i$215047[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L215051
	mov	esi, esp
	mov	ecx, DWORD PTR _i$215047[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215051:

; 17341: 			zFree(certificateList);

	jmp	SHORT $L215049
$L215050:
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17342: 			for (int i=0; i<oldCertificateListCount; i++)

	mov	DWORD PTR _i$215052[ebp], 0
	jmp	SHORT $L215053
$L215054:
	mov	edx, DWORD PTR _i$215052[ebp]
	add	edx, 1
	mov	DWORD PTR _i$215052[ebp], edx
$L215053:
	mov	eax, DWORD PTR _i$215052[ebp]
	cmp	eax, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215055

; 17343: 				if (oldCertificateList[i]) xmlFree(oldCertificateList[i]);

	mov	ecx, DWORD PTR _i$215052[ebp]
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L215056
	mov	esi, esp
	mov	eax, DWORD PTR _i$215052[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215056:

; 17344: 			zFree(oldCertificateList);

	jmp	SHORT $L215054
$L215055:
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17345: 			setError(SigHandle, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17346: 			if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215057
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215057:

; 17347: 			if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215058
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215058:

; 17348: 			return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215046:

; 17349: 		}
; 17350: 	}
; 17351: 	else

	jmp	$L215060
$L215019:

; 17352: 	{// There was no Certificate Chain provided during digest calculation so lets process them here now.
; 17353: 		if ((CertVerifyParams.usedCrlCount != 0) &&
; 17354: 			(CertVerifyParams.usedCrlList != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	$L215061
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1892], 0
	je	$L215061

; 17355: 		{
; 17356: 			for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$215062[ebp], 0
	jmp	SHORT $L215063
$L215064:
	mov	ecx, DWORD PTR _i$215062[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$215062[ebp], ecx
$L215063:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$215062[ebp]
	cmp	eax, DWORD PTR [edx+1888]
	jae	SHORT $L215065

; 17357: 			{
; 17358: 				if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$215062[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L215066

; 17359: 					zFree(CertVerifyParams.usedCrlList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$215062[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L215066:

; 17360: 			}

	jmp	SHORT $L215064
$L215065:

; 17361: 			zFree(CertVerifyParams.usedCrlList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	push	eax
	call	_rFree
	add	esp, 4

; 17362: 			CertVerifyParams.usedCrlList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1892], 0

; 17363: 			CertVerifyParams.usedCrlCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1888], 0
$L215061:

; 17364: 		}
; 17365: 
; 17366: 		if (((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) || (useCam) || (useOcsp)) &&
; 17367: 			(certificateList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	jne	SHORT $L215068
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	jne	SHORT $L215068
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 0
	je	$L215067
$L215068:
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L215067

; 17368: 		{
; 17369: 			SYSTEMTIME	tsSysTime;
; 17370: #ifdef WIN32
; 17371: 			GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	ecx, DWORD PTR _tsSysTime$215069[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17372: #else
; 17373: 			GetSystemTimeLinux(&tsSysTime);
; 17374: #endif
; 17375: 			if (useCam)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	SHORT $L215070

; 17376: 				result = crVerifyCertificateUsingCam(certificateList,
; 17377: 									certificateListCount,
; 17378: 									&tsSysTime, 
; 17379: 									(LPWSTR)PfxPassword.pbData, 
; 17380: 									&CertVerifyParams,
; 17381: 									SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$215069[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 17382: 			else

	jmp	$L215072
$L215070:

; 17383: 				if (useOcsp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	je	SHORT $L215073

; 17384: 					result = crVerifyCertificateUsingOcsp(certificateList,
; 17385: 										certificateListCount,
; 17386: 										&tsSysTime, 
; 17387: 										(LPWSTR)PfxPassword.pbData, 
; 17388: 										&CertVerifyParams,
; 17389: 										SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$215069[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 17390: 				else {

	jmp	SHORT $L215072
$L215073:

; 17391: #ifdef NSS
; 17392: 					SECItem s;
; 17393: 					s.data = PfxPassword.pbData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+900]
	mov	DWORD PTR _s$215076[ebp+4], eax

; 17394: 					s.len  = PfxPassword.cbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	DWORD PTR _s$215076[ebp+8], edx

; 17395: 					result = crVerifyCertificate(certificateList,
; 17396: 										certificateListCount,
; 17397: 										&tsSysTime, 
; 17398: 										&s, 
; 17399: 										&CertVerifyParams,
; 17400: 										SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	lea	eax, DWORD PTR _s$215076[ebp]
	push	eax
	lea	ecx, DWORD PTR _tsSysTime$215069[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateListCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L215072:

; 17401: #else
; 17402: 					result = crVerifyCertificate(certificateList,
; 17403: 										certificateListCount,
; 17404: 										&tsSysTime, 
; 17405: 										(LPWSTR)PfxPassword.pbData, 
; 17406: 										&CertVerifyParams,
; 17407: 										SigHandle);
; 17408: #endif
; 17409: 				}
; 17410: 			if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L215067

; 17411: 			{
; 17412: 				for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215079
$L215080:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L215079:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L215081

; 17413: 				{
; 17414: 					xmlFree(certificateList[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17415: 				}

	jmp	SHORT $L215080
$L215081:

; 17416: 				zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17417: 				if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215082
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215082:

; 17418: 				if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215083
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215083:

; 17419: 				return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215067:

; 17420: 			}
; 17421: 		}
; 17422: 
; 17423: 		/*
; 17424: 		* set <X509Data> certificate
; 17425: 		*/
; 17426: 		if (ExcludeSignerCertificateFlag != 1)// Either include the whole chain or just the end certificate

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 1
	je	$L215060

; 17427: 		{
; 17428: 			ki = xsCoreAddKeyInfo(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_xsCoreAddKeyInfo
	add	esp, 4
	mov	DWORD PTR _ki$[ebp], eax

; 17429: 			curX509Data = xsCoreAddX509Data(ki, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _ki$[ebp]
	push	edx
	call	_xsCoreAddX509Data
	add	esp, 8
	mov	DWORD PTR _curX509Data$[ebp], eax

; 17430: 
; 17431: 			if (ExcludeSignerCertificateFlag == 0)// Include the whole chain of certificates

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 0
	jne	$L215086

; 17432: 			{
; 17433: 				for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215088
$L215089:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L215088:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	$L215086

; 17434: 				{
; 17435: 					char *crlData = NULL;

	mov	DWORD PTR _crlData$215091[ebp], 0

; 17436: 
; 17437: 					curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _curX509Data$[ebp]
	push	edx
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 17438: 					if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2192], 1
	jne	SHORT $L215092
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1888], 0
	je	SHORT $L215092

; 17439: 					{
; 17440: 						crlData = CertVerifyParams.usedCrlList[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _crlData$215091[ebp], edx
$L215092:

; 17441: 					}
; 17442: 
; 17443: 					if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[i],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _crlData$215091[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _curX509Group$[ebp]
	push	eax
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	SHORT $L215094

; 17444: 					{
; 17445: 						for (int j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$215095[ebp], 0
	jmp	SHORT $L215096
$L215097:
	mov	ecx, DWORD PTR _j$215095[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215095[ebp], ecx
$L215096:
	mov	edx, DWORD PTR _j$215095[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215098

; 17446: 						{
; 17447: 							xmlFree(certificateList[j]);

	mov	esi, esp
	mov	eax, DWORD PTR _j$215095[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17448: 						}

	jmp	SHORT $L215097
$L215098:

; 17449: 						zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17450: 						if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215099
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215099:

; 17451: 						if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215100
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215100:

; 17452: 						return FALSE;

	xor	eax, eax
	jmp	$L214947
$L215094:

; 17453: 					}
; 17454: 				}

	jmp	$L215089
$L215086:

; 17455: 			}
; 17456: 			if (ExcludeSignerCertificateFlag == 2) //Just include the signer end certificate

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 2
	jne	$L215060

; 17457: 			{
; 17458: 				char *crlData = NULL;

	mov	DWORD PTR _crlData$215102[ebp], 0

; 17459: 				curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _curX509Data$[ebp]
	push	eax
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 17460: 				if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2192], 1
	jne	SHORT $L215103
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	SHORT $L215103

; 17461: 				{
; 17462: 					crlData = CertVerifyParams.usedCrlList[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _crlData$215102[ebp], edx
$L215103:

; 17463: 				}
; 17464: 				if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[0],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _crlData$215102[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _curX509Group$[ebp]
	push	edx
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	SHORT $L215060

; 17465: 				{
; 17466: 					for (int j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$215106[ebp], 0
	jmp	SHORT $L215107
$L215108:
	mov	eax, DWORD PTR _j$215106[ebp]
	add	eax, 1
	mov	DWORD PTR _j$215106[ebp], eax
$L215107:
	mov	ecx, DWORD PTR _j$215106[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215109

; 17467: 					{
; 17468: 						xmlFree(certificateList[j]);

	mov	esi, esp
	mov	edx, DWORD PTR _j$215106[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17469: 					}

	jmp	SHORT $L215108
$L215109:

; 17470: 					zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17471: 					if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215110
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215110:

; 17472: 					if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215111
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215111:

; 17473: 					return FALSE;

	xor	eax, eax
	jmp	$L214947
$L215060:

; 17474: 				}
; 17475: 			}
; 17476: 		} // ExcludeSignerCertificateFlag != 1
; 17477: 	}
; 17478: 
; 17479: 	/*
; 17480: 	 * Generate other XML sections
; 17481: 	 */
; 17482: 	if (!xsAcceptSignature(
; 17483: 		(const char *)certificateList[0],
; 17484: 		pbSignature,			// signature
; 17485: 		dwSigLen,				// signature size
; 17486: 		pbPublicKey,			// public key
; 17487: 		dwKeyLen,				// public key size
; 17488: 		sigalgtype,
; 17489: 		SigHandle
; 17490: 		))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _sigalgtype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwKeyLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSigLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xsAcceptSignature
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$L215113

; 17491: 	{
; 17492: 		if (certificateList != NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L215114

; 17493: 		{
; 17494: 			for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215115[ebp], 0
	jmp	SHORT $L215116
$L215117:
	mov	edx, DWORD PTR _i$215115[ebp]
	add	edx, 1
	mov	DWORD PTR _i$215115[ebp], edx
$L215116:
	mov	eax, DWORD PTR _i$215115[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215118

; 17495: 				if (certificateList[i]) xmlFree(certificateList[i]);

	mov	ecx, DWORD PTR _i$215115[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L215119
	mov	esi, esp
	mov	eax, DWORD PTR _i$215115[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215119:

; 17496: 			zFree(certificateList);

	jmp	SHORT $L215117
$L215118:
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215114:

; 17497: 		}
; 17498: 		if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215120
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215120:

; 17499: 		if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215121
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215121:

; 17500: 		return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215113:

; 17501: 	}
; 17502: 	if (certificateList != NULL)

	cmp	DWORD PTR _certificateList$[ebp], 0
	je	SHORT $L215123

; 17503: 	{
; 17504: 		for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215124[ebp], 0
	jmp	SHORT $L215125
$L215126:
	mov	eax, DWORD PTR _i$215124[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215124[ebp], eax
$L215125:
	mov	ecx, DWORD PTR _i$215124[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215127

; 17505: 			if (certificateList[i]) xmlFree(certificateList[i]);

	mov	edx, DWORD PTR _i$215124[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L215128
	mov	esi, esp
	mov	ecx, DWORD PTR _i$215124[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215128:

; 17506: 		zFree(certificateList);

	jmp	SHORT $L215126
$L215127:
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215123:

; 17507: 	}
; 17508: 
; 17509: 	if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215129
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215129:

; 17510: 	if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215130
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215130:

; 17511: 
; 17512: 	/*
; 17513: 	 * get result XML as string and save it
; 17514: 	 */
; 17515: 	char *xsignature = (char *)xsCoreGenerateXMLSec(SigHandle, &iSize);

	lea	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_xsCoreGenerateXMLSec
	add	esp, 8
	mov	DWORD PTR _xsignature$[ebp], eax

; 17516: 	if (Base64EncodeXML == FALSE)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2180], 0
	jne	SHORT $L215133

; 17517: 		*signedXML = A2WBSTR((LPCSTR)xsignature, iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _xsignature$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [ecx], eax

; 17518: 	else

	jmp	$L215135
$L215133:

; 17519: 	{
; 17520: 		int srcSize;
; 17521: 		unsigned int cbData;
; 17522: 		unsigned char *pbData;
; 17523: 		srcSize = iSize;

	mov	edx, DWORD PTR _iSize$[ebp]
	mov	DWORD PTR _srcSize$215136[ebp], edx

; 17524: 		cbData = base64encodeSize(srcSize);

	mov	eax, DWORD PTR _srcSize$215136[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$215137[ebp], eax

; 17525: 
; 17526: 		if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	ecx, DWORD PTR _cbData$215137[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$215138[ebp], eax
	cmp	DWORD PTR _pbData$215138[ebp], 0
	jne	SHORT $L215140

; 17527: 		{
; 17528: 			xmlFree(xsignature);

	mov	esi, esp
	mov	edx, DWORD PTR _xsignature$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17529: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17530: 			return S_FALSE;

	mov	eax, 1
	jmp	$L214947
$L215140:

; 17531: 		}
; 17532: 		if ((cbData  = base64encode((unsigned char *)xsignature,srcSize,(unsigned char*)pbData,cbData+1))==-1) 

	mov	edx, DWORD PTR _cbData$215137[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbData$215138[ebp]
	push	eax
	mov	ecx, DWORD PTR _srcSize$215136[ebp]
	push	ecx
	mov	edx, DWORD PTR _xsignature$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$215137[ebp], eax
	cmp	DWORD PTR _cbData$215137[ebp], -1
	jne	SHORT $L215144

; 17533: 		{
; 17534: 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17535: 			xmlFree(xsignature);

	mov	esi, esp
	mov	edx, DWORD PTR _xsignature$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17536: 			zFree(pbData);

	mov	eax, DWORD PTR _pbData$215138[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17537: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L214947
$L215144:

; 17538: 		}
; 17539: 		*signedXML = A2WBSTR((LPCSTR)pbData,cbData);

	mov	ecx, DWORD PTR _cbData$215137[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbData$215138[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedXML$[ebp]
	mov	DWORD PTR [ecx], eax

; 17540: 		zFree(pbData);

	mov	edx, DWORD PTR _pbData$215138[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215135:

; 17541: 	}
; 17542: 	xmlFree(xsignature);

	mov	esi, esp
	mov	eax, DWORD PTR _xsignature$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17543: 	return S_OK;

	xor	eax, eax
$L214947:

; 17544: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222922
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222922:
	DD	4
	DD	$L222921
$L222921:
	DD	-48					; ffffffd0H
	DD	4
	DD	$L222917
	DD	-96					; ffffffa0H
	DD	4
	DD	$L222918
	DD	-164					; ffffff5cH
	DD	16					; 00000010H
	DD	$L222919
	DD	-184					; ffffff48H
	DD	12					; 0000000cH
	DD	$L222920
$L222920:
	DB	115					; 00000073H
	DB	0
$L222919:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L222918:
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222917:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z ENDP	; CSignature::ApplySignatureValue
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

	mov	eax, DWORD PTR _nRequestedSize$[ebp]
	add	eax, 8
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L159703

; 378  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L159690
$L159703:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L159690:

; 385  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 32   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_p$159709 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L159707:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L159705

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$159709[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

	mov	ecx, DWORD PTR _p$159709[ebp]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 394  : 		}

	jmp	SHORT $L159707
$L159705:

; 395  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp

; 36   : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 37   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
PUBLIC	??BCBufferVariant@@QBEPADXZ			; CBufferVariant::operator char *
PUBLIC	?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ; CSignature::GetSignedInfoDigestFromByteArray
xdata$x	SEGMENT
$T222957 DD	0ffffffffH
	DD	FLAT:$L222942
	DD	00H
	DD	FLAT:$L222943
$T222945 DD	019930520H
	DD	02H
	DD	FLAT:$T222957
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv242 = -316						; size = 4
$T222941 = -312						; size = 4
$T222940 = -308						; size = 4
$T222939 = -304						; size = 4
$T222938 = -300						; size = 4
$T222937 = -296						; size = 4
$T222936 = -292						; size = 4
$T222935 = -288						; size = 4
_pbData$215327 = -284					; size = 4
_cbData$215326 = -280					; size = 4
_tmpEnvFlag$ = -276					; size = 2
_freeCharSigId$ = -272					; size = 4
__lpa$ = -268						; size = 4
__lpw$ = -264						; size = 4
__acp$ = -260						; size = 4
__convert$ = -256					; size = 4
_dwFileSize$ = -252					; size = 4
_dataPtr$ = -248					; size = 4
_inputByteArray$ = -244					; size = 4
_m_binaryData$ = -236					; size = 48
_templateFound$ = -184					; size = 4
_guidStr$ = -176					; size = 50
_sigGuid$ = -116					; size = 16
_ptemp$ = -96						; size = 4
_sigId$ = -88						; size = 4
_iSize$ = -76						; size = 4
_mem$ = -68						; size = 4
_signedInfoNode$ = -64					; size = 4
_sigNode$ = -60						; size = 4
_parent$ = -56						; size = 4
_cur$ = -52						; size = 4
_root$ = -48						; size = 4
_doc$ = -44						; size = 4
_charSignedInfoDigest$ = -36				; size = 4
_curCharSigId$ = -28					; size = 4
_charSigId$ = -24					; size = 4
_charXMLStr$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_xmlByteArray$ = 12					; size = 16
_signatureId$ = 28					; size = 4
_signedInfoDigest$ = 32					; size = 4
?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z PROC NEAR ; CSignature::GetSignedInfoDigestFromByteArray

; 17549: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 17550: 	char *charXMLStr=NULL, *charSigId=NULL, *curCharSigId=NULL;

	mov	DWORD PTR _charXMLStr$[ebp], 0
	mov	DWORD PTR _charSigId$[ebp], 0
	mov	DWORD PTR _curCharSigId$[ebp], 0

; 17551: 	unsigned char *charSignedInfoDigest=NULL;

	mov	DWORD PTR _charSignedInfoDigest$[ebp], 0

; 17552: 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 17553: 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 17554: 	xmlChar *mem=NULL;

	mov	DWORD PTR _mem$[ebp], 0

; 17555: 	int iSize=0;

	mov	DWORD PTR _iSize$[ebp], 0

; 17556: 	CComBSTR	sigId;

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 17557: 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 17558: #ifdef WIN32
; 17559: 	GUID sigGuid;
; 17560: #else
; 17561: 	uuid_t sigGuid;
; 17562: #endif
; 17563: 	char guidStr[50];
; 17564: 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 17565: 
; 17566: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 17567: 	VARIANT *inputByteArray;
; 17568: 	EnterLog;
; 17569: 
; 17570: 	if (! LicObj.checkLicense()) {

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?checkLicense@CLicense@@QAEHXZ		; CLicense::checkLicense
	test	eax, eax
	jne	SHORT $L215173

; 17571: 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17572: 		return S_FALSE;

	mov	DWORD PTR $T222935[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222935[ebp]
	jmp	$L215153
$L215173:

; 17573: 	}
; 17574: 
; 17575: 	if (xmlByteArray.vt == (VT_VARIANT | VT_BYREF))

	movzx	edx, WORD PTR _xmlByteArray$[ebp]
	cmp	edx, 16396				; 0000400cH
	jne	SHORT $L215176

; 17576: 	{
; 17577: 		inputByteArray = xmlByteArray.pvarVal;

	mov	eax, DWORD PTR _xmlByteArray$[ebp+8]
	mov	DWORD PTR _inputByteArray$[ebp], eax

; 17578: 	}
; 17579: 	else

	jmp	SHORT $L215177
$L215176:

; 17580: 		inputByteArray = &xmlByteArray;

	lea	ecx, DWORD PTR _xmlByteArray$[ebp]
	mov	DWORD PTR _inputByteArray$[ebp], ecx
$L215177:

; 17581: 
; 17582: 	if (inputByteArray->vt != (VT_ARRAY | VT_UI1))

	mov	edx, DWORD PTR _inputByteArray$[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 8209				; 00002011H
	je	SHORT $L215178

; 17583: 	{
; 17584: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17585: 		*signedInfoDigest = NULL;

	mov	eax, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [eax], 0

; 17586: 		return S_FALSE;

	mov	DWORD PTR $T222936[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222936[ebp]
	jmp	$L215153
$L215178:

; 17587: 	}
; 17588: 
; 17589: 	m_binaryData = xmlByteArray;

	lea	ecx, DWORD PTR _xmlByteArray$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??4CBufferVariant@@QAEAAV0@ABUtagVARIANT@@@Z ; CBufferVariant::operator=

; 17590: 
; 17591: 	char *dataPtr = (char *)m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??BCBufferVariant@@QBEPADXZ		; CBufferVariant::operator char *
	mov	DWORD PTR _dataPtr$[ebp], eax

; 17592: 	UINT dwFileSize = (UINT) m_binaryData.GetLength();

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?GetLength@CBufferVariant@@QAEJXZ	; CBufferVariant::GetLength
	mov	DWORD PTR _dwFileSize$[ebp], eax

; 17593: 	if (! LicObj.getSignAllowed()) 

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getSignAllowed@CLicense@@QAEHXZ	; CLicense::getSignAllowed
	test	eax, eax
	jne	SHORT $L215185

; 17594: 	{
; 17595: 		if (!LicObj.getFormSignAllowed((unsigned char *)dataPtr, dwFileSize, SigHandle))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _dwFileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dataPtr$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
	test	eax, eax
	jne	SHORT $L215185

; 17596: 		{
; 17597: 			setError(SigHandle, NO_SIGNING_LIC);

	push	45					; 0000002dH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17598: 			return S_FALSE;

	mov	DWORD PTR $T222937[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222937[ebp]
	jmp	$L215153
$L215185:

; 17599: 		}
; 17600: 	}
; 17601: 
; 17602: 	// original document
; 17603: 	doc = xmlParseMemory((const char *)dataPtr,dwFileSize);

	mov	edx, DWORD PTR _dwFileSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _dataPtr$[ebp]
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 17604: 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L215191

; 17605: 	{
; 17606: 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17607: 		return S_FALSE;

	mov	DWORD PTR $T222938[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222938[ebp]
	jmp	$L215153
$L215191:

; 17608: 	}
; 17609: 
; 17610: 	if (sgArr != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $L215194

; 17611: 	{
; 17612: 		if (uriArr != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $L215195

; 17613: 			FreeUriArr();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeUriArr@CSignature@@QAEXXZ		; CSignature::FreeUriArr
$L215195:

; 17614: 		sgArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0

; 17615: 		signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$L215194:

; 17616: 	}
; 17617: 
; 17618: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 17619: 
; 17620: 	BOOL freeCharSigId = FALSE;

	mov	DWORD PTR _freeCharSigId$[ebp], 0

; 17621: 	sigId = signatureId;

	mov	ecx, DWORD PTR _signatureId$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 17622: 	if (sigId.Length() == 0)

	lea	ecx, DWORD PTR _sigId$[ebp]
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L215201

; 17623: 		charSigId = NULL;

	mov	DWORD PTR _charSigId$[ebp], 0

; 17624: 	else

	jmp	SHORT $L215202
$L215201:

; 17625: 	{
; 17626: 		charSigId = (char *)HeapW2A(signatureId);

	mov	edx, DWORD PTR _signatureId$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 17627: 		freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L215202:

; 17628: 	}
; 17629: 
; 17630: 	if (charSigId == NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	jne	SHORT $L215204

; 17631: 		if (SignatureID.Length() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 392				; 00000188H
	call	?Length@CComBSTR@ATL@@QBEIXZ		; ATL::CComBSTR::Length
	test	eax, eax
	jne	SHORT $L215205

; 17632: 		{
; 17633: #ifdef WIN32
; 17634: 			CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17635: 			GuidToString(&sigGuid, guidStr);

	lea	ecx, DWORD PTR _guidStr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 17636: #else
; 17637: 			uuid_generate(sigGuid);
; 17638: 			uuid_unparse(sigGuid, guidStr);
; 17639: #endif
; 17640: 			charSigId = guidStr;

	lea	eax, DWORD PTR _guidStr$[ebp]
	mov	DWORD PTR _charSigId$[ebp], eax

; 17641: 		}
; 17642: 		else

	jmp	SHORT $L215204
$L215205:

; 17643: 		{
; 17644: 			charSigId = (char *)HeapW2A(SignatureID.m_str);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+392]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charSigId$[ebp], eax

; 17645: 			freeCharSigId = TRUE;

	mov	DWORD PTR _freeCharSigId$[ebp], 1
$L215204:

; 17646: 		}
; 17647: 
; 17648: 	  root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 17649: //	  cur = root->xmlChildrenNode;
; 17650: 
; 17651: 	sigNode = xsSigNodeById((const xmlNodePtr) root, (const xmlChar *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	call	_xsSigNodeById
	add	esp, 8
	mov	DWORD PTR _sigNode$[ebp], eax

; 17652: 	if (sigNode != NULL)

	cmp	DWORD PTR _sigNode$[ebp], 0
	je	SHORT $L215210

; 17653: 	{
; 17654: 		templateFound = TRUE;

	mov	DWORD PTR _templateFound$[ebp], 1

; 17655: 		cur = sigNode->xmlChildrenNode;

	mov	eax, DWORD PTR _sigNode$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx
$L215212:

; 17656: 		while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	SHORT $L215210

; 17657: 		{
; 17658: 				if (!(xmlStrcmp(cur->name, (const xmlChar *) "SignedInfo")))

	push	OFFSET FLAT:$SG215216
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215215

; 17659: 				{
; 17660: 					signedInfoNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], ecx

; 17661: 					break;

	jmp	SHORT $L215210
$L215215:

; 17662: 				}
; 17663: 				cur = cur->next;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _cur$[ebp], eax

; 17664: 		}  // end while cur != NULL

	jmp	SHORT $L215212
$L215210:

; 17665: 	}
; 17666: 	cur = root->xmlChildrenNode;

	mov	ecx, DWORD PTR _root$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _cur$[ebp], edx

; 17667: 
; 17668: 	  if (templateFound == FALSE) // A Signature element with matching Id was not found

	cmp	DWORD PTR _templateFound$[ebp], 0
	jne	$L215217

; 17669: 	  {
; 17670: 		  // Add a new Signature element
; 17671: 
; 17672: 		/*
; 17673: 		* Signature
; 17674: 		*/
; 17675: 
; 17676: 		cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215219
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17677: 		sigNode = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _sigNode$[ebp], eax

; 17678: 		if (charSigId != NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	je	SHORT $L215220

; 17679: 			xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	ecx, DWORD PTR _charSigId$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG215223
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215220:

; 17680: 		cur = xmlAddChild(root,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17681: 		//xmlNewNs(cur,(const unsigned char *)"http://www.w3.org/2000/09/xmldsig#",(const unsigned char *)NULL);
; 17682: 
; 17683: 		xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)NULL);

	push	0
	push	OFFSET FLAT:$SG215226
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 17684: 		parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 17685: 
; 17686: 		/*
; 17687: 		* SignedInfo
; 17688: 		*/
; 17689: 		cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215228
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17690: 		signedInfoNode = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _signedInfoNode$[ebp], ecx

; 17691: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17692: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 17693: 
; 17694: 		/*
; 17695: 		 * Canonicalization Method
; 17696: 		*/
; 17697: 		cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG215230
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17698: 		switch(CanonicalizationMethod)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+3336]
	mov	DWORD PTR tv242[ebp], eax
	cmp	DWORD PTR tv242[ebp], 3
	ja	SHORT $L215255
	mov	ecx, DWORD PTR tv242[ebp]
	jmp	DWORD PTR $L222956[ecx*4]
$L215235:

; 17699: 		{
; 17700: 			case WITH_COMMENTS:
; 17701: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG215238
	push	OFFSET FLAT:$SG215239
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17702: 				break;

	jmp	SHORT $L215232
$L215240:

; 17703: 			case WITHOUT_COMMENTS:
; 17704: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG215243
	push	OFFSET FLAT:$SG215244
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17705: 				break;

	jmp	SHORT $L215232
$L215245:

; 17706: 			case EXC_WITH_COMMENTS:
; 17707: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG215248
	push	OFFSET FLAT:$SG215249
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17708: 				break;

	jmp	SHORT $L215232
$L215250:

; 17709: 			case EXC_WITHOUT_COMMENTS:
; 17710: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG215253
	push	OFFSET FLAT:$SG215254
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17711: 				break;

	jmp	SHORT $L215232
$L215255:

; 17712: 			default:
; 17713: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG215258
	push	OFFSET FLAT:$SG215259
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215232:

; 17714: 		}
; 17715: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17716: 		if (signerCertChain == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3412], 0
	jne	SHORT $L215260

; 17717: 		{//We assume RSA Algorithm will be used if no signer certificate info is provided
; 17718: 			cur = xmlNewNode(NULL, (const unsigned char *)"SignatureMethod");

	push	OFFSET FLAT:$SG215262
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17719: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_RSAWITHSHA1);

	push	OFFSET FLAT:$SG215265
	push	OFFSET FLAT:$SG215266
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17720: 			cur = xmlAddChild(parent, cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L215260:

; 17721: 		}
; 17722: 		/*
; 17723: 		* Reference
; 17724: 		*/
; 17725: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215268
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17726: 		cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17727: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)"");

	push	OFFSET FLAT:$SG215271
	push	OFFSET FLAT:$SG215272
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17728: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 17729: 
; 17730: 		/*
; 17731: 		* Transforms
; 17732: 		*/
; 17733: 	
; 17734: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG215274
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17735: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17736: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 17737: 
; 17738: 		/*
; 17739: 		* Transform
; 17740: 		*/
; 17741: 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 17742: 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	je	SHORT $L215276
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	$L215275
$L215276:

; 17743: 		{
; 17744: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG215278
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17745: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L215279

; 17746: 			{
; 17747: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG215282
	push	OFFSET FLAT:$SG215283
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17748: 			}
; 17749: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L215284
$L215279:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L215284

; 17750: 			{
; 17751: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG215288
	push	OFFSET FLAT:$SG215289
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215284:

; 17752: 			}
; 17753: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17754: 			parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 17755: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L215290

; 17756: 			{
; 17757: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG215292
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17758: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG215295
	push	OFFSET FLAT:$SG215296
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 17759: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG215299
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17760: 			}
; 17761: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L215300
$L215290:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L215300

; 17762: 			{
; 17763: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG215303
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17764: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG215306
	push	OFFSET FLAT:$SG215307
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 17765: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG215310
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215300:

; 17766: 			}
; 17767: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17768: 			parent = parent->parent;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _parent$[ebp], eax
$L215275:

; 17769: 		}
; 17770: 
; 17771: 		/*
; 17772: 		* Transform
; 17773: 		*/
; 17774: 
; 17775: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG215312
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 17776: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_ENVELOPED_SIG);

	push	OFFSET FLAT:$SG215315
	push	OFFSET FLAT:$SG215316
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 17777: 		cur = xmlAddChild(parent,cur);		

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L215217:

; 17778: 	  }
; 17779: #ifdef WIN32
; 17780: 	  if (PhysicalSigUsage != NO_PHYSICAL_SIG)		  

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+956], 0
	je	SHORT $L215317

; 17781: 		  AddPhysicalSignature(sigNode, signedInfoNode, charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddPhysicalSignature@CSignature@@QAEXPAU_xmlNode@@0PAD@Z ; CSignature::AddPhysicalSignature
$L215317:

; 17782: #endif
; 17783: 	/*
; 17784: 	 * init Signature. crBlob contains XML - envelope document
; 17785: 	 */
; 17786: 	short tmpEnvFlag = EnvelopingFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR [edx+688]
	mov	WORD PTR _tmpEnvFlag$[ebp], ax

; 17787: 	EnvelopingFlag = ENVELOPED;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+688], 2

; 17788: 
; 17789: 	calculateDigestOnly = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3408], 1

; 17790: 	if (!(CreateSigFromTmplBlob(doc, charSigId, &charSignedInfoDigest, &iSize)))

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	lea	ecx, DWORD PTR _charSignedInfoDigest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CreateSigFromTmplBlob@CSignature@@QAEHPAU_xmlDoc@@PADPAPAEPAH@Z ; CSignature::CreateSigFromTmplBlob
	test	eax, eax
	jne	$L215319

; 17791: 	{
; 17792: 		if (charSignedInfoDigest != NULL)

	cmp	DWORD PTR _charSignedInfoDigest$[ebp], 0
	je	SHORT $L215320

; 17793: 		{
; 17794: 			zFree(charSignedInfoDigest);

	mov	ecx, DWORD PTR _charSignedInfoDigest$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215320:

; 17795: 		}
; 17796: 		EnvelopingFlag = tmpEnvFlag;

	mov	edx, DWORD PTR _this$[ebp]
	mov	ax, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [edx+688], ax

; 17797: 		*signedInfoDigest = NULL;

	mov	ecx, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [ecx], 0

; 17798: 		calculateDigestOnly = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3408], 0

; 17799: 		if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L215321

; 17800: 			zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215321:

; 17801: 		return S_FALSE;

	mov	DWORD PTR $T222939[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222939[ebp]
	jmp	$L215153
$L215319:

; 17802: 	}
; 17803: 	else
; 17804: 	{
; 17805: 		if (charSignedInfoDigest != NULL)

	cmp	DWORD PTR _charSignedInfoDigest$[ebp], 0
	je	$L215324

; 17806: 		{
; 17807: 			unsigned int cbData;
; 17808: 			unsigned char *pbData;
; 17809: 			cbData = base64encodeSize(iSize);

	mov	ecx, DWORD PTR _iSize$[ebp]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$215326[ebp], eax

; 17810: 			pbData = (unsigned char *)zMalloc(cbData+1);

	mov	edx, DWORD PTR _cbData$215326[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$215327[ebp], eax

; 17811: 			if ((cbData = base64encode(charSignedInfoDigest, iSize, pbData, cbData+1)) == -1)

	mov	eax, DWORD PTR _cbData$215326[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pbData$215327[ebp]
	push	ecx
	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _charSignedInfoDigest$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cbData$215326[ebp], eax
	cmp	DWORD PTR _cbData$215326[ebp], -1
	jne	$L215329

; 17812: 			{
; 17813: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17814: 				zFree(pbData);

	mov	eax, DWORD PTR _pbData$215327[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17815: 				zFree(charSignedInfoDigest);

	mov	ecx, DWORD PTR _charSignedInfoDigest$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17816: 				calculateDigestOnly = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3408], 0

; 17817: 				if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L215330

; 17818: 					zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215330:

; 17819: 				return S_FALSE;

	mov	DWORD PTR $T222940[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222940[ebp]
	jmp	$L215153
$L215329:

; 17820: 			}
; 17821: 			zFree(charSignedInfoDigest);

	mov	ecx, DWORD PTR _charSignedInfoDigest$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17822: 			*signedInfoDigest = A2WBSTR((LPCSTR) pbData, cbData);

	mov	edx, DWORD PTR _cbData$215326[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$215327[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _signedInfoDigest$[ebp]
	mov	DWORD PTR [ecx], eax

; 17823: 			zFree(pbData);

	mov	edx, DWORD PTR _pbData$215327[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215324:

; 17824: 		}
; 17825: 	}
; 17826: 	EnvelopingFlag = tmpEnvFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _tmpEnvFlag$[ebp]
	mov	WORD PTR [eax+688], cx

; 17827: 	calculateDigestOnly = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+3408], 0

; 17828: 	if (freeCharSigId)

	cmp	DWORD PTR _freeCharSigId$[ebp], 0
	je	SHORT $L215334

; 17829: 		zFree(charSigId);

	mov	eax, DWORD PTR _charSigId$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215334:

; 17830: 	ExitLog;
; 17831: 	return S_OK;

	mov	DWORD PTR $T222941[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _sigId$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T222941[ebp]
$L215153:

; 17832: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222955
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L222955:
	DD	6
	DD	$L222954
$L222954:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L222946
	DD	-76					; ffffffb4H
	DD	4
	DD	$L222947
	DD	-88					; ffffffa8H
	DD	4
	DD	$L222948
	DD	-116					; ffffff8cH
	DD	16					; 00000010H
	DD	$L222949
	DD	-176					; ffffff50H
	DD	50					; 00000032H
	DD	$L222950
	DD	-236					; ffffff14H
	DD	48					; 00000030H
	DD	$L222951
$L222951:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222950:
	DB	103					; 00000067H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L222949:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L222948:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L222947:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L222946:
	DB	99					; 00000063H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L222956:
	DD	$L215240
	DD	$L215235
	DD	$L215250
	DD	$L215245
_TEXT	ENDS
text$x	SEGMENT
$L222942:
	lea	ecx, DWORD PTR _sigId$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L222943:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:
	mov	eax, OFFSET FLAT:$T222945
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z ENDP ; CSignature::GetSignedInfoDigestFromByteArray
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\buffervariant.h
;	COMDAT ??BCBufferVariant@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCBufferVariant@@QBEPADXZ PROC NEAR			; CBufferVariant::operator char *, COMDAT
; _this$ = ecx

; 172  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 	return (char *)(m_pBuffer);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCBufferVariant@@QBEPADXZ ENDP			; CBufferVariant::operator char *
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L159763

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L159763:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z ; CSignature::ApplySignatureValueGetByteArray
xdata$x	SEGMENT
$T222995 DD	0ffffffffH
	DD	FLAT:$L222984
$T222986 DD	019930520H
	DD	01H
	DD	FLAT:$T222995
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
xdata$x	ENDS
_TEXT	SEGMENT
$T222983 = -364						; size = 4
$T222982 = -360						; size = 16
$T222981 = -344						; size = 4
$T222980 = -340						; size = 4
$T222979 = -336						; size = 4
$T222978 = -332						; size = 4
$T222977 = -328						; size = 4
$T222976 = -324						; size = 4
$T222975 = -320						; size = 4
$T222974 = -316						; size = 4
$T222973 = -312						; size = 4
$T222972 = -308						; size = 4
$T222971 = -304						; size = 4
$T222970 = -300						; size = 4
$T222969 = -296						; size = 16
_xsignature$ = -280					; size = 4
_j$215513 = -276					; size = 4
_crlData$215509 = -272					; size = 4
_j$215501 = -268					; size = 4
_crlData$215497 = -264					; size = 4
_s$215481 = -256					; size = 12
_tsSysTime$215474 = -236				; size = 16
_i$215467 = -216					; size = 4
_i$215456 = -212					; size = 4
_i$215451 = -208					; size = 4
_j$215445 = -204					; size = 4
_j$215436 = -200					; size = 4
_j$215431 = -196					; size = 4
_i$215424 = -192					; size = 4
_curX509Group$ = -188					; size = 4
_curX509Data$ = -184					; size = 4
_ki$ = -180						; size = 4
_result$ = -176						; size = 4
_oldCertificateListCount$ = -168			; size = 4
_certificateListCount$ = -160				; size = 4
_certListIndex$ = -156					; size = 4
_oldCertificateList$ = -152				; size = 4
_certificateList$ = -148				; size = 4
_m_binaryData$ = -140					; size = 48
_pbData$ = -88						; size = 4
_cbData$ = -84						; size = 4
_sigalgtype$ = -80					; size = 4
_dwKeyLen$ = -76					; size = 4
_pbPublicKey$ = -72					; size = 4
_dwSigLen$ = -68					; size = 4
_pbSignature$ = -64					; size = 4
_iSize$ = -56						; size = 4
_sizeM$ = -48						; size = 4
_newPtr$ = -44						; size = 4
_ptr$ = -40						; size = 4
_i$ = -36						; size = 4
_certList$ = -32					; size = 4
_tmpCharPtr$ = -28					; size = 4
_root$ = -24						; size = 4
_cur$ = -20						; size = 4
_doc$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_b64SigValXml$ = 12					; size = 4
_signedXmlByteArray$ = 16				; size = 4
?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z PROC NEAR ; CSignature::ApplySignatureValueGetByteArray

; 17835: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 352				; 00000160H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-364]
	mov	ecx, 88					; 00000058H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 17836: 	xmlDocPtr doc;
; 17837: 	xmlNodePtr cur=NULL, root=NULL;

	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _root$[ebp], 0

; 17838: 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 17839: 	BYTE **certList=NULL;

	mov	DWORD PTR _certList$[ebp], 0

; 17840: 	UINT i=0;

	mov	DWORD PTR _i$[ebp], 0

; 17841: 	unsigned char *ptr=NULL, *newPtr=NULL; 

	mov	DWORD PTR _ptr$[ebp], 0
	mov	DWORD PTR _newPtr$[ebp], 0

; 17842: 	unsigned int sizeM;
; 17843: 	int iSize;
; 17844: 	PBYTE pbSignature=NULL;		// signature BLOB

	mov	DWORD PTR _pbSignature$[ebp], 0

; 17845: 	DWORD dwSigLen=0;			// signature BLOB

	mov	DWORD PTR _dwSigLen$[ebp], 0

; 17846: 	PBYTE pbPublicKey=NULL;		// (out) pub key BLOB

	mov	DWORD PTR _pbPublicKey$[ebp], 0

; 17847: 	DWORD dwKeyLen=0;			// (out) pub key BLOB

	mov	DWORD PTR _dwKeyLen$[ebp], 0

; 17848: 	DWORD sigalgtype=0;

	mov	DWORD PTR _sigalgtype$[ebp], 0

; 17849: //	unsigned char *certData=NULL;	// base64 encoded certData
; 17850: 	unsigned int cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 17851: 	unsigned char *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 17852: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 17853: 	BYTE **certificateList=NULL, **oldCertificateList=NULL;

	mov	DWORD PTR _certificateList$[ebp], 0
	mov	DWORD PTR _oldCertificateList$[ebp], 0

; 17854: 	int certListIndex=0, certificateListCount=0, oldCertificateListCount=0;

	mov	DWORD PTR _certListIndex$[ebp], 0
	mov	DWORD PTR _certificateListCount$[ebp], 0
	mov	DWORD PTR _oldCertificateListCount$[ebp], 0

; 17855: 	BOOL result=0;

	mov	DWORD PTR _result$[ebp], 0

; 17856: 	keyinfo *ki = NULL;

	mov	DWORD PTR _ki$[ebp], 0

; 17857: 	x509data *curX509Data = NULL;

	mov	DWORD PTR _curX509Data$[ebp], 0

; 17858: 	x509group *curX509Group = NULL;

	mov	DWORD PTR _curX509Group$[ebp], 0

; 17859: 
; 17860: 	EnterLog;
; 17861: 
; 17862: 	m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 17863: 	*signedXmlByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222969[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 17864: 
; 17865: 	if ((b64SigValXml == NULL) || 
; 17866: 		(SysStringByteLen(b64SigValXml) == 0))

	cmp	DWORD PTR _b64SigValXml$[ebp], 0
	je	SHORT $L215371
	mov	esi, esp
	mov	ecx, DWORD PTR _b64SigValXml$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L215370
$L215371:

; 17867: 	{
; 17868: 		setError(SigHandle, NULL_DATA_STRING);

	push	68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 17869: 		return S_FALSE;

	mov	DWORD PTR $T222970[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222970[ebp]
	jmp	$L215341
$L215370:

; 17870: 	}
; 17871: 
; 17872: 	// Base64 decode b64SigValXml
; 17873: 	ptr = HeapW2A(b64SigValXml);

	mov	ecx, DWORD PTR _b64SigValXml$[ebp]
	push	ecx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 17874: 	sizeM = strlen((const char *)ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17875: 	sizeM = base64decodeSize(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17876: 	newPtr = (unsigned char *)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newPtr$[ebp], eax

; 17877: 	if ((sizeM = base64decode(ptr,newPtr,sizeM+1))==-1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L215376

; 17878: 	{
; 17879: 		zFree(ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17880: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17881: 		setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17882: 		return S_FALSE;

	mov	DWORD PTR $T222971[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222971[ebp]
	jmp	$L215341
$L215376:

; 17883: 	}
; 17884: 	zFree(ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17885: 
; 17886: 	if ((doc = xmlParseMemory((const char *)newPtr, sizeM)) == NULL)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newPtr$[ebp]
	push	edx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax
	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L215380

; 17887: 	{
; 17888: 		zFree(newPtr);

	mov	eax, DWORD PTR _newPtr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17889: 		return S_FALSE;

	mov	DWORD PTR $T222972[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222972[ebp]
	jmp	$L215341
$L215380:

; 17890: 	}
; 17891: 	zFree(newPtr);

	mov	ecx, DWORD PTR _newPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17892: 
; 17893: 	root = xmlDocGetRootElement(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 17894: 	cur = root->xmlChildrenNode;

	mov	eax, DWORD PTR _root$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _cur$[ebp], ecx

; 17895: 	if (cur == NULL)

	cmp	DWORD PTR _cur$[ebp], 0
	jne	SHORT $L215387

; 17896: 	{
; 17897: 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 17898: 		return S_FALSE;

	mov	DWORD PTR $T222973[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222973[ebp]
	jmp	$L215341
$L215387:

; 17899: 	}
; 17900: 
; 17901: 	while (cur)

	cmp	DWORD PTR _cur$[ebp], 0
	je	$L215388

; 17902: 	{
; 17903: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"SignatureValue"))

	push	OFFSET FLAT:$SG215391
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L215390

; 17904: 		{
; 17905: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17906: 			sizeM = strlen((const char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17907: 			sizeM  = base64decodeSize(sizeM);

	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17908: 			pbSignature = (PBYTE)zMalloc(sizeM+1);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbSignature$[ebp], eax

; 17909: 			if ((dwSigLen = base64decode(tmpCharPtr, pbSignature, sizeM+1)) == -1)

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwSigLen$[ebp], eax
	cmp	DWORD PTR _dwSigLen$[ebp], -1
	jne	SHORT $L215394

; 17910: 			{
; 17911: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 17912: 				zFree(pbSignature);

	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17913: 				xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17914: 				return S_FALSE;

	mov	DWORD PTR $T222974[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222974[ebp]
	jmp	$L215341
$L215394:

; 17915: 			}
; 17916: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215390:

; 17917: 		}
; 17918: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"PublicKeyValue"))

	push	OFFSET FLAT:$SG215399
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L215398

; 17919: 		{
; 17920: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17921: 			sizeM = strlen((const char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17922: 			sizeM  = base64decodeSize(sizeM);

	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 17923: 			pbPublicKey = (PBYTE)zMalloc(sizeM+1);

	mov	edx, DWORD PTR _sizeM$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbPublicKey$[ebp], eax

; 17924: 			if ((dwKeyLen = base64decode(tmpCharPtr, pbPublicKey, sizeM+1)) == -1)

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwKeyLen$[ebp], eax
	cmp	DWORD PTR _dwKeyLen$[ebp], -1
	jne	SHORT $L215402

; 17925: 			{
; 17926: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17927: 				zFree(pbPublicKey);

	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17928: 				xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17929: 				return S_FALSE;

	mov	DWORD PTR $T222975[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222975[ebp]
	jmp	$L215341
$L215402:

; 17930: 			}
; 17931: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215398:

; 17932: 		}
; 17933: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"AlgorithmType"))

	push	OFFSET FLAT:$SG215407
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215406

; 17934: 		{
; 17935: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17936: 			sigalgtype = (DWORD)atoi((const char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _sigalgtype$[ebp], eax

; 17937: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215406:

; 17938: 		}
; 17939: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"CertificateChainLength"))

	push	OFFSET FLAT:$SG215412
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215411

; 17940: 		{
; 17941: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _cur$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17942: 			certificateListCount = (DWORD)atoi((const char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _certificateListCount$[ebp], eax

; 17943: 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 17944: 			certificateList = (BYTE **)zMalloc(sizeof(BYTE *) * certificateListCount);

	mov	ecx, DWORD PTR _certificateListCount$[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _certificateList$[ebp], eax

; 17945: 			memset(certificateList, 0, certificateListCount * sizeof(BYTE *));

	mov	edx, DWORD PTR _certificateListCount$[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 17946: 			certListIndex = 0;

	mov	DWORD PTR _certListIndex$[ebp], 0
$L215411:

; 17947: 		}
; 17948: 		if (!xmlStrcmp(cur->name, (const unsigned char *)"X509Certificate"))

	push	OFFSET FLAT:$SG215420
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L215419

; 17949: 		{
; 17950: 			tmpCharPtr = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _cur$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 17951: 			certificateList[certListIndex++] = tmpCharPtr;

	mov	eax, DWORD PTR _certListIndex$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _certListIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _certListIndex$[ebp], eax
$L215419:

; 17952: 		}
; 17953: 		cur = cur->next;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _cur$[ebp], edx

; 17954: 	}

	jmp	$L215387
$L215388:

; 17955: 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 17956: 	oldCertificateList = getSignerCertChain((UINT *)&oldCertificateListCount);

	lea	ecx, DWORD PTR _oldCertificateListCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getSignerCertChain@CSignature@@QAEPAPAEPAI@Z ; CSignature::getSignerCertChain
	mov	DWORD PTR _oldCertificateList$[ebp], eax

; 17957: 
; 17958: 	if ((oldCertificateList != NULL) && (oldCertificateListCount != 0))

	cmp	DWORD PTR _oldCertificateList$[ebp], 0
	je	$L215422
	cmp	DWORD PTR _oldCertificateListCount$[ebp], 0
	je	$L215422

; 17959: 	{ // Make sure that the certificates used during signing are the same as the ones provided during digest calculation
; 17960: 		if  (oldCertificateListCount == certificateListCount)

	mov	edx, DWORD PTR _oldCertificateListCount$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jne	$L215423

; 17961: 		{
; 17962: 			for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215424[ebp], 0
	jmp	SHORT $L215425
$L215426:
	mov	eax, DWORD PTR _i$215424[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215424[ebp], eax
$L215425:
	mov	ecx, DWORD PTR _i$215424[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	$L215427

; 17963: 			{
; 17964: 				if (strcmp((const char *)oldCertificateList[i], (const char *)certificateList[i]))

	mov	edx, DWORD PTR _i$215424[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _i$215424[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L215430

; 17965: 				{// The chain provided during digest calculation != chain captured during signing
; 17966: 					for (int j=0; j<certificateListCount; j++)

	mov	DWORD PTR _j$215431[ebp], 0
	jmp	SHORT $L215432
$L215433:
	mov	edx, DWORD PTR _j$215431[ebp]
	add	edx, 1
	mov	DWORD PTR _j$215431[ebp], edx
$L215432:
	mov	eax, DWORD PTR _j$215431[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215434

; 17967: 						if (certificateList[j]) xmlFree(certificateList[j]);

	mov	ecx, DWORD PTR _j$215431[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L215435
	mov	esi, esp
	mov	eax, DWORD PTR _j$215431[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215435:

; 17968: 					zFree(certificateList);

	jmp	SHORT $L215433
$L215434:
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17969: 					for (int j=0; j<oldCertificateListCount; j++)

	mov	DWORD PTR _j$215436[ebp], 0
	jmp	SHORT $L215437
$L215438:
	mov	ecx, DWORD PTR _j$215436[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215436[ebp], ecx
$L215437:
	mov	edx, DWORD PTR _j$215436[ebp]
	cmp	edx, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215439

; 17970: 						if (oldCertificateList[j]) xmlFree(oldCertificateList[j]);

	mov	eax, DWORD PTR _j$215436[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L215440
	mov	esi, esp
	mov	edx, DWORD PTR _j$215436[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215440:

; 17971: 					zFree(oldCertificateList);

	jmp	SHORT $L215438
$L215439:
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17972: 					setError(SigHandle, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 17973: 					if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215441
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215441:

; 17974: 					if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215442
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215442:

; 17975: 					return S_FALSE;

	mov	DWORD PTR $T222976[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222976[ebp]
	jmp	$L215341
$L215430:

; 17976: 				}
; 17977: 			}

	jmp	$L215426
$L215427:

; 17978: 			// The chain is identical to the one provided during digest calculation so there is no need to process it again
; 17979: 			for (int j=0; j<oldCertificateListCount; j++)

	mov	DWORD PTR _j$215445[ebp], 0
	jmp	SHORT $L215446
$L215447:
	mov	ecx, DWORD PTR _j$215445[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215445[ebp], ecx
$L215446:
	mov	edx, DWORD PTR _j$215445[ebp]
	cmp	edx, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215448

; 17980: 				if (oldCertificateList[j]) xmlFree(oldCertificateList[j]);

	mov	eax, DWORD PTR _j$215445[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L215449
	mov	esi, esp
	mov	edx, DWORD PTR _j$215445[ebp]
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215449:

; 17981: 			zFree(oldCertificateList);

	jmp	SHORT $L215447
$L215448:
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 17982: 		}
; 17983: 		else

	jmp	$L215450
$L215423:

; 17984: 		{// The chain does not have the same number of cretificates as provided during digest calculation.
; 17985: 			for (int i=0; i<certificateListCount; i++)

	mov	DWORD PTR _i$215451[ebp], 0
	jmp	SHORT $L215452
$L215453:
	mov	eax, DWORD PTR _i$215451[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215451[ebp], eax
$L215452:
	mov	ecx, DWORD PTR _i$215451[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215454

; 17986: 				if (certificateList[i]) xmlFree(certificateList[i]);

	mov	edx, DWORD PTR _i$215451[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $L215455
	mov	esi, esp
	mov	ecx, DWORD PTR _i$215451[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215455:

; 17987: 			zFree(certificateList);

	jmp	SHORT $L215453
$L215454:
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 17988: 			for (int i=0; i<oldCertificateListCount; i++)

	mov	DWORD PTR _i$215456[ebp], 0
	jmp	SHORT $L215457
$L215458:
	mov	edx, DWORD PTR _i$215456[ebp]
	add	edx, 1
	mov	DWORD PTR _i$215456[ebp], edx
$L215457:
	mov	eax, DWORD PTR _i$215456[ebp]
	cmp	eax, DWORD PTR _oldCertificateListCount$[ebp]
	jge	SHORT $L215459

; 17989: 				if (oldCertificateList[i]) xmlFree(oldCertificateList[i]);

	mov	ecx, DWORD PTR _i$215456[ebp]
	mov	edx, DWORD PTR _oldCertificateList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L215460
	mov	esi, esp
	mov	eax, DWORD PTR _i$215456[ebp]
	mov	ecx, DWORD PTR _oldCertificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215460:

; 17990: 			zFree(oldCertificateList);

	jmp	SHORT $L215458
$L215459:
	mov	eax, DWORD PTR _oldCertificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 17991: 			setError(SigHandle, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 17992: 			if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215461
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215461:

; 17993: 			if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215462
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215462:

; 17994: 			return S_FALSE;

	mov	DWORD PTR $T222977[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222977[ebp]
	jmp	$L215341
$L215450:

; 17995: 		}
; 17996: 	}
; 17997: 	else

	jmp	$L215465
$L215422:

; 17998: 	{// There was no Certificate Chain provided during digest calculation so lets process them here now.
; 17999: 		if ((CertVerifyParams.usedCrlCount != 0) &&
; 18000: 			(CertVerifyParams.usedCrlList != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	$L215466
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1892], 0
	je	$L215466

; 18001: 		{
; 18002: 			for (UINT i=0; i < CertVerifyParams.usedCrlCount; i++)

	mov	DWORD PTR _i$215467[ebp], 0
	jmp	SHORT $L215468
$L215469:
	mov	ecx, DWORD PTR _i$215467[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$215467[ebp], ecx
$L215468:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$215467[ebp]
	cmp	eax, DWORD PTR [edx+1888]
	jae	SHORT $L215470

; 18003: 			{
; 18004: 				if (CertVerifyParams.usedCrlList[i] != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$215467[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L215471

; 18005: 					zFree(CertVerifyParams.usedCrlList[i]);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1892]
	mov	eax, DWORD PTR _i$215467[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4
$L215471:

; 18006: 			}

	jmp	SHORT $L215469
$L215470:

; 18007: 			zFree(CertVerifyParams.usedCrlList);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	push	eax
	call	_rFree
	add	esp, 4

; 18008: 			CertVerifyParams.usedCrlList = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1892], 0

; 18009: 			CertVerifyParams.usedCrlCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1888], 0
$L215466:

; 18010: 		}
; 18011: 
; 18012: 		if (((CertVerifyParams.verificationOptions & (~VERIFY_CRL_REC)) || (useCam) || (useOcsp)) &&
; 18013: 			(certificateList != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1856]
	and	ecx, -65				; ffffffbfH
	jne	SHORT $L215473
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	jne	SHORT $L215473
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 0
	je	$L215472
$L215473:
	cmp	DWORD PTR _certificateList$[ebp], 0
	je	$L215472

; 18014: 		{
; 18015: 			SYSTEMTIME	tsSysTime;
; 18016: #ifdef WIN32
; 18017: 			GetSystemTime(&tsSysTime);

	mov	esi, esp
	lea	ecx, DWORD PTR _tsSysTime$215474[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18018: #else
; 18019: 			GetSystemTimeLinux(&tsSysTime);
; 18020: #endif
; 18021: 			if (useCam)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1908], 0
	je	SHORT $L215475

; 18022: 				result = crVerifyCertificateUsingCam(certificateList,
; 18023: 									certificateListCount,
; 18024: 									&tsSysTime, 
; 18025: 									(LPWSTR)PfxPassword.pbData, 
; 18026: 									&CertVerifyParams,
; 18027: 									SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$215474[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingCam@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingCam
	mov	DWORD PTR _result$[ebp], eax

; 18028: 			else

	jmp	$L215477
$L215475:

; 18029: 				if (useOcsp)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 0
	je	SHORT $L215478

; 18030: 					result = crVerifyCertificateUsingOcsp(certificateList,
; 18031: 										certificateListCount,
; 18032: 										&tsSysTime, 
; 18033: 										(LPWSTR)PfxPassword.pbData, 
; 18034: 										&CertVerifyParams,
; 18035: 										SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+900]
	push	ecx
	lea	edx, DWORD PTR _tsSysTime$215474[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateListCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?crVerifyCertificateUsingOcsp@CSignature@@QAEHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; CSignature::crVerifyCertificateUsingOcsp
	mov	DWORD PTR _result$[ebp], eax

; 18036: 				else {

	jmp	SHORT $L215477
$L215478:

; 18037: #ifdef NSS
; 18038: 					SECItem s;
; 18039: 					s.data = PfxPassword.pbData;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+900]
	mov	DWORD PTR _s$215481[ebp+4], eax

; 18040: 					s.len  = PfxPassword.cbData;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+904]
	mov	DWORD PTR _s$215481[ebp+8], edx

; 18041: 					result = crVerifyCertificate(certificateList,
; 18042: 										certificateListCount,
; 18043: 										&tsSysTime, 
; 18044: 										&s, 
; 18045: 										&CertVerifyParams,
; 18046: 										SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1828				; 00000724H
	push	edx
	lea	eax, DWORD PTR _s$215481[ebp]
	push	eax
	lea	ecx, DWORD PTR _tsSysTime$215474[ebp]
	push	ecx
	mov	edx, DWORD PTR _certificateListCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
	add	esp, 24					; 00000018H
	mov	DWORD PTR _result$[ebp], eax
$L215477:

; 18047: #else
; 18048: 					result = crVerifyCertificate(certificateList,
; 18049: 										certificateListCount,
; 18050: 										&tsSysTime, 
; 18051: 										(LPWSTR)PfxPassword.pbData, 
; 18052: 										&CertVerifyParams,
; 18053: 										SigHandle);
; 18054: #endif
; 18055: 				}
; 18056: 			if (result == FALSE)

	cmp	DWORD PTR _result$[ebp], 0
	jne	$L215472

; 18057: 			{
; 18058: 				for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215484
$L215485:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L215484:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L215486

; 18059: 				{
; 18060: 					xmlFree(certificateList[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18061: 				}

	jmp	SHORT $L215485
$L215486:

; 18062: 				zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18063: 				if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215487
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215487:

; 18064: 				if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215488
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215488:

; 18065: 				return S_FALSE;

	mov	DWORD PTR $T222978[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222978[ebp]
	jmp	$L215341
$L215472:

; 18066: 			}
; 18067: 		}
; 18068: 
; 18069: 		/*
; 18070: 		* set <X509Data> certificate
; 18071: 		*/
; 18072: 		if (ExcludeSignerCertificateFlag != 1)// Either include the whole chain or just the end certificate

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 1
	je	$L215465

; 18073: 		{
; 18074: 			ki = xsCoreAddKeyInfo(SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_xsCoreAddKeyInfo
	add	esp, 4
	mov	DWORD PTR _ki$[ebp], eax

; 18075: 			curX509Data = xsCoreAddX509Data(ki, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _ki$[ebp]
	push	edx
	call	_xsCoreAddX509Data
	add	esp, 8
	mov	DWORD PTR _curX509Data$[ebp], eax

; 18076: 
; 18077: 			if (ExcludeSignerCertificateFlag == 0)// Include the whole chain of certificates

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 0
	jne	$L215492

; 18078: 			{
; 18079: 				for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215494
$L215495:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L215494:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	$L215492

; 18080: 				{
; 18081: 					char *crlData = NULL;

	mov	DWORD PTR _crlData$215497[ebp], 0

; 18082: 
; 18083: 					curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	mov	edx, DWORD PTR _curX509Data$[ebp]
	push	edx
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 18084: 					if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+2192], 1
	jne	SHORT $L215498
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1888], 0
	je	SHORT $L215498

; 18085: 					{
; 18086: 						crlData = CertVerifyParams.usedCrlList[i];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1892]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _crlData$215497[ebp], edx
$L215498:

; 18087: 					}
; 18088: 
; 18089: 					if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[i],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _crlData$215497[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _curX509Group$[ebp]
	push	eax
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	$L215500

; 18090: 					{
; 18091: 						for (int j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$215501[ebp], 0
	jmp	SHORT $L215502
$L215503:
	mov	ecx, DWORD PTR _j$215501[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$215501[ebp], ecx
$L215502:
	mov	edx, DWORD PTR _j$215501[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215504

; 18092: 						{
; 18093: 							xmlFree(certificateList[j]);

	mov	esi, esp
	mov	eax, DWORD PTR _j$215501[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18094: 						}

	jmp	SHORT $L215503
$L215504:

; 18095: 						zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18096: 						if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215505
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215505:

; 18097: 						if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215506
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215506:

; 18098: 						return FALSE;

	mov	DWORD PTR $T222979[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222979[ebp]
	jmp	$L215341
$L215500:

; 18099: 					}
; 18100: 				}

	jmp	$L215495
$L215492:

; 18101: 			}
; 18102: 			if (ExcludeSignerCertificateFlag == 2) //Just include the signer end certificate

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1820], 2
	jne	$L215465

; 18103: 			{
; 18104: 				char *crlData = NULL;

	mov	DWORD PTR _crlData$215509[ebp], 0

; 18105: 				curX509Group = xsCoreAddX509Group(curX509Data, SigHandle);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	mov	eax, DWORD PTR _curX509Data$[ebp]
	push	eax
	call	_xsCoreAddX509Group
	add	esp, 8
	mov	DWORD PTR _curX509Group$[ebp], eax

; 18106: 				if ((IncludeCRLInSignature == TRUE) && (CertVerifyParams.usedCrlCount != 0))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+2192], 1
	jne	SHORT $L215510
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1888], 0
	je	SHORT $L215510

; 18107: 				{
; 18108: 					crlData = CertVerifyParams.usedCrlList[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1892]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _crlData$215509[ebp], edx
$L215510:

; 18109: 				}
; 18110: 				if (xsCoreSetX509Group(curX509Group,NULL,NULL,(char *)certificateList[0],crlData, NULL, NULL, SigHandle)!=TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _crlData$215509[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _curX509Group$[ebp]
	push	edx
	call	_xsCoreSetX509Group
	add	esp, 32					; 00000020H
	cmp	eax, 1
	je	$L215465

; 18111: 				{
; 18112: 					for (int j=0; j < certificateListCount; j++)

	mov	DWORD PTR _j$215513[ebp], 0
	jmp	SHORT $L215514
$L215515:
	mov	eax, DWORD PTR _j$215513[ebp]
	add	eax, 1
	mov	DWORD PTR _j$215513[ebp], eax
$L215514:
	mov	ecx, DWORD PTR _j$215513[ebp]
	cmp	ecx, DWORD PTR _certificateListCount$[ebp]
	jge	SHORT $L215516

; 18113: 					{
; 18114: 						xmlFree(certificateList[j]);

	mov	esi, esp
	mov	edx, DWORD PTR _j$215513[ebp]
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18115: 					}

	jmp	SHORT $L215515
$L215516:

; 18116: 					zFree(certificateList);

	mov	edx, DWORD PTR _certificateList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 18117: 					if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215517
	mov	eax, DWORD PTR _pbSignature$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215517:

; 18118: 					if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215518
	mov	ecx, DWORD PTR _pbPublicKey$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215518:

; 18119: 					return FALSE;

	mov	DWORD PTR $T222980[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222980[ebp]
	jmp	$L215341
$L215465:

; 18120: 				}
; 18121: 			}
; 18122: 		} // ExcludeSignerCertificateFlag != 1
; 18123: 	}
; 18124: 
; 18125: 	/*
; 18126: 	 * Generate other XML sections
; 18127: 	 */
; 18128: 	if (!xsAcceptSignature(
; 18129: 		(const char *)certificateList[0],
; 18130: 		pbSignature,			// signature
; 18131: 		dwSigLen,				// signature size
; 18132: 		pbPublicKey,			// public key
; 18133: 		dwKeyLen,				// public key size
; 18134: 		sigalgtype,
; 18135: 		SigHandle
; 18136: 		))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	mov	ecx, DWORD PTR _sigalgtype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwKeyLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwSigLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	mov	eax, DWORD PTR _certificateList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xsAcceptSignature
	add	esp, 28					; 0000001cH
	test	eax, eax
	jne	$L215521

; 18137: 	{
; 18138: 		for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215523
$L215524:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L215523:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L215525

; 18139: 		{
; 18140: 			xmlFree(certificateList[i]);

	mov	esi, esp
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certificateList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18141: 		}

	jmp	SHORT $L215524
$L215525:

; 18142: 		zFree(certificateList);

	mov	ecx, DWORD PTR _certificateList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 18143: 		if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215526
	mov	edx, DWORD PTR _pbSignature$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215526:

; 18144: 		if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215527
	mov	eax, DWORD PTR _pbPublicKey$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215527:

; 18145: 		return S_FALSE;

	mov	DWORD PTR $T222981[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222981[ebp]
	jmp	$L215341
$L215521:

; 18146: 	}
; 18147: 
; 18148: 	for (i=0; i < (UINT) certificateListCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L215531
$L215532:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L215531:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _certificateListCount$[ebp]
	jae	SHORT $L215533

; 18149: 	{
; 18150: 		xmlFree(certificateList[i]);

	mov	esi, esp
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _certificateList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18151: 	}

	jmp	SHORT $L215532
$L215533:

; 18152: 	zFree(certificateList);

	mov	eax, DWORD PTR _certificateList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18153: 	if (pbSignature) zFree(pbSignature);

	cmp	DWORD PTR _pbSignature$[ebp], 0
	je	SHORT $L215534
	mov	ecx, DWORD PTR _pbSignature$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215534:

; 18154: 	if (pbPublicKey) zFree(pbPublicKey);

	cmp	DWORD PTR _pbPublicKey$[ebp], 0
	je	SHORT $L215535
	mov	edx, DWORD PTR _pbPublicKey$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215535:

; 18155: 
; 18156: 	/*
; 18157: 	 * get result XML as string and save it
; 18158: 	 */
; 18159: 	char *xsignature = (char *)xsCoreGenerateXMLSec(SigHandle, &iSize);

	lea	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_xsCoreGenerateXMLSec
	add	esp, 8
	mov	DWORD PTR _xsignature$[ebp], eax

; 18160: #ifdef WIN32
; 18161: 	m_binaryData.AssignData((const void *)xsignature, iSize);

	mov	eax, DWORD PTR _iSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xsignature$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 18162: 	*signedXmlByteArray = m_binaryData.Copy();

	lea	edx, DWORD PTR $T222982[ebp]
	push	edx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedXmlByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 18163: #else		
; 18164: 	VARIANT v;
; 18165: 	VariantInit(&v);
; 18166: 	*signedXmlByteArray = v;
; 18167: 	VariantFromByteArray(signedXmlByteArray,(const char *)xsignature, (long) iSize);
; 18168: #endif
; 18169: 
; 18170: 	xmlFree(xsignature);

	mov	esi, esp
	mov	ecx, DWORD PTR _xsignature$[ebp]
	push	ecx
	call	DWORD PTR _xmlFree
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18171: 	ExitLog;
; 18172: 	return S_OK;

	mov	DWORD PTR $T222983[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222983[ebp]
$L215341:

; 18173: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L222994
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 364				; 0000016cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L222994:
	DD	5
	DD	$L222993
$L222993:
	DD	-56					; ffffffc8H
	DD	4
	DD	$L222987
	DD	-140					; ffffff74H
	DD	48					; 00000030H
	DD	$L222988
	DD	-168					; ffffff58H
	DD	4
	DD	$L222989
	DD	-236					; ffffff14H
	DD	16					; 00000010H
	DD	$L222990
	DD	-256					; ffffff00H
	DD	12					; 0000000cH
	DD	$L222991
$L222991:
	DB	115					; 00000073H
	DB	0
$L222990:
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	83					; 00000053H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L222989:
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	100					; 00000064H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L222988:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L222987:
	DB	105					; 00000069H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L222984:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z:
	mov	eax, OFFSET FLAT:$T222986
	jmp	___CxxFrameHandler
text$x	ENDS
?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z ENDP ; CSignature::ApplySignatureValueGetByteArray
PUBLIC	?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z ; CSignature::GetSignedDocumentB64Str
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
__lpa$215561 = -20					; size = 4
__lpw$215560 = -16					; size = 4
__acp$215559 = -12					; size = 4
__convert$215558 = -8					; size = 4
_maxUri$ = -4						; size = 4
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_uriIndex$ = 16						; size = 4
_signedDocB64Str$ = 20					; size = 4
?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z PROC NEAR ; CSignature::GetSignedDocumentB64Str

; 18176: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 18177: 	int maxUri=0;

	mov	DWORD PTR _maxUri$[ebp], 0

; 18178: 
; 18179: 	*signedDocB64Str = NULL;

	mov	eax, DWORD PTR _signedDocB64Str$[ebp]
	mov	DWORD PTR [eax], 0

; 18180: 
; 18181: 	EnterLog;
; 18182: 
; 18183: 	if (DetailedVerificationReportFlag != NO_SIGNED_OBJ_ACCESS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 2
	je	$L215549

; 18184: 	{
; 18185: 		if (sgArr==NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $L215550

; 18186: 		{
; 18187: 			setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18188: 			return S_FALSE;

	mov	eax, 1
	jmp	$L215547
$L215550:

; 18189: 		}
; 18190: 		if ((sigIndex >= signum) || (sigIndex < 0))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L215553
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L215552
$L215553:

; 18191: 		{
; 18192: 			setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 18193: 			return S_FALSE;

	mov	eax, 1
	jmp	$L215547
$L215552:

; 18194: 		}
; 18195: 
; 18196: 		maxUri = sgArr[sigIndex]->refNumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _maxUri$[ebp], ecx

; 18197: 
; 18198: 		if ((uriIndex >= maxUri) || (uriIndex < 0))

	mov	edx, DWORD PTR _uriIndex$[ebp]
	cmp	edx, DWORD PTR _maxUri$[ebp]
	jge	SHORT $L215556
	cmp	DWORD PTR _uriIndex$[ebp], 0
	jge	SHORT $L215555
$L215556:

; 18199: 		{
; 18200: 			setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18201: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L215547
$L215555:

; 18202: 		}
; 18203: 
; 18204: USES_CONVERSION;

	mov	DWORD PTR __convert$215558[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$215559[ebp], eax
	mov	DWORD PTR __lpw$215560[ebp], 0
	mov	DWORD PTR __lpa$215561[ebp], 0

; 18205: 		*signedDocB64Str = A2WBSTR((LPCSTR) sgArr[sigIndex]->refArray[uriIndex]->refObject->encodedData);

	push	-1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _uriIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _signedDocB64Str$[ebp]
	mov	DWORD PTR [edx], eax
$L215549:

; 18206: 	}
; 18207: 	ExitLog;
; 18208: 	return S_OK;

	xor	eax, eax
$L215547:

; 18209: }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z ENDP	; CSignature::GetSignedDocumentB64Str
_TEXT	ENDS
PUBLIC	?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z ; CSignature::GetSignedDocumentByteArray
xdata$x	SEGMENT
$T223012 DD	0ffffffffH
	DD	FLAT:$L223005
$T223007 DD	019930520H
	DD	01H
	DD	FLAT:$T223012
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T223004 = -132						; size = 4
$T223003 = -128						; size = 16
$T223002 = -112						; size = 4
$T223001 = -108						; size = 4
$T223000 = -104						; size = 4
$T222999 = -100						; size = 4
$T222998 = -96						; size = 16
_pbData$ = -80						; size = 4
_cbData$ = -76						; size = 4
_m_binaryData$ = -68					; size = 48
_maxUri$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_sigIndex$ = 12						; size = 4
_uriIndex$ = 16						; size = 4
_signedDocumentByteArray$ = 20				; size = 4
?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z PROC NEAR ; CSignature::GetSignedDocumentByteArray

; 18212: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 120				; 00000078H
	push	edi
	lea	edi, DWORD PTR [ebp-132]
	mov	ecx, 30					; 0000001eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 18213: 	int maxUri=0;

	mov	DWORD PTR _maxUri$[ebp], 0

; 18214: 	CBufferVariant m_binaryData;

	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??0CBufferVariant@@QAE@XZ		; CBufferVariant::CBufferVariant
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 18215: 	unsigned long cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 18216: 	unsigned char *pbData=NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 18217: 
; 18218: 	EnterLog;
; 18219: 	m_binaryData.SetLength(0);

	push	0
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?SetLength@CBufferVariant@@QAEXJ@Z	; CBufferVariant::SetLength

; 18220: 	*signedDocumentByteArray = m_binaryData.Copy();

	lea	eax, DWORD PTR $T222998[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	ecx, DWORD PTR _signedDocumentByteArray$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 18221: 
; 18222: 	if (DetailedVerificationReportFlag != NO_SIGNED_OBJ_ACCESS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1816], 2
	je	$L215575

; 18223: 	{
; 18224: 		if (sgArr==NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $L215576

; 18225: 		{
; 18226: 			setError(SigHandle, NO_SIGNATURE_DATA);

	push	49					; 00000031H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18227: 			return S_FALSE;

	mov	DWORD PTR $T222999[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T222999[ebp]
	jmp	$L215569
$L215576:

; 18228: 		}
; 18229: 		if ((sigIndex >= signum) || (sigIndex < 0))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jge	SHORT $L215580
	cmp	DWORD PTR _sigIndex$[ebp], 0
	jge	SHORT $L215579
$L215580:

; 18230: 		{
; 18231: 			setError(SigHandle, SIG_INDEX_ERROR);

	push	50					; 00000032H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 18232: 			return S_FALSE;

	mov	DWORD PTR $T223000[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T223000[ebp]
	jmp	$L215569
$L215579:

; 18233: 		}
; 18234: 
; 18235: 		maxUri = sgArr[sigIndex]->refNumber;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _sigIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _maxUri$[ebp], ecx

; 18236: 
; 18237: 		if ((uriIndex >= maxUri) || (uriIndex < 0))

	mov	edx, DWORD PTR _uriIndex$[ebp]
	cmp	edx, DWORD PTR _maxUri$[ebp]
	jge	SHORT $L215584
	cmp	DWORD PTR _uriIndex$[ebp], 0
	jge	SHORT $L215583
$L215584:

; 18238: 		{
; 18239: 			setError(SigHandle, URI_INDEX_ERROR);

	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18240: 			return S_FALSE;

	mov	DWORD PTR $T223001[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T223001[ebp]
	jmp	$L215569
$L215583:

; 18241: 		}
; 18242: 
; 18243: 		if (sgArr[sigIndex]->refArray[uriIndex]->refObject->encodedData != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _uriIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	cmp	DWORD PTR [eax+256], 0
	je	$L215575

; 18244: 		{
; 18245: 			cbData = strlen((const char *)sgArr[sigIndex]->refArray[uriIndex]->refObject->encodedData);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _sigIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _uriIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 18246: 			cbData = base64decodeSize(cbData);

	mov	ecx, DWORD PTR _cbData$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 18247: 			pbData = (unsigned char *) zMalloc(cbData+1);

	mov	edx, DWORD PTR _cbData$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax

; 18248: 			if ((cbData = base64decode(sgArr[sigIndex]->refArray[uriIndex]->refObject->encodedData, pbData, cbData+1)) == -1)

	mov	eax, DWORD PTR _cbData$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _sigIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _uriIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+256]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cbData$[ebp], eax
	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L215590

; 18249: 			{
; 18250: 				if (pbData)

	cmp	DWORD PTR _pbData$[ebp], 0
	je	SHORT $L215591

; 18251: 					zFree(pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L215591:

; 18252: 				setError(SigHandle, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18253: 				return S_FALSE;

	mov	DWORD PTR $T223002[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T223002[ebp]
	jmp	SHORT $L215569
$L215590:

; 18254: 			}
; 18255: #ifdef WIN32
; 18256: 			m_binaryData.AssignData((const void *)pbData, cbData);

	mov	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?AssignData@CBufferVariant@@QAEXPBXJ@Z	; CBufferVariant::AssignData

; 18257: 			*signedDocumentByteArray = m_binaryData.Copy();

	lea	ecx, DWORD PTR $T223003[ebp]
	push	ecx
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	?Copy@CBufferVariant@@QAE?AUtagVARIANT@@XZ ; CBufferVariant::Copy
	mov	edx, DWORD PTR _signedDocumentByteArray$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], eax

; 18258: #else		
; 18259: 			VARIANT v;
; 18260: 			VariantInit(&v);
; 18261: 			*signedDocumentByteArray = v;
; 18262: 			VariantFromByteArray(signedDocumentByteArray,(const char *)pbData, (long) cbData);
; 18263: #endif
; 18264: 			if (pbData)

	cmp	DWORD PTR _pbData$[ebp], 0
	je	SHORT $L215575

; 18265: 				zFree(pbData);

	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L215575:

; 18266: 		}
; 18267: 	}
; 18268: 
; 18269: 	ExitLog;
; 18270: 	return S_OK;

	mov	DWORD PTR $T223004[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	call	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
	mov	eax, DWORD PTR $T223004[ebp]
$L215569:

; 18271: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223011
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 132				; 00000084H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L223011:
	DD	1
	DD	$L223010
$L223010:
	DD	-68					; ffffffbcH
	DD	48					; 00000030H
	DD	$L223008
$L223008:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	98					; 00000062H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L223005:
	lea	ecx, DWORD PTR _m_binaryData$[ebp]
	jmp	??1CBufferVariant@@UAE@XZ		; CBufferVariant::~CBufferVariant
__ehhandler$?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z:
	mov	eax, OFFSET FLAT:$T223007
	jmp	___CxxFrameHandler
text$x	ENDS
?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z ENDP ; CSignature::GetSignedDocumentByteArray
PUBLIC	?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z ; CSignature::get_CertValidationTransactionId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_CertValidationTransactionId

; 18274: {

	push	ebp
	mov	ebp, esp

; 18275: 	if (useCam == 1)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1908], 1
	jne	SHORT $L215603

; 18276: 		*pVal = A2WBSTR((LPCSTR) CamResponseTransactionId);

	push	-1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2212]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18277: 	else

	jmp	SHORT $L215605
$L215603:

; 18278: 	{
; 18279: 		if ((useOcsp == TRUE) && (pOcspClient != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 1
	jne	SHORT $L215606
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1916], 0
	je	SHORT $L215606

; 18280: 		{
; 18281: 			*pVal = ocspOutputNonce.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2256				; 000008d0H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18282: 		}
; 18283: 		else

	jmp	SHORT $L215605
$L215606:

; 18284: 			*pVal = NULL;

	mov	edx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [edx], 0
$L215605:

; 18285: 	}
; 18286: 
; 18287: 	return S_OK;

	xor	eax, eax

; 18288: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_CertValidationTransactionId
_TEXT	ENDS
PUBLIC	?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z ; CSignature::put_CertValidationTransactionId
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_zero$215618 = -16					; size = 2
_newTransactionId$215616 = -8				; size = 4
_numChar$215614 = -4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_CertValidationTransactionId

; 18291: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 18292: 	if ((useOcsp == TRUE) && (pOcspClient != NULL))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 1
	jne	$L215613
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+1916], 0
	je	$L215613

; 18293: 	{
; 18294: 		UINT numChar = 0;

	mov	DWORD PTR _numChar$215614[ebp], 0

; 18295: 		numChar = SysStringLen(newVal);

	mov	esi, esp
	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _numChar$215614[ebp], eax

; 18296: 
; 18297: 		if (numChar % 2 != 0) // It is odd

	mov	eax, DWORD PTR _numChar$215614[ebp]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	je	SHORT $L215615

; 18298: 		{
; 18299: 			WCHAR * newTransactionId = (WCHAR *)zMalloc((numChar + 2) *2);

	mov	edx, DWORD PTR _numChar$215614[ebp]
	lea	eax, DWORD PTR [edx+edx+4]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _newTransactionId$215616[ebp], eax

; 18300: 			WCHAR zero = L'0';

	mov	WORD PTR _zero$215618[ebp], 48		; 00000030H

; 18301: 			memcpy(newTransactionId, (const void *)&zero, 2);

	push	2
	lea	ecx, DWORD PTR _zero$215618[ebp]
	push	ecx
	mov	edx, DWORD PTR _newTransactionId$215616[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 18302: 			wcscpy(newTransactionId + 1, newVal);

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _newTransactionId$215616[ebp]
	add	ecx, 2
	push	ecx
	call	_wcscpy
	add	esp, 8

; 18303: 			ocspInputNonce = newTransactionId;

	mov	edx, DWORD PTR _newTransactionId$215616[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18304: 			zFree(newTransactionId);

	mov	eax, DWORD PTR _newTransactionId$215616[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18305: 		}
; 18306: 		else

	jmp	SHORT $L215613
$L215615:

; 18307: 			ocspInputNonce = newVal;

	mov	ecx, DWORD PTR _newVal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2252				; 000008ccH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=
$L215613:

; 18308: 	}
; 18309: 	return S_OK;

	xor	eax, eax

; 18310: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223017
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223017:
	DD	1
	DD	$L223016
$L223016:
	DD	-16					; fffffff0H
	DD	2
	DD	$L223015
$L223015:
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_CertValidationTransactionId
_TEXT	ENDS
PUBLIC	?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z ; CSignature::get_IgnoreIncompleteSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z PROC NEAR ; CSignature::get_IgnoreIncompleteSignature

; 18313: {

	push	ebp
	mov	ebp, esp

; 18314: 	*pVal = IgnoreIncompleteSignature;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3420]
	mov	DWORD PTR [eax], edx

; 18315: 	return S_OK;

	xor	eax, eax

; 18316: }

	pop	ebp
	ret	8
?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z ENDP ; CSignature::get_IgnoreIncompleteSignature
_TEXT	ENDS
PUBLIC	?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z ; CSignature::put_IgnoreIncompleteSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z PROC NEAR ; CSignature::put_IgnoreIncompleteSignature

; 18319: {

	push	ebp
	mov	ebp, esp

; 18320: 	IgnoreIncompleteSignature = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+3420], ecx

; 18321: 	return S_OK;

	xor	eax, eax

; 18322: }

	pop	ebp
	ret	8
?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z ENDP	; CSignature::put_IgnoreIncompleteSignature
_TEXT	ENDS
PUBLIC	?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z ; CSignature::get_SignatureIndexToVerify
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z PROC NEAR ; CSignature::get_SignatureIndexToVerify

; 18325: {

	push	ebp
	mov	ebp, esp

; 18326: 	*pVal = SigIndexToVerify;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3424]
	mov	DWORD PTR [eax], edx

; 18327: 	return S_OK;

	xor	eax, eax

; 18328: }

	pop	ebp
	ret	8
?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_SignatureIndexToVerify
_TEXT	ENDS
PUBLIC	?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z	; CSignature::put_SignatureIndexToVerify
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z PROC NEAR ; CSignature::put_SignatureIndexToVerify

; 18331: {

	push	ebp
	mov	ebp, esp

; 18332: 	SigIndexToVerify = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+3424], ecx

; 18333: 	return S_OK;

	xor	eax, eax

; 18334: }

	pop	ebp
	ret	8
?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z ENDP	; CSignature::put_SignatureIndexToVerify
_TEXT	ENDS
PUBLIC	?get_UseOcsp@CSignature@@UAGJPAH@Z		; CSignature::get_UseOcsp
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_UseOcsp@CSignature@@UAGJPAH@Z PROC NEAR		; CSignature::get_UseOcsp

; 18337: {

	push	ebp
	mov	ebp, esp

; 18338: 	*pVal = useOcsp;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+1912]
	mov	DWORD PTR [eax], edx

; 18339: 	return S_OK;

	xor	eax, eax

; 18340: }

	pop	ebp
	ret	8
?get_UseOcsp@CSignature@@UAGJPAH@Z ENDP			; CSignature::get_UseOcsp
_TEXT	ENDS
PUBLIC	?put_UseOcsp@CSignature@@UAGJH@Z		; CSignature::put_UseOcsp
PUBLIC	__GUID_b15c7688_86e5_48bd_9c71_1e131cd191a9
;	COMDAT __GUID_b15c7688_86e5_48bd_9c71_1e131cd191a9
CONST	SEGMENT
__GUID_b15c7688_86e5_48bd_9c71_1e131cd191a9 DD 0b15c7688H
	DW	086e5H
	DW	048bdH
	DB	09cH
	DB	071H
	DB	01eH
	DB	013H
	DB	01cH
	DB	0d1H
	DB	091H
	DB	0a9H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
_hr$215659 = -16					; size = 4
_pUnknown$ = -8						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_UseOcsp@CSignature@@UAGJH@Z PROC NEAR		; CSignature::put_UseOcsp

; 18343: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 18344: 	IUnknown *pUnknown;
; 18345: 
; 18346: 
; 18347: 	if (useOcsp == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+1912], 1
	jne	SHORT $L215652

; 18348: 	{
; 18349: 		if (newVal == FALSE)

	cmp	DWORD PTR _newVal$[ebp], 0
	jne	SHORT $L215653

; 18350: 		{
; 18351: 			useOcsp = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1912], 0

; 18352: 			if (pOcspClient != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1916], 0
	je	SHORT $L215654

; 18353: 			{
; 18354: #ifdef WIN32
; 18355: 				pOcspClient->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1916]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+1916]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18356: #endif
; 18357: 				pOcspClient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1916], 0
$L215654:

; 18358: 			}
; 18359: #ifdef WIN32
; 18360: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18361: #endif
; 18362: 			return S_OK;

	xor	eax, eax
	jmp	$L215650
$L215653:

; 18363: 		}
; 18364: 		else
; 18365: 			return S_OK;

	xor	eax, eax
	jmp	$L215650
$L215652:

; 18366: 	}
; 18367: 	useOcsp = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+1912], ecx

; 18368: 
; 18369: 	if (useOcsp == TRUE)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+1912], 1
	jne	$L215658

; 18370: 	{
; 18371: 		put_UseCam(FALSE); // Disable CAM based validation

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+544]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18372: #ifdef WIN32
; 18373: 		CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18374: 		HRESULT hr = CoCreateInstance(__uuidof(OcspClient), NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_b15c7688_86e5_48bd_9c71_1e131cd191a9
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$215659[ebp], eax

; 18375: 		if (FAILED(hr))

	cmp	DWORD PTR _hr$215659[ebp], 0
	jge	SHORT $L215663

; 18376: 		{
; 18377: 			useOcsp = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1912], 0

; 18378: 			pOcspClient = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+1916], 0

; 18379: 			setError(SigHandle, OCSP_ERROR);

	push	123					; 0000007bH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18380: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18381: 			return S_FALSE;

	mov	eax, 1
	jmp	$L215650
$L215663:

; 18382: 		}
; 18383: 
; 18384: 		hr = pUnknown->QueryInterface(__uuidof(IOcspClient), (void **) &pOcspClient);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 1916				; 0000077cH
	mov	esi, esp
	push	edx
	push	OFFSET FLAT:__GUID_c8be4864_227a_4a1b_84ee_473681bd4872
	mov	eax, DWORD PTR _pUnknown$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pUnknown$[ebp]
	push	edx
	call	DWORD PTR [ecx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$215659[ebp], eax

; 18385: 		if (FAILED(hr))

	cmp	DWORD PTR _hr$215659[ebp], 0
	jge	SHORT $L215667

; 18386: 		{
; 18387: 			pUnknown->Release();

	mov	eax, DWORD PTR _pUnknown$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _pUnknown$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18388: 			pOcspClient = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+1916], 0

; 18389: 			useOcsp = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1912], 0

; 18390: 			setError(SigHandle, OCSP_ERROR);

	push	123					; 0000007bH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 18391: 			CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18392: 			return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L215650
$L215667:

; 18393: 		}
; 18394: 		pUnknown->Release();

	mov	ecx, DWORD PTR _pUnknown$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L215658:

; 18395: #elif LINUX
; 18396: 		nsresult rv;
; 18397: 		pOcspClient = do_CreateInstance("@infomosaic.com/OcspClientL;1", &rv);
; 18398: 		if (NS_FAILED(rv))
; 18399: 		{
; 18400: 			pOcspClient = NULL;
; 18401: 			useOcsp = FALSE;
; 18402: 			setError(SigHandle, OCSP_ERROR);
; 18403: 			return S_FALSE;
; 18404: 		}
; 18405: #endif
; 18406: 	}
; 18407: 	return S_OK;

	xor	eax, eax
$L215650:

; 18408: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223026
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223026:
	DD	1
	DD	$L223025
$L223025:
	DD	-8					; fffffff8H
	DD	4
	DD	$L223024
$L223024:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
?put_UseOcsp@CSignature@@UAGJH@Z ENDP			; CSignature::put_UseOcsp
_TEXT	ENDS
PUBLIC	?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z ; CSignature::get_OcspTrustedRespSignerCertPath
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_OcspTrustedRespSignerCertPath

; 18411: {

	push	ebp
	mov	ebp, esp

; 18412: 	*pVal = ocspResponseCACertPath.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18413: 	return S_OK;

	xor	eax, eax

; 18414: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_OcspTrustedRespSignerCertPath
_TEXT	ENDS
PUBLIC	?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z ; CSignature::put_OcspTrustedRespSignerCertPath
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_OcspTrustedRespSignerCertPath

; 18417: {

	push	ebp
	mov	ebp, esp

; 18418: 	ocspResponseCACertPath = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18419: 	return S_OK;

	xor	eax, eax

; 18420: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_OcspTrustedRespSignerCertPath
_TEXT	ENDS
PUBLIC	?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z ; CSignature::get_OcspReqSignerPFXCertPath
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_OcspReqSignerPFXCertPath

; 18423: {

	push	ebp
	mov	ebp, esp

; 18424: 	*pVal = ocspRequestSignerB64PfxCertPath.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18425: 	return S_OK;

	xor	eax, eax

; 18426: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_OcspReqSignerPFXCertPath
_TEXT	ENDS
PUBLIC	?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z ; CSignature::put_OcspReqSignerPFXCertPath
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_result$ = -16						; size = 4
_tmpBstr$ = -8						; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_OcspReqSignerPFXCertPath

; 18429: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 18430: 	BSTR tmpBstr=NULL;

	mov	DWORD PTR _tmpBstr$[ebp], 0

; 18431: 	HRESULT result;
; 18432: 
; 18433: 	ocspRequestSignerB64PfxCertPath = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2244				; 000008c4H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18434: 	result = ReadAllBase64(newVal, &tmpBstr);

	mov	esi, esp
	lea	ecx, DWORD PTR _tmpBstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _newVal$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+504]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _result$[ebp], eax

; 18435: 	if (tmpBstr != NULL)

	cmp	DWORD PTR _tmpBstr$[ebp], 0
	je	SHORT $L215691

; 18436: 		ocspRequestSignerB64PfxCert = tmpBstr;

	mov	eax, DWORD PTR _tmpBstr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2240				; 000008c0H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18437: 	else

	jmp	SHORT $L215692
$L215691:

; 18438: 		return S_FALSE;

	mov	eax, 1
	jmp	SHORT $L215688
$L215692:

; 18439: 	SysFreeString(tmpBstr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpBstr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18440: 	return S_OK;

	xor	eax, eax
$L215688:

; 18441: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223033
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223033:
	DD	1
	DD	$L223032
$L223032:
	DD	-8					; fffffff8H
	DD	4
	DD	$L223031
$L223031:
	DB	116					; 00000074H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_OcspReqSignerPFXCertPath
_TEXT	ENDS
PUBLIC	?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z ; CSignature::get_OcspReqSignerPFXCertPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_OcspReqSignerPFXCertPassword

; 18444: {

	push	ebp
	mov	ebp, esp

; 18445: 	*pVal = ocspRequestSignerB64PfxCertPassword.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18446: 	return S_OK;

	xor	eax, eax

; 18447: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z ENDP ; CSignature::get_OcspReqSignerPFXCertPassword
_TEXT	ENDS
PUBLIC	?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z ; CSignature::put_OcspReqSignerPFXCertPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z PROC NEAR ; CSignature::put_OcspReqSignerPFXCertPassword

; 18450: {

	push	ebp
	mov	ebp, esp

; 18451: 	ocspRequestSignerB64PfxCertPassword = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2248				; 000008c8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18452: 	return S_OK;

	xor	eax, eax

; 18453: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z ENDP ; CSignature::put_OcspReqSignerPFXCertPassword
_TEXT	ENDS
PUBLIC	?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z	; CSignature::get_OcspResponderURL
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_OcspResponderURL

; 18456: {

	push	ebp
	mov	ebp, esp

; 18457: 	*pVal = ocspOutputResponderUrl.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2236				; 000008bcH
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18458: 	return S_OK;

	xor	eax, eax

; 18459: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_OcspResponderURL
_TEXT	ENDS
PUBLIC	?put_OcspResponderURL@CSignature@@UAGJPAG@Z	; CSignature::put_OcspResponderURL
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_OcspResponderURL@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_OcspResponderURL

; 18462: {

	push	ebp
	mov	ebp, esp

; 18463: 	ocspResponderUrl = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2232				; 000008b8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18464: 	return S_OK;

	xor	eax, eax

; 18465: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_OcspResponderURL@CSignature@@UAGJPAG@Z ENDP	; CSignature::put_OcspResponderURL
_TEXT	ENDS
PUBLIC	?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z	; CSignature::get_OcspTextResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_OcspTextResponse

; 18468: {

	push	ebp
	mov	ebp, esp

; 18469: 	*pVal = ocspTextResponse.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2216				; 000008a8H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18470: 	return S_OK;

	xor	eax, eax

; 18471: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_OcspTextResponse
_TEXT	ENDS
PUBLIC	?get_OcspB64Response@CSignature@@UAGJPAPAG@Z	; CSignature::get_OcspB64Response
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_OcspB64Response@CSignature@@UAGJPAPAG@Z PROC NEAR	; CSignature::get_OcspB64Response

; 18474: {

	push	ebp
	mov	ebp, esp

; 18475: 	*pVal = ocspB64Response.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2220				; 000008acH
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18476: 	return S_OK;

	xor	eax, eax

; 18477: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_OcspB64Response@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_OcspB64Response
_TEXT	ENDS
PUBLIC	?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z	; CSignature::get_CertRevocationDate
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z PROC NEAR ; CSignature::get_CertRevocationDate

; 18480: {

	push	ebp
	mov	ebp, esp

; 18481: 	*pVal = ocspRevocationTime.Copy();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2228				; 000008b4H
	call	?Copy@CComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::Copy
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [ecx], eax

; 18482: 	return S_OK;

	xor	eax, eax

; 18483: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z ENDP	; CSignature::get_CertRevocationDate
_TEXT	ENDS
PUBLIC	?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z	; CSignature::get_IncludeOcspResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z PROC NEAR ; CSignature::get_IncludeOcspResponse

; 18486: {

	push	ebp
	mov	ebp, esp

; 18487: 	*pVal = IncludeOcspResponse;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2264]
	mov	DWORD PTR [eax], edx

; 18488: 	return S_OK;

	xor	eax, eax

; 18489: }

	pop	ebp
	ret	8
?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_IncludeOcspResponse
_TEXT	ENDS
PUBLIC	?put_IncludeOcspResponse@CSignature@@UAGJJ@Z	; CSignature::put_IncludeOcspResponse
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_IncludeOcspResponse@CSignature@@UAGJJ@Z PROC NEAR	; CSignature::put_IncludeOcspResponse

; 18492: {

	push	ebp
	mov	ebp, esp

; 18493: 	IncludeOcspResponse = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+2264], ecx

; 18494: 	return S_OK;

	xor	eax, eax

; 18495: }

	pop	ebp
	ret	8
?put_IncludeOcspResponse@CSignature@@UAGJJ@Z ENDP	; CSignature::put_IncludeOcspResponse
_TEXT	ENDS
PUBLIC	?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z ; SigWinImage::ICaptureImage::PutPhysicalSignatureFile
PUBLIC	?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ; SigWinImage::ICaptureImage::ShowFileSignature
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv169 = -88						; size = 4
tv167 = -84						; size = 4
tv166 = -80						; size = 4
tv164 = -76						; size = 4
$T223046 = -72						; size = 4
$T223045 = -68						; size = 4
$T223044 = -64						; size = 4
_hr$ = -60						; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_result$ = -40						; size = 4
_charFilePath$ = -36					; size = 4
_bstrFilePath$ = -32					; size = 4
_captureImageObject$ = -24				; size = 4
_pUnknown$ = -12					; size = 4
_this$ = -4						; size = 4
_filePathBuf$ = 8					; size = 4
_outFilePathBuf$ = 12					; size = 4
_sigCapturedOnce$ = 16					; size = 4
_windowDim$ = 20					; size = 4
_guidStr$ = 24						; size = 4
?ShowFileSignature@CSignature@@QAEJPAD0HPAUtagRECT@@0@Z PROC NEAR ; CSignature::ShowFileSignature
; _this$ = ecx

; 18499: {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 18500: 	IUnknown *pUnknown;
; 18501: 	ICaptureImage *captureImageObject;
; 18502: 	BSTR bstrFilePath;
; 18503: 	char *charFilePath;
; 18504: 	HRESULT result = S_FALSE;

	mov	DWORD PTR _result$[ebp], 1

; 18505: 
; 18506: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 18507: 	EnterLog;
; 18508: 	CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18509: 	HRESULT hr = CoCreateInstance(__uuidof(CCaptureImage), NULL, CLSCTX_INPROC_SERVER, 
; 18510: 						IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 18511: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L215761

; 18512: 	{
; 18513: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18514: 		return S_FALSE;

	mov	eax, 1
	jmp	$L215747
$L215761:

; 18515: 	}
; 18516: 
; 18517: 	hr = pUnknown->QueryInterface(__uuidof(ICaptureImage), (void **) &captureImageObject);

	mov	esi, esp
	lea	ecx, DWORD PTR _captureImageObject$[ebp]
	push	ecx
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 18518: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L215765

; 18519: 	{
; 18520: 		pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18521: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18522: 		return S_FALSE;

	mov	eax, 1
	jmp	$L215747
$L215765:

; 18523: 	}
; 18524: 	pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18525: 
; 18526: 	captureImageObject->PhysicalSignatureFile = _bstr_t(filePathBuf);

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T223044[ebp], esp
	mov	edx, DWORD PTR _filePathBuf$[ebp]
	push	edx
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv164[ebp], eax
	mov	ecx, DWORD PTR _captureImageObject$[ebp]
	call	?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z ; SigWinImage::ICaptureImage::PutPhysicalSignatureFile

; 18527: 
; 18528: 	bstrFilePath = captureImageObject->ShowFileSignature(_bstr_t(guidStr));

	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T223045[ebp], esp
	mov	eax, DWORD PTR _guidStr$[ebp]
	push	eax
	call	??0_bstr_t@@QAE@PBD@Z			; _bstr_t::_bstr_t
	mov	DWORD PTR tv166[ebp], eax
	lea	ecx, DWORD PTR $T223046[ebp]
	push	ecx
	mov	ecx, DWORD PTR _captureImageObject$[ebp]
	call	?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ; SigWinImage::ICaptureImage::ShowFileSignature
	mov	DWORD PTR tv167[ebp], eax
	mov	edx, DWORD PTR tv167[ebp]
	mov	DWORD PTR tv169[ebp], edx
	mov	ecx, DWORD PTR tv169[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	DWORD PTR _bstrFilePath$[ebp], eax
	lea	ecx, DWORD PTR $T223046[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 18529: 	captureImageObject->Release();

	mov	eax, DWORD PTR _captureImageObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _captureImageObject$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18530: 	CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18531: 	if (bstrFilePath != NULL)

	cmp	DWORD PTR _bstrFilePath$[ebp], 0
	je	SHORT $L215772

; 18532: 	{
; 18533: 		result = S_OK;

	mov	DWORD PTR _result$[ebp], 0

; 18534: 		charFilePath = (char *)HeapW2A(bstrFilePath);

	mov	eax, DWORD PTR _bstrFilePath$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charFilePath$[ebp], eax

; 18535: 		strcpy(outFilePathBuf, charFilePath);

	mov	ecx, DWORD PTR _charFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _outFilePathBuf$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 18536: 		zFree(charFilePath);

	mov	eax, DWORD PTR _charFilePath$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215772:

; 18537: 	}
; 18538: 	ExitLog;
; 18539: 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L215747:

; 18540: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223053
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L223053:
	DD	2
	DD	$L223052
$L223052:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223050
	DD	-24					; ffffffe8H
	DD	4
	DD	$L223051
$L223051:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$L223050:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
?ShowFileSignature@CSignature@@QAEJPAD0HPAUtagRECT@@0@Z ENDP ; CSignature::ShowFileSignature
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\activex\xmlsign\nssdebug\sigwinimage.tli
xdata$x	SEGMENT
$T223059 DD	0ffffffffH
	DD	FLAT:$L223055
$T223057 DD	019930520H
	DD	01H
	DD	FLAT:$T223059
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z
_TEXT	SEGMENT
__hr$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__arg1$ = 8						; size = 4
?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z PROC NEAR ; SigWinImage::ICaptureImage::PutPhysicalSignatureFile, COMDAT
; _this$ = ecx

; 21   : inline void ICaptureImage::PutPhysicalSignatureFile ( _bstr_t _arg1 ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 22   :     HRESULT _hr = put_PhysicalSignatureFile(_arg1);

	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 23   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L204826
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __hr$[ebp]
	push	ecx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L204826:

; 24   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __arg1$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223055:
	lea	ecx, DWORD PTR __arg1$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z:
	mov	eax, OFFSET FLAT:$T223057
	jmp	___CxxFrameHandler
text$x	ENDS
?PutPhysicalSignatureFile@ICaptureImage@SigWinImage@@QAEXV_bstr_t@@@Z ENDP ; SigWinImage::ICaptureImage::PutPhysicalSignatureFile
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223074 DD	0ffffffffH
	DD	FLAT:$L223064
$T223069 DD	019930520H
	DD	01H
	DD	FLAT:$T223074
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
_TEXT	SEGMENT
$T223066 = -36						; size = 4
__hr$ = -32						; size = 4
__result$ = -24						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_guidStr$ = 12						; size = 4
?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z PROC NEAR ; SigWinImage::ICaptureImage::ShowFileSignature, COMDAT
; _this$ = ecx

; 46   : inline _bstr_t ICaptureImage::ShowFileSignature ( _bstr_t guidStr ) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223066[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 47   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 48   :     HRESULT _hr = raw_ShowFileSignature(guidStr, &_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	lea	ecx, DWORD PTR _guidStr$[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+52]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 49   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L204863
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L204863:

; 50   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T223066[ebp]
	or	ecx, 1
	mov	DWORD PTR $T223066[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _guidStr$[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 51   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223073
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223073:
	DD	1
	DD	$L223072
$L223072:
	DD	-24					; ffffffe8H
	DD	4
	DD	$L223070
$L223070:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223064:
	lea	ecx, DWORD PTR _guidStr$[ebp]
	jmp	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t
__ehhandler$?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z:
	mov	eax, OFFSET FLAT:$T223069
	jmp	___CxxFrameHandler
text$x	ENDS
?ShowFileSignature@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@V3@@Z ENDP ; SigWinImage::ICaptureImage::ShowFileSignature
PUBLIC	?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ ; SigWinImage::ICaptureImage::CaptureCurrentWindowImage
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
tv135 = -68						; size = 4
$T223079 = -64						; size = 4
_hr$ = -60						; size = 4
__lpa$ = -56						; size = 4
__lpw$ = -52						; size = 4
__acp$ = -48						; size = 4
__convert$ = -44					; size = 4
_result$ = -40						; size = 4
_charFilePath$ = -36					; size = 4
_bstrFilePath$ = -32					; size = 4
_captureImageObject$ = -24				; size = 4
_pUnknown$ = -12					; size = 4
_this$ = -4						; size = 4
_imageFilePath$ = 8					; size = 4
_guidStr$ = 12						; size = 4
?CaptureCurrentWindowImage@CSignature@@QAEHPAD0@Z PROC NEAR ; CSignature::CaptureCurrentWindowImage
; _this$ = ecx

; 18543: {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 18544: 	IUnknown *pUnknown;
; 18545: 	ICaptureImage *captureImageObject;
; 18546: 	BSTR bstrFilePath;
; 18547: 	char *charFilePath;
; 18548: 	BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 18549: 
; 18550: 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 18551: 	EnterLog;
; 18552: 	CoInitialize(NULL);

	mov	esi, esp
	push	0
	call	DWORD PTR __imp__CoInitialize@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18553: 	HRESULT hr = CoCreateInstance(__uuidof(CCaptureImage), NULL, CLSCTX_INPROC_SERVER, 
; 18554: 						IID_IUnknown, (void **) &pUnknown);

	mov	esi, esp
	lea	eax, DWORD PTR _pUnknown$[ebp]
	push	eax
	push	OFFSET FLAT:_IID_IUnknown
	push	1
	push	0
	push	OFFSET FLAT:__GUID_f18805cc_5075_4d36_bb01_76a4caf6ee31
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 18555: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L215792

; 18556: 	{
; 18557: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18558: 		return S_FALSE;

	mov	eax, 1
	jmp	$L215779
$L215792:

; 18559: 	}
; 18560: 
; 18561: 	hr = pUnknown->QueryInterface(__uuidof(ICaptureImage), (void **) &captureImageObject);

	mov	esi, esp
	lea	ecx, DWORD PTR _captureImageObject$[ebp]
	push	ecx
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 18562: 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L215796

; 18563: 	{
; 18564: 		pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18565: 		CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18566: 		return S_FALSE;

	mov	eax, 1
	jmp	$L215779
$L215796:

; 18567: 	}
; 18568: 	pUnknown->Release();

	mov	edx, DWORD PTR _pUnknown$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pUnknown$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18569: 
; 18570: 	bstrFilePath = captureImageObject->CaptureCurrentWindowImage();

	lea	edx, DWORD PTR $T223079[ebp]
	push	edx
	mov	ecx, DWORD PTR _captureImageObject$[ebp]
	call	?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ ; SigWinImage::ICaptureImage::CaptureCurrentWindowImage
	mov	DWORD PTR tv135[ebp], eax
	mov	ecx, DWORD PTR tv135[ebp]
	call	??B_bstr_t@@QBEPAGXZ			; _bstr_t::operator unsigned short *
	mov	DWORD PTR _bstrFilePath$[ebp], eax
	lea	ecx, DWORD PTR $T223079[ebp]
	call	??1_bstr_t@@QAE@XZ			; _bstr_t::~_bstr_t

; 18571: 	captureImageObject->Release();

	mov	eax, DWORD PTR _captureImageObject$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	esi, esp
	mov	edx, DWORD PTR _captureImageObject$[ebp]
	push	edx
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18572: 	CoUninitialize();

	mov	esi, esp
	call	DWORD PTR __imp__CoUninitialize@0
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18573: 	if (bstrFilePath != NULL)

	cmp	DWORD PTR _bstrFilePath$[ebp], 0
	je	SHORT $L215799

; 18574: 	{
; 18575: 		result = TRUE;

	mov	DWORD PTR _result$[ebp], 1

; 18576: 		charFilePath = (char *)HeapW2A(bstrFilePath);

	mov	eax, DWORD PTR _bstrFilePath$[ebp]
	push	eax
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _charFilePath$[ebp], eax

; 18577: 		strcpy(imageFilePath, charFilePath);

	mov	ecx, DWORD PTR _charFilePath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _imageFilePath$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 18578: 		zFree(charFilePath);

	mov	eax, DWORD PTR _charFilePath$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215799:

; 18579: 	}
; 18580: 	ExitLog;
; 18581: 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L215779:

; 18582: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223084
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223084:
	DD	2
	DD	$L223083
$L223083:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223081
	DD	-24					; ffffffe8H
	DD	4
	DD	$L223082
$L223082:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	109					; 0000006dH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	79					; 0000004fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$L223081:
	DB	112					; 00000070H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	119					; 00000077H
	DB	110					; 0000006eH
	DB	0
?CaptureCurrentWindowImage@CSignature@@QAEHPAD0@Z ENDP	; CSignature::CaptureCurrentWindowImage
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\nssdebug\sigwinimage.tli
_TEXT	ENDS
;	COMDAT ?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ
_TEXT	SEGMENT
$T223087 = -24						; size = 4
__hr$ = -20						; size = 4
__result$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ PROC NEAR ; SigWinImage::ICaptureImage::CaptureCurrentWindowImage, COMDAT
; _this$ = ecx

; 14   : inline _bstr_t ICaptureImage::CaptureCurrentWindowImage ( ) {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223087[ebp], 0

; 15   :     BSTR _result = 0;

	mov	DWORD PTR __result$[ebp], 0

; 16   :     HRESULT _hr = raw_CaptureCurrentWindowImage(&_result);

	mov	esi, esp
	lea	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __hr$[ebp], eax

; 17   :     if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));

	cmp	DWORD PTR __hr$[ebp], 0
	jge	SHORT $L204818
	push	OFFSET FLAT:__GUID_0674a7d1_0a9c_4fe4_b914_96bcc6edc4cf
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR __hr$[ebp]
	push	edx
	call	?_com_issue_errorex@@YGXJPAUIUnknown@@ABU_GUID@@@Z ; _com_issue_errorex
$L204818:

; 18   :     return _bstr_t(_result, false);

	push	0
	mov	eax, DWORD PTR __result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0_bstr_t@@QAE@PAG_N@Z			; _bstr_t::_bstr_t
	mov	ecx, DWORD PTR $T223087[ebp]
	or	ecx, 1
	mov	DWORD PTR $T223087[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 19   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223091
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L223091:
	DD	1
	DD	$L223090
$L223090:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223089
$L223089:
	DB	95					; 0000005fH
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	116					; 00000074H
	DB	0
?CaptureCurrentWindowImage@ICaptureImage@SigWinImage@@QAE?AV_bstr_t@@XZ ENDP ; SigWinImage::ICaptureImage::CaptureCurrentWindowImage
_TEXT	ENDS
PUBLIC	?put_ProxyHost@CSignature@@UAGJPAG@Z		; CSignature::put_ProxyHost
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_ProxyHost@CSignature@@UAGJPAG@Z PROC NEAR		; CSignature::put_ProxyHost

; 18586: {

	push	ebp
	mov	ebp, esp

; 18587: 	proxyHost = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2268				; 000008dcH
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18588: 	return S_OK;

	xor	eax, eax

; 18589: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_ProxyHost@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_ProxyHost
_TEXT	ENDS
PUBLIC	?put_ProxyPort@CSignature@@UAGJG@Z		; CSignature::put_ProxyPort
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 2
?put_ProxyPort@CSignature@@UAGJG@Z PROC NEAR		; CSignature::put_ProxyPort

; 18592: {

	push	ebp
	mov	ebp, esp

; 18593: 	proxyPort = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR _newVal$[ebp]
	mov	WORD PTR [eax+2272], cx

; 18594: 	return S_OK;

	xor	eax, eax

; 18595: }

	pop	ebp
	ret	8
?put_ProxyPort@CSignature@@UAGJG@Z ENDP			; CSignature::put_ProxyPort
_TEXT	ENDS
PUBLIC	?put_ProxyUserName@CSignature@@UAGJPAG@Z	; CSignature::put_ProxyUserName
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_ProxyUserName@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_ProxyUserName

; 18598: {

	push	ebp
	mov	ebp, esp

; 18599: 	proxyUserName = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2276				; 000008e4H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18600: 	return S_OK;

	xor	eax, eax

; 18601: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_ProxyUserName@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_ProxyUserName
_TEXT	ENDS
PUBLIC	?put_ProxyPassword@CSignature@@UAGJPAG@Z	; CSignature::put_ProxyPassword
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_ProxyPassword@CSignature@@UAGJPAG@Z PROC NEAR	; CSignature::put_ProxyPassword

; 18604: {

	push	ebp
	mov	ebp, esp

; 18605: 	proxyPassword = newVal;

	mov	eax, DWORD PTR _newVal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2280				; 000008e8H
	call	??4CComBSTR@ATL@@QAEAAV01@PBG@Z		; ATL::CComBSTR::operator=

; 18606: 	return S_OK;

	xor	eax, eax

; 18607: }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?put_ProxyPassword@CSignature@@UAGJPAG@Z ENDP		; CSignature::put_ProxyPassword
_TEXT	ENDS
PUBLIC	?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z ; CSignature::put_InclusiveNamespacePrefixList
xdata$x	SEGMENT
$T223111 DD	0ffffffffH
	DD	FLAT:$L223102
$T223104 DD	019930520H
	DD	01H
	DD	FLAT:$T223111
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T223101 = -88						; size = 4
$T223100 = -84						; size = 4
$T223099 = -80						; size = 4
_tmpPtr$ = -76						; size = 4
_namespaceList$ = -68					; size = 28
_bstrList$ = -36					; size = 4
_itemCount$ = -28					; size = 4
_elementCount$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_newVal$ = 12						; size = 16
?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z PROC NEAR ; CSignature::put_InclusiveNamespacePrefixList

; 18610: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 76					; 0000004cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 19					; 00000013H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 18611: 	UINT elementCount=0;

	mov	DWORD PTR _elementCount$[ebp], 0

; 18612: 	UINT itemCount=0;

	mov	DWORD PTR _itemCount$[ebp], 0

; 18613: 	BSTR	*bstrList=NULL;

	mov	DWORD PTR _bstrList$[ebp], 0

; 18614: 	string namespaceList;

	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 18615: 	char *tmpPtr=NULL;

	mov	DWORD PTR _tmpPtr$[ebp], 0

; 18616: 
; 18617: 	EnterLog;
; 18618: 	if ((newVal.vt != VT_BSTR) &&
; 18619: 		(newVal.vt != VT_DISPATCH) &&
; 18620: 		!(newVal.vt & VT_ARRAY) && 
; 18621: 		!(newVal.vt & VT_BYREF))

	movzx	eax, WORD PTR _newVal$[ebp]
	cmp	eax, 8
	je	SHORT $L215830
	movzx	ecx, WORD PTR _newVal$[ebp]
	cmp	ecx, 9
	je	SHORT $L215830
	movzx	edx, WORD PTR _newVal$[ebp]
	and	edx, 8192				; 00002000H
	jne	SHORT $L215830
	movzx	eax, WORD PTR _newVal$[ebp]
	and	eax, 16384				; 00004000H
	jne	SHORT $L215830

; 18622: 	{
; 18623: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 18624: 		return S_FALSE;

	mov	DWORD PTR $T223099[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223099[ebp]
	jmp	$L215824
$L215830:

; 18625: 	}
; 18626: 
; 18627: 	if (InclusiveNamespaceList != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+96], 0
	je	SHORT $L215833

; 18628: 		zFree(InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	call	_rFree
	add	esp, 4
$L215833:

; 18629: 	InclusiveNamespaceList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 18630: 
; 18631: 	bstrList = GetBstrArrayFromVariant(newVal, &itemCount);

	lea	ecx, DWORD PTR _itemCount$[ebp]
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _newVal$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _newVal$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _newVal$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBstrArrayFromVariant@CSignature@@QAEPAPAGUtagVARIANT@@PAI@Z ; CSignature::GetBstrArrayFromVariant
	mov	DWORD PTR _bstrList$[ebp], eax

; 18632: 
; 18633: 	if ((bstrList == NULL) || (itemCount == 0))

	cmp	DWORD PTR _bstrList$[ebp], 0
	je	SHORT $L215835
	cmp	DWORD PTR _itemCount$[ebp], 0
	jne	SHORT $L215834
$L215835:

; 18634: 	{
; 18635: 		setError(SigHandle, INVALID_VARIANT);

	push	71					; 00000047H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 18636: 		return S_FALSE;

	mov	DWORD PTR $T223100[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223100[ebp]
	jmp	$L215824
$L215834:

; 18637: 	}
; 18638: 
; 18639: 	for (elementCount =0; elementCount < itemCount; elementCount++)

	mov	DWORD PTR _elementCount$[ebp], 0
	jmp	SHORT $L215838
$L215839:
	mov	ecx, DWORD PTR _elementCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _elementCount$[ebp], ecx
$L215838:
	mov	edx, DWORD PTR _elementCount$[ebp]
	cmp	edx, DWORD PTR _itemCount$[ebp]
	jae	SHORT $L215840

; 18640: 	{
; 18641: 		tmpPtr = (char *)HeapW2A(bstrList[elementCount]);

	mov	eax, DWORD PTR _elementCount$[ebp]
	mov	ecx, DWORD PTR _bstrList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _tmpPtr$[ebp], eax

; 18642: 		namespaceList += tmpPtr;

	mov	eax, DWORD PTR _tmpPtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 18643: 		namespaceList += " ";

	push	OFFSET FLAT:$SG215842
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 18644: 		SysFreeString(bstrList[elementCount]);

	mov	esi, esp
	mov	ecx, DWORD PTR _elementCount$[ebp]
	mov	edx, DWORD PTR _bstrList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18645: 		zFree(tmpPtr);

	mov	ecx, DWORD PTR _tmpPtr$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 18646: 	}

	jmp	SHORT $L215839
$L215840:

; 18647: 	zFree(bstrList);

	mov	edx, DWORD PTR _bstrList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 18648: 	InclusiveNamespaceList = (LPSTR) zMalloc(namespaceList.length() + 1);

	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], eax

; 18649: 	memcpy(InclusiveNamespaceList, namespaceList.c_str(), (namespaceList.length() + 1));

	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+96]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 18650: 	ExitLog;
; 18651: 	return S_OK;

	mov	DWORD PTR $T223101[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223101[ebp]
$L215824:

; 18652: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223110
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L223110:
	DD	2
	DD	$L223109
$L223109:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L223105
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$L223106
$L223106:
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L223105:
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L223102:
	lea	ecx, DWORD PTR _namespaceList$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z:
	mov	eax, OFFSET FLAT:$T223104
	jmp	___CxxFrameHandler
text$x	ENDS
?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z ENDP ; CSignature::put_InclusiveNamespacePrefixList
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv156 = -184						; size = 4
_i$216016 = -180					; size = 4
_i$215937 = -176					; size = 4
_objectId$ = -168					; size = 50
_sigGuid$ = -108					; size = 16
_dtd$ = -88						; size = 4
_ctxt$ = -84						; size = 4
_bareFileName$ = -80					; size = 4
_bstrPropValue$ = -76					; size = 4
_bstrPropName$ = -72					; size = 4
_varprop$ = -64						; size = 4
_cbDocument$ = -52					; size = 4
_cbData$ = -44						; size = 4
_pbDocument$ = -40					; size = 4
_pbData$ = -36						; size = 4
_sigNs$ = -32						; size = 4
_curNs$ = -28						; size = 4
_parent$ = -24						; size = 4
_cur$ = -20						; size = 4
_rootNode$ = -16					; size = 4
_doc$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_charSigId$ = 8						; size = 4
_sigNode$ = 12						; size = 4
_signedInfoNode$ = 16					; size = 4
?PrepareSignatureEnvelopeFromObjects@CSignature@@QAEPAU_xmlDoc@@PADPAPAU_xmlNode@@1@Z PROC NEAR ; CSignature::PrepareSignatureEnvelopeFromObjects
; _this$ = ecx

; 18655: {

	push	ebp
	mov	ebp, esp
	sub	esp, 184				; 000000b8H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-184]
	mov	ecx, 46					; 0000002eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 18656: 	xmlDocPtr doc=NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 18657: 	xmlNodePtr rootNode=NULL, cur=NULL, parent=NULL;

	mov	DWORD PTR _rootNode$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0

; 18658: 	xmlNsPtr curNs=NULL, sigNs=NULL;

	mov	DWORD PTR _curNs$[ebp], 0
	mov	DWORD PTR _sigNs$[ebp], 0

; 18659: 	BYTE *pbData=NULL, *pbDocument=NULL;

	mov	DWORD PTR _pbData$[ebp], 0
	mov	DWORD PTR _pbDocument$[ebp], 0

; 18660: 	DWORD cbData = 0, cbDocument = 0;

	mov	DWORD PTR _cbData$[ebp], 0
	mov	DWORD PTR _cbDocument$[ebp], 0

; 18661: 	char *varprop[1];
; 18662: 	BSTR bstrPropName, bstrPropValue;
; 18663: 	unsigned char *bareFileName=NULL;

	mov	DWORD PTR _bareFileName$[ebp], 0

; 18664: 	xmlValidCtxtPtr ctxt=NULL;

	mov	DWORD PTR _ctxt$[ebp], 0

; 18665: 	xmlDtdPtr dtd=NULL;

	mov	DWORD PTR _dtd$[ebp], 0

; 18666: 
; 18667: #ifdef WIN32
; 18668: 	GUID sigGuid;
; 18669: #else
; 18670: 	uuid_t sigGuid;
; 18671: #endif
; 18672: 	char objectId[50];
; 18673: 
; 18674: 	if ((AttachedObjectCount == 0) && (DetachedObjectCount == 0))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+80], 0
	jne	SHORT $L215870
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $L215870

; 18675: 		return NULL;

	xor	eax, eax
	jmp	$L215851
$L215870:

; 18676: 
; 18677: 	doc = xmlNewDoc((const unsigned char *)"1.0");

	push	OFFSET FLAT:$SG215872
	call	_xmlNewDoc
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 18678: 
; 18679: 	// DTD
; 18680:     dtd = xmlNewDtd(doc, BAD_CAST "SignatureEnvelope",NULL,NULL);

	push	0
	push	0
	push	OFFSET FLAT:$SG215874
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDtd
	add	esp, 16					; 00000010H
	mov	DWORD PTR _dtd$[ebp], eax

; 18681: 	// create DTD validation context
; 18682:     ctxt = xmlNewValidCtxt();

	call	_xmlNewValidCtxt
	mov	DWORD PTR _ctxt$[ebp], eax

; 18683: 	// add ATTLIST
; 18684: 	xmlAddAttributeDecl(ctxt, dtd, BAD_CAST "ifmc:SignedObject",
; 18685:                     BAD_CAST "Id", NULL, 
; 18686: 					XML_ATTRIBUTE_ID, XML_ATTRIBUTE_IMPLIED, 
; 18687: 					NULL, NULL);		    

	push	0
	push	0
	push	3
	push	2
	push	0
	push	OFFSET FLAT:$SG215877
	push	OFFSET FLAT:$SG215878
	mov	eax, DWORD PTR _dtd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlAddAttributeDecl
	add	esp, 36					; 00000024H

; 18688: 	
; 18689:     xmlAddChild((xmlNodePtr) doc, (xmlNodePtr) dtd);

	mov	edx, DWORD PTR _dtd$[ebp]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8

; 18690: 	xmlFreeValidCtxt(ctxt);

	mov	ecx, DWORD PTR _ctxt$[ebp]
	push	ecx
	call	_xmlFreeValidCtxt
	add	esp, 4

; 18691: 
; 18692: 	// document, namespace, element name, element content
; 18693: 	cur = xmlNewDocNode(doc,NULL,(const unsigned char *)"SignatureEnvelope",NULL);

	push	0
	push	OFFSET FLAT:$SG215882
	push	0
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNewDocNode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _cur$[ebp], eax

; 18694: 
; 18695: 	// if you want any namespace definition here
; 18696: 	curNs = xmlNewNs(cur,(const unsigned char *)"http://www.infomosaic.net/",(const unsigned char *)"ifmc");

	push	OFFSET FLAT:$SG215885
	push	OFFSET FLAT:$SG215886
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _curNs$[ebp], eax

; 18697: 	xmlSetNs(cur,curNs);

	mov	ecx, DWORD PTR _curNs$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlSetNs
	add	esp, 8

; 18698: 
; 18699: 	// add root element
; 18700: 	xmlDocSetRootElement(doc,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlDocSetRootElement
	add	esp, 8

; 18701: 	rootNode = cur;

	mov	edx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _rootNode$[ebp], edx

; 18702: 
; 18703: 	/*
; 18704: 	* Signature
; 18705: 	*/
; 18706: 
; 18707: 	cur = xmlNewNode(NULL,(const unsigned char *)"Signature"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215888
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18708: 	*sigNode = cur;

	mov	eax, DWORD PTR _sigNode$[ebp]
	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [eax], ecx

; 18709: 	if (charSigId != NULL)

	cmp	DWORD PTR _charSigId$[ebp], 0
	je	SHORT $L215889

; 18710: 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)charSigId);

	mov	edx, DWORD PTR _charSigId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG215892
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215889:

; 18711: 	sigNs = xmlNewNs(cur,(const unsigned char *)SIGNATURE_URI,(const unsigned char *)"ds");

	push	OFFSET FLAT:$SG215895
	push	OFFSET FLAT:$SG215896
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sigNs$[ebp], eax

; 18712: 	xmlSetNs(cur,sigNs);

	mov	edx, DWORD PTR _sigNs$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlSetNs
	add	esp, 8

; 18713: 	parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 18714: 
; 18715: 	/*
; 18716: 	* SignedInfo
; 18717: 	*/
; 18718: 	cur = xmlNewNode(NULL,(const unsigned char *)"SignedInfo"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215898
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18719: 	*signedInfoNode = cur;

	mov	edx, DWORD PTR _signedInfoNode$[ebp]
	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR [edx], eax

; 18720: 	cur = xmlAddChild(parent,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18721: 	parent = cur;

	mov	eax, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], eax

; 18722: 
; 18723: 	/*
; 18724: 		* Canonicalization Method
; 18725: 	*/
; 18726: 	cur = xmlNewNode(NULL,(const unsigned char *)"CanonicalizationMethod");

	push	OFFSET FLAT:$SG215900
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18727: 	switch(CanonicalizationMethod)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+3336]
	mov	DWORD PTR tv156[ebp], edx
	cmp	DWORD PTR tv156[ebp], 3
	ja	SHORT $L215925
	mov	eax, DWORD PTR tv156[ebp]
	jmp	DWORD PTR $L223121[eax*4]
$L215905:

; 18728: 	{
; 18729: 		case WITH_COMMENTS:
; 18730: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG215908
	push	OFFSET FLAT:$SG215909
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18731: 			break;

	jmp	SHORT $L215902
$L215910:

; 18732: 		case WITHOUT_COMMENTS:
; 18733: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_NO_COMM);

	push	OFFSET FLAT:$SG215913
	push	OFFSET FLAT:$SG215914
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18734: 			break;

	jmp	SHORT $L215902
$L215915:

; 18735: 		case EXC_WITH_COMMENTS:
; 18736: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG215918
	push	OFFSET FLAT:$SG215919
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18737: 			break;

	jmp	SHORT $L215902
$L215920:

; 18738: 		case EXC_WITHOUT_COMMENTS:
; 18739: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG215923
	push	OFFSET FLAT:$SG215924
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18740: 			break;

	jmp	SHORT $L215902
$L215925:

; 18741: 		default:
; 18742: 			xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_XML_WITH_COMM);

	push	OFFSET FLAT:$SG215928
	push	OFFSET FLAT:$SG215929
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215902:

; 18743: 	}
; 18744: 	cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18745: 	if (signerCertChain == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3412], 0
	jne	SHORT $L215930

; 18746: 	{//We assume RSA Algorithm will be used if no signer certificate info is provided
; 18747: 		cur = xmlNewNode(NULL, (const unsigned char *)"SignatureMethod");

	push	OFFSET FLAT:$SG215932
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18748: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_RSAWITHSHA1);

	push	OFFSET FLAT:$SG215935
	push	OFFSET FLAT:$SG215936
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18749: 		cur = xmlAddChild(parent, cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _parent$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax
$L215930:

; 18750: 	}
; 18751: 	for (UINT i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$215937[ebp], 0
	jmp	SHORT $L215938
$L215939:
	mov	eax, DWORD PTR _i$215937[ebp]
	add	eax, 1
	mov	DWORD PTR _i$215937[ebp], eax
$L215938:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$215937[ebp]
	cmp	edx, DWORD PTR [ecx+80]
	jae	$L215940

; 18752: 	{
; 18753: #ifdef WIN32
; 18754: 		CoCreateGuid(&sigGuid);

	mov	esi, esp
	lea	eax, DWORD PTR _sigGuid$[ebp]
	push	eax
	call	DWORD PTR __imp__CoCreateGuid@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18755: 		GuidToString(&sigGuid, &objectId[1]);

	lea	ecx, DWORD PTR _objectId$[ebp+1]
	push	ecx
	lea	edx, DWORD PTR _sigGuid$[ebp]
	push	edx
	call	?GuidToString@@YAXPAU_GUID@@PAD@Z	; GuidToString
	add	esp, 8

; 18756: #else
; 18757: 		uuid_generate(sigGuid);
; 18758: 		uuid_unparse(sigGuid, &objectId[1]);
; 18759: #endif
; 18760: 		objectId[0] = '#';

	mov	BYTE PTR _objectId$[ebp], 35		; 00000023H

; 18761: 
; 18762: 		if ((pbDocument = xsDereferenceBstrURI(
; 18763: 			AttachedObjectList[i],
; 18764: 			&cbDocument))==NULL) // (in/out) size of data

	lea	eax, DWORD PTR _cbDocument$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR _i$215937[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?xsDereferenceBstrURI@CSignature@@QAEPAEPAGPAK@Z ; CSignature::xsDereferenceBstrURI
	mov	DWORD PTR _pbDocument$[ebp], eax
	cmp	DWORD PTR _pbDocument$[ebp], 0
	jne	SHORT $L215941

; 18765: 		{
; 18766: 				setError(SigHandle, DEREF_URI_ERROR);

	push	21					; 00000015H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+692]
	push	eax
	call	_setError
	add	esp, 8

; 18767: 				xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 18768: 				return NULL;

	xor	eax, eax
	jmp	$L215851
$L215941:

; 18769: 		}
; 18770: 		// Base64 encode
; 18771: 		cbData = base64encodeSize(cbDocument);

	mov	edx, DWORD PTR _cbDocument$[ebp]
	push	edx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 18772: 		// allocate memory
; 18773: 		if (pbData) zFree (pbData);

	cmp	DWORD PTR _pbData$[ebp], 0
	je	SHORT $L215942
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_rFree
	add	esp, 4
$L215942:

; 18774: 		pbData = NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 18775: 		if(!(pbData = (BYTE *)zMalloc(cbData+1)))

	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _pbData$[ebp], eax
	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L215944

; 18776: 		{
; 18777: 			zFree(pbDocument);

	mov	edx, DWORD PTR _pbDocument$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 18778: 			setError(SigHandle, MEMORY_FAULT);

	push	7
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+692]
	push	ecx
	call	_setError
	add	esp, 8

; 18779: 			xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 18780: 			return NULL;

	xor	eax, eax
	jmp	$L215851
$L215944:

; 18781: 		}
; 18782: 		if (base64encode(pbDocument,cbDocument,(unsigned char*)pbData,cbData)==-1) 

	mov	eax, DWORD PTR _cbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cbDocument$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbDocument$[ebp]
	push	eax
	call	_base64encode
	add	esp, 16					; 00000010H
	cmp	eax, -1
	jne	SHORT $L215946

; 18783: 		{
; 18784: 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+692]
	push	edx
	call	_setError
	add	esp, 8

; 18785: 			zFree(pbDocument);

	mov	eax, DWORD PTR _pbDocument$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18786: 			zFree(pbData);

	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 18787: 			xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 18788: 			return NULL;

	xor	eax, eax
	jmp	$L215851
$L215946:

; 18789: 		}
; 18790: 		*(pbData+cbData)='\0';

	mov	eax, DWORD PTR _pbData$[ebp]
	add	eax, DWORD PTR _cbData$[ebp]
	mov	BYTE PTR [eax], 0

; 18791: 		zFree(pbDocument);

	mov	ecx, DWORD PTR _pbDocument$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 18792: 		varprop[0] = NULL;

	mov	DWORD PTR _varprop$[ebp], 0

; 18793: 		varprop[0] = (char *)zMalloc(MAX_PATH*2);

	push	520					; 00000208H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _varprop$[ebp], eax

; 18794: 		memset(varprop[0],0,MAX_PATH*2);

	push	520					; 00000208H
	push	0
	mov	edx, DWORD PTR _varprop$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 18795: 		sprintf(varprop[0], "URI_%s",&objectId[1]);

	lea	eax, DWORD PTR _objectId$[ebp+1]
	push	eax
	push	OFFSET FLAT:$SG215948
	mov	ecx, DWORD PTR _varprop$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18796: 		bareFileName = (unsigned char *)xsRemovePath((const char *)AttachedObjectList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _i$215937[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_xsRemovePath
	add	esp, 4
	mov	DWORD PTR _bareFileName$[ebp], eax

; 18797: 		bstrPropName = A2WBSTR((LPCSTR)varprop[0]);

	push	-1
	mov	eax, DWORD PTR _varprop$[ebp]
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropName$[ebp], eax

; 18798: 		bstrPropValue = A2WBSTR((LPCSTR)bareFileName);

	push	-1
	mov	ecx, DWORD PTR _bareFileName$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _bstrPropValue$[ebp], eax

; 18799: 		ChangeOrAddProperty(bstrPropName, bstrPropValue);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrPropName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18800: 		SysFreeString(bstrPropName);

	mov	esi, esp
	mov	ecx, DWORD PTR _bstrPropName$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18801: 		SysFreeString(bstrPropValue);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrPropValue$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18802: 
; 18803: 		/*
; 18804: 		* SignedObject
; 18805: 		*/
; 18806: 
; 18807: 		cur = xmlNewNode(curNs,(const unsigned char *)"SignedObject"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215954
	mov	eax, DWORD PTR _curNs$[ebp]
	push	eax
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18808: 		cur = xmlAddChild(rootNode,cur);

	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rootNode$[ebp]
	push	edx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18809: 		xmlNewProp(cur, (const unsigned char *)"Encoding", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG215957
	push	OFFSET FLAT:$SG215958
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18810: 		xmlNewProp(cur, (const unsigned char *)"Id", (const unsigned char *)&objectId[1]);

	lea	ecx, DWORD PTR _objectId$[ebp+1]
	push	ecx
	push	OFFSET FLAT:$SG215961
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18811: 		xmlNewProp(cur, (const unsigned char *)"FileName", (const unsigned char *)bareFileName);

	mov	eax, DWORD PTR _bareFileName$[ebp]
	push	eax
	push	OFFSET FLAT:$SG215964
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18812: 		xmlNodeSetContent(cur,(const unsigned char *)pbData);

	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNodeSetContent
	add	esp, 8

; 18813: 		zFree(pbData);

	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 18814: 		pbData = NULL;

	mov	DWORD PTR _pbData$[ebp], 0

; 18815: 
; 18816: 		/*
; 18817: 		* Add Reference
; 18818: 		*/
; 18819: 		cur = xmlNewNode(NULL,(const unsigned char *)"Reference"); // Using the parent element's name space

	push	OFFSET FLAT:$SG215967
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18820: 		cur = xmlAddChild(*signedInfoNode,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _signedInfoNode$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18821: 
; 18822: 		xmlNewProp(cur, (const unsigned char *)"URI", (const unsigned char *)objectId);

	lea	edx, DWORD PTR _objectId$[ebp]
	push	edx
	push	OFFSET FLAT:$SG215970
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18823: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 18824: 
; 18825: 		/*
; 18826: 		* Transforms
; 18827: 		*/
; 18828: 
; 18829: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transforms");

	push	OFFSET FLAT:$SG215972
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18830: 		cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18831: 		parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 18832: 
; 18833: 		/*
; 18834: 		* Transform
; 18835: 		*/
; 18836: 
; 18837: 		if ((CanonicalizationMethod == EXC_WITH_COMMENTS) ||
; 18838: 			(CanonicalizationMethod == EXC_WITHOUT_COMMENTS))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	je	SHORT $L215974
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	$L215973
$L215974:

; 18839: 		{
; 18840: 			cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG215976
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18841: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 3
	jne	SHORT $L215977

; 18842: 			{
; 18843: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_WITH_COMM);

	push	OFFSET FLAT:$SG215980
	push	OFFSET FLAT:$SG215981
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18844: 			}
; 18845: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L215982
$L215977:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+3336], 2
	jne	SHORT $L215982

; 18846: 			{
; 18847: 				xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_CANON_EXC_NO_COMM);

	push	OFFSET FLAT:$SG215986
	push	OFFSET FLAT:$SG215987
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215982:

; 18848: 			}
; 18849: 			cur = xmlAddChild(parent,cur);

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18850: 			parent = cur;

	mov	ecx, DWORD PTR _cur$[ebp]
	mov	DWORD PTR _parent$[ebp], ecx

; 18851: 			if (CanonicalizationMethod == EXC_WITH_COMMENTS)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+3336], 3
	jne	SHORT $L215988

; 18852: 			{
; 18853: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG215990
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18854: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_WITH_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG215993
	push	OFFSET FLAT:$SG215994
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 18855: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	push	edx
	push	OFFSET FLAT:$SG215997
	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18856: 			}
; 18857: 			else if (CanonicalizationMethod == EXC_WITHOUT_COMMENTS)

	jmp	SHORT $L215998
$L215988:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+3336], 2
	jne	SHORT $L215998

; 18858: 			{
; 18859: 				cur = xmlNewNode(NULL,(const unsigned char *)"InclusiveNamespaces");

	push	OFFSET FLAT:$SG216001
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18860: 				xmlNewNs(cur,(const unsigned char *)ALG_CANON_EXC_NO_COMM,(const unsigned char *)"ec");

	push	OFFSET FLAT:$SG216004
	push	OFFSET FLAT:$SG216005
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewNs
	add	esp, 12					; 0000000cH

; 18861: 				xmlNewProp(cur, (const unsigned char *)"PrefixList", (const unsigned char *)InclusiveNamespaceList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	push	OFFSET FLAT:$SG216008
	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH
$L215998:

; 18862: 			}
; 18863: 			cur = xmlAddChild(parent,cur);

	mov	eax, DWORD PTR _cur$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parent$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18864: 			parent = parent->parent;

	mov	edx, DWORD PTR _parent$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR _parent$[ebp], eax
$L215973:

; 18865: 		}
; 18866: 
; 18867: 		cur = xmlNewNode(NULL,(const unsigned char *)"Transform");

	push	OFFSET FLAT:$SG216010
	push	0
	call	_xmlNewNode
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18868: 		xmlNewProp(cur, (const unsigned char *)"Algorithm", (const unsigned char *)ALG_BASE64);

	push	OFFSET FLAT:$SG216013
	push	OFFSET FLAT:$SG216014
	mov	ecx, DWORD PTR _cur$[ebp]
	push	ecx
	call	_xmlNewProp
	add	esp, 12					; 0000000cH

; 18869: 		cur = xmlAddChild(parent,cur);		

	mov	edx, DWORD PTR _cur$[ebp]
	push	edx
	mov	eax, DWORD PTR _parent$[ebp]
	push	eax
	call	_xmlAddChild
	add	esp, 8
	mov	DWORD PTR _cur$[ebp], eax

; 18870: 
; 18871: 
; 18872: 		if (varprop[0]) zFree(varprop[0]);

	cmp	DWORD PTR _varprop$[ebp], 0
	je	SHORT $L216015
	mov	ecx, DWORD PTR _varprop$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L216015:

; 18873: 		varprop[0] = NULL;

	mov	DWORD PTR _varprop$[ebp], 0

; 18874: 	}

	jmp	$L215939
$L215940:

; 18875: 	xmlAddChild(rootNode,*sigNode);

	mov	edx, DWORD PTR _sigNode$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _rootNode$[ebp]
	push	ecx
	call	_xmlAddChild
	add	esp, 8

; 18876: 	for (UINT i=0; i < AttachedObjectCount; i++)

	mov	DWORD PTR _i$216016[ebp], 0
	jmp	SHORT $L216017
$L216018:
	mov	edx, DWORD PTR _i$216016[ebp]
	add	edx, 1
	mov	DWORD PTR _i$216016[ebp], edx
$L216017:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$216016[ebp]
	cmp	ecx, DWORD PTR [eax+80]
	jae	SHORT $L216019

; 18877: 	{
; 18878: 		if (AttachedObjectList[i] != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _i$216016[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L216020

; 18879: 			SysFreeString(AttachedObjectList[i]);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	esi, esp
	mov	ecx, DWORD PTR _i$216016[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L216020:

; 18880: 
; 18881: 	}

	jmp	SHORT $L216018
$L216019:

; 18882: 	zFree(AttachedObjectList);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	_rFree
	add	esp, 4

; 18883: 	AttachedObjectCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 18884: 	AttachedObjectList = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 18885: 	return doc;

	mov	eax, DWORD PTR _doc$[ebp]
$L215851:

; 18886: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223120
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 184				; 000000b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L223120:
	DD	4
	DD	$L223119
$L223119:
	DD	-52					; ffffffccH
	DD	4
	DD	$L223114
	DD	-64					; ffffffc0H
	DD	4
	DD	$L223115
	DD	-108					; ffffff94H
	DD	16					; 00000010H
	DD	$L223116
	DD	-168					; ffffff58H
	DD	50					; 00000032H
	DD	$L223117
$L223117:
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	106					; 0000006aH
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	73					; 00000049H
	DB	100					; 00000064H
	DB	0
$L223116:
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	103					; 00000067H
	DB	71					; 00000047H
	DB	117					; 00000075H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L223115:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	0
$L223114:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L223121:
	DD	$L215910
	DD	$L215905
	DD	$L215920
	DD	$L215915
?PrepareSignatureEnvelopeFromObjects@CSignature@@QAEPAU_xmlDoc@@PADPAPAU_xmlNode@@1@Z ENDP ; CSignature::PrepareSignatureEnvelopeFromObjects
_TEXT	ENDS
PUBLIC	?getMaintExpiryYear@CLicense@@QBEHXZ		; CLicense::getMaintExpiryYear
PUBLIC	?getMaintExpiryMonth@CLicense@@QBEHXZ		; CLicense::getMaintExpiryMonth
PUBLIC	?getMaintExpiryDay@CLicense@@QBEHXZ		; CLicense::getMaintExpiryDay
PUBLIC	?isClientLinux@CLicense@@QBEHXZ			; CLicense::isClientLinux
PUBLIC	?isClientWindows@CLicense@@QBEHXZ		; CLicense::isClientWindows
PUBLIC	?isClientSolaris@CLicense@@QBEHXZ		; CLicense::isClientSolaris
PUBLIC	?isClientMac@CLicense@@QBEHXZ			; CLicense::isClientMac
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
xdata$x	SEGMENT
$T223155 DD	0ffffffffH
	DD	FLAT:$L223130
	DD	00H
	DD	FLAT:$L223131
	DD	01H
	DD	FLAT:$L223132
	DD	02H
	DD	FLAT:$L223133
	DD	03H
	DD	FLAT:$L223134
	DD	04H
	DD	FLAT:$L223135
	DD	05H
	DD	FLAT:$L223136
	DD	01H
	DD	FLAT:$L223136
	DD	07H
	DD	FLAT:$L223135
	DD	08H
	DD	FLAT:$L223134
	DD	09H
	DD	FLAT:$L223133
	DD	07H
	DD	FLAT:$L223137
	DD	0bH
	DD	FLAT:$L223138
	DD	0bH
	DD	FLAT:$L223139
$T223141 DD	019930520H
	DD	0eH
	DD	FLAT:$T223155
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv426 = -956						; size = 4
tv152 = -952						; size = 4
tv422 = -948						; size = 4
tv434 = -944						; size = 4
tv420 = -940						; size = 4
tv433 = -936						; size = 4
tv418 = -932						; size = 4
tv65 = -928						; size = 4
tv416 = -924						; size = 4
tv68 = -920						; size = 4
$T223129 = -916						; size = 4
$T223128 = -912						; size = 28
$T223127 = -884						; size = 28
$T223126 = -856						; size = 28
$T223125 = -828						; size = 28
$T223124 = -800						; size = 28
_i$216112 = -772					; size = 4
_dateStr$ = -768					; size = 4
_floatingLicenseStr$ = -760				; size = 4
_i$216069 = -752					; size = 4
_pfxX509Cert$ = -744					; size = 4
_pfxPassword$ = -736					; size = 4
_pfxDataBuffer$ = -732					; size = 4
_charPfxPassword$ = -728				; size = 4
_oSize$ = -724						; size = 4
_iSize$ = -720						; size = 4
_junkValue$ = -716					; size = 4
_date$ = -708						; size = 28
_junk$ = -672						; size = 28
_flLic$ = -636						; size = 28
_ampm$ = -604						; size = 4
_propValue$ = -596					; size = 4
_propName$ = -584					; size = 4
_buffer$ = -572						; size = 512
_t$ = -52						; size = 16
_tmpCurrentCertificate$ = -32				; size = 4
_tmpExcludeSignerCertificateFlag$ = -28			; size = 4
_tmpBase64EncodeXML$ = -24				; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?createSgts@CSignature@@QAEPAGXZ PROC NEAR		; CSignature::createSgts
; _this$ = ecx

; 18889: {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?createSgts@CSignature@@QAEPAGXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 944				; 000003b0H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-956]
	mov	ecx, 236				; 000000ecH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 18890: 	BOOL tmpBase64EncodeXML, tmpExcludeSignerCertificateFlag, tmpCurrentCertificate;
; 18891: 	SYSTEMTIME t;
; 18892: 	char buffer[BUFSIZ];
; 18893: 	CComBSTR propName, propValue;

	lea	ecx, DWORD PTR _propName$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 18894: //DebugBreak();
; 18895: #ifdef WIN32
; 18896: 	GetSystemTime(&t);

	mov	esi, esp
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18897: #else
; 18898: 	GetSystemTimeLinux(&t);
; 18899: #endif
; 18900: 	char *ampm;
; 18901: 	if (t.wHour >= 12)

	movzx	ecx, WORD PTR _t$[ebp+8]
	cmp	ecx, 12					; 0000000cH
	jl	SHORT $L216032

; 18902: 		ampm = "pm";

	mov	DWORD PTR _ampm$[ebp], OFFSET FLAT:$SG216033

; 18903: 	else

	jmp	SHORT $L216034
$L216032:

; 18904: 		ampm = "am";

	mov	DWORD PTR _ampm$[ebp], OFFSET FLAT:$SG216035
$L216034:

; 18905: 	sprintf((char *)buffer, "%02d/%02d/%04d %02d:%02d:%02d %s", t.wMonth, t.wDay, t.wYear, t.wHour, t.wMinute, t.wSecond, ampm);

	mov	edx, DWORD PTR _ampm$[ebp]
	push	edx
	movzx	eax, WORD PTR _t$[ebp+12]
	push	eax
	movzx	ecx, WORD PTR _t$[ebp+10]
	push	ecx
	movzx	edx, WORD PTR _t$[ebp+8]
	push	edx
	movzx	eax, WORD PTR _t$[ebp]
	push	eax
	movzx	ecx, WORD PTR _t$[ebp+6]
	push	ecx
	movzx	edx, WORD PTR _t$[ebp+2]
	push	edx
	push	OFFSET FLAT:$SG216037
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 36					; 00000024H

; 18906: 
; 18907: 	tmpBase64EncodeXML = Base64EncodeXML;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+2180]
	mov	DWORD PTR _tmpBase64EncodeXML$[ebp], edx

; 18908: 	tmpExcludeSignerCertificateFlag = ExcludeSignerCertificateFlag;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+1820]
	mov	DWORD PTR _tmpExcludeSignerCertificateFlag$[ebp], ecx

; 18909: 	tmpCurrentCertificate = CurrentCertificate;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	mov	DWORD PTR _tmpCurrentCertificate$[ebp], eax

; 18910: 
; 18911: 	string flLic = FL_LIC1 + FL_LIC2 + FL_LIC3 + FL_LIC4 + FL_LIC5 + FL_LIC6;

	push	OFFSET FLAT:?FL_LIC2@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC2
	push	OFFSET FLAT:?FL_LIC1@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC1
	lea	ecx, DWORD PTR $T223124[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv68[ebp], eax
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR tv416[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET FLAT:?FL_LIC3@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC3
	mov	eax, DWORD PTR tv416[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223125[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv418[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET FLAT:?FL_LIC4@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC4
	mov	eax, DWORD PTR tv418[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223126[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv433[ebp], eax
	mov	edx, DWORD PTR tv433[ebp]
	mov	DWORD PTR tv420[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	OFFSET FLAT:?FL_LIC5@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC5
	mov	eax, DWORD PTR tv420[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223127[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv434[ebp], eax
	mov	edx, DWORD PTR tv434[ebp]
	mov	DWORD PTR tv422[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET FLAT:?FL_LIC6@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC6
	mov	eax, DWORD PTR tv422[ebp]
	push	eax
	lea	ecx, DWORD PTR _flLic$[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T223127[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	lea	ecx, DWORD PTR $T223126[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T223125[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T223124[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 18912: 	string junk =  FL_LIC7 + FL_LIC9;

	push	OFFSET FLAT:?FL_LIC9@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC9
	push	OFFSET FLAT:?FL_LIC7@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC7
	lea	edx, DWORD PTR _junk$[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH

; 18913: 	junk += FL_LIC8 + FL_LIC10;

	push	OFFSET FLAT:?FL_LIC10@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC10
	push	OFFSET FLAT:?FL_LIC8@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC8
	lea	eax, DWORD PTR $T223128[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv152[ebp], eax
	mov	ecx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv426[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	edx, DWORD PTR tv426[ebp]
	push	edx
	lea	ecx, DWORD PTR _junk$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR $T223128[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 18914: 	string date = (char *)buffer; //timeStr.GetString();

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _date$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH

; 18915: 	unsigned char *junkValue = (unsigned char *)"SW5mb21vc2FpY1NlY3VyZVdlYnNpZ25QYXNzd29yZA==";

	mov	DWORD PTR _junkValue$[ebp], OFFSET FLAT:$SG216058

; 18916: 
; 18917: 	unsigned int iSize = strlen((const char *)junkValue);

	mov	ecx, DWORD PTR _junkValue$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _iSize$[ebp], eax

; 18918: 	int oSize = base64decodeSize(iSize);

	mov	edx, DWORD PTR _iSize$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _oSize$[ebp], eax

; 18919: 	unsigned char *charPfxPassword = (unsigned char *)zMalloc(oSize + 1);

	mov	eax, DWORD PTR _oSize$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _charPfxPassword$[ebp], eax

; 18920: 	memset(charPfxPassword, 0, oSize +1);

	mov	ecx, DWORD PTR _oSize$[ebp]
	add	ecx, 1
	push	ecx
	push	0
	mov	edx, DWORD PTR _charPfxPassword$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 18921: 	base64decode(junkValue, charPfxPassword, oSize + 1);

	mov	eax, DWORD PTR _oSize$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _charPfxPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _junkValue$[ebp]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH

; 18922: 	Base64EncodeXML = 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2180], 1

; 18923: 	ExcludeSignerCertificateFlag = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+1820], 2

; 18924: 	BSTR pfxDataBuffer = A2WBSTR((LPCSTR)flLic.c_str());

	push	-1
	lea	ecx, DWORD PTR _flLic$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _pfxDataBuffer$[ebp], eax

; 18925: 	BSTR pfxPassword = A2WBSTR((LPCSTR) charPfxPassword);

	push	-1
	mov	edx, DWORD PTR _charPfxPassword$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _pfxPassword$[ebp], eax

; 18926: 	zFree(charPfxPassword);

	mov	eax, DWORD PTR _charPfxPassword$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 18927: 	BSTR pfxX509Cert=NULL;

	mov	DWORD PTR _pfxX509Cert$[ebp], 0

; 18928: 	SetActivePFXB64Data(pfxDataBuffer, pfxPassword, &pfxX509Cert);

	mov	esi, esp
	lea	ecx, DWORD PTR _pfxX509Cert$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfxPassword$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfxDataBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+700]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18929: 	SysFreeString(pfxX509Cert);

	mov	esi, esp
	mov	ecx, DWORD PTR _pfxX509Cert$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18930: 	SysFreeString(pfxDataBuffer);

	mov	esi, esp
	mov	edx, DWORD PTR _pfxDataBuffer$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18931: 	SysFreeString(pfxPassword);

	mov	esi, esp
	mov	eax, DWORD PTR _pfxPassword$[ebp]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18932: 
; 18933: 	for (int i=0; i<PropertyCount; i++)

	mov	DWORD PTR _i$216069[ebp], 0
	jmp	SHORT $L216070
$L216071:
	mov	ecx, DWORD PTR _i$216069[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$216069[ebp], ecx
$L216070:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$216069[ebp]
	cmp	eax, DWORD PTR [edx+100]
	jge	SHORT $L216072

; 18934: 	{
; 18935: 		if (Properties[i] != NULL)

	mov	ecx, DWORD PTR _i$216069[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+ecx*4+136], 0
	je	SHORT $L216073

; 18936: 		{
; 18937: 			zFree(Properties[i]);

	mov	eax, DWORD PTR _i$216069[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+136]
	push	edx
	call	_rFree
	add	esp, 4

; 18938: 			Properties[i] = NULL;

	mov	eax, DWORD PTR _i$216069[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+eax*4+136], 0
$L216073:

; 18939: 		}
; 18940: 	}

	jmp	SHORT $L216071
$L216072:

; 18941: 	PropertyCount = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0

; 18942: 
; 18943: 	sprintf((char *)buffer, "%d", LicObj.getMaintExpiryYear());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getMaintExpiryYear@CLicense@@QBEHXZ	; CLicense::getMaintExpiryYear
	push	eax
	push	OFFSET FLAT:$SG216075
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18944: 	propName = (const char *)"MaintExpiryYear";

	push	OFFSET FLAT:$SG216077
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18945: 	propValue = (const char *)buffer;

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18946: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18947: 
; 18948: 	sprintf((char *)buffer, "%d", LicObj.getMaintExpiryMonth());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getMaintExpiryMonth@CLicense@@QBEHXZ	; CLicense::getMaintExpiryMonth
	push	eax
	push	OFFSET FLAT:$SG216080
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18949: 	propName = (const char *)"MaintExpiryMonth";

	push	OFFSET FLAT:$SG216082
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18950: 	propValue = (const char *)buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18951: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18952: 
; 18953: 	sprintf((char *)buffer, "%d", LicObj.getMaintExpiryDay());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?getMaintExpiryDay@CLicense@@QBEHXZ	; CLicense::getMaintExpiryDay
	push	eax
	push	OFFSET FLAT:$SG216085
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18954: 	propName = (const char *)"MaintExpiryDay";

	push	OFFSET FLAT:$SG216087
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18955: 	propValue = (const char *)buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18956: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18957: 
; 18958: 	sprintf((char *)buffer, "%d", LicObj.isClientLinux());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?isClientLinux@CLicense@@QBEHXZ		; CLicense::isClientLinux
	push	eax
	push	OFFSET FLAT:$SG216090
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18959: 	propName = (const char *)"LinuxClient";

	push	OFFSET FLAT:$SG216092
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18960: 	propValue = (const char *)buffer;

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18961: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18962: 
; 18963: 	sprintf((char *)buffer, "%d", LicObj.isClientWindows());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?isClientWindows@CLicense@@QBEHXZ	; CLicense::isClientWindows
	push	eax
	push	OFFSET FLAT:$SG216095
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18964: 	propName = (const char *)"WindowsClient";

	push	OFFSET FLAT:$SG216097
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18965: 	propValue = (const char *)buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18966: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18967: 
; 18968: 	sprintf((char *)buffer, "%d", LicObj.isClientSolaris());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?isClientSolaris@CLicense@@QBEHXZ	; CLicense::isClientSolaris
	push	eax
	push	OFFSET FLAT:$SG216100
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18969: 	propName = (const char *)"SolarisClient";

	push	OFFSET FLAT:$SG216102
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18970: 	propValue = (const char *)buffer;

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18971: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR [ecx+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18972: 
; 18973: 	sprintf((char *)buffer, "%d", LicObj.isClientMac());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	?isClientMac@CLicense@@QBEHXZ		; CLicense::isClientMac
	push	eax
	push	OFFSET FLAT:$SG216105
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 18974: 	propName = (const char *)"MacClient";

	push	OFFSET FLAT:$SG216107
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18975: 	propValue = (const char *)buffer;

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??4CComBSTR@ATL@@QAEAAV01@PBD@Z		; ATL::CComBSTR::operator=

; 18976: 	ChangeOrAddProperty(propName, propValue);

	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	esi, esp
	push	eax
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+436]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18977: 
; 18978: 
; 18979: 	BSTR floatingLicenseStr=NULL;

	mov	DWORD PTR _floatingLicenseStr$[ebp], 0

; 18980: 	BSTR dateStr = A2WBSTR((LPCSTR) date.c_str());

	push	-1
	lea	ecx, DWORD PTR _date$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	DWORD PTR _dateStr$[ebp], eax

; 18981: 	SignDataStr(dateStr, &floatingLicenseStr);

	mov	esi, esp
	lea	edx, DWORD PTR _floatingLicenseStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _dateStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx+448]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18982: 	SysFreeString(dateStr);

	mov	esi, esp
	mov	ecx, DWORD PTR _dateStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 18983: 	Base64EncodeXML = tmpBase64EncodeXML;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpBase64EncodeXML$[ebp]
	mov	DWORD PTR [edx+2180], eax

; 18984: 	ExcludeSignerCertificateFlag = tmpExcludeSignerCertificateFlag;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpExcludeSignerCertificateFlag$[ebp]
	mov	DWORD PTR [ecx+1820], edx

; 18985: 	CurrentCertificate = tmpCurrentCertificate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpCurrentCertificate$[ebp]
	mov	DWORD PTR [eax+120], ecx

; 18986: 
; 18987: 	for (int i=0; i<PropertyCount; i++)

	mov	DWORD PTR _i$216112[ebp], 0
	jmp	SHORT $L216113
$L216114:
	mov	edx, DWORD PTR _i$216112[ebp]
	add	edx, 1
	mov	DWORD PTR _i$216112[ebp], edx
$L216113:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _i$216112[ebp]
	cmp	ecx, DWORD PTR [eax+100]
	jge	SHORT $L216115

; 18988: 	{
; 18989: 		if (Properties[i] != NULL)

	mov	edx, DWORD PTR _i$216112[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+edx*4+136], 0
	je	SHORT $L216116

; 18990: 		{
; 18991: 			zFree(Properties[i]);

	mov	ecx, DWORD PTR _i$216112[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+136]
	push	eax
	call	_rFree
	add	esp, 4

; 18992: 			Properties[i] = NULL;

	mov	ecx, DWORD PTR _i$216112[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx*4+136], 0
$L216116:

; 18993: 		}
; 18994: 	}

	jmp	SHORT $L216114
$L216115:

; 18995: 	PropertyCount = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 18996: 
; 18997: 	return floatingLicenseStr;

	mov	ecx, DWORD PTR _floatingLicenseStr$[ebp]
	mov	DWORD PTR $T223129[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	lea	ecx, DWORD PTR _date$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _junk$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _flLic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _propValue$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _propName$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T223129[ebp]

; 18998: }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223154
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 956				; 000003bcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223154:
	DD	9
	DD	$L223153
$L223153:
	DD	-52					; ffffffccH
	DD	16					; 00000010H
	DD	$L223142
	DD	-572					; fffffdc4H
	DD	512					; 00000200H
	DD	$L223143
	DD	-584					; fffffdb8H
	DD	4
	DD	$L223144
	DD	-596					; fffffdacH
	DD	4
	DD	$L223145
	DD	-636					; fffffd84H
	DD	28					; 0000001cH
	DD	$L223146
	DD	-672					; fffffd60H
	DD	28					; 0000001cH
	DD	$L223147
	DD	-708					; fffffd3cH
	DD	28					; 0000001cH
	DD	$L223148
	DD	-744					; fffffd18H
	DD	4
	DD	$L223149
	DD	-760					; fffffd08H
	DD	4
	DD	$L223150
$L223150:
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	103					; 00000067H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L223149:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L223148:
	DB	100					; 00000064H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$L223147:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	0
$L223146:
	DB	102					; 00000066H
	DB	108					; 0000006cH
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L223145:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$L223144:
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L223143:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L223142:
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L223130:
	lea	ecx, DWORD PTR _propName$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L223131:
	lea	ecx, DWORD PTR _propValue$[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L223132:
	lea	ecx, DWORD PTR $T223124[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223133:
	lea	ecx, DWORD PTR $T223125[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223134:
	lea	ecx, DWORD PTR $T223126[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223135:
	lea	ecx, DWORD PTR $T223127[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223136:
	lea	ecx, DWORD PTR _flLic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223137:
	lea	ecx, DWORD PTR _junk$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223138:
	lea	ecx, DWORD PTR $T223128[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L223139:
	lea	ecx, DWORD PTR _date$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?createSgts@CSignature@@QAEPAGXZ:
	mov	eax, OFFSET FLAT:$T223141
	jmp	___CxxFrameHandler
text$x	ENDS
?createSgts@CSignature@@QAEPAGXZ ENDP			; CSignature::createSgts
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.h
;	COMDAT ?getMaintExpiryYear@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaintExpiryYear@CLicense@@QBEHXZ PROC NEAR		; CLicense::getMaintExpiryYear, COMDAT
; _this$ = ecx

; 120  : 	int getMaintExpiryYear() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		return maintExpYear;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 122  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMaintExpiryYear@CLicense@@QBEHXZ ENDP		; CLicense::getMaintExpiryYear
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getMaintExpiryMonth@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaintExpiryMonth@CLicense@@QBEHXZ PROC NEAR		; CLicense::getMaintExpiryMonth, COMDAT
; _this$ = ecx

; 123  : 	int getMaintExpiryMonth() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		return maintExpMon;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]

; 125  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMaintExpiryMonth@CLicense@@QBEHXZ ENDP		; CLicense::getMaintExpiryMonth
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?getMaintExpiryDay@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaintExpiryDay@CLicense@@QBEHXZ PROC NEAR		; CLicense::getMaintExpiryDay, COMDAT
; _this$ = ecx

; 126  : 	int getMaintExpiryDay() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		return maintExpDay;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 128  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMaintExpiryDay@CLicense@@QBEHXZ ENDP		; CLicense::getMaintExpiryDay
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?isClientLinux@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isClientLinux@CLicense@@QBEHXZ PROC NEAR		; CLicense::isClientLinux, COMDAT
; _this$ = ecx

; 130  : 	BOOL isClientLinux() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 131  : 		return linuxClient;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+136]

; 132  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isClientLinux@CLicense@@QBEHXZ ENDP			; CLicense::isClientLinux
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?isClientWindows@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isClientWindows@CLicense@@QBEHXZ PROC NEAR		; CLicense::isClientWindows, COMDAT
; _this$ = ecx

; 134  : 	BOOL isClientWindows() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 		return windowsClient;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+132]

; 136  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isClientWindows@CLicense@@QBEHXZ ENDP			; CLicense::isClientWindows
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?isClientSolaris@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isClientSolaris@CLicense@@QBEHXZ PROC NEAR		; CLicense::isClientSolaris, COMDAT
; _this$ = ecx

; 138  : 	BOOL isClientSolaris() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 		return solarisClient;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+144]

; 140  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isClientSolaris@CLicense@@QBEHXZ ENDP			; CLicense::isClientSolaris
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?isClientMac@CLicense@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isClientMac@CLicense@@QBEHXZ PROC NEAR			; CLicense::isClientMac, COMDAT
; _this$ = ecx

; 142  : 	BOOL isClientMac() const {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return macClient;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+140]

; 144  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?isClientMac@CLicense@@QBEHXZ ENDP			; CLicense::isClientMac
_TEXT	ENDS
PUBLIC	?get_TimeStampFormat@CSignature@@UAGJPAJ@Z	; CSignature::get_TimeStampFormat
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_TimeStampFormat@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_TimeStampFormat

; 19001: {

	push	ebp
	mov	ebp, esp

; 19002: 	*pVal = TimeStampFormat;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+944]
	mov	DWORD PTR [eax], edx

; 19003: 	return S_OK;

	xor	eax, eax

; 19004: }

	pop	ebp
	ret	8
?get_TimeStampFormat@CSignature@@UAGJPAJ@Z ENDP		; CSignature::get_TimeStampFormat
_TEXT	ENDS
PUBLIC	?put_TimeStampFormat@CSignature@@UAGJJ@Z	; CSignature::put_TimeStampFormat
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_TimeStampFormat@CSignature@@UAGJJ@Z PROC NEAR	; CSignature::put_TimeStampFormat

; 19007: {

	push	ebp
	mov	ebp, esp

; 19008: 	TimeStampFormat = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+944], ecx

; 19009: 	return S_OK;

	xor	eax, eax

; 19010: }

	pop	ebp
	ret	8
?put_TimeStampFormat@CSignature@@UAGJJ@Z ENDP		; CSignature::put_TimeStampFormat
_TEXT	ENDS
PUBLIC	?get_TimeStampCritical@CSignature@@UAGJPAJ@Z	; CSignature::get_TimeStampCritical
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pVal$ = 12						; size = 4
?get_TimeStampCritical@CSignature@@UAGJPAJ@Z PROC NEAR	; CSignature::get_TimeStampCritical

; 19013: {

	push	ebp
	mov	ebp, esp

; 19014: 	*pVal = TimeStampCritical;

	mov	eax, DWORD PTR _pVal$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+948]
	mov	DWORD PTR [eax], edx

; 19015: 	return S_OK;

	xor	eax, eax

; 19016: }

	pop	ebp
	ret	8
?get_TimeStampCritical@CSignature@@UAGJPAJ@Z ENDP	; CSignature::get_TimeStampCritical
_TEXT	ENDS
PUBLIC	?put_TimeStampCritical@CSignature@@UAGJJ@Z	; CSignature::put_TimeStampCritical
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = 8						; size = 4
_newVal$ = 12						; size = 4
?put_TimeStampCritical@CSignature@@UAGJJ@Z PROC NEAR	; CSignature::put_TimeStampCritical

; 19019: {

	push	ebp
	mov	ebp, esp

; 19020: 	TimeStampCritical = newVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _newVal$[ebp]
	mov	DWORD PTR [eax+948], ecx

; 19021: 	return S_OK;

	xor	eax, eax

; 19022: }

	pop	ebp
	ret	8
?put_TimeStampCritical@CSignature@@UAGJJ@Z ENDP		; CSignature::put_TimeStampCritical
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ PROC NEAR	; ATL::CSimpleStringT<char,0>::operator char const *, COMDAT
; _this$ = ecx

; 378  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 379  : 		return( m_pszData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 380  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ ENDP		; ATL::CSimpleStringT<char,0>::operator char const *
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z	; ATL::CW2AEX<128>::Init

; 421  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L216157

; 430  : 		{
; 431  : 			free( m_psz );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4
$L216157:

; 432  : 		}
; 433  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 438  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
PUBLIC	?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 796  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	call	?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>

; 797  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >, COMDAT
; _this$ = ecx

; 962  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 963  : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ	; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::~CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >
_TEXT	ENDS
PUBLIC	??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@ ; `string'
PUBLIC	?AtlIsValidString@ATL@@YAHPBDI@Z		; ATL::AtlIsValidString
PUBLIC	?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV
;	COMDAT ??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
CONST	SEGMENT
??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@ DB 'AtlIsVa'
	DB	'lidString( pszFormat )', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT
_argList$ = -4						; size = 4
_this$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format, COMDAT

; 1795 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1796 : 		ATLASSERT( AtlIsValidString( pszFormat ) );

	push	-1
	mov	eax, DWORD PTR _pszFormat$[ebp]
	push	eax
	call	?AtlIsValidString@ATL@@YAHPBDI@Z	; ATL::AtlIsValidString
	add	esp, 8
	test	eax, eax
	jne	SHORT $L223187
	push	OFFSET FLAT:??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
	push	0
	push	1796					; 00000704H
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223187
	int	3
$L223187:

; 1797 : 		
; 1798 : 		va_list argList;
; 1799 : 		va_start( argList, pszFormat );

	lea	edx, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$[ebp], edx

; 1800 : 		FormatV( pszFormat, argList );

	mov	eax, DWORD PTR _argList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV

; 1801 : 		va_end( argList );

	mov	DWORD PTR _argList$[ebp], 0

; 1802 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Format@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::Format
_TEXT	ENDS
EXTRN	__imp__IsBadStringPtrA@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?AtlIsValidString@ATL@@YAHPBDI@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_nMaxLength$ = 12					; size = 4
?AtlIsValidString@ATL@@YAHPBDI@Z PROC NEAR		; ATL::AtlIsValidString, COMDAT

; 72   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 73   : #if defined(_DEBUG)
; 74   : 	if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L77292

; 75   : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L77291
$L77292:

; 76   : 	return ::IsBadStringPtrA(psz, nMaxLength) == 0;

	mov	esi, esp
	mov	eax, DWORD PTR _nMaxLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadStringPtrA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	neg	eax
	sbb	eax, eax
	inc	eax
$L77291:

; 77   : #else
; 78   : 	(nMaxLength);
; 79   : 	return (psz != NULL);
; 80   : #endif
; 81   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?AtlIsValidString@ATL@@YAHPBDI@Z ENDP			; ATL::AtlIsValidString
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 311  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 312  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 313  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@ DB 'm_p == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lalloc.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L223195
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223195
	int	3
$L223195:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 128		; 00000080H
	jbe	SHORT $L160415

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L160416
$L160415:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L160416:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 466  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 		return (assign(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 468  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 471  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 		return (assign(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 473  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 481  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 483  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 486  : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 487  : 		return (append(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 488  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1103 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1105 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
; Function compile flags: /Odt /RTCsu
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1247 : 		{	// look for _Ch before _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1248 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));

	push	1
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ch$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind

; 1249 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T223220 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 1374 : 		{	// return [_Off, _Off + _Count) as new string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223220[ebp], 0

; 1375 : 		return (_Myt(*this, _Off, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223220[ebp]
	or	eax, 1
	mov	DWORD PTR $T223220[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1376 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1401 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1402 : 		return (compare(0, _Mysize, _Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1403 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 367  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L160603

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L160603:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L223229:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
_TEXT	ENDS
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 138  : 		{	// call basic_ostream manipulator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 		return ((*_Pfn)(*this));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __Pfn$[ebp]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223246 DD	0ffffffffH
	DD	FLAT:$L223239
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T223248 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L223238
$T223247 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T223248
$T223241 DD	019930520H
	DD	03H
	DD	FLAT:$T223246
	DD	01H
	DD	FLAT:$T223247
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
tv134 = -65						; size = 1
tv133 = -64						; size = 4
tv132 = -60						; size = 4
tv65 = -56						; size = 4
$T223236 = -52						; size = 4
$T223235 = -48						; size = 4
$T223234 = -44						; size = 4
__Ok$ = -36						; size = 8
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 471  : 		{	// insert a character

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 473  : 		const sentry _Ok(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 474  : 
; 475  : 		if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $L216430

; 476  : 			_State |= ios_base::badbit;

	mov	edx, DWORD PTR __State$[ebp]
	or	edx, 4
	mov	DWORD PTR __State$[ebp], edx

; 477  : 		else

	jmp	SHORT $L223237
$L216430:

; 478  : 			{	// state okay, insert character
; 479  : 			_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 480  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 481  : 				_Myios::rdbuf()->sputc(_Ch)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv65[ebp], eax
	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv65[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR $T223234[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv133[ebp], eax
	mov	edx, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T223235[ebp], edx
	lea	eax, DWORD PTR $T223234[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223235[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv134[ebp], al
	movzx	edx, BYTE PTR tv134[ebp]
	test	edx, edx
	je	SHORT $L216435

; 482  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L216435:
	jmp	SHORT $L223237
$L223238:

; 483  : 			_CATCH_IO_END

	push	1
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $L223237
	ret	0
$L223237:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 484  : 			}
; 485  : 
; 486  : 		_Myios::setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 487  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T223236[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T223236[ebp]

; 488  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223245
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L223245:
	DD	1
	DD	$L223244
$L223244:
	DD	-36					; ffffffdcH
	DD	8
	DD	$L223242
$L223242:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223239:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
	mov	eax, OFFSET FLAT:$T223241
	jmp	___CxxFrameHandler
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC NEAR	; std::char_traits<char>::eq_int_type, COMDAT

; 390  : 		{	// test for metacharacter equality

	push	ebp
	mov	ebp, esp

; 391  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 392  : 		}

	pop	ebp
	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC NEAR		; std::char_traits<char>::eof, COMDAT

; 395  : 		{	// return end-of-file metacharacter

	push	ebp
	mov	ebp, esp

; 396  : 		return (EOF);

	or	eax, -1

; 397  : 		}

	pop	ebp
	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?fail@ios_base@std@@QBE_NXZ			; std::ios_base::fail
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__State$ = -8						; size = 4
_this$ = -4						; size = 4
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 511  : 		{	// flush output stream

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 512  : 		ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 513  : 		if (!ios_base::fail() && _Myios::rdbuf()->pubsync() == -1)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?fail@ios_base@std@@QBE_NXZ		; std::ios_base::fail
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L216440
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
	cmp	eax, -1
	jne	SHORT $L216440

; 514  : 			_State |= ios_base::badbit;	// sync failed

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L216440:

; 515  : 		_Myios::setstate(_State);

	push	0
	mov	ecx, DWORD PTR __State$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 516  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 517  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
_TEXT	ENDS
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fail@ios_base@std@@QBE_NXZ PROC NEAR			; std::ios_base::fail, COMDAT
; _this$ = ecx

; 297  : 		{	// test if badbit or failbit is set in stream state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 298  : 		return (((int)rdstate()
; 299  : 			& ((int)badbit | (int)failbit)) != 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	and	eax, 6
	neg	eax
	sbb	eax, eax
	neg	eax

; 300  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?fail@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::fail
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 265  : 		{	// return stream state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 266  : 		return (_Mystate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 267  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
PUBLIC	??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ios<char,std::char_traits<char> >::`vftable'
PUBLIC	??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
EXTRN	??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:NEAR ; std::basic_ios<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??1ios_base@std@@UAE@XZ:NEAR			; std::ios_base::~ios_base
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ios
CONST	SEGMENT
??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_E?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ios<char,std::char_traits<char> >::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 35   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ios_base@std@@UAE@XZ			; std::ios_base::~ios_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Except$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   : 		{	// merge _State into state, possible reraise exception

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 		if (_State != goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	je	SHORT $L216444

; 51   : 			clear((iostate)((int)rdstate() | (int)_State), _Except);

	mov	al, BYTE PTR __Except$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	or	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
$L216444:

; 52   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 80   : 		{	// return stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]

; 82   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
PUBLIC	??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@	; `string'
PUBLIC	?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z ; ATL::CAtlWinModule::AddCreateWndData
PUBLIC	?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z ; ATL::CDialogImplBaseT<ATL::CWindow>::StartDialogProc
PUBLIC	?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetResourceInstance
EXTRN	__imp__AtlAxDialogBoxA@20:NEAR
;	COMDAT ??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlwin.h
CONST	SEGMENT
??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@ DB 'm_hWnd == 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hWndParent$ = 8					; size = 4
_dwInitParam$ = 12					; size = 4
?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z PROC NEAR ; ATL::CAxDialogImpl<CShowSelectCert,ATL::CWindow>::DoModal, COMDAT
; _this$ = ecx

; 3421 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3422 : 		ATLASSERT(m_hWnd == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L223270
	push	OFFSET FLAT:??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@
	push	0
	push	3422					; 00000d5eH
	push	OFFSET FLAT:??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223270
	int	3
$L223270:

; 3423 : 		_AtlWinModule.AddCreateWndData(&m_thunk.cd, (CDialogImplBaseT< TBase >*)this);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z ; ATL::CAtlWinModule::AddCreateWndData

; 3424 : #ifdef _DEBUG
; 3425 : 		m_bModal = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 1

; 3426 : #endif //_DEBUG
; 3427 : 		return AtlAxDialogBox(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(static_cast<T*>(this)->IDD),
; 3428 : 					hWndParent, T::StartDialogProc, dwInitParam);

	mov	esi, esp
	mov	edx, DWORD PTR _dwInitParam$[ebp]
	push	edx
	push	OFFSET FLAT:?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z ; ATL::CDialogImplBaseT<ATL::CWindow>::StartDialogProc
	mov	eax, DWORD PTR _hWndParent$[ebp]
	push	eax
	push	103					; 00000067H
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetResourceInstance
	push	eax
	call	DWORD PTR __imp__AtlAxDialogBoxA@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3429 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z ENDP ; ATL::CAxDialogImpl<CShowSelectCert,ATL::CWindow>::DoModal
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetResourceInstance, COMDAT
; _this$ = ecx

; 210  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 		return m_hInstResource;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 212  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetResourceInstance
_TEXT	ENDS
EXTRN	__imp__AtlWinModuleAddCreateWndData@12:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
_pObject$ = 12						; size = 4
?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z PROC NEAR ; ATL::CAtlWinModule::AddCreateWndData, COMDAT
; _this$ = ecx

; 2592 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2593 : 		AtlWinModuleAddCreateWndData(this, pData, pObject);

	mov	esi, esp
	mov	eax, DWORD PTR _pObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	DWORD PTR __imp__AtlWinModuleAddCreateWndData@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2594 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z ENDP ; ATL::CAtlWinModule::AddCreateWndData
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
PUBLIC	??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
PUBLIC	?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 281  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::~list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Tidy

; 366  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::~list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
PUBLIC	??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::end
_TEXT	ENDS
PUBLIC	?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Insert
PUBLIC	??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator--
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert, COMDAT
; _this$ = ecx

; 514  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Insert

; 516  : 		return (--_Where);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator--
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 517  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@ABQAUTempFilePathInfo@@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::insert
_TEXT	ENDS
PUBLIC	?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::erase
PUBLIC	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT
$T223288 = -32						; size = 4
__First$216796 = -24					; size = 4
__Last$ = -12						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove, COMDAT
; _this$ = ecx

; 679  : 		{	// erase each element matching _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 680  : 		iterator _Last = end();

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::end

; 681  : 		for (iterator _First = begin(); _First != _Last; )

	lea	ecx, DWORD PTR __First$216796[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::begin
$L216799:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$216796[ebp]
	call	??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $L216793

; 682  : 			if (*_First == _Val)

	lea	ecx, DWORD PTR __First$216796[ebp]
	call	??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $L216801

; 683  : 				_First = erase(_First);

	mov	eax, DWORD PTR __First$216796[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223288[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::erase
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __First$216796[ebp], edx

; 684  : 			else

	jmp	SHORT $L216803
$L216801:

; 685  : 				++_First;

	lea	ecx, DWORD PTR __First$216796[ebp]
	call	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
$L216803:
	jmp	SHORT $L216799
$L216793:

; 686  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223292
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L223292:
	DD	2
	DD	$L223291
$L223291:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223289
	DD	-24					; ffffffe8H
	DD	4
	DD	$L223290
$L223290:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L223289:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
?remove@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXABQAUTempFilePathInfo@@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::remove
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator*

; 241  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEAAPAUTempFilePathInfo@@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 255  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 257  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++

; 258  : 			return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 259  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223299
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223299:
	DD	1
	DD	$L223298
$L223298:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223297
$L223297:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator==
; Function compile flags: /Odt /RTCsu
;	COMDAT ??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 201  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	inc	eax

; 203  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ	; ATL::CComPtrBase<IHTMLDocument2>::CComPtrBase<IHTMLDocument2>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<IHTMLDocument2>::CComPtr<IHTMLDocument2>, COMDAT
; _this$ = ecx

; 248  : 	CComPtr() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ ; ATL::CComPtrBase<IHTMLDocument2>::CComPtrBase<IHTMLDocument2>

; 249  : 	{
; 250  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtr@UIHTMLDocument2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<IHTMLDocument2>::CComPtr<IHTMLDocument2>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComPtrBase<IHTMLDocument2>::~CComPtrBase<IHTMLDocument2>, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		if (p)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L216817

; 128  : 			p->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L216817:

; 129  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<IHTMLDocument2>::~CComPtrBase<IHTMLDocument2>
_TEXT	ENDS
PUBLIC	??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@		; `string'
;	COMDAT ??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
CONST	SEGMENT
??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@ DB 'p==0', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ PROC NEAR ; ATL::CComPtrBase<IHTMLDocument2>::operator&, COMDAT
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		ATLASSERT(p==NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L223308
	push	OFFSET FLAT:??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
	push	0
	push	143					; 0000008fH
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223308
	int	3
$L223308:

; 144  : 		return &p;

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??I?$CComPtrBase@UIHTMLDocument2@@@ATL@@QAEPAPAUIHTMLDocument2@@XZ ENDP ; ATL::CComPtrBase<IHTMLDocument2>::operator&
_TEXT	ENDS
PUBLIC	??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@		; `string'
;	COMDAT ??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
CONST	SEGMENT
??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@ DB 'p!=0', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ PROC NEAR ; ATL::CComPtrBase<IHTMLDocument2>::operator->, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		ATLASSERT(p!=NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L223311
	push	OFFSET FLAT:??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
	push	0
	push	148					; 00000094H
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223311
	int	3
$L223311:

; 149  : 		return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 150  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$CComPtrBase@UIHTMLDocument2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIHTMLDocument2@@@1@XZ ENDP ; ATL::CComPtrBase<IHTMLDocument2>::operator->
_TEXT	ENDS
PUBLIC	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
PUBLIC	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:NEAR ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
xdata$x	SEGMENT
$T223322 DD	0ffffffffH
	DD	FLAT:$L223315
	DD	00H
	DD	FLAT:$L223317
$T223320 DD	019930520H
	DD	02H
	DD	FLAT:$T223322
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	060H
CONST	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T223314 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$initVBases$ = 8					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 583  : 		{	// construct unopened

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223314[ebp], 0
	cmp	DWORD PTR _$initVBases$[ebp], 0
	je	SHORT $L216829
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T223314[ebp]
	or	ecx, 1
	mov	DWORD PTR $T223314[ebp], ecx
$L216829:
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx], OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >

; 584  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223315:
	mov	eax, DWORD PTR $T223314[ebp]
	and	eax, 1
	je	$L223316
	and	DWORD PTR $T223314[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$L223316:
	ret	0
$L223317:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T223320
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
EXTRN	??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:NEAR ; std::basic_ostream<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
CONST	SEGMENT
??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_E?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_ostream<char,std::char_traits<char> >::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 56   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx-4], OFFSET FLAT:??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
xdata$x	SEGMENT
$T223337 DD	0ffffffffH
	DD	FLAT:$L223330
	DD	00H
	DD	FLAT:$L223332
	DD	01H
	DD	FLAT:$L223333
$T223335 DD	019930520H
	DD	03H
	DD	FLAT:$T223337
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
$T223329 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
_$initVBases$ = 20					; size = 4
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 590  : 		{	// construct with named file and specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223329[ebp], 0
	cmp	DWORD PTR _$initVBases$[ebp], 0
	je	SHORT $L216833
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T223329[ebp]
	or	ecx, 1
	mov	DWORD PTR $T223329[ebp], ecx
$L216833:
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx], OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 591  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	mov	ecx, DWORD PTR __Prot$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mode$[ebp]
	or	edx, 2
	push	edx
	mov	eax, DWORD PTR __Filename$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $L216832

; 592  : 			_Myios::setstate(ios_base::failbit);

	push	0
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$L216832:

; 593  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223330:
	mov	eax, DWORD PTR $T223329[ebp]
	and	eax, 1
	je	$L223331
	and	DWORD PTR $T223329[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$L223331:
	ret	0
$L223332:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
$L223333:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z:
	mov	eax, OFFSET FLAT:$T223335
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223347 DD	0ffffffffH
	DD	FLAT:$L223342
$T223345 DD	019930520H
	DD	01H
	DD	FLAT:$T223347
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 602  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax-96]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+edx-96], OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 603  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 92					; 0000005cH
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 92					; 0000005cH
	call	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223342:
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 92					; 0000005cH
	jmp	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
__ehhandler$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T223345
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 618  : 		{	// open a C stream with specified mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 619  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

	mov	eax, DWORD PTR __Prot$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Mode$[ebp]
	or	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __Filename$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
	test	eax, eax
	jne	SHORT $L216838

; 620  : 			_Myios::setstate(ios_base::failbit);

	push	0
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$L216838:

; 621  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXPBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
_TEXT	ENDS
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
; Function compile flags: /Odt /RTCsu
;	COMDAT ?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 629  : 		{	// close the C stream

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 630  : 		if (_Filebuffer.close() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
	test	eax, eax
	jne	SHORT $L216841

; 631  : 			_Myios::setstate(ios_base::failbit);

	push	0
	push	2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$L216841:

; 632  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?close@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
PUBLIC	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
PUBLIC	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
PUBLIC	??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z ; std::_DebugHeapDelete<std::_DebugHeapString>
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:NEAR ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223360 DD	0ffffffffH
	DD	FLAT:$L223356
$T223358 DD	019930520H
	DD	01H
	DD	FLAT:$T223360
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z
	DD	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 105  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 		if (_Closef)

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+84]
	test	edx, edx
	je	SHORT $L216845

; 107  : 			close();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
$L216845:

; 108  : 		_DELETE_CRT(_Mystr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z ; std::_DebugHeapDelete<std::_DebugHeapString>
	add	esp, 4

; 109  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223356:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T223358
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z ; std::_DebugHeapDelete<std::locale>
PUBLIC	?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<char,std::char_traits<char> >::imbue
PUBLIC	??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
EXTRN	??1_Mutex@std@@QAE@XZ:NEAR			; std::_Mutex::~_Mutex
EXTRN	??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z:NEAR ; std::basic_streambuf<char,std::char_traits<char> >::`vector deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T223369 DD	0ffffffffH
	DD	FLAT:$L223365
$T223367 DD	019930520H
	DD	01H
	DD	FLAT:$T223369
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@ DD FLAT:??_E?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<char,std::char_traits<char> >::`vftable'
	DD	FLAT:?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
	DD	FLAT:?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 38   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 39   : 		_DELETE_CRT(_Plocale);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	call	??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z ; std::_DebugHeapDelete<std::locale>
	add	esp, 4

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223365:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T223367
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 266  : 		{	// put a character to stream (always fail)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 		return (_Traits::eof());

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof

; 268  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 271  : 		{	// put a character back to stream (always fail)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 272  : 		return (_Traits::eof());

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof

; 273  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbackfail
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc, COMDAT
; _this$ = ecx

; 276  : 		{	// return count of input characters

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		return (0);

	xor	eax, eax

; 278  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 281  : 		{	// get a character from stream, but don't point past it

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 282  : 		return (_Traits::eof());

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof

; 283  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Odt /RTCsu
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
tv79 = -16						; size = 4
$T223383 = -12						; size = 4
$T223382 = -8						; size = 4
_this$ = -4						; size = 4
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 286  : 		{	// get a character from stream, point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 		return (_Traits::eq_int_type(_Traits::eof(), underflow())
; 288  : 			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T223382[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223383[ebp], eax
	lea	eax, DWORD PTR $T223382[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223383[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L223384
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $L223385
$L223384:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv79[ebp], eax
$L223385:
	mov	eax, DWORD PTR tv79[ebp]

; 289  : 		}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 4
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC NEAR	; std::char_traits<char>::to_int_type, COMDAT

; 384  : 		{	// convert character to metacharacter

	push	ebp
	mov	ebp, esp

; 385  : 		return ((unsigned char)_Ch);

	mov	eax, DWORD PTR __Ch$[ebp]
	movzx	eax, BYTE PTR [eax]

; 386  : 		}

	pop	ebp
	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
PUBLIC	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT
$T223390 = -28						; size = 4
__Copied$ = -24						; size = 4
__Size$ = -20						; size = 4
__Meta$ = -12						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn, COMDAT
; _this$ = ecx

; 293  : 		{	// get _Count characters from stream

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 		int_type _Meta;
; 295  : 		streamsize _Size, _Copied;
; 296  : 
; 297  : 		for (_Copied = 0; 0 < _Count; )

	mov	DWORD PTR __Copied$[ebp], 0
$L216495:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$L216496

; 298  : 			if (gptr() != 0 && 0 < (_Size = (streamsize)(egptr() - gptr())))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	test	eax, eax
	je	SHORT $L216498
	mov	ecx, DWORD PTR _this$[ebp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	sub	esi, eax
	mov	DWORD PTR __Size$[ebp], esi
	cmp	DWORD PTR __Size$[ebp], 0
	jle	SHORT $L216498

; 299  : 				{	// copy from read buffer
; 300  : 				if (_Count < _Size)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Size$[ebp]
	jge	SHORT $L216499

; 301  : 					_Size = _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Size$[ebp], ecx
$L216499:

; 302  : 				_Traits::copy(_Ptr, gptr(), _Size);

	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 303  : 				_Ptr += _Size;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 304  : 				_Copied += _Size;

	mov	edx, DWORD PTR __Copied$[ebp]
	add	edx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Copied$[ebp], edx

; 305  : 				_Count -= _Size;

	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 306  : 				gbump((int)_Size);

	mov	ecx, DWORD PTR __Size$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::gbump

; 307  : 				}
; 308  : 			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	jmp	SHORT $L216501
$L216498:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Meta$[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223390[ebp], eax
	lea	ecx, DWORD PTR __Meta$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223390[ebp]
	push	edx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $L216503

; 309  : 				break;	// end of file, quit

	jmp	SHORT $L216496
$L216503:

; 310  : 			else
; 311  : 				{	// get a single character
; 312  : 				*_Ptr++ = _Traits::to_char_type(_Meta);

	lea	ecx, DWORD PTR __Meta$[ebp]
	push	ecx
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 313  : 				++_Copied;

	mov	ecx, DWORD PTR __Copied$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Copied$[ebp], ecx

; 314  : 				--_Count;

	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$L216501:

; 315  : 				}

	jmp	$L216495
$L216496:

; 316  : 
; 317  : 		return (_Copied);

	mov	eax, DWORD PTR __Copied$[ebp]

; 318  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223393
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L223393:
	DD	1
	DD	$L223392
$L223392:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223391
$L223391:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC NEAR	; std::char_traits<char>::to_char_type, COMDAT

; 379  : 		{	// convert metacharacter to character

	push	ebp
	mov	ebp, esp

; 380  : 		return ((_Elem)_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	al, BYTE PTR [eax]

; 381  : 		}

	pop	ebp
	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
PUBLIC	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
PUBLIC	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
PUBLIC	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT
$T223401 = -20						; size = 4
$T223400 = -16						; size = 4
__Copied$ = -12						; size = 4
__Size$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::xsputn, COMDAT
; _this$ = ecx

; 322  : 		{	// put _Count characters to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 		streamsize _Size, _Copied;
; 324  : 
; 325  : 		for (_Copied = 0; 0 < _Count; )

	mov	DWORD PTR __Copied$[ebp], 0
$L216510:
	cmp	DWORD PTR __Count$[ebp], 0
	jle	$L216511

; 326  : 			if (pptr() != 0 && 0 < (_Size = (streamsize)(epptr() - pptr())))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	test	eax, eax
	je	SHORT $L216513
	mov	ecx, DWORD PTR _this$[ebp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	sub	esi, eax
	mov	DWORD PTR __Size$[ebp], esi
	cmp	DWORD PTR __Size$[ebp], 0
	jle	SHORT $L216513

; 327  : 				{	// copy to write buffer
; 328  : 				if (_Count < _Size)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Size$[ebp]
	jge	SHORT $L216514

; 329  : 					_Size = _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Size$[ebp], ecx
$L216514:

; 330  : 				_Traits::copy(pptr(), _Ptr, _Size);

	mov	edx, DWORD PTR __Size$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 331  : 				_Ptr += _Size;

	mov	ecx, DWORD PTR __Ptr$[ebp]
	add	ecx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Ptr$[ebp], ecx

; 332  : 				_Copied += _Size;

	mov	edx, DWORD PTR __Copied$[ebp]
	add	edx, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Copied$[ebp], edx

; 333  : 				_Count -= _Size;

	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Size$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 334  : 				pbump((int)_Size);

	mov	ecx, DWORD PTR __Size$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ; std::basic_streambuf<char,std::char_traits<char> >::pbump

; 335  : 				}
; 336  : 			else if (_Traits::eq_int_type(_Traits::eof(),

	jmp	SHORT $L216516
$L216513:

; 337  : 				overflow(_Traits::to_int_type(*_Ptr))))

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T223400[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223401[ebp], eax
	lea	eax, DWORD PTR $T223400[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223401[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L216519

; 338  : 				break;	// single character put failed, quit

	jmp	SHORT $L216511
$L216519:

; 339  : 			else
; 340  : 				{	// count character successfully put
; 341  : 				++_Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	add	eax, 1
	mov	DWORD PTR __Ptr$[ebp], eax

; 342  : 				++_Copied;

	mov	ecx, DWORD PTR __Copied$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Copied$[ebp], ecx

; 343  : 				--_Count;

	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Count$[ebp], edx
$L216516:

; 344  : 				}

	jmp	$L216510
$L216511:

; 345  : 
; 346  : 		return (_Copied);

	mov	eax, DWORD PTR __Copied$[ebp]

; 347  : 		}

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@J@Z			; std::fpos<int>::fpos<int>
EXTRN	?_BADOFF@std@@3JB:DWORD				; std::_BADOFF
; Function compile flags: /Odt /RTCsu
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 351  : 		{	// change position by offset, according to way and mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 353  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekoff
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 357  : 		{	// change to specified position, according to mode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 358  : 		return (streampos(_BADOFF));

	mov	eax, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 359  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::seekpos
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 362  : 		{	// offer buffer to external agent (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 363  : 		return (this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 367  : 		{	// synchronize with external agent (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 368  : 		return (0);

	xor	eax, eax

; 369  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sync
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 372  : 		{	// set locale to argument (do nothing)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 373  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
PUBLIC	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
xdata$x	SEGMENT
$T223439 DD	0ffffffffH
	DD	FLAT:$L223428
$T223430 DD	019930520H
	DD	01H
	DD	FLAT:$T223439
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
tv203 = -148						; size = 4
tv169 = -144						; size = 4
tv130 = -140						; size = 4
$T223427 = -136						; size = 4
$T223424 = -132						; size = 4
$T223423 = -128						; size = 4
$T223422 = -124						; size = 4
$T223421 = -120						; size = 4
$T223420 = -116						; size = 4
$T223419 = -112						; size = 4
$T223418 = -108						; size = 4
$T223415 = -104						; size = 4
__Count$217070 = -100					; size = 4
__Str$216865 = -92					; size = 28
__Dest$216864 = -56					; size = 4
__Source$216863 = -44					; size = 4
__Ch$216862 = -29					; size = 1
__STRING_INC$216861 = -24				; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT
; _this$ = ecx

; 168  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 136				; 00000088H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 34					; 00000022H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223415[ebp], eax
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223415[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L216853

; 170  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?not_eof@?$char_traits@D@std@@SAHABH@Z	; std::char_traits<char>::not_eof
	add	esp, 4
	jmp	$L216851
$L216853:

; 171  : 		else if (_Mysb::pptr() != 0
; 172  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	test	eax, eax
	je	SHORT $L216855
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	cmp	esi, eax
	jae	SHORT $L216855

; 173  : 			{	// room in buffer, store it
; 174  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	lea	ecx, DWORD PTR __Meta$[ebp]
	push	ecx
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	bl, al
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	BYTE PTR [eax], bl

; 175  : 			return (_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	jmp	$L216851
$L216855:

; 176  : 			}
; 177  : 		else if (_Myfile == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 0
	jne	SHORT $L216857

; 178  : 			return (_Traits::eof());	// no open C stream, fail

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	jmp	$L216851
$L216857:

; 179  : 		else if (_Pcvt == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $L216859

; 180  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
; 181  : 				? _Meta : _Traits::eof());	// no codecvt facet, put as is

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	push	eax
	call	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z	; std::_Fputc<char>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L223416
	mov	edx, DWORD PTR __Meta$[ebp]
	mov	DWORD PTR tv130[ebp], edx
	jmp	SHORT $L223417
$L223416:
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv130[ebp], eax
$L223417:
	mov	eax, DWORD PTR tv130[ebp]
	jmp	$L216851
$L216859:

; 182  : 		else
; 183  : 			{	// put using codecvt facet
; 184  : 			const int _STRING_INC = 8;

	mov	DWORD PTR __STRING_INC$216861[ebp], 8

; 185  : 			const _Elem _Ch = _Traits::to_char_type(_Meta);

	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	BYTE PTR __Ch$216862[ebp], al

; 186  : 			const _Elem *_Source;
; 187  : 			char *_Dest;
; 188  : 
; 189  : 			_Mystr->erase();

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase

; 190  : 			string _Str(_STRING_INC, '\0');

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$L216946:

; 191  : 			for (; ; )
; 192  : 				switch (_Pcvt->out(_State,
; 193  : 					&_Ch, &_Ch + 1, _Source,
; 194  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	lea	eax, DWORD PTR __Dest$216864[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223418[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	lea	edx, DWORD PTR $T223419[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	push	eax
	lea	eax, DWORD PTR __Source$216863[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ch$216862[ebp+1]
	push	ecx
	lea	edx, DWORD PTR __Ch$216862[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::out
	mov	DWORD PTR tv169[ebp], eax
	cmp	DWORD PTR tv169[ebp], 0
	jl	$L217080
	cmp	DWORD PTR tv169[ebp], 1
	jle	SHORT $L217069
	cmp	DWORD PTR tv169[ebp], 3
	je	$L217078
	jmp	$L217080
$L217069:

; 195  : 				{	// test result of converting one element
; 196  : 				case codecvt_base::partial:
; 197  : 				case codecvt_base::ok:
; 198  : 					{	// converted something, try to put it out
; 199  : 					size_t _Count = _Dest - &*_Str.begin();

	lea	edx, DWORD PTR $T223420[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	mov	ecx, DWORD PTR __Dest$216864[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$217070[ebp], ecx

; 200  : 					if (0 < _Count && _Count !=
; 201  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))

	je	SHORT $L217073
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	mov	ecx, DWORD PTR __Count$217070[ebp]
	push	ecx
	push	1
	lea	edx, DWORD PTR $T223421[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	DWORD PTR __Count$217070[ebp], eax
	je	SHORT $L217073

; 202  : 						return (_Traits::eof());	// write failed

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223422[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223422[ebp]
	jmp	$L216851
$L217073:

; 203  : 
; 204  : 					_Wrotesome = true;	// write succeeded

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+76], 1

; 205  : 					if (_Source != &_Ch)

	mov	ecx, DWORD PTR __Source$216863[ebp]
	lea	edx, DWORD PTR __Ch$216862[ebp]
	cmp	ecx, edx
	je	SHORT $L217075

; 206  : 						return (_Meta);	// converted whole element

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	DWORD PTR $T223423[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223423[ebp]
	jmp	$L216851
$L217075:

; 207  : 					if (_Count == 0)

	cmp	DWORD PTR __Count$217070[ebp], 0
	jne	SHORT $L217077

; 208  : 						_Str.append(_STRING_INC, '\0');	// try with more space

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L217077:

; 209  : 					break;

	jmp	SHORT $L217066
$L217078:

; 210  : 					}
; 211  : 
; 212  : 				case codecvt_base::noconv:
; 213  : 					return (_Fputc(_Ch, _Myfile) ? _Meta
; 214  : 						: _Traits::eof());	// no conversion, put as is

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	mov	al, BYTE PTR __Ch$216862[ebp]
	push	eax
	call	??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z	; std::_Fputc<char>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L223425
	mov	edx, DWORD PTR __Meta$[ebp]
	mov	DWORD PTR tv203[ebp], edx
	jmp	SHORT $L223426
$L223425:
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv203[ebp], eax
$L223426:
	mov	eax, DWORD PTR tv203[ebp]
	mov	DWORD PTR $T223424[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223424[ebp]
	jmp	SHORT $L216851
$L217080:

; 215  : 
; 216  : 				default:
; 217  : 					return (_Traits::eof());	// conversion failed

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223427[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$216865[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T223427[ebp]
	jmp	SHORT $L216851
$L217066:

; 218  : 				}

	jmp	$L216946
$L216851:

; 219  : 			}
; 220  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223438
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L223438:
	DD	4
	DD	$L223437
$L223437:
	DD	-29					; ffffffe3H
	DD	1
	DD	$L223431
	DD	-44					; ffffffd4H
	DD	4
	DD	$L223432
	DD	-56					; ffffffc8H
	DD	4
	DD	$L223433
	DD	-92					; ffffffa4H
	DD	28					; 0000001cH
	DD	$L223434
$L223434:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L223433:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L223432:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
$L223431:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223428:
	lea	ecx, DWORD PTR __Str$216865[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z:
	mov	eax, OFFSET FLAT:$T223430
	jmp	___CxxFrameHandler
text$x	ENDS
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Meta$ = 8						; size = 4
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC NEAR	; std::char_traits<char>::not_eof, COMDAT

; 400  : 		{	// return anything but EOF

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 401  : 		return (_Meta != eof() ? _Meta : !eof());

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	ecx, DWORD PTR __Meta$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L223444
	mov	edx, DWORD PTR __Meta$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L223445
$L223444:
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR tv69[ebp], eax
$L223445:
	mov	eax, DWORD PTR tv69[ebp]

; 402  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
EXTRN	_fputc:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
__File$ = 12						; size = 4
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z PROC NEAR		; std::_Fputc<char>, COMDAT

; 55   : 	{	// put a char element to a C stream

	push	ebp
	mov	ebp, esp

; 56   : 	return (fputc(_Byte, _File) != EOF);

	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Byte$[ebp]
	push	ecx
	call	_fputc
	add	esp, 8
	xor	edx, edx
	cmp	eax, -1
	setne	dl
	mov	al, dl

; 57   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Fputc@D@std@@YA_NDPAU_iobuf@@@Z ENDP		; std::_Fputc<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z		; std::_Ungetc<char>
PUBLIC	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
PUBLIC	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
PUBLIC	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT
$T223455 = -17						; size = 1
$T223454 = -16						; size = 4
$T223453 = -12						; size = 4
$T223452 = -8						; size = 4
_this$ = -4						; size = 4
__Meta$ = 8						; size = 4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT
; _this$ = ecx

; 223  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		if (_Mysb::gptr() != 0
; 225  : 			&& _Mysb::eback() < _Mysb::gptr()
; 226  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
; 227  : 			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
; 228  : 				_Meta)))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	test	eax, eax
	je	SHORT $L217086
	mov	ecx, DWORD PTR _this$[ebp]
	call	?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::eback
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	cmp	esi, eax
	jae	SHORT $L217086
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223452[ebp], eax
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223452[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L217087
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	sub	eax, 1
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR $T223453[ebp], eax
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223453[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217086
$L217087:

; 229  : 			{	// just back up position
; 230  : 			_Mysb::_Gndec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec

; 231  : 			return (_Traits::not_eof(_Meta));

	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?not_eof@?$char_traits@D@std@@SAHABH@Z	; std::char_traits<char>::not_eof
	add	esp, 4
	jmp	$L217083
$L217086:

; 232  : 			}
; 233  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $L217091
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223454[ebp], eax
	lea	edx, DWORD PTR __Meta$[ebp]
	push	edx
	lea	eax, DWORD PTR $T223454[ebp]
	push	eax
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217090
$L217091:

; 234  : 			return (_Traits::eof());	// no open C stream or EOF, fail

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	jmp	$L217083
$L217090:

; 235  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $L217094
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	BYTE PTR $T223455[ebp], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	lea	eax, DWORD PTR $T223455[ebp]
	push	eax
	call	??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z	; std::_Ungetc<char>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217094

; 236  : 			return (_Meta);	// no facet and unget succeeded, return

	mov	eax, DWORD PTR __Meta$[ebp]
	jmp	SHORT $L217083
$L217094:

; 237  : 		else if (_Mysb::gptr() != &_Mychar)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	cmp	eax, edx
	je	SHORT $L217096

; 238  : 			{	// putback to _Mychar
; 239  : 			_Mychar = _Traits::to_char_type(_Meta);

	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	call	?to_char_type@?$char_traits@D@std@@SADABH@Z ; std::char_traits<char>::to_char_type
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+68], al

; 240  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 69					; 00000045H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 241  : 			return (_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	jmp	SHORT $L217083
$L217096:

; 242  : 			}
; 243  : 		else
; 244  : 			return (_Traits::eof());	// nowhere to put back

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
$L217083:

; 245  : 		}

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
EXTRN	_ungetc:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z PROC NEAR	; std::_Ungetc<char>, COMDAT

; 73   : 	{	// put back a char element to a C stream

	push	ebp
	mov	ebp, esp

; 74   : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Byte$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	_ungetc
	add	esp, 8
	xor	ecx, ecx
	cmp	eax, -1
	setne	cl
	mov	al, cl

; 75   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Ungetc@D@std@@YA_NABDPAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T223460 = -20						; size = 4
__Meta$ = -12						; size = 4
_this$ = -4						; size = 4
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT
; _this$ = ecx

; 248  : 		{	// get an element from stream, but don't point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 249  : 		int_type _Meta;
; 250  : 		if (_Mysb::gptr() != 0
; 251  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	test	eax, eax
	je	SHORT $L217101
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	cmp	esi, eax
	jae	SHORT $L217101

; 252  : 			return (_Traits::to_int_type(*_Mysb::gptr()));	// return buffered

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	jmp	SHORT $L217099
$L217101:

; 253  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __Meta$[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223460[ebp], eax
	lea	eax, DWORD PTR __Meta$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223460[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217104

; 254  : 			return (_Meta);	// uflow failed, return EOF

	mov	eax, DWORD PTR __Meta$[ebp]
	jmp	SHORT $L217099
$L217104:

; 255  : 		else
; 256  : 			{	// get a char, don't point past it
; 257  : 			pbackfail(_Meta);

	mov	esi, esp
	mov	eax, DWORD PTR __Meta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 258  : 			return (_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
$L217099:

; 259  : 			}
; 260  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223463
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223463:
	DD	1
	DD	$L223462
$L223462:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223461
$L223461:
	DB	95					; 0000005fH
	DB	77					; 0000004dH
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
PUBLIC	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
PUBLIC	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::append
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
PUBLIC	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
EXTRN	_fgetc:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
tv172 = -88						; size = 4
tv90 = -84						; size = 4
$T223472 = -80						; size = 4
$T223471 = -76						; size = 4
$T223470 = -72						; size = 4
$T223469 = -68						; size = 4
$T223468 = -64						; size = 4
__Meta$217122 = -60					; size = 4
__Nleft$217121 = -56					; size = 4
__Source$217120 = -48					; size = 4
__Dest$217119 = -36					; size = 4
__Ch$217118 = -21					; size = 1
__Ch$217113 = -9					; size = 1
_this$ = -4						; size = 4
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT
; _this$ = ecx

; 263  : 		{	// get an element from stream, point past it

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 264  : 		if (_Mysb::gptr() != 0
; 265  : 			&& _Mysb::gptr() < _Mysb::egptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	test	eax, eax
	je	SHORT $L217108
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	cmp	esi, eax
	jae	SHORT $L217108

; 266  : 			return (_Traits::to_int_type(
; 267  : 				*_Mysb::_Gninc()));	// return buffered

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	jmp	$L217107
$L217108:

; 268  : 		else if (_Myfile == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $L217110

; 269  : 			return (_Traits::eof());	// no open C stream, fail

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	jmp	$L217107
$L217110:

; 270  : 		else if (_Pcvt == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	jne	SHORT $L217112

; 271  : 			{	// no codecvt facet, just get it
; 272  : 			_Elem _Ch = 0;

	mov	BYTE PTR __Ch$217113[ebp], 0

; 273  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
; 274  : 				: _Traits::eof());

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	lea	ecx, DWORD PTR __Ch$217113[ebp]
	push	ecx
	call	??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z	; std::_Fgetc<char>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $L223466
	lea	eax, DWORD PTR __Ch$217113[ebp]
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $L223467
$L223466:
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv90[ebp], eax
$L223467:
	mov	eax, DWORD PTR tv90[ebp]
	jmp	$L217107
$L217112:

; 275  : 			}
; 276  : 		else
; 277  : 			for (_State0 = _State, _Mystr->erase(); ; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+64], eax
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase
$L217116:

; 278  : 				{	// get using codecvt facet
; 279  : 				_Elem _Ch, *_Dest;
; 280  : 				const char *_Source;
; 281  : 				ptrdiff_t _Nleft;
; 282  : 				int _Meta = fgetc(_Myfile);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	_fgetc
	add	esp, 4
	mov	DWORD PTR __Meta$217122[ebp], eax

; 283  : 
; 284  : 				if (_Meta == EOF)

	cmp	DWORD PTR __Meta$217122[ebp], -1
	jne	SHORT $L217123

; 285  : 					return (_Traits::eof());	// partial char?

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	jmp	$L217107
$L217123:

; 286  : 
; 287  : 				_Mystr->append(1, (char)_Meta);	// append byte and convert

	mov	dl, BYTE PTR __Meta$217122[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::append

; 288  : 				switch (_Pcvt->in(_State,
; 289  : 					&*_Mystr->begin(), &*_Mystr->begin() + _Mystr->size(),
; 290  : 						_Source, &_Ch, &_Ch + 1, _Dest))

	lea	ecx, DWORD PTR __Dest$217119[ebp]
	push	ecx
	lea	edx, DWORD PTR __Ch$217118[ebp+1]
	push	edx
	lea	eax, DWORD PTR __Ch$217118[ebp]
	push	eax
	lea	ecx, DWORD PTR __Source$217120[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223468[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
	add	esi, eax
	push	esi
	lea	edx, DWORD PTR $T223469[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	call	?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::in
	mov	DWORD PTR tv172[ebp], eax
	cmp	DWORD PTR tv172[ebp], 0
	je	$L217227
	cmp	DWORD PTR tv172[ebp], 1
	je	SHORT $L217218
	cmp	DWORD PTR tv172[ebp], 3
	je	SHORT $L217222
	jmp	$L217232
$L217218:

; 291  : 				{	// test result of converting one element
; 292  : 				case codecvt_base::partial:
; 293  : 					_Mystr->erase((size_t)0,	// partial, not done yet
; 294  : 						(size_t)(_Source - &*_Mystr->begin()));

	lea	eax, DWORD PTR $T223470[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
	mov	edx, DWORD PTR __Source$217120[ebp]
	sub	edx, eax
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase

; 295  : 					break;

	jmp	$L217215
$L217222:

; 296  : 
; 297  : 				case codecvt_base::noconv:
; 298  : 					if (_Mystr->size() < sizeof (_Elem))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
	cmp	eax, 1
	jae	SHORT $L217224

; 299  : 						break;	// no conversion, but need more chars

	jmp	$L217215
$L217224:

; 300  : 
; 301  : 					memcpy(&_Ch, &*_Mystr->begin(),
; 302  : 						sizeof (_Elem));	// copy raw bytes to element

	push	1
	lea	edx, DWORD PTR $T223471[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
	push	eax
	lea	ecx, DWORD PTR __Ch$217118[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 303  : 					return (_Traits::to_int_type(_Ch));	// return result

	lea	edx, DWORD PTR __Ch$217118[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	jmp	SHORT $L217107
$L217227:

; 304  : 
; 305  : 				case codecvt_base::ok:
; 306  : 					for (_Nleft = &*_Mystr->begin() + _Mystr->size() - _Source;

	lea	eax, DWORD PTR $T223472[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
	mov	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+72]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
	add	esi, eax
	sub	esi, DWORD PTR __Source$217120[ebp]
	mov	DWORD PTR __Nleft$217121[ebp], esi
$L217230:

; 307  : 						0 < _Nleft; )

	cmp	DWORD PTR __Nleft$217121[ebp], 0
	jle	SHORT $L217231

; 308  : 						ungetc(_Source[--_Nleft], _Myfile);

	mov	eax, DWORD PTR __Nleft$217121[ebp]
	sub	eax, 1
	mov	DWORD PTR __Nleft$217121[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	mov	eax, DWORD PTR __Source$217120[ebp]
	add	eax, DWORD PTR __Nleft$217121[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_ungetc
	add	esp, 8
	jmp	SHORT $L217230
$L217231:

; 309  : 					return (_Traits::to_int_type(_Ch));	// return result

	lea	edx, DWORD PTR __Ch$217118[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	jmp	SHORT $L217107
$L217232:

; 310  : 
; 311  : 				default:
; 312  : 					return (_Traits::eof());	// conversion failed

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	jmp	SHORT $L217107
$L217215:

; 313  : 				}
; 314  : 				}

	jmp	$L217116
$L217107:

; 315  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223478
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223478:
	DD	4
	DD	$L223477
$L223477:
	DD	-9					; fffffff7H
	DD	1
	DD	$L223473
	DD	-21					; ffffffebH
	DD	1
	DD	$L223474
	DD	-36					; ffffffdcH
	DD	4
	DD	$L223475
	DD	-48					; ffffffd0H
	DD	4
	DD	$L223476
$L223476:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
$L223475:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L223474:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	0
$L223473:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	0
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z
_TEXT	SEGMENT
__Meta$ = -4						; size = 4
__Byte$ = 8						; size = 4
__File$ = 12						; size = 4
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z PROC NEAR		; std::_Fgetc<char>, COMDAT

; 23   : 	{	// get a char element from a C stream

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 24   : 	int _Meta;
; 25   : 	if ((_Meta = fgetc(_File)) == EOF)

	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	call	_fgetc
	add	esp, 4
	mov	DWORD PTR __Meta$[ebp], eax
	cmp	DWORD PTR __Meta$[ebp], -1
	jne	SHORT $L204028

; 26   : 		return (false);

	xor	al, al
	jmp	SHORT $L204026
$L204028:

; 27   : 	else
; 28   : 		{	// got one, convert to char
; 29   : 		_Byte = (char)_Meta;

	mov	ecx, DWORD PTR __Byte$[ebp]
	mov	dl, BYTE PTR __Meta$[ebp]
	mov	BYTE PTR [ecx], dl

; 30   : 		return (true);

	mov	al, 1
$L204026:

; 31   : 		}
; 32   : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fgetc@D@std@@YA_NAADPAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
PUBLIC	??0?$fpos@H@std@@QAE@H_J@Z			; std::fpos<int>::fpos<int>
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::operator[]
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
EXTRN	_fgetpos:NEAR
EXTRN	_fseek:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT
__Nleft$217244 = -24					; size = 4
__Fileposition$ = -16					; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Way$ = 16						; size = 4
___formal$ = 20						; size = 4
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT
; _this$ = ecx

; 321  : 		{	// change position by _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 322  : 		fpos_t _Fileposition;
; 323  : 
; 324  : 		if (_Mysb::egptr() <= _Mysb::gptr()	// nothing buffered
; 325  : 			|| _Mysb::gptr() != &_Mychar	// nothing putback
; 326  : 			|| _Way != ios_base::cur)		// not a relative seek

	mov	ecx, DWORD PTR _this$[ebp]
	call	?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::egptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	cmp	esi, eax
	jbe	SHORT $L217238
	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	cmp	eax, ecx
	jne	SHORT $L217238
	cmp	DWORD PTR __Way$[ebp], 1
	je	SHORT $L217237
$L217238:

; 327  : 			;	// don't have to worry about putback character
; 328  : 		else if (_Pcvt == 0)

	jmp	SHORT $L217239
$L217237:
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $L217240

; 329  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

	mov	eax, DWORD PTR __Off$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Off$[ebp], eax

; 330  : 		else

	jmp	SHORT $L217239
$L217240:

; 331  : 			{	// back up over converted bytes
; 332  : 			for (ptrdiff_t _Nleft = _Mystr->size(); 0 < _Nleft; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+72]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
	mov	DWORD PTR __Nleft$217244[ebp], eax
$L217246:
	cmp	DWORD PTR __Nleft$217244[ebp], 0
	jle	SHORT $L217247

; 333  : 				ungetc(_Mystr->operator[](--_Nleft), _Myfile);

	mov	edx, DWORD PTR __Nleft$217244[ebp]
	sub	edx, 1
	mov	DWORD PTR __Nleft$217244[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	mov	edx, DWORD PTR __Nleft$217244[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::operator[]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	_ungetc
	add	esp, 8
	jmp	SHORT $L217246
$L217247:

; 334  : 			_Mystr->erase();

	mov	edx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase

; 335  : 			_State = _State0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+80], eax
$L217239:

; 336  : 			}
; 337  : 		if (_Myfile == 0 || !_Endwrite()
; 338  : 			|| (_Off != 0 || _Way != ios_base::cur)
; 339  : 				&& fseek(_Myfile, (long)_Off, _Way) != 0
; 340  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+88], 0
	je	SHORT $L217250
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217250
	cmp	DWORD PTR __Off$[ebp], 0
	jne	SHORT $L217252
	cmp	DWORD PTR __Way$[ebp], 1
	je	SHORT $L217251
$L217252:
	mov	eax, DWORD PTR __Way$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L217250
$L217251:
	lea	ecx, DWORD PTR __Fileposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fgetpos
	add	esp, 8
	test	eax, eax
	je	SHORT $L217249
$L217250:

; 341  : 			return (pos_type(_BADOFF));	// report failure

	mov	ecx, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L217235
$L217249:

; 342  : 		if (_Mysb::gptr() == &_Mychar)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	cmp	eax, edx
	jne	SHORT $L217254

; 343  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar);	// discard any putback

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
$L217254:

; 344  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	mov	eax, DWORD PTR __Fileposition$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Fileposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@H_J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L217235:

; 345  : 			_Fileposition));	// return new position
; 346  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223485
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L223485:
	DD	1
	DD	$L223484
$L223484:
	DD	-16					; fffffff0H
	DD	8
	DD	$L223483
$L223483:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
PUBLIC	?state@?$fpos@H@std@@QBEHXZ			; std::fpos<int>::state
PUBLIC	?seekpos@?$fpos@H@std@@QBE_JXZ			; std::fpos<int>::seekpos
PUBLIC	??B?$fpos@H@std@@QBEJXZ				; std::fpos<int>::operator long
EXTRN	_fsetpos:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT
__Off$ = -24						; size = 4
__Fileposition$ = -16					; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT
; _this$ = ecx

; 351  : 		{	// change position to _Pos

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);

	lea	ecx, DWORD PTR __Pos$[ebp]
	call	?seekpos@?$fpos@H@std@@QBE_JXZ		; std::fpos<int>::seekpos
	mov	DWORD PTR __Fileposition$[ebp], eax
	mov	DWORD PTR __Fileposition$[ebp+4], edx

; 353  : 		off_type _Off = (off_type)_Pos - _FPOSOFF(_Fileposition);

	lea	ecx, DWORD PTR __Pos$[ebp]
	call	??B?$fpos@H@std@@QBEJXZ			; std::fpos<int>::operator long
	mov	ecx, DWORD PTR __Fileposition$[ebp]
	sub	eax, ecx
	mov	DWORD PTR __Off$[ebp], eax

; 354  : 
; 355  : 		if (_Myfile == 0 || !_Endwrite()
; 356  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 357  : 			|| _Off != 0 && fseek(_Myfile, (long)_Off, SEEK_CUR) != 0
; 358  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+88], 0
	je	SHORT $L217265
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	movzx	eax, al
	test	eax, eax
	je	SHORT $L217265
	lea	ecx, DWORD PTR __Fileposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fsetpos
	add	esp, 8
	test	eax, eax
	jne	SHORT $L217265
	cmp	DWORD PTR __Off$[ebp], 0
	je	SHORT $L217266
	push	1
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L217265
$L217266:
	lea	ecx, DWORD PTR __Fileposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fgetpos
	add	esp, 8
	test	eax, eax
	je	SHORT $L217264
$L217265:

; 359  : 			return (pos_type(_BADOFF));	// report failure

	mov	ecx, DWORD PTR ?_BADOFF@std@@3JB	; std::_BADOFF
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $L217258
$L217264:

; 360  : 		if (_Mystr != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+72], 0
	je	SHORT $L217268

; 361  : 			{	// restore state
; 362  : 			_State = _POS_TYPE_TO_STATE(_Pos);

	lea	ecx, DWORD PTR __Pos$[ebp]
	call	?state@?$fpos@H@std@@QBEHXZ		; std::fpos<int>::state
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+80], eax

; 363  : 			_Mystr->erase();

	mov	edx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase
$L217268:

; 364  : 			}
; 365  : 		if (_Mysb::gptr() == &_Mychar)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	cmp	eax, ecx
	jne	SHORT $L217269

; 366  : 			_Mysb::setg(&_Mychar, &_Mychar, &_Mychar);	// discard any putback

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg
$L217269:

; 367  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

	mov	edx, DWORD PTR __Fileposition$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Fileposition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$fpos@H@std@@QAE@H_J@Z		; std::fpos<int>::fpos<int>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$L217258:

; 368  : 			_Fileposition));	// return new position
; 369  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223490
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$L223490:
	DD	1
	DD	$L223489
$L223489:
	DD	-16					; fffffff0H
	DD	8
	DD	$L223488
$L223488:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	112					; 00000070H
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	105					; 00000069H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
EXTRN	_setvbuf:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 4
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT
; _this$ = ecx

; 372  : 		{	// offer _Buffer to C stream

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 373  : 		return (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
; 374  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 375  : 			_Count * sizeof (_Elem)) != 0 ? 0 : this);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L223495
	cmp	DWORD PTR __Buffer$[ebp], 0
	jne	SHORT $L223493
	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $L223493
	mov	DWORD PTR tv70[ebp], 4
	jmp	SHORT $L223494
$L223493:
	mov	DWORD PTR tv70[ebp], 0
$L223494:
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv70[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	push	edx
	call	_setvbuf
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $L223495
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $L223496
$L223495:
	mov	DWORD PTR tv76[ebp], 0
$L223496:
	mov	eax, DWORD PTR tv76[ebp]

; 376  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PADH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
EXTRN	_fflush:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT
tv82 = -16						; size = 4
$T223500 = -12						; size = 4
$T223499 = -8						; size = 4
_this$ = -4						; size = 4
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT
; _this$ = ecx

; 379  : 		{	// synchronize C stream with external file

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		return (_Myfile == 0
; 381  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 382  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L223501
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T223499[ebp], eax
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR $T223500[ebp], eax
	lea	eax, DWORD PTR $T223499[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223500[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L223501
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	call	_fflush
	add	esp, 4
	test	eax, eax
	jge	SHORT $L223501
	mov	DWORD PTR tv82[ebp], -1
	jmp	SHORT $L223502
$L223501:
	mov	DWORD PTR tv82[ebp], 0
$L223502:
	mov	eax, DWORD PTR tv82[ebp]

; 383  : 		}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
PUBLIC	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
; Function compile flags: /Odt /RTCsu
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT
; _this$ = ecx

; 386  : 		{	// set locale to argument (capture nontrivial codecvt facet)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		_Initcvt((_Cvt *)&_USE(_Loc, _Cvt));

	mov	eax, DWORD PTR __Loc$[ebp]
	push	eax
	call	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt

; 388  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
PUBLIC	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 4
	call	??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217313
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 4
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217313:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217316
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217316:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217325
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217325:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC NEAR ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 96					; 00000060H
	call	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217333
	mov	ecx, DWORD PTR _this$[ebp]
	sub	ecx, 96					; 00000060H
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217333:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 96					; 00000060H
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217336
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217336:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::~basic_ostream<char,std::char_traits<char> >
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
PUBLIC	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
PUBLIC	??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@ DB 'pStringMgr != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lsimpstr.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT
_pData$ = -8						; size = 4
_this$ = -4						; size = 4
_pStringMgr$ = 8					; size = 4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 210  : 	explicit CSimpleStringT( IAtlStringMgr* pStringMgr ) throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	{
; 212  : 		ATLASSERT( pStringMgr != NULL );

	cmp	DWORD PTR _pStringMgr$[ebp], 0
	jne	SHORT $L223519
	push	OFFSET FLAT:??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
	push	0
	push	212					; 000000d4H
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223519
	int	3
$L223519:

; 213  : 		CStringData* pData = pStringMgr->GetNilString();

	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	call	DWORD PTR [edx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pData$[ebp], eax

; 214  : 		Attach( pData );

	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach

; 215  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z ENDP ; ATL::CSimpleStringT<char,0>::CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	?data@CStringData@ATL@@QAEPAXXZ			; ATL::CStringData::data
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pData$ = 8						; size = 4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Attach, COMDAT
; _this$ = ecx

; 711  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 712  : 		m_pszData = static_cast< PXSTR >( pData->data() );

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 713  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ENDP ; ATL::CSimpleStringT<char,0>::Attach
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@CStringData@ATL@@QAEPAXXZ PROC NEAR		; ATL::CStringData::data, COMDAT
; _this$ = ecx

; 65   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 		return (this+1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H

; 67   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?data@CStringData@ATL@@QAEPAXXZ ENDP			; ATL::CStringData::data
_TEXT	ENDS
PUBLIC	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
PUBLIC	?Release@CStringData@ATL@@QAEXXZ		; ATL::CStringData::Release
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT
_pData$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ PROC NEAR		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>, COMDAT
; _this$ = ecx

; 262  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 		CStringData* pData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pData$[ebp], eax

; 264  : 		pData->Release();

	mov	ecx, DWORD PTR _pData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 265  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ ENDP		; ATL::CSimpleStringT<char,0>::~CSimpleStringT<char,0>
_TEXT	ENDS
PUBLIC	??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@ DB 'nRefs != 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Release@CStringData@ATL@@QAEXXZ PROC NEAR		; ATL::CStringData::Release, COMDAT
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		ATLASSERT( nRefs != 0 );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $L223528
	push	OFFSET FLAT:??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
	push	0
	push	93					; 0000005dH
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223528
	int	3
$L223528:

; 94   : 
; 95   : 		if( _InterlockedDecrement( &nRefs ) <= 0 )

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	or	eax, -1
	lock	 xadd	 DWORD PTR [edx], eax
	dec	eax
	test	eax, eax
	jg	SHORT $L98168

; 96   : 		{
; 97   : 			pStringMgr->Free( this );

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L98168:

; 98   : 		}
; 99   : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Release@CStringData@ATL@@QAEXXZ ENDP			; ATL::CStringData::Release
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ PROC NEAR ; ATL::CSimpleStringT<char,0>::GetData, COMDAT
; _this$ = ecx

; 730  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return( reinterpret_cast< CStringData* >( m_pszData )-1 );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, 16					; 00000010H

; 732  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ENDP ; ATL::CSimpleStringT<char,0>::GetData
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT
_nLengthA$ = -12					; size = 4
_nLengthW$ = -8						; size = 4
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L217364

; 444  : 		{
; 445  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 446  : 			return;

	jmp	$L223532
$L217364:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

	mov	edx, DWORD PTR _nLengthW$[ebp]
	shl	edx, 1
	mov	DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

	cmp	DWORD PTR _nLengthA$[ebp], 128		; 00000080H
	jle	SHORT $L217367

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L217367

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L217367:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L223532

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$L223532:

; 463  : 		}
; 464  : 	}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 81   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	cmp	DWORD PTR _dwError$[ebp], 0
	jg	SHORT $L223535
	mov	eax, DWORD PTR _dwError$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L223536
$L223535:
	mov	ecx, DWORD PTR _dwError$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv69[ebp], ecx
$L223536:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L223534:

; 83   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
PUBLIC	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
PUBLIC	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
PUBLIC	?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
PUBLIC	?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z	; ATL::ChTraitsCRT<char>::Format
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT
_pszBuffer$ = -12					; size = 4
_nLength$ = -8						; size = 4
_this$ = -4						; size = 4
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z PROC NEAR ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV, COMDAT
; _this$ = ecx

; 1855 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1856 : 		ATLASSERT( AtlIsValidString( pszFormat ) );

	push	-1
	mov	eax, DWORD PTR _pszFormat$[ebp]
	push	eax
	call	?AtlIsValidString@ATL@@YAHPBDI@Z	; ATL::AtlIsValidString
	add	esp, 8
	test	eax, eax
	jne	SHORT $L223539
	push	OFFSET FLAT:??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
	push	0
	push	1856					; 00000740H
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223539
	int	3
$L223539:

; 1857 : 		if(pszFormat == NULL)

	cmp	DWORD PTR _pszFormat$[ebp], 0
	jne	SHORT $L217384

; 1858 : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L217384:

; 1859 : 
; 1860 : 		int nLength = StringTraits::GetFormattedLength( pszFormat, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszFormat$[ebp]
	push	eax
	call	?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ; ATL::ChTraitsCRT<char>::GetFormattedLength
	add	esp, 8
	mov	DWORD PTR _nLength$[ebp], eax

; 1861 : 		PXSTR pszBuffer = GetBuffer( nLength );

	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ; ATL::CSimpleStringT<char,0>::GetBuffer
	mov	DWORD PTR _pszBuffer$[ebp], eax

; 1862 : 		StringTraits::Format( pszBuffer, pszFormat, args );

	mov	edx, DWORD PTR _args$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszFormat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$[ebp]
	push	ecx
	call	?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ; ATL::ChTraitsCRT<char>::Format
	add	esp, 12					; 0000000cH

; 1863 : 		ReleaseBufferSetLength( nLength );

	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
$L223538:

; 1864 : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?FormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z ENDP ; ATL::CStringT<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::FormatV
_TEXT	ENDS
PUBLIC	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nMinBufferLength$ = 8					; size = 4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::GetBuffer, COMDAT
; _this$ = ecx

; 489  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 490  : 		return( PrepareWrite( nMinBufferLength ) );

	mov	eax, DWORD PTR _nMinBufferLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite

; 491  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z ENDP	; ATL::CSimpleStringT<char,0>::GetBuffer
_TEXT	ENDS
PUBLIC	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt /RTCsu
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT
_nTooShort$ = -16					; size = 4
_nShared$ = -12						; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite, COMDAT
; _this$ = ecx

; 734  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 735  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 736  : 		int nShared = 1-pOldData->nRefs;  // nShared < 0 means true, >= 0 means false

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, 1
	sub	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _nShared$[ebp], ecx

; 737  : 		int nTooShort = pOldData->nAllocLength-nLength;  // nTooShort < 0 means true, >= 0 means false

	mov	edx, DWORD PTR _pOldData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nTooShort$[ebp], eax

; 738  : 		if( (nShared|nTooShort) < 0 )  // If either sign bit is set (i.e. either is less than zero), we need to copy data

	mov	ecx, DWORD PTR _nShared$[ebp]
	or	ecx, DWORD PTR _nTooShort$[ebp]
	jge	SHORT $L160465

; 739  : 		{
; 740  : 			PrepareWrite2( nLength );

	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::PrepareWrite2
$L160465:

; 741  : 		}
; 742  : 
; 743  : 		return( m_pszData );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 744  : 	}

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z ENDP ; ATL::CSimpleStringT<char,0>::PrepareWrite
_TEXT	ENDS
PUBLIC	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Fork
PUBLIC	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::Reallocate
PUBLIC	?IsShared@CStringData@ATL@@QBE_NXZ		; ATL::CStringData::IsShared
; Function compile flags: /Odt /RTCsu
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_nNewLength$160618 = -12				; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::PrepareWrite2, COMDAT
; _this$ = ecx

; 746  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 747  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 748  : 		if( pOldData->nDataLength > nLength )

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jle	SHORT $L160614

; 749  : 		{
; 750  : 			nLength = pOldData->nDataLength;

	mov	edx, DWORD PTR _pOldData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _nLength$[ebp], eax
$L160614:

; 751  : 		}
; 752  : 		if( pOldData->IsShared() )

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?IsShared@CStringData@ATL@@QBE_NXZ	; ATL::CStringData::IsShared
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L160615

; 753  : 		{
; 754  : 			Fork( nLength );

	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Fork

; 755  : 		}
; 756  : 		else if( pOldData->nAllocLength < nLength )

	jmp	SHORT $L160612
$L160615:
	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jge	SHORT $L160612

; 757  : 		{
; 758  : 			// Grow exponentially, until we hit 1K.
; 759  : 			int nNewLength = pOldData->nAllocLength;

	mov	edx, DWORD PTR _pOldData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _nNewLength$160618[ebp], eax

; 760  : 			if( nNewLength > 1024 )

	cmp	DWORD PTR _nNewLength$160618[ebp], 1024	; 00000400H
	jle	SHORT $L160619

; 761  : 			{
; 762  : 				nNewLength += 1024;

	mov	ecx, DWORD PTR _nNewLength$160618[ebp]
	add	ecx, 1024				; 00000400H
	mov	DWORD PTR _nNewLength$160618[ebp], ecx

; 763  : 			}
; 764  : 			else

	jmp	SHORT $L160620
$L160619:

; 765  : 			{
; 766  : 				nNewLength *= 2;

	mov	edx, DWORD PTR _nNewLength$160618[ebp]
	shl	edx, 1
	mov	DWORD PTR _nNewLength$160618[ebp], edx
$L160620:

; 767  : 			}
; 768  : 			if( nNewLength < nLength )

	mov	eax, DWORD PTR _nNewLength$160618[ebp]
	cmp	eax, DWORD PTR _nLength$[ebp]
	jge	SHORT $L160621

; 769  : 			{
; 770  : 				nNewLength = nLength;

	mov	ecx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nNewLength$160618[ebp], ecx
$L160621:

; 771  : 			}
; 772  : 			Reallocate( nNewLength );

	mov	edx, DWORD PTR _nNewLength$160618[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::Reallocate
$L160612:

; 773  : 		}
; 774  : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::PrepareWrite2
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsShared@CStringData@ATL@@QBE_NXZ PROC NEAR		; ATL::CStringData::IsShared, COMDAT
; _this$ = ecx

; 79   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 		return( nRefs > 1 ); 

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+12], 1
	setg	cl
	mov	al, cl

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsShared@CStringData@ATL@@QBE_NXZ ENDP			; ATL::CStringData::IsShared
_TEXT	ENDS
PUBLIC	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
PUBLIC	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
tv82 = -28						; size = 4
tv74 = -24						; size = 4
_nCharsToCopy$ = -20					; size = 4
_pNewData$ = -16					; size = 4
_nOldLength$ = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR	; ATL::CSimpleStringT<char,0>::Fork, COMDAT
; _this$ = ecx

; 715  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 716  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 717  : 		int nOldLength = pOldData->nDataLength;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _nOldLength$[ebp], ecx

; 718  : 		CStringData* pNewData = pOldData->pStringMgr->Clone()->Allocate( nLength, sizeof( XCHAR ) );

	mov	edx, DWORD PTR _pOldData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv74[ebp], eax
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv74[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv74[ebp]
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$[ebp], eax

; 719  : 		if( pNewData == NULL )

	cmp	DWORD PTR _pNewData$[ebp], 0
	jne	SHORT $L160646

; 720  : 		{
; 721  : 			ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L160646:

; 722  : 		}
; 723  : 		int nCharsToCopy = ((nOldLength < nLength) ? nOldLength : nLength)+1;  // Copy '\0'

	mov	eax, DWORD PTR _nOldLength$[ebp]
	cmp	eax, DWORD PTR _nLength$[ebp]
	jge	SHORT $L223550
	mov	ecx, DWORD PTR _nOldLength$[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $L223551
$L223550:
	mov	edx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR tv82[ebp], edx
$L223551:
	mov	eax, DWORD PTR tv82[ebp]
	add	eax, 1
	mov	DWORD PTR _nCharsToCopy$[ebp], eax

; 724  : 		CopyChars( PXSTR( pNewData->data() ), PCXSTR( pOldData->data() ), nCharsToCopy );

	mov	ecx, DWORD PTR _nCharsToCopy$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	mov	ecx, DWORD PTR _pNewData$[ebp]
	call	?data@CStringData@ATL@@QAEPAXXZ		; ATL::CStringData::data
	push	eax
	call	?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ; ATL::CSimpleStringT<char,0>::CopyChars
	add	esp, 12					; 0000000cH

; 725  : 		pNewData->nDataLength = nOldLength;

	mov	edx, DWORD PTR _pNewData$[ebp]
	mov	eax, DWORD PTR _nOldLength$[ebp]
	mov	DWORD PTR [edx+4], eax

; 726  : 		pOldData->Release();

	mov	ecx, DWORD PTR _pOldData$[ebp]
	call	?Release@CStringData@ATL@@QAEXXZ	; ATL::CStringData::Release

; 727  : 		Attach( pNewData );

	mov	ecx, DWORD PTR _pNewData$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L223549:

; 728  : 	}

	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP		; ATL::CSimpleStringT<char,0>::Fork
_TEXT	ENDS
PUBLIC	??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@ ; `string'
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT
??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@ DB 'pOldDat'
	DB	'a->nAllocLength < nLength', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_pNewData$ = -16					; size = 4
_pStringMgr$ = -12					; size = 4
_pOldData$ = -8						; size = 4
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::Reallocate, COMDAT
; _this$ = ecx

; 776  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 777  : 		CStringData* pOldData = GetData();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	DWORD PTR _pOldData$[ebp], eax

; 778  : 		ATLASSERT( pOldData->nAllocLength < nLength );

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _nLength$[ebp]
	jl	SHORT $L223554
	push	OFFSET FLAT:??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
	push	0
	push	778					; 0000030aH
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223554
	int	3
$L223554:

; 779  : 		IAtlStringMgr* pStringMgr = pOldData->pStringMgr;

	mov	eax, DWORD PTR _pOldData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pStringMgr$[ebp], ecx

; 780  : 		CStringData* pNewData = pStringMgr->Reallocate( pOldData, nLength, sizeof( XCHAR ) );

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOldData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pStringMgr$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pNewData$[ebp], eax

; 781  : 		if( pNewData == NULL )

	cmp	DWORD PTR _pNewData$[ebp], 0
	jne	SHORT $L160656

; 782  : 		{
; 783  : 			ThrowMemoryException();

	call	?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
$L160656:

; 784  : 		}
; 785  : 		Attach( pNewData );

	mov	eax, DWORD PTR _pNewData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z ; ATL::CSimpleStringT<char,0>::Attach
$L223553:

; 786  : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::Reallocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT
_pchDest$ = 8						; size = 4
_pchSrc$ = 12						; size = 4
_nChars$ = 16						; size = 4
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::CopyChars, COMDAT

; 652  : 	{

	push	ebp
	mov	ebp, esp

; 653  : 		memcpy( pchDest, pchSrc, nChars*sizeof( XCHAR ) );

	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 654  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z ENDP ; ATL::CSimpleStringT<char,0>::CopyChars
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ PROC NEAR ; ATL::CSimpleStringT<char,0>::ThrowMemoryException, COMDAT

; 704  : 	{

	push	ebp
	mov	ebp, esp

; 705  : 		AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L223558:

; 706  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ ENDP ; ATL::CSimpleStringT<char,0>::ThrowMemoryException
_TEXT	ENDS
EXTRN	?g_strmgr@ATL@@3VCAtlStringMgr@1@A:BYTE		; ATL::g_strmgr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlstr.h
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT
?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ PROC NEAR ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager, COMDAT

; 953  : 	{

	push	ebp
	mov	ebp, esp

; 954  : 		return( &g_strmgr );

	mov	eax, OFFSET FLAT:?g_strmgr@ATL@@3VCAtlStringMgr@1@A ; ATL::g_strmgr

; 955  : 	}

	pop	ebp
	ret	0
?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ ENDP ; ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> >::GetDefaultManager
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 331  : 		{	// construct from _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 332  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 333  : 		assign(_Right, _Roff, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 334  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 374  : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 375  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 376  : 		assign(_Count, _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 377  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 496  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		return (append(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 498  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 537  : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 538  : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 539  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 542  : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		if (npos - _Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $L217420

; 544  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217420:

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217422
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217422

; 548  : 			{	// make room and append new stuff using assign
; 549  : 			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 550  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217422:

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 553  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 374  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 375  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	movsx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 376  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 584  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 585  : 		return (assign(_Right, 0, npos));

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	push	0
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 586  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L217427

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L217427:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L217429

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L217429:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L217430

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L217432
$L217430:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217432

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217432:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 		return (_STRING_ITERATOR(_Myptr()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv68 = -12						; size = 4
__Uptr$217444 = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1223 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1224 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $L217442

; 1225 : 			return (_Off < _Mysize ? _Off : _Mysize);	// null always matches

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L223585
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $L223586
$L223585:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv68[ebp], ecx
$L223586:
	mov	eax, DWORD PTR tv68[ebp]
	jmp	$L217441
$L217442:

; 1226 : 		if (_Count <= _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	ja	$L217443

; 1227 : 			{	// room for match, look for it
; 1228 : 			const _Elem *_Uptr = _Myptr() +
; 1229 : 				(_Off < _Mysize - _Count ? _Off : _Mysize - _Count);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Off$[ebp], edx
	jae	SHORT $L223587
	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $L223588
$L223587:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv78[ebp], edx
$L223588:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR tv78[ebp]
	mov	DWORD PTR __Uptr$217444[ebp], eax

; 1230 : 			for (; ; --_Uptr)

	jmp	SHORT $L217445
$L217446:
	mov	eax, DWORD PTR __Uptr$217444[ebp]
	sub	eax, 1
	mov	DWORD PTR __Uptr$217444[ebp], eax
$L217445:

; 1231 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1232 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)

	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Uptr$217444[ebp]
	push	edx
	call	?eq@?$char_traits@D@std@@SA_NABD0@Z	; std::char_traits<char>::eq
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $L217448
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	mov	eax, DWORD PTR __Uptr$217444[ebp]
	push	eax
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L217448

; 1233 : 					return (_Uptr - _Myptr());	// found a match

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Uptr$217444[ebp]
	sub	ecx, eax
	mov	eax, ecx
	jmp	SHORT $L217441
$L217448:

; 1234 : 				else if (_Uptr == _Myptr())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Uptr$217444[ebp], eax
	jne	SHORT $L217449

; 1235 : 					break;	// at beginning, no more chance for match

	jmp	SHORT $L217443
$L217449:

; 1236 : 			}

	jmp	SHORT $L217446
$L217443:

; 1237 : 
; 1238 : 		return (npos);	// no match

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
$L217441:

; 1239 : 		}

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC NEAR		; std::char_traits<char>::eq, COMDAT

; 335  : 		{	// test for element equality

	push	ebp
	mov	ebp, esp

; 336  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	movsx	eax, BYTE PTR [eax]
	mov	ecx, DWORD PTR __Right$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	neg	eax
	sbb	eax, eax
	inc	eax

; 337  : 		}

	pop	ebp
	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC NEAR	; std::char_traits<char>::compare, COMDAT

; 346  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	push	ebp
	mov	ebp, esp

; 347  : 		return (::memcmp(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH

; 348  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
tv87 = -24						; size = 4
tv88 = -20						; size = 4
tv75 = -16						; size = 4
tv82 = -12						; size = 4
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1412 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1413 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L217453

; 1414 : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L217453:

; 1415 : 		if (_Mysize - _Off < _N0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __N0$[ebp]
	jae	SHORT $L217454

; 1416 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __N0$[ebp], edx
$L217454:

; 1417 : 
; 1418 : 		size_type _Ans = _N0 == 0 ? 0
; 1419 : 			: _Traits::compare(_Myptr() + _Off, _Ptr,
; 1420 : 				_N0 < _Count ? _N0 : _Count);

	cmp	DWORD PTR __N0$[ebp], 0
	jne	SHORT $L223597
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $L223598
$L223597:
	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L223595
	mov	ecx, DWORD PTR __N0$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $L223596
$L223595:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv75[ebp], edx
$L223596:
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv82[ebp], eax
$L223598:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR __Ans$[ebp], edx

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

	cmp	DWORD PTR __Ans$[ebp], 0
	je	SHORT $L223601
	mov	eax, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $L223602
$L223601:
	mov	ecx, DWORD PTR __N0$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $L223599
	mov	DWORD PTR tv87[ebp], -1
	jmp	SHORT $L223600
$L223599:
	mov	edx, DWORD PTR __N0$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	setne	al
	mov	DWORD PTR tv87[ebp], eax
$L223600:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$L223602:
	mov	eax, DWORD PTR tv88[ebp]

; 1423 : 		}

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$217462 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L217459

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L217460
$L217459:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L217460

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$217462[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L217463

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$217462[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L217463:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$217462[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L217460:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L223607
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L223608
$L223607:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L223608:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Grow
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::append, COMDAT
; _this$ = ecx

; 542  : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		if (npos - _Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $L217474

; 544  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217474:

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217476
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217476

; 548  : 			{	// make room and append new stuff using assign
; 549  : 			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 550  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
$L217476:

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 553  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::append
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$217493 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L217490

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L217490:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L217491

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L217491:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217492

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$217493[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$217493[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
$L217492:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin, COMDAT
; _this$ = ecx

; 1024 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1025 : 		return (_STRING_ITERATOR(_Myptr()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE?AViterator@12@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1078 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1079 : 		return (_Myptr()[_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]

; 1080 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::operator[]
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::size
_TEXT	ENDS
PUBLIC	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init
PUBLIC	??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T223635 DD	0ffffffffH
	DD	FLAT:$L223630
$T223633 DD	019930520H
	DD	01H
	DD	FLAT:$T223635
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`vbtable'
	DD	04H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
_TEXT	SEGMENT
$T223629 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 44   : 	explicit basic_ostream(basic_streambuf<_Elem, _Traits> *_Strbuf,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223629[ebp], 0
	cmp	DWORD PTR _$initVBases$[ebp], 0
	je	SHORT $L217553
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_8?$basic_ostream@DU?$char_traits@D@std@@@std@@7B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T223629[ebp]
	or	ecx, 1
	mov	DWORD PTR $T223629[ebp], ecx
$L217553:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+ecx], OFFSET FLAT:??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@

; 45   : 		bool _Isstd = false)
; 46   : 		{	// construct from a stream buffer pointer
; 47   : 		_Myios::init(_Strbuf, _Isstd);

	mov	al, BYTE PTR __Isstd$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Strbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ; std::basic_ios<char,std::char_traits<char> >::init

; 48   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223630:
	mov	eax, DWORD PTR $T223629[ebp]
	and	eax, 1
	je	$L223631
	and	DWORD PTR $T223629[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_ios<char,std::char_traits<char> >::~basic_ios<char,std::char_traits<char> >
$L223631:
	ret	0
__ehhandler$??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:
	mov	eax, OFFSET FLAT:$T223633
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::basic_ostream<char,std::char_traits<char> >
EXTRN	?clear@ios_base@std@@QAEXH_N@Z:NEAR		; std::ios_base::clear
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Except$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 38   : 		{	// set state, possibly reraise exception

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		ios_base::clear((iostate)(_Mystrbuf == 0
; 40   : 			? (int)_State | (int)badbit : (int)_State), _Except);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L223640
	mov	ecx, DWORD PTR __State$[ebp]
	or	ecx, 4
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $L223641
$L223640:
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR tv69[ebp], edx
$L223641:
	mov	al, BYTE PTR __Except$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv69[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@ios_base@std@@QAEXH_N@Z		; std::ios_base::clear

; 41   : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
PUBLIC	??0ios_base@std@@IAE@XZ				; std::ios_base::ios_base
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 142  : 	basic_ios()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ios_base@std@@IAE@XZ			; std::ios_base::ios_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@

; 143  : 		{	// default constructor, do nothing
; 144  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP	; std::basic_ios<char,std::char_traits<char> >::basic_ios<char,std::char_traits<char> >
_TEXT	ENDS
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
EXTRN	??_Eios_base@std@@UAEPAXI@Z:NEAR		; std::ios_base::`vector deleting destructor'
;	COMDAT ??_7ios_base@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_Eios_base@std@@UAEPAXI@Z ; std::ios_base::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0ios_base@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ios_base@std@@IAE@XZ PROC NEAR			; std::ios_base::ios_base, COMDAT
; _this$ = ecx

; 421  : 	ios_base()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7ios_base@std@@6B@

; 422  : 		{	// default constructor
; 423  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ios_base@std@@IAE@XZ ENDP				; std::ios_base::ios_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC NEAR			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ios_base@std@@UAE@XZ			; std::ios_base::~ios_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L195476
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L195476:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 95   : 		{	// synchronize with external agent

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 		return (sync());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+44]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 97   : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv83 = -12						; size = 4
$T223654 = -8						; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 145  : 		{	// put a character

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (pptr() != 0 && pptr() < epptr()
; 147  : 			? _Traits::to_int_type(*_Pninc() = _Ch)
; 148  : 			: overflow(_Traits::to_int_type(_Ch)));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	test	eax, eax
	je	SHORT $L223653
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::pptr
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::epptr
	cmp	esi, eax
	jae	SHORT $L223653
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
	mov	DWORD PTR $T223654[ebp], eax
	mov	eax, DWORD PTR $T223654[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR $T223654[ebp]
	push	edx
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $L223655
$L223653:
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	call	?to_int_type@?$char_traits@D@std@@SAHABD@Z ; std::char_traits<char>::to_int_type
	add	esp, 4
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv83[ebp], eax
$L223655:
	mov	eax, DWORD PTR tv83[ebp]

; 149  : 		}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::eback, COMDAT
; _this$ = ecx

; 169  : 		{	// return beginning of read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 		return (*_IGfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR [ecx]

; 171  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::eback
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 174  : 		{	// return current position in read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 		return (*_IGnext);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	eax, DWORD PTR [ecx]

; 176  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pptr, COMDAT
; _this$ = ecx

; 184  : 		{	// return current position in write buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 		return (*_IPnext);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	eax, DWORD PTR [ecx]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::egptr, COMDAT
; _this$ = ecx

; 189  : 		{	// return end of read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx

; 191  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::egptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::gbump, COMDAT
; _this$ = ecx

; 194  : 		{	// alter current position in read buffer by _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 196  : 		*_IGnext += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx

; 197  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gbump
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Next$ = 12						; size = 4
__Last$ = 16						; size = 4
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::setg, COMDAT
; _this$ = ecx

; 200  : 		{	// set pointers for read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx

; 202  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR __Next$[ebp]
	mov	DWORD PTR [ecx], edx

; 203  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __Next$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [edx], eax

; 204  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setg
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::epptr, COMDAT
; _this$ = ecx

; 207  : 		{	// return end of write buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 208  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax]
	mov	eax, ecx

; 209  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::epptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec, COMDAT
; _this$ = ecx

; 212  : 		{	// decrement current position in read buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		++*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 214  : 		return (--*_IGnext);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR [edx]

; 215  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gndec
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 218  : 		{	// increment current position in read buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		--*_IGcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [ecx], edx

; 220  : 		return ((*_IGnext)++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 221  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::pbump, COMDAT
; _this$ = ecx

; 224  : 		{	// alter current position in write buffer by _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 225  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx], edx

; 226  : 		*_IPnext += _Off;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax], ecx

; 227  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pbump
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 244  : 		{	// decrement current position in write buffer

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 245  : 		--*_IPcount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [ecx], edx

; 246  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR tv76[ebp]

; 247  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

	push	ebp
	mov	ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
PUBLIC	?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
PUBLIC	?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Incsize
PUBLIC	?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::_Mynode
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT
__Newnode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Insert, COMDAT
; _this$ = ecx

; 521  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 524  : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 527  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Insert@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXViterator@12@ABQAUTempFilePathInfo@@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T223684 = -12						; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::erase, COMDAT
; _this$ = ecx

; 586  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 587  : 		_Nodeptr _Pnode = (_Where++)._Mynode();

	push	0
	lea	eax, DWORD PTR $T223684[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AV012@H@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 588  : 		if (_Pnode != _Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $L217663

; 589  : 			{	// not list head, safe to erase
; 590  : 			_Nextnode(_Prevnode(_Pnode)) = _Nextnode(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 591  : 			_Prevnode(_Nextnode(_Pnode)) = _Prevnode(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx

; 592  : 			this->_Alnod.destroy(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::destroy

; 593  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate

; 594  : 			--_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
$L217663:

; 595  : 			}
; 596  : 		return (_Where);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 597  : 		}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::erase
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223695 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T223697 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L223688
$T223696 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T223697
$T223690 DD	019930520H
	DD	02H
	DD	FLAT:$T223695
	DD	01H
	DD	FLAT:$T223696
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -44						; size = 4
tv92 = -40						; size = 4
__Linkcnt$ = -36					; size = 4
__Pnode$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv92[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

	mov	eax, DWORD PTR __Linkcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	DWORD PTR tv93[ebp], eax
	lea	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv93[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::construct
	jmp	SHORT $L223687
$L223688:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $L217669

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy
$L217669:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate

; 910  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L223687:

; 911  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L223686:

; 913  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223694
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223694:
	DD	1
	DD	$L223693
$L223693:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L223691
$L223691:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ:
	mov	eax, OFFSET FLAT:$T223690
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
PUBLIC	?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 935  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXXZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
PUBLIC	??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z PROC NEAR ; std::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>

; 83   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_val@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ENDP ; std::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_val<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ PROC NEAR ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@XZ ENDP	; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::const_iterator

; 236  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator++
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++, COMDAT
; _this$ = ecx

; 249  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 			++(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator++

; 251  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 252  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Eiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator--, COMDAT
; _this$ = ecx

; 262  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator--

; 264  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 265  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Myval
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Myval
	add	esp, 4

; 162  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEABQAUTempFilePathInfo@@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 196  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 197  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 198  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator==
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ PROC NEAR ; ATL::CComPtrBase<IHTMLDocument2>::CComPtrBase<IHTMLDocument2>, COMDAT
; _this$ = ecx

; 107  : 	CComPtrBase() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	{
; 109  : 		p = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtrBase@UIHTMLDocument2@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<IHTMLDocument2>::CComPtrBase<IHTMLDocument2>
_TEXT	ENDS
PUBLIC	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
xdata$x	SEGMENT
$T223725 DD	0ffffffffH
	DD	FLAT:$L223721
$T223723 DD	019930520H
	DD	01H
	DD	FLAT:$T223725
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__File$ = 8						; size = 4
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 113  : 		{	// construct from pointer to C stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 114  : 		_Init(_File, _Newfl);

	push	0
	mov	edx, DWORD PTR __File$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 115  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223721:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ ; std::basic_streambuf<char,std::char_traits<char> >::~basic_streambuf<char,std::char_traits<char> >
__ehhandler$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z:
	mov	eax, OFFSET FLAT:$T223723
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAE@PAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:NEAR		; std::_Fiopen
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223735 DD	0ffffffffH
	DD	FLAT:$L223731
$T223733 DD	019930520H
	DD	01H
	DD	FLAT:$T223735
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
tv84 = -32						; size = 4
tv85 = -28						; size = 4
$T223730 = -24						; size = 4
__File$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT
; _this$ = ecx

; 140  : 		{	// open a C stream with specified mode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		_Filet *_File;
; 142  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	jne	SHORT $L217697
	mov	ecx, DWORD PTR __Prot$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Mode$[ebp]
	push	edx
	mov	eax, DWORD PTR __Filename$[ebp]
	push	eax
	call	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z	; std::_Fiopen
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __File$[ebp], eax
	cmp	DWORD PTR __File$[ebp], 0
	jne	SHORT $L217696
$L217697:

; 143  : 			return (0);	// open failed

	xor	eax, eax
	jmp	SHORT $L217694
$L217696:

; 144  : 
; 145  : 		_Init(_File, _Openfl);

	push	1
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 146  : 		_Initcvt((_Cvt *)&_USE(_Mysb::getloc(), _Cvt));

	lea	edx, DWORD PTR $T223730[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<char,std::char_traits<char> >::getloc
	mov	DWORD PTR tv85[ebp], eax
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv84[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv84[ebp]
	push	ecx
	call	??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,int> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T223730[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 147  : 		return (this);	// open succeeded

	mov	eax, DWORD PTR _this$[ebp]
$L217694:

; 148  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223731:
	lea	ecx, DWORD PTR $T223730[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z:
	mov	eax, OFFSET FLAT:$T223733
	jmp	___CxxFrameHandler
text$x	ENDS
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?_Decref@facet@locale@std@@QAEPAV123@XZ		; std::locale::facet::_Decref
PUBLIC	??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ; std::_DebugHeapDelete<std::locale::facet>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC NEAR				; std::locale::~locale, COMDAT
; _this$ = ecx

; 245  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (_Ptr != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L193906

; 247  : 			_DELETE_CRT(_Ptr->_Decref());

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Decref@facet@locale@std@@QAEPAV123@XZ	; std::locale::facet::_Decref
	push	eax
	call	??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ; std::_DebugHeapDelete<std::locale::facet>
	add	esp, 4
$L193906:

; 248  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
EXTRN	??0_Lockit@std@@QAE@H@Z:NEAR			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:NEAR			; std::_Lockit::~_Lockit
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT
$T223742 = -20						; size = 4
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@QAEPAV123@XZ PROC NEAR	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 111  : 			{	// safely decrement the reference count, return this when dead

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 			_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 113  : 
; 114  : 			if (0 < _Refs && _Refs < (size_t)(-1))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jbe	SHORT $L193895
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], -1
	jae	SHORT $L193895

; 115  : 				--_Refs;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
$L193895:

; 116  : 			return (_Refs == 0 ? this : 0);

	mov	edx, DWORD PTR _this$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+4], 0
	setne	al
	dec	eax
	and	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T223742[ebp], eax
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T223742[ebp]

; 117  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223746
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223746:
	DD	1
	DD	$L223745
$L223745:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223744
$L223744:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Decref@facet@locale@std@@QAEPAV123@XZ ENDP		; std::locale::facet::_Decref
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
_TEXT	ENDS
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT
; _this$ = ecx

; 156  : 		{	// close the C stream

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		if (_Myfile != 0 && _Endwrite() && fclose(_Myfile) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $L217702
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217702
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	call	_fclose
	add	esp, 4
	test	eax, eax
	jne	SHORT $L217702

; 158  : 			{	// close succeeded, tidy up
; 159  : 			_Init(0, _Closefl);

	push	2
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 160  : 			return (this);

	mov	eax, DWORD PTR _this$[ebp]
	jmp	SHORT $L217701
$L217702:

; 161  : 			}
; 162  : 		else
; 163  : 			return (0);

	xor	eax, eax
$L217701:

; 164  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
PUBLIC	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z	; std::codecvt<char,char,int>::unshift
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223769 DD	0ffffffffH
	DD	FLAT:$L223760
$T223762 DD	019930520H
	DD	01H
	DD	FLAT:$T223769
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
tv133 = -100						; size = 4
$T223759 = -96						; size = 1
$T223758 = -95						; size = 1
$T223757 = -94						; size = 1
$T223756 = -93						; size = 1
$T223755 = -92						; size = 4
$T223754 = -88						; size = 4
$T223753 = -84						; size = 4
$T223752 = -80						; size = 4
__Count$217723 = -76					; size = 4
__Str$217711 = -68					; size = 28
__Dest$217710 = -32					; size = 4
__STRING_INC$217709 = -24				; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT
; _this$ = ecx

; 418  : 		{	// put shift to initial conversion state, as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 88					; 00000058H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-100]
	mov	ecx, 22					; 00000016H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 		if (_Pcvt == 0 || !_Wrotesome)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $L217707
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+76]
	test	edx, edx
	jne	SHORT $L217706
$L217707:

; 420  : 			return (true);

	mov	al, 1
	jmp	$L217705
$L217706:

; 421  : 		else
; 422  : 			{	// may have to put
; 423  : 			const int _STRING_INC = 8;

	mov	DWORD PTR __STRING_INC$217709[ebp], 8

; 424  : 			char *_Dest;
; 425  : 			overflow();

	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 426  : 
; 427  : 			string _Str(_STRING_INC, '\0');

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$L217713:

; 428  : 			for (; ; )
; 429  : 				switch (_Pcvt->unshift(_State,
; 430  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))

	lea	eax, DWORD PTR __Dest$217710[ebp]
	push	eax
	lea	ecx, DWORD PTR $T223752[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	add	esi, eax
	push	esi
	lea	edx, DWORD PTR $T223753[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+60]
	call	?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::unshift
	mov	DWORD PTR tv133[ebp], eax
	cmp	DWORD PTR tv133[ebp], 0
	je	SHORT $L217721
	cmp	DWORD PTR tv133[ebp], 1
	je	SHORT $L217722
	cmp	DWORD PTR tv133[ebp], 3
	je	$L217730
	jmp	$L217732
$L217721:

; 431  : 				{	// test result of homing conversion
; 432  : 				case codecvt_base::ok:
; 433  : 					_Wrotesome = false;	// homed successfully

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+76], 0
$L217722:

; 434  : 
; 435  : 				case codecvt_base::partial:	// can fall through
; 436  : 					{	// put any generated bytes
; 437  : 					size_t _Count = _Dest - &*_Str.begin();

	lea	eax, DWORD PTR $T223754[ebp]
	push	eax
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	mov	ecx, DWORD PTR __Dest$217710[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Count$217723[ebp], ecx

; 438  : 					if (0 < _Count && _Count !=
; 439  : 						fwrite(&*_Str.begin(), _Count, 1, _Myfile))

	je	SHORT $L217726
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+88]
	push	eax
	push	1
	mov	ecx, DWORD PTR __Count$217723[ebp]
	push	ecx
	lea	edx, DWORD PTR $T223755[ebp]
	push	edx
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AViterator@12@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
	mov	ecx, eax
	call	??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
	push	eax
	call	_fwrite
	add	esp, 16					; 00000010H
	cmp	DWORD PTR __Count$217723[ebp], eax
	je	SHORT $L217726

; 440  : 						return (false);	// write failed

	mov	BYTE PTR $T223756[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T223756[ebp]
	jmp	SHORT $L217705
$L217726:

; 441  : 					if (!_Wrotesome)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+76]
	test	ecx, ecx
	jne	SHORT $L217728

; 442  : 						return (true);

	mov	BYTE PTR $T223757[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T223757[ebp]
	jmp	SHORT $L217705
$L217728:

; 443  : 					_Str.append(_STRING_INC, '\0');	// try some more

	push	0
	push	8
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 444  : 					break;

	jmp	SHORT $L217718
$L217730:

; 445  : 					}
; 446  : 
; 447  : 				case codecvt_base::noconv:
; 448  : 					return (true);	// nothing to do

	mov	BYTE PTR $T223758[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T223758[ebp]
	jmp	SHORT $L217705
$L217732:

; 449  : 
; 450  : 				default:
; 451  : 					return (false);	// conversion failed

	mov	BYTE PTR $T223759[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Str$217711[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, BYTE PTR $T223759[ebp]
	jmp	SHORT $L217705
$L217718:

; 452  : 				}

	jmp	$L217713
$L217705:

; 453  : 			}
; 454  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223768
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 100				; 00000064H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223768:
	DD	2
	DD	$L223767
$L223767:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L223763
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$L223764
$L223764:
	DB	95					; 0000005fH
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L223763:
	DB	95					; 0000005fH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223760:
	lea	ecx, DWORD PTR __Str$217711[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ:
	mov	eax, OFFSET FLAT:$T223762
	jmp	___CxxFrameHandler
text$x	ENDS
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?always_noconv@codecvt_base@std@@QBE_NXZ	; std::codecvt_base::always_noconv
PUBLIC	??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	??0_DebugHeapString@std@@QAE@XZ			; std::_DebugHeapString::_DebugHeapString
EXTRN	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator new
EXTRN	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator delete
EXTRN	?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B:DWORD	; std::_DebugHeapTag
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223782 DD	0ffffffffH
	DD	FLAT:$L223778
$T223780 DD	019930520H
	DD	01H
	DD	FLAT:$T223782
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\include\fstream', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z
_TEXT	SEGMENT
tv87 = -28						; size = 4
$T223775 = -24						; size = 4
$T223774 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Newpcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT
; _this$ = ecx

; 457  : 		{	// initialize codecvt pointer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		if (_Newpcvt->always_noconv())

	mov	ecx, DWORD PTR __Newpcvt$[ebp]
	call	?always_noconv@codecvt_base@std@@QBE_NXZ ; std::codecvt_base::always_noconv
	movzx	eax, al
	test	eax, eax
	je	SHORT $L217736

; 459  : 			_Pcvt = 0;	// nothing to do

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 460  : 		else

	jmp	SHORT $L217735
$L217736:

; 461  : 			{	// set up for nontrivial codecvt facet
; 462  : 			_Pcvt = _Newpcvt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newpcvt$[ebp]
	mov	DWORD PTR [edx+60], eax

; 463  : 			_Mysb::_Init();	// reset any buffering

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init

; 464  : 			if (_Mystr == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	jne	SHORT $L217735

; 465  : 				_Mystr = _NEW_CRT _STRING_CRT;	// buy conversion buffer

	push	465					; 000001d1H
	push	OFFSET FLAT:??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	28					; 0000001cH
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T223775[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T223775[ebp], 0
	je	SHORT $L223776
	mov	ecx, DWORD PTR $T223775[ebp]
	call	??0_DebugHeapString@std@@QAE@XZ		; std::_DebugHeapString::_DebugHeapString
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $L223777
$L223776:
	mov	DWORD PTR tv87[ebp], 0
$L223777:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T223774[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T223774[ebp]
	mov	DWORD PTR [eax+72], ecx
$L217735:

; 466  : 			}
; 467  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223778:
	push	465					; 000001d1H
	push	OFFSET FLAT:??_C@_0EH@FCAPEONK@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR $T223775[ebp]
	push	eax
	call	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z ; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z:
	mov	eax, OFFSET FLAT:$T223780
	jmp	___CxxFrameHandler
text$x	ENDS
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAV?$codecvt@DDH@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
;	COMDAT ??0_DebugHeapString@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_DebugHeapString@std@@QAE@XZ PROC NEAR		; std::_DebugHeapString::_DebugHeapString, COMDAT
; _this$ = ecx

; 108  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >

; 109  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_DebugHeapString@std@@QAE@XZ ENDP			; std::_DebugHeapString::_DebugHeapString
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?always_noconv@codecvt_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?always_noconv@codecvt_base@std@@QBE_NXZ PROC NEAR	; std::codecvt_base::always_noconv, COMDAT
; _this$ = ecx

; 507  : 		{	// return true if conversions never change input (from codecvt)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 508  : 		return (do_always_noconv());

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 509  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?always_noconv@codecvt_base@std@@QBE_NXZ ENDP		; std::codecvt_base::always_noconv
_TEXT	ENDS
PUBLIC	??0?$_DebugHeapAllocator@D@std@@QAE@XZ		; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>
PUBLIC	??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z ; std::_String_val<char,std::_DebugHeapAllocator<char> >::_String_val<char,std::_DebugHeapAllocator<char> >
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >, COMDAT
; _this$ = ecx

; 311  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$_DebugHeapAllocator@D@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z ; std::_String_val<char,std::_DebugHeapAllocator<char> >::_String_val<char,std::_DebugHeapAllocator<char> >

; 312  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy

; 313  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_DebugHeapAllocator@D@std@@QAE@XZ PROC NEAR	; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_DebugHeapAllocator@D@std@@QAE@XZ ENDP		; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>
_TEXT	ENDS
PUBLIC	?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z ; std::_DebugHeapAllocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$217507 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L217504

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L217505
$L217504:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L217505

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$217507[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L217508

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$217507[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L217508:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$217507[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z ; std::_DebugHeapAllocator<char>::deallocate
$L217505:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z	; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::_DebugHeapAllocator<char> >::_String_val<char,std::_DebugHeapAllocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z ENDP ; std::_String_val<char,std::_DebugHeapAllocator<char> >::_String_val<char,std::_DebugHeapAllocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z PROC NEAR	; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z ENDP	; std::_DebugHeapAllocator<char>::_DebugHeapAllocator<char>
_TEXT	ENDS
PUBLIC	?_Stz@?$fpos@H@std@@0HA				; std::fpos<int>::_Stz
EXTRN	?_Fpz@std@@3_JA:QWORD				; std::_Fpz
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_BSS	SEGMENT
?_Stz@?$fpos@H@std@@0HA DD 01H DUP (?)			; std::fpos<int>::_Stz
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??0?$fpos@H@std@@QAE@J@Z PROC NEAR			; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct with stream offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?_Fpz@std@@3_JA
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR ?_Fpz@std@@3_JA+4
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?_Stz@?$fpos@H@std@@0HA	; std::fpos<int>::_Stz
	mov	DWORD PTR [edx+16], eax

; 38   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$fpos@H@std@@QAE@J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@H_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Fileposition$ = 12					; size = 8
??0?$fpos@H@std@@QAE@H_J@Z PROC NEAR			; std::fpos<int>::fpos<int>, COMDAT
; _this$ = ecx

; 42   : 		{	// construct with conversion state and C file position

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Fileposition$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Fileposition$[ebp+4]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 43   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0?$fpos@H@std@@QAE@H_J@Z ENDP				; std::fpos<int>::fpos<int>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?state@?$fpos@H@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?state@?$fpos@H@std@@QBEHXZ PROC NEAR			; std::fpos<int>::state, COMDAT
; _this$ = ecx

; 46   : 		{	// return conversion state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return (_Mystate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 48   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?state@?$fpos@H@std@@QBEHXZ ENDP			; std::fpos<int>::state
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?seekpos@?$fpos@H@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?seekpos@?$fpos@H@std@@QBE_JXZ PROC NEAR		; std::fpos<int>::seekpos, COMDAT
; _this$ = ecx

; 56   : 		{	// return C file position

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 		return (_Fpos);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+12]

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?seekpos@?$fpos@H@std@@QBE_JXZ ENDP			; std::fpos<int>::seekpos
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$fpos@H@std@@QBEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$fpos@H@std@@QBEJXZ PROC NEAR			; std::fpos<int>::operator long, COMDAT
; _this$ = ecx

; 61   : 		{	// return offset

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 		return (_Myoff + _FPOSOFF(_Fpos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$fpos@H@std@@QBEJXZ ENDP				; std::fpos<int>::operator long
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T223817 DD	0ffffffffH
	DD	FLAT:$L223813
$T223815 DD	019930520H
	DD	01H
	DD	FLAT:$T223817
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	movzx	eax, al
	test	eax, eax
	je	SHORT $L217760
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	test	eax, eax
	je	SHORT $L217760

; 90   : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
	mov	ecx, eax
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$L217760:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?good@ios_base@std@@QBE_NXZ		; std::ios_base::good
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 92   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223813:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	eax, OFFSET FLAT:$T223815
	jmp	___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC NEAR			; std::ios_base::good, COMDAT
; _this$ = ecx

; 287  : 		{	// test if no state bits are set

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 288  : 		return (rdstate() == goodbit);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?rdstate@ios_base@std@@QBEHXZ		; std::ios_base::rdstate
	neg	eax
	sbb	eax, eax
	inc	eax

; 289  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
EXTRN	?uncaught_exception@std@@YA_NXZ:NEAR		; std::uncaught_exception
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	SEGMENT
$T223828 DD	0ffffffffH
	DD	FLAT:$L223824
$T223826 DD	019930520H
	DD	01H
	DD	FLAT:$T223828
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

	call	?uncaught_exception@std@@YA_NXZ		; std::uncaught_exception
	movzx	eax, al
	test	eax, eax
	jne	SHORT $L217762

; 99   : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$L217762:

; 100  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223824:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T223826
	jmp	___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 108  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 109  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 110  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::in, COMDAT
; _this$ = ecx

; 557  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 558  : 		return (do_in(_State,
; 559  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

	mov	esi, esp
	mov	eax, DWORD PTR __Mid2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+16]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 560  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?in@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP	; std::codecvt<char,char,int>::in
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::out, COMDAT
; _this$ = ecx

; 565  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (do_out(_State,
; 567  : 			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));

	mov	esi, esp
	mov	eax, DWORD PTR __Mid2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Mid1$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 568  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?out@?$codecvt@DDH@std@@QBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::out
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*, COMDAT
; _this$ = ecx

; 231  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::operator*

; 233  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*, COMDAT
; _this$ = ecx

; 231  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::operator*

; 233  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::operator*
_TEXT	ENDS
PUBLIC	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z	; ATL::CSimpleStringT<char,0>::SetLength
PUBLIC	??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
CONST	SEGMENT
??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@ DB 'nNewLength >= 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nNewLength$ = 8					; size = 4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength, COMDAT
; _this$ = ecx

; 546  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 		ATLASSERT( nNewLength >= 0 );

	cmp	DWORD PTR _nNewLength$[ebp], 0
	jge	SHORT $L223843
	push	OFFSET FLAT:??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
	push	0
	push	547					; 00000223H
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223843
	int	3
$L223843:

; 548  : 		SetLength( nNewLength );

	mov	ecx, DWORD PTR _nNewLength$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ; ATL::CSimpleStringT<char,0>::SetLength

; 549  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z ENDP ; ATL::CSimpleStringT<char,0>::ReleaseBufferSetLength
_TEXT	ENDS
PUBLIC	??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@ ; `string'
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@ DB 'nLength >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT
??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@ DB 'n'
	DB	'Length <= GetData()->nAllocLength', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nLength$ = 8						; size = 4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z PROC NEAR ; ATL::CSimpleStringT<char,0>::SetLength, COMDAT
; _this$ = ecx

; 789  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 790  : 		ATLASSERT( nLength >= 0 );

	cmp	DWORD PTR _nLength$[ebp], 0
	jge	SHORT $L223846
	push	OFFSET FLAT:??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
	push	0
	push	790					; 00000316H
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223846
	int	3
$L223846:

; 791  : 		ATLASSERT( nLength <= GetData()->nAllocLength );

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	ecx, DWORD PTR _nLength$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $L223847
	push	OFFSET FLAT:??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
	push	0
	push	791					; 00000317H
	push	OFFSET FLAT:??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L223847
	int	3
$L223847:

; 792  : 
; 793  : 		if( nLength < 0 || nLength > GetData()->nAllocLength)

	cmp	DWORD PTR _nLength$[ebp], 0
	jl	SHORT $L160473
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	ecx, DWORD PTR _nLength$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jle	SHORT $L160472
$L160473:

; 794  : 			AtlThrow(E_INVALIDARG);

	push	-2147024809				; 80070057H
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L160472:

; 795  : 			
; 796  : 		GetData()->nDataLength = nLength;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ ; ATL::CSimpleStringT<char,0>::GetData
	mov	edx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR [eax+4], edx

; 797  : 		m_pszData[nLength] = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nLength$[ebp]
	mov	BYTE PTR [ecx+edx], 0
$L223845:

; 798  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z ENDP	; ATL::CSimpleStringT<char,0>::SetLength
_TEXT	ENDS
EXTRN	__vscprintf:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT
_pszFormat$ = 8						; size = 4
_args$ = 12						; size = 4
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z PROC NEAR ; ATL::ChTraitsCRT<char>::GetFormattedLength, COMDAT

; 407  : 	{

	push	ebp
	mov	ebp, esp

; 408  : 		return _vscprintf( pszFormat, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	call	__vscprintf
	add	esp, 8

; 409  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z ENDP ; ATL::ChTraitsCRT<char>::GetFormattedLength
_TEXT	ENDS
EXTRN	_vsprintf:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT
_pszBuffer$ = 8						; size = 4
_pszFormat$ = 12					; size = 4
_args$ = 16						; size = 4
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z PROC NEAR	; ATL::ChTraitsCRT<char>::Format, COMDAT

; 412  : 	{

	push	ebp
	mov	ebp, esp

; 413  : 		return vsprintf( pszBuffer, pszFormat, args );

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	push	edx
	call	_vsprintf
	add	esp, 12					; 0000000cH

; 414  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z ENDP		; ATL::ChTraitsCRT<char>::Format
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 502  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L217865

; 504  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L217865:

; 505  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 506  : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L217867

; 507  : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$L217867:

; 508  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $L217868

; 509  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217868:

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217869
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217869

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 515  : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217869:

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 518  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 521  : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217872

; 523  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	jmp	SHORT $L217871
$L217872:

; 524  : 		if (npos - _Mysize <= _Count)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	sub	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $L217873

; 525  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217873:

; 526  : 
; 527  : 		size_type _Num;
; 528  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217875
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	push	0
	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217875

; 529  : 			{	// make room and append new stuff
; 530  : 			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	edx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [edx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 531  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217875:

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L217871:

; 534  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217878

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L217877
$L217878:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L217879

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217879:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L217877:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 626  : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 627  : 		if (_Count == npos)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	jne	SHORT $L217882

; 628  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217882:

; 629  : 
; 630  : 		if (_Grow(_Count))

	push	0
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	edx, al
	test	edx, edx
	je	SHORT $L217883

; 631  : 			{	// make room and assign new stuff
; 632  : 			_Traits::assign(_Myptr(), _Count, _Ch);

	mov	al, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?assign@?$char_traits@D@std@@SAPADPADID@Z ; std::char_traits<char>::assign
	add	esp, 12					; 0000000cH

; 633  : 			_Eos(_Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217883:

; 634  : 			}
; 635  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 636  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$217889 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L217886

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L217886:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L217887

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L217887:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L217888

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$217889[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$217889[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217888:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T223864 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T223864[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T223864[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L217895

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217895:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L217896

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L217897
$L217896:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L217898
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L217898

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L223869
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L223870
$L223869:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L223870:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L217897
$L217898:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L217897

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L217897:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L223873
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L223874
$L223873:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L223874:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T223879 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T223879[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T223879[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L217914

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L217914:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L217915

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L217916
$L217915:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L217917
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L217917

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L223882
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L223883
$L223882:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L223883:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L217916
$L217917:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L217916

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
$L217916:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L223886
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L223887
$L223886:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L223887:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??$_DebugHeapDelete@X@std@@YAXPAX@Z		; std::_DebugHeapDelete<void>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z PROC NEAR ; std::_DebugHeapAllocator<char>::deallocate, COMDAT
; _this$ = ecx

; 91   : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 		_DELETE_CRT_VEC(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_DebugHeapDelete@X@std@@YAXPAX@Z	; std::_DebugHeapDelete<void>
	add	esp, 4

; 93   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z ENDP ; std::_DebugHeapAllocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 132  : 		{	// perform any wrapup

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 133  : 		if (ios_base::flags() & ios_base::unitbuf)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	and	eax, 2
	je	SHORT $L217932

; 134  : 			flush();	// flush stream as needed

	mov	ecx, DWORD PTR _this$[ebp]
	call	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
$L217932:

; 135  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 324  : 		{	// return format flags

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 325  : 		return (_Fmtfl);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 326  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ios
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 68   : 		{	// return tie pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		return (_Tiestr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 70   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
EXTRN	?_Addstd@ios_base@std@@QAEXXZ:NEAR		; std::ios_base::_Addstd
EXTRN	?_Init@ios_base@std@@IAEXXZ:NEAR		; std::ios_base::_Init
; Function compile flags: /Odt /RTCsu
;	COMDAT ?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::init, COMDAT
; _this$ = ecx

; 127  : 		{	// initialize with stream buffer pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		_Init();	// initialize ios_base

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@ios_base@std@@IAEXXZ		; std::ios_base::_Init

; 129  : 		_Mystrbuf = _Strbuf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Strbuf$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 130  : 		_Tiestr = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0

; 131  : 		_Fillch = widen(' ');

	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+48], al

; 132  : 
; 133  : 		if (_Mystrbuf == 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $L217938

; 134  : 			setstate(badbit);

	push	0
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$L217938:

; 135  : 
; 136  : 		if (_Isstd)

	movzx	eax, BYTE PTR __Isstd$[ebp]
	test	eax, eax
	je	SHORT $L217939

; 137  : 			_Addstd();	// special handling for standard streams

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Addstd@ios_base@std@@QAEXXZ		; std::ios_base::_Addstd

; 138  : 		else

	jmp	SHORT $L217937
$L217939:

; 139  : 			_Stdstr = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L217937:

; 140  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?init@?$basic_ios@DU?$char_traits@D@std@@@std@@IAEXPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::init
_TEXT	ENDS
PUBLIC	??_C@_0EJ@EMNMEGHE@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
EXTRN	??0_Mutex@std@@QAE@XZ:NEAR			; std::_Mutex::_Mutex
EXTRN	??0locale@std@@QAE@XZ:NEAR			; std::locale::locale
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T223907 DD	0ffffffffH
	DD	FLAT:$L223903
$T223905 DD	019930520H
	DD	01H
	DD	FLAT:$T223907
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0EJ@EMNMEGHE@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EJ@EMNMEGHE@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\include\streambuf'
	DB	00H						; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
tv80 = -24						; size = 4
$T223900 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 24   : 		{	// construct with no buffers

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_Mutex@std@@QAE@XZ			; std::_Mutex::_Mutex
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	23					; 00000017H
	push	OFFSET FLAT:??_C@_0EJ@EMNMEGHE@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	4
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T223900[ebp], eax
	cmp	DWORD PTR $T223900[ebp], 0
	je	SHORT $L223901
	mov	ecx, DWORD PTR $T223900[ebp]
	call	??0locale@std@@QAE@XZ			; std::locale::locale
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L223902
$L223901:
	mov	DWORD PTR tv80[ebp], 0
$L223902:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR [ecx+56], edx

; 25   : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init

; 26   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223903:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1_Mutex@std@@QAE@XZ			; std::_Mutex::~_Mutex
__ehhandler$??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:
	mov	eax, OFFSET FLAT:$T223905
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::basic_streambuf<char,std::char_traits<char> >
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
; Function compile flags: /Odt /RTCsu
;	COMDAT ?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T223913 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::getloc, COMDAT
; _this$ = ecx

; 84   : 		{	// get locale

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T223913[ebp], 0

; 85   : 		return (*_Plocale);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0locale@std@@QAE@ABV01@@Z		; std::locale::locale
	mov	edx, DWORD PTR $T223913[ebp]
	or	edx, 1
	mov	DWORD PTR $T223913[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::getloc
_TEXT	ENDS
PUBLIC	?_Incref@facet@locale@std@@QAEXXZ		; std::locale::facet::_Incref
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC NEAR			; std::locale::locale, COMDAT
; _this$ = ecx

; 231  : 		{	// construct by copying

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 232  : 		_Ptr->_Incref();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 233  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT
__Lock$ = -12						; size = 4
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@QAEXXZ PROC NEAR		; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 103  : 			{	// safely increment the reference count

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 104  : 			_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 105  : 
; 106  : 			if (_Refs < (size_t)(-1))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], -1
	jae	SHORT $L193890

; 107  : 				++_Refs;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$L193890:

; 108  : 			}

	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L223922
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L223922:
	DD	1
	DD	$L223921
$L223921:
	DD	-12					; fffffff4H
	DD	4
	DD	$L223920
$L223920:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Incref@facet@locale@std@@QAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
PUBLIC	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 250  : 		{	// initialize buffer parameters for no buffers

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 251  : 		_IGfirst = &_Gfirst, _IPfirst = &_Pfirst;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 252  : 		_IGnext = &_Gnext, _IPnext = &_Pnext;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 253  : 		_IGcount = &_Gcount, _IPcount = &_Pcount;

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], ecx

; 254  : 		setp(0, 0), setg(0, 0, 0);

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ; std::basic_streambuf<char,std::char_traits<char> >::setp
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z ; std::basic_streambuf<char,std::char_traits<char> >::setg

; 255  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

	push	ebp
	mov	ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 114  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 119  : 		}

	pop	ebp
	ret	0
?_Myval@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAUTempFilePathInfo@@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Myval
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	jmp	SHORT $L217969
$L217970:
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx
$L217969:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $L217966

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate

; 622  : 			}

	jmp	SHORT $L217970
$L217966:

; 623  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEXXZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::clear
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node::_Node
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223943 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L223939
	DD	0ffffffffH
	DD	00H
$T223945 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L223938
$T223944 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T223945
$T223941 DD	019930520H
	DD	03H
	DD	FLAT:$T223943
	DD	01H
	DD	FLAT:$T223944
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT
tv79 = -44						; size = 4
tv90 = -40						; size = 4
tv87 = -36						; size = 4
$T223934 = -32						; size = 4
$T223933 = -28						; size = 4
__Pnode$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode, COMDAT
; _this$ = ecx

; 917  : 		{	// allocate a node and set links and value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 919  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR tv87[ebp], eax
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR $T223934[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T223934[ebp], 0
	je	SHORT $L223935
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Prev$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T223934[ebp]
	call	??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node::_Node
	mov	DWORD PTR tv90[ebp], eax
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $L223936
$L223935:
	mov	DWORD PTR tv79[ebp], 0
$L223936:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T223933[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $L223937
$L223938:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate

; 923  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L223937:

; 924  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 925  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L223932:

; 926  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223939:
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T223934[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z:
	mov	eax, OFFSET FLAT:$T223941
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@0ABQAUTempFilePathInfo@@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Buynode
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__P$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 109  :         {return (_P); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __P$[ebp]
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 112  :         {return; }

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::max_size
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
xdata$x	SEGMENT
$T223960 DD	0ffffffffH
	DD	FLAT:$L223956
$T223958 DD	019930520H
	DD	01H
	DD	FLAT:$T223960
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T223955 = -84						; size = 28
$T223954 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 957  : 		if (max_size() - _Mysize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L217984

; 958  : 			_THROW(length_error, "list<T> too long");

	push	OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T223955[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T223955[ebp]
	push	edx
	lea	ecx, DWORD PTR $T223954[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T223954[ebp]
	push	eax
	call	__CxxThrowException@8
$L217984:

; 959  : 		_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$L223953:

; 960  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223956:
	lea	ecx, DWORD PTR $T223955[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET FLAT:$T223958
	jmp	___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAEXI@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Incsize
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223973 DD	0ffffffffH
	DD	FLAT:$L223968
$T223971 DD	019930520H
	DD	01H
	DD	FLAT:$T223973
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@XZ			; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 20   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223968:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET FLAT:$T223971
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 28   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L192485
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L192485:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T223987 DD	0ffffffffH
	DD	FLAT:$L223982
$T223985 DD	019930520H
	DD	01H
	DD	FLAT:$T223987
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@@UAE@XZ			; exception::~exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L223982:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T223985
	jmp	___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L192551
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L192551:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
PUBLIC	??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *><TempFilePathInfo *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z PROC NEAR ; std::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *><TempFilePathInfo *>

; 65   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_ptr@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ENDP ; std::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_ptr<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUTempFilePathInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<TempFilePathInfo *>::allocator<TempFilePathInfo *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *,std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *,std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
	add	esp, 8

; 148  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::destroy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 157  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@@Z ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 170  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 			_Ptr = _Nextnode(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 172  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 173  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator++
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 183  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 			_Ptr = _Prevnode(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Prevnode@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@KAAAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@2@PAU342@@Z ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 185  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 206  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 208  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@3@XZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA
; File c:\program files\microsoft visual studio .net 2003\vc7\include\fstream
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA DD 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nw$218053 = -20					; size = 4
__Nr$218051 = -16					; size = 4
__Pn$218049 = -12					; size = 4
__Pb$218047 = -8					; size = 4
_this$ = -4						; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC NEAR ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 391  : 		{	// initialize to C stream _File after {new, open, close}

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 		static typename _Traits::state_type _Stinit;	// initial state
; 393  : 		_Closef = _Which == _Openfl;

	xor	eax, eax
	cmp	DWORD PTR __Which$[ebp], 1
	sete	al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+84], al

; 394  : 		_Wrotesome = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+76], 0

; 395  : 
; 396  : 		_Mysb::_Init();	// initialize stream buffer base object

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Init

; 397  : 
; 398  :  #ifndef _IORCNT
; 399  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 400  :   #define _IOWCNT _IOCNT
; 401  :  #endif /* _IORCNT */
; 402  : 
; 403  : 		if (_File != 0 && sizeof (_Elem) == 1)

	cmp	DWORD PTR __File$[ebp], 0
	je	SHORT $L218046
	mov	eax, 1
	test	eax, eax
	je	SHORT $L218046

; 404  : 			{	// point inside C stream with [first, first + count) buffer
; 405  : 			_Elem **_Pb = (_Elem **)&_File->_IOBASE;

	mov	ecx, DWORD PTR __File$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Pb$218047[ebp], ecx

; 406  : 			_Elem **_Pn = (_Elem **)&_File->_IOPTR;

	mov	edx, DWORD PTR __File$[ebp]
	mov	DWORD PTR __Pn$218049[ebp], edx

; 407  : 			int *_Nr = (int *)&_File->_IORCNT;

	mov	eax, DWORD PTR __File$[ebp]
	add	eax, 4
	mov	DWORD PTR __Nr$218051[ebp], eax

; 408  : 			int *_Nw = (int *)&_File->_IOWCNT;

	mov	ecx, DWORD PTR __File$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Nw$218053[ebp], ecx

; 409  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

	mov	edx, DWORD PTR __Nw$218053[ebp]
	push	edx
	mov	eax, DWORD PTR __Pn$218049[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pb$218047[ebp]
	push	ecx
	mov	edx, DWORD PTR __Nr$218051[ebp]
	push	edx
	mov	eax, DWORD PTR __Pn$218049[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pb$218047[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ; std::basic_streambuf<char,std::char_traits<char> >::_Init
$L218046:

; 410  : 			}
; 411  : 		_Myfile = _File;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __File$[ebp]
	mov	DWORD PTR [edx+88], eax

; 412  : 		_State = _Stinit;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	DWORD PTR [ecx+80], edx

; 413  : 		_State0 = _Stinit;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4HA ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	DWORD PTR [eax+64], ecx

; 414  : 		_Pcvt = 0;	// pointer to codecvt facet

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], 0

; 415  : 		}

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 69   : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR [ecx+4]
	mov	ecx, eax
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $L218056

; 70   : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
$L218056:

; 71   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
EXTRN	?_Lock@_Mutex@std@@QAEXXZ:NEAR			; std::_Mutex::_Lock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Lock, COMDAT
; _this$ = ecx

; 157  : 		{	// set the thread lock

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		_Mylock._Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Lock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Lock

; 159  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
PUBLIC	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 74   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	test	eax, eax
	je	SHORT $L218059

; 76   : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	ecx, eax
	call	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
$L218059:

; 77   : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
EXTRN	?_Unlock@_Mutex@std@@QAEXXZ:NEAR		; std::_Mutex::_Unlock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock, COMDAT
; _this$ = ecx

; 162  : 		{	// clear the thread lock

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		_Mylock._Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?_Unlock@_Mutex@std@@QAEXXZ		; std::_Mutex::_Unlock

; 164  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 90   : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 
; 92   : 
; 93   : 			return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 94   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::unshift, COMDAT
; _this$ = ecx

; 572  : 		{	// generate bytes to return to default shift state

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 573  : 		return (do_unshift(_State, _First2, _Last2, _Mid2));

	mov	esi, esp
	mov	eax, DWORD PTR __Mid2$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 574  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?unshift@?$codecvt@DDH@std@@QBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::unshift
_TEXT	ENDS
PUBLIC	??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::iterator, COMDAT
; _this$ = ecx

; 227  : 			{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::const_iterator

; 228  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PAD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 90   : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 91   : 
; 92   : 
; 93   : 			return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 94   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEABDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::iterator, COMDAT
; _this$ = ecx

; 227  : 			{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::const_iterator

; 228  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PAD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224051 DD	0ffffffffH
	DD	FLAT:$L224046
$T224049 DD	019930520H
	DD	01H
	DD	FLAT:$T224051
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@ABV0@@Z		; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224046:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T224049
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L224056
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L224057
$L224056:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L224057:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224067 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T224069 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L224063
$T224070 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L224061
$T224068 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T224069
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T224070
$T224065 DD	019930520H
	DD	04H
	DD	FLAT:$T224067
	DD	02H
	DD	FLAT:$T224068
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L218203

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L218204
$L218203:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L218204
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L218204

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L218204:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L224060
$L224061:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L224062
$L224063:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L224062:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L224060
	ret	0
$L224060:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L218209

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L218209:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L224059:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T224065
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L218213
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L218212
$L218213:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L218211
$L218212:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L218211:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L224077
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L224078
$L224077:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L224078:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z ; std::_DebugHeapAllocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224088 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T224090 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L224084
$T224091 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L224082
$T224089 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T224090
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T224091
$T224086 DD	019930520H
	DD	04H
	DD	FLAT:$T224088
	DD	02H
	DD	FLAT:$T224089
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L218221

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L218222
$L218221:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L218222
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L218222

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L218222:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z ; std::_DebugHeapAllocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L224081
$L224082:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z ; std::_DebugHeapAllocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L224083
$L224084:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L224083:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L224081
	ret	0
$L224081:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L218227

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L218227:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Eos
$L224080:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T224086
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Copy
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ios
xdata$x	SEGMENT
$T224101 DD	0ffffffffH
	DD	FLAT:$L224097
$T224099 DD	019930520H
	DD	01H
	DD	FLAT:$T224101
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
tv75 = -32						; size = 4
tv76 = -28						; size = 4
$T224096 = -24						; size = 4
__Ctype_fac$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 119  : 		{	// convert _Byte to character using imbued locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		const _Ctype& _Ctype_fac = _USE(getloc(), _Ctype);

	lea	eax, DWORD PTR $T224096[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getloc@ios_base@std@@QBE?AVlocale@2@XZ	; std::ios_base::getloc
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv75[ebp]
	push	edx
	call	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
	add	esp, 4
	mov	DWORD PTR __Ctype_fac$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T224096[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale

; 121  : 		return (_Ctype_fac.widen(_Byte));

	mov	al, BYTE PTR __Byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ctype_fac$[ebp]
	call	?widen@?$ctype@D@std@@QBEDD@Z		; std::ctype<char>::widen

; 122  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224097:
	lea	ecx, DWORD PTR $T224096[ebp]
	jmp	??1locale@std@@QAE@XZ			; std::locale::~locale
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
	mov	eax, OFFSET FLAT:$T224099
	jmp	___CxxFrameHandler
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC NEAR			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 1193 : 		{	// widen char

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1194 : 		return (do_widen(_Byte));

	mov	esi, esp
	mov	al, BYTE PTR __Byte$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+24]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1195 : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
$T224109 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC NEAR	; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 381  : 		{	// get locale

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T224109[ebp], 0

; 382  : 		return (*_Ploc);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0locale@std@@QAE@ABV01@@Z		; std::locale::locale
	mov	edx, DWORD PTR $T224109[ebp]
	or	edx, 1
	mov	DWORD PTR $T224109[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::setp, COMDAT
; _this$ = ecx

; 230  : 		{	// set pointers for write buffer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 231  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx

; 232  : 		*_IPnext = _First;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [ecx], edx

; 233  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [edx], eax

; 234  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::setp
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Gf$ = 8						; size = 4
__Gn$ = 12						; size = 4
__Gc$ = 16						; size = 4
__Pf$ = 20						; size = 4
__Pn$ = 24						; size = 4
__Pc$ = 28						; size = 4
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::_Init, COMDAT
; _this$ = ecx

; 259  : 		{	// initialize buffer parameters as specified

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 260  : 		_IGfirst = _Gf, _IPfirst = _Pf;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Gf$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR [edx+20], eax

; 261  : 		_IGnext = _Gn, _IPnext = _Pn;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Gn$[ebp]
	mov	DWORD PTR [ecx+32], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pn$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 262  : 		_IGcount = _Gc, _IPcount = _Pc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Gc$[ebp]
	mov	DWORD PTR [edx+48], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pc$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAPAD0PAH001@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ ; std::allocator<TempFilePathInfo *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ PROC NEAR ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::max_size, COMDAT
; _this$ = ecx

; 435  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ ; std::allocator<TempFilePathInfo *>::max_size

; 437  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$list@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QBEIXZ ENDP ; std::list<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::max_size
_TEXT	ENDS
PUBLIC	??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node><TempFilePathInfo *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z PROC NEAR ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node><TempFilePathInfo *>

; 45   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@IAE@V?$allocator@PAUTempFilePathInfo@@@1@@Z ENDP ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 84   : 		const_iterator(_Ctptr _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			{	// construct with pointer _Ptr
; 86   : 			_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 87   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 84   : 		const_iterator(_Ctptr _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			{	// construct with pointer _Ptr
; 86   : 			_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 87   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z PROC NEAR ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Nextarg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Prevarg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Myvalarg$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 35   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@QAE@PAU012@0ABQAUTempFilePathInfo@@@Z ENDP ; std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L224129
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L224130
$L224129:
	mov	DWORD PTR tv65[ebp], 1
$L224130:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
EXTRN	??_U@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z:NEAR	; operator new[]
;	COMDAT ??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
CONST	SEGMENT
??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\include\xdebug', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T224133 = -8						; size = 4
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z PROC NEAR ; std::_DebugHeapAllocator<char>::allocate, COMDAT
; _this$ = ecx

; 86   : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 87   : 		return ((_Ty *)_NEW_CRT char[_Count * sizeof(_Ty)]);

	push	87					; 00000057H
	push	OFFSET FLAT:??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??_U@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T224133[ebp], eax
	mov	eax, DWORD PTR $T224133[ebp]

; 88   : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z ENDP	; std::_DebugHeapAllocator<char>::allocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ PROC NEAR ; std::allocator<TempFilePathInfo *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L224136
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L224137
$L224136:
	mov	DWORD PTR tv65[ebp], 1
$L224137:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUTempFilePathInfo@@@std@@QBEIXZ ENDP ; std::allocator<TempFilePathInfo *>::max_size
_TEXT	ENDS
PUBLIC	?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ ; ATL::CAtlWinModule::ExtractCreateWndData
PUBLIC	?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z		; SetWindowLongPtrA
PUBLIC	?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z ; ATL::CWndProcThunk::Init
PUBLIC	?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ ; ATL::CWndProcThunk::GetWNDPROC
EXTRN	?atlTraceWindowing@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceWindowing
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlwin.h
;	COMDAT ?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
$T224141 = -20						; size = 8
_pOldProc$ = -12					; size = 4
_pProc$ = -8						; size = 4
_pThis$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z PROC NEAR ; ATL::CDialogImplBaseT<ATL::CWindow>::StartDialogProc, COMDAT

; 3268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 3269 : 	CDialogImplBaseT< TBase >* pThis = (CDialogImplBaseT< TBase >*)_AtlWinModule.ExtractCreateWndData();

	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ ; ATL::CAtlWinModule::ExtractCreateWndData
	mov	DWORD PTR _pThis$[ebp], eax

; 3270 : 	ATLASSERT(pThis != NULL);

	cmp	DWORD PTR _pThis$[ebp], 0
	jne	SHORT $L224140
	push	OFFSET FLAT:$SG218324
	push	0
	push	3270					; 00000cc6H
	push	OFFSET FLAT:$SG218325
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L224140
	int	3
$L224140:

; 3271 : 	pThis->m_hWnd = hWnd;

	mov	ecx, DWORD PTR _pThis$[ebp]
	mov	edx, DWORD PTR _hWnd$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 3272 : 	pThis->m_thunk.Init((WNDPROC)pThis->GetDialogProc(), pThis);

	mov	eax, DWORD PTR _pThis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pThis$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pThis$[ebp]
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pThis$[ebp]
	add	ecx, 8
	call	?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z ; ATL::CWndProcThunk::Init

; 3273 : 	DLGPROC pProc = (DLGPROC)pThis->m_thunk.GetWNDPROC();

	mov	ecx, DWORD PTR _pThis$[ebp]
	add	ecx, 8
	call	?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ ; ATL::CWndProcThunk::GetWNDPROC
	mov	DWORD PTR _pProc$[ebp], eax

; 3274 : 	DLGPROC pOldProc = (DLGPROC)::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);

	mov	eax, DWORD PTR _pProc$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z	; SetWindowLongPtrA
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pOldProc$[ebp], eax

; 3275 : #ifdef _DEBUG
; 3276 : 	// check if somebody has subclassed us already since we discard it
; 3277 : 	if(pOldProc != StartDialogProc)

	cmp	DWORD PTR _pOldProc$[ebp], OFFSET FLAT:?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z ; ATL::CDialogImplBaseT<ATL::CWindow>::StartDialogProc
	je	SHORT $L218333

; 3278 : 		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));

	push	OFFSET FLAT:$SG218336
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceWindowing@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceWindowing
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3278					; 00000cceH
	push	OFFSET FLAT:$SG218335
	lea	ecx, DWORD PTR $T224141[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H
$L218333:

; 3279 : #else
; 3280 : 	pOldProc;	// avoid unused warning
; 3281 : #endif
; 3282 : 	return pProc(hWnd, uMsg, wParam, lParam);

	mov	esi, esp
	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR _pProc$[ebp]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3283 : }

	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z ENDP ; ATL::CDialogImplBaseT<ATL::CWindow>::StartDialogProc
_TEXT	ENDS
EXTRN	__imp__AtlWinModuleExtractCreateWndData@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ PROC NEAR ; ATL::CAtlWinModule::ExtractCreateWndData, COMDAT
; _this$ = ecx

; 2597 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2598 : 		return AtlWinModuleExtractCreateWndData(this);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleExtractCreateWndData@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2599 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ ENDP	; ATL::CAtlWinModule::ExtractCreateWndData
_TEXT	ENDS
EXTRN	__imp__SetWindowLongA@12:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlwin.h
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_nIndex$ = 12						; size = 4
_dwNewLong$ = 16					; size = 4
?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z PROC NEAR	; SetWindowLongPtrA, COMDAT

; 41   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 42   : 	return( ::SetWindowLongA( hWnd, nIndex, LONG( dwNewLong ) ) );

	mov	esi, esp
	mov	eax, DWORD PTR _dwNewLong$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__SetWindowLongA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 43   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z ENDP		; SetWindowLongPtrA
_TEXT	ENDS
PUBLIC	?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z	; ATL::CDynamicStdCallThunk::Init
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_proc$ = 8						; size = 4
_pThis$ = 12						; size = 4
?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z PROC NEAR ; ATL::CWndProcThunk::Init, COMDAT
; _this$ = ecx

; 2234 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2235 : 		thunk.Init((DWORD_PTR)proc, pThis);

	mov	eax, DWORD PTR _pThis$[ebp]
	push	eax
	mov	ecx, DWORD PTR _proc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z ; ATL::CDynamicStdCallThunk::Init

; 2236 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z ENDP ; ATL::CWndProcThunk::Init
_TEXT	ENDS
PUBLIC	?Init@_stdcallthunk@ATL@@QAEXKPAX@Z		; ATL::_stdcallthunk::Init
PUBLIC	??_C@_06CIAHICCP@pThunk?$AA@			; `string'
PUBLIC	??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
EXTRN	__imp__HeapAlloc@12:NEAR
EXTRN	__imp__GetProcessHeap@0:NEAR
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CONST	SEGMENT
??_C@_06CIAHICCP@pThunk?$AA@ DB 'pThunk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lbase.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_proc$ = 8						; size = 4
_pThis$ = 12						; size = 4
?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z PROC NEAR	; ATL::CDynamicStdCallThunk::Init, COMDAT
; _this$ = ecx

; 633  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 634  : 		if (pThunk == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L87671

; 635  : 			pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
; 636  : 				HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));

	mov	esi, esp
	push	13					; 0000000dH
	push	4
	mov	edi, esp
	call	DWORD PTR __imp__GetProcessHeap@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L87671:

; 637  : 		ATLASSERT(pThunk);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L224150
	push	OFFSET FLAT:??_C@_06CIAHICCP@pThunk?$AA@
	push	0
	push	637					; 0000027dH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L224150
	int	3
$L224150:

; 638  : 		pThunk->Init(proc, pThis);

	mov	ecx, DWORD PTR _pThis$[ebp]
	push	ecx
	mov	edx, DWORD PTR _proc$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Init@_stdcallthunk@ATL@@QAEXKPAX@Z	; ATL::_stdcallthunk::Init

; 639  : 	}

	pop	edi
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z ENDP		; ATL::CDynamicStdCallThunk::Init
_TEXT	ENDS
EXTRN	__imp__FlushInstructionCache@12:NEAR
EXTRN	__imp__GetCurrentProcess@0:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_proc$ = 8						; size = 4
_pThis$ = 12						; size = 4
?Init@_stdcallthunk@ATL@@QAEXKPAX@Z PROC NEAR		; ATL::_stdcallthunk::Init, COMDAT
; _this$ = ecx

; 453  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 454  : 		m_mov = 0x042444C7;  //C7 44 24 0C

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 69485767		; 042444c7H

; 455  : 		m_this = PtrToUlong(pThis);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pThis$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 456  : 		m_jmp = 0xe9;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 233			; 000000e9H

; 457  : 		m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 13					; 0000000dH
	mov	edx, DWORD PTR _proc$[ebp]
	sub	edx, ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+9], edx

; 458  : 		// write block from data cache and
; 459  : 		//  flush from instruction cache
; 460  : 		FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));

	mov	esi, esp
	push	13					; 0000000dH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edi, esp
	call	DWORD PTR __imp__GetCurrentProcess@0
	cmp	edi, esp
	call	__RTC_CheckEsp
	push	eax
	call	DWORD PTR __imp__FlushInstructionCache@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 461  : 	}

	pop	edi
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@_stdcallthunk@ATL@@QAEXKPAX@Z ENDP		; ATL::_stdcallthunk::Init
_TEXT	ENDS
PUBLIC	?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ ; ATL::CDynamicStdCallThunk::GetCodeAddress
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlwin.h
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ PROC NEAR ; ATL::CWndProcThunk::GetWNDPROC, COMDAT
; _this$ = ecx

; 2238 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2239 : 		return (WNDPROC)thunk.GetCodeAddress();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ ; ATL::CDynamicStdCallThunk::GetCodeAddress

; 2240 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ ENDP ; ATL::CWndProcThunk::GetWNDPROC
_TEXT	ENDS
PUBLIC	?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ	; ATL::_stdcallthunk::GetCodeAddress
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ PROC NEAR ; ATL::CDynamicStdCallThunk::GetCodeAddress, COMDAT
; _this$ = ecx

; 642  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		ATLASSERT(pThunk);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L224157
	push	OFFSET FLAT:??_C@_06CIAHICCP@pThunk?$AA@
	push	0
	push	643					; 00000283H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L224157
	int	3
$L224157:

; 644  : 		return pThunk->GetCodeAddress();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ ; ATL::_stdcallthunk::GetCodeAddress

; 645  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ ENDP	; ATL::CDynamicStdCallThunk::GetCodeAddress
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ PROC NEAR	; ATL::_stdcallthunk::GetCodeAddress, COMDAT
; _this$ = ecx

; 464  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 		return this;

	mov	eax, DWORD PTR _this$[ebp]

; 466  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ ENDP	; ATL::_stdcallthunk::GetCodeAddress
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z PROC NEAR ; std::_DebugHeapDelete<std::locale::facet>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp
	push	esi

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L218408

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L218408:

; 64   : 		}
; 65   : 	}

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z ENDP ; std::_DebugHeapDelete<std::locale::facet>
_TEXT	ENDS
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
EXTRN	??0bad_cast@@QAE@PBD@Z:NEAR			; bad_cast::bad_cast
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	?_Register@facet@locale@std@@QAEXXZ:NEAR	; std::locale::facet::_Register
EXTRN	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR	; std::locale::_Getfacet
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224174 DD	0ffffffffH
	DD	FLAT:$L224166
$T224168 DD	019930520H
	DD	01H
	DD	FLAT:$T224174
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T224165 = -64						; size = 4
$T224164 = -60						; size = 12
__Pfmod$218439 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
	mov	DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

	mov	ecx, OFFSET FLAT:?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

	cmp	DWORD PTR __Pf$[ebp], 0
	je	SHORT $L218425

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

	jmp	SHORT $L218426
$L218425:
	cmp	DWORD PTR __Psave$[ebp], 0
	je	SHORT $L218427

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	jmp	SHORT $L218426
$L218427:
	lea	eax, DWORD PTR __Psave$[ebp]
	push	eax
	call	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ; std::ctype<char>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $L218430

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

	push	OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T224164[ebp]
	call	??0bad_cast@@QAE@PBD@Z			; bad_cast::bad_cast
	push	OFFSET FLAT:__TI2?AVbad_cast@@
	lea	ecx, DWORD PTR $T224164[ebp]
	push	ecx
	call	__CxxThrowException@8
$L218430:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	ecx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pfmod$218439[ebp], ecx

; 342  : 		_Pfmod->_Incref();

	mov	ecx, DWORD PTR __Pfmod$218439[ebp]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 343  : 		_Pfmod->_Register();

	mov	ecx, DWORD PTR __Pfmod$218439[ebp]
	call	?_Register@facet@locale@std@@QAEXXZ	; std::locale::facet::_Register
$L218426:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	mov	edx, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR $T224165[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T224165[ebp]
$L224163:

; 347  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L224173
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L224173:
	DD	2
	DD	$L224172
$L224172:
	DD	-20					; ffffffecH
	DD	4
	DD	$L224169
	DD	-32					; ffffffe0H
	DD	4
	DD	$L224170
$L224170:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$L224169:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224166:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
	mov	eax, OFFSET FLAT:$T224168
	jmp	___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$193882 = -12					; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC NEAR			; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 70   : 			{	// get stamp, with lazy allocation

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			if (_Id == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L193881

; 72   : 				{	// still zero, allocate stamp
; 73   : 				_Lockit _Lock(_LOCK_LOCALE);

	push	0
	lea	ecx, DWORD PTR __Lock$193882[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit

; 74   : 				if (_Id == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L193883

; 75   : 					_Id = ++_Id_cnt;

	mov	edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	add	edx, 1
	mov	DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
	mov	DWORD PTR [eax], ecx
$L193883:

; 76   : 				}

	lea	ecx, DWORD PTR __Lock$193882[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
$L193881:

; 77   : 			return (_Id);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 78   : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L224183
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L224183:
	DD	1
	DD	$L224182
$L224182:
	DD	-12					; fffffff4H
	DD	4
	DD	$L224181
$L224181:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
PUBLIC	??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??0?$ctype@D@std@@QAE@PBF_NI@Z			; std::ctype<char>::ctype<char>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224194 DD	0ffffffffH
	DD	FLAT:$L224190
$T224192 DD	019930520H
	DD	01H
	DD	FLAT:$T224194
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\include\xlocale', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
tv82 = -24						; size = 4
$T224187 = -20						; size = 4
$T224186 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z PROC NEAR ; std::ctype<char>::_Getcat, COMDAT

; 1237 : 		{	// construct from specified locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH

; 1238 : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	SHORT $L194717
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L194717

; 1239 : 			*_Ppf = _NEW_CRT ctype<_Elem>;

	push	1239					; 000004d7H
	push	OFFSET FLAT:??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	24					; 00000018H
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T224187[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T224187[ebp], 0
	je	SHORT $L224188
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR $T224187[ebp]
	call	??0?$ctype@D@std@@QAE@PBF_NI@Z		; std::ctype<char>::ctype<char>
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $L224189
$L224188:
	mov	DWORD PTR tv82[ebp], 0
$L224189:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T224186[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T224186[ebp]
	mov	DWORD PTR [edx], eax
$L194717:

; 1240 : 		return (_X_CTYPE);

	mov	eax, 2

; 1241 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224190:
	push	1239					; 000004d7H
	push	OFFSET FLAT:??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR $T224187[ebp]
	push	eax
	call	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z ; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	eax, OFFSET FLAT:$T224192
	jmp	___CxxFrameHandler
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z ENDP	; std::ctype<char>::_Getcat
PUBLIC	??_C@_01GFHCPBMG@C?$AA@				; `string'
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
EXTRN	??0_Locinfo@std@@QAE@PBD@Z:NEAR			; std::_Locinfo::_Locinfo
EXTRN	??1_Locinfo@std@@QAE@XZ:NEAR			; std::_Locinfo::~_Locinfo
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:NEAR		; std::ctype<char>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224205 DD	0ffffffffH
	DD	FLAT:$L224200
	DD	00H
	DD	FLAT:$L224201
$T224203 DD	019930520H
	DD	02H
	DD	FLAT:$T224205
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_E?$ctype@D@std@@MAEPAXI@Z ; std::ctype<char>::`vftable'
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT
??_C@_01GFHCPBMG@C?$AA@ DB 'C', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT
tv86 = -140						; size = 4
tv65 = -136						; size = 4
$T224199 = -132						; size = 116
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Table$ = 8						; size = 4
__Deletetable$ = 12					; size = 1
__Refs$ = 16						; size = 4
??0?$ctype@D@std@@QAE@PBF_NI@Z PROC NEAR		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 1220 : 		{	// construct with specified table and delete flag for table

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 128				; 00000080H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ctype_base@std@@QAE@I@Z		; std::ctype_base::ctype_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7?$ctype@D@std@@6B@

; 1221 : 		_Init(_Locinfo());

	push	OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR $T224199[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv86[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv86[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T224199[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 1222 : 		if (_Table != 0)

	cmp	DWORD PTR __Table$[ebp], 0
	je	SHORT $L194711

; 1223 : 			{	// replace existing char to mask table
; 1224 : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$ctype@D@std@@IAEXXZ		; std::ctype<char>::_Tidy

; 1225 : 			_Ctype._Table = _Table;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Table$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1226 : 			_Ctype._Delfl = _Deletetable ? -1 : 0;

	movzx	eax, BYTE PTR __Deletetable$[ebp]
	neg	eax
	sbb	eax, eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$L194711:

; 1227 : 			}
; 1228 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224200:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
$L224201:
	lea	ecx, DWORD PTR $T224199[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
__ehhandler$??0?$ctype@D@std@@QAE@PBF_NI@Z:
	mov	eax, OFFSET FLAT:$T224203
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$ctype@D@std@@QAE@PBF_NI@Z ENDP			; std::ctype<char>::ctype<char>
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:NEAR		; std::ctype_base::`vector deleting destructor'
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_Ectype_base@std@@UAEPAXI@Z ; std::ctype_base::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC NEAR			; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 902  : 		{	// default constructor

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7ctype_base@std@@6B@

; 903  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_Gfacet@locale@std@@UAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
EXTRN	??_Efacet@locale@std@@UAEPAXI@Z:NEAR		; std::locale::facet::`vector deleting destructor'
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_Efacet@locale@std@@UAEPAXI@Z ; std::locale::facet::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC NEAR			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 129  : 			{	// construct with initial reference count

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7facet@locale@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Initrefs$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 130  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
PUBLIC	??1facet@locale@std@@UAE@XZ			; std::locale::facet::~facet
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@UAEPAXI@Z PROC NEAR		; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L193927
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L193927:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gfacet@locale@std@@UAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@UAE@XZ PROC NEAR			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 123  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7facet@locale@std@@6B@

; 124  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??1facet@locale@std@@UAE@XZ ENDP			; std::locale::facet::~facet
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ctype_base@std@@UAE@XZ PROC NEAR			; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 906  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7ctype_base@std@@6B@

; 907  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC NEAR			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L194363
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L194363:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T224224 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC NEAR	; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 1253 : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_Ctype = _Lobj._Getctype();

	lea	eax, DWORD PTR $T224224[ebp]
	push	eax
	mov	ecx, DWORD PTR __Lobj$[ebp]
	call	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 1255 : 		}

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
EXTRN	__Getctype:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T224228 = -36						; size = 16
$T224227 = -20						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC NEAR	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 76   : 		{	// return ctype stuff

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 		return (::_Getctype());

	lea	eax, DWORD PTR $T224228[ebp]
	push	eax
	call	__Getctype
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T224227[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T224227[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR $T224227[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR $T224227[ebp+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR $T224227[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR $T224227[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR $T224227[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR $T224227[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 78   : 		}

	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T224231 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC NEAR			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 1258 : 		{	// free any allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1259 : 		if (0 < _Ctype._Delfl)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $L194732

; 1260 : 			free((void *)_Ctype._Table);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_free
	add	esp, 4

; 1261 : 		else if (_Ctype._Delfl < 0)

	jmp	SHORT $L194731
$L194732:
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jge	SHORT $L194731

; 1262 : 			delete[] (void *)_Ctype._Table;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR $T224231[ebp], edx
	mov	eax, DWORD PTR $T224231[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L194731:

; 1263 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
EXTRN	__Tolower:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1266 : 		{	// convert element to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1267 : 		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Tolower
	add	esp, 8

; 1268 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC NEAR	; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 1272 : 		{	// convert [_First, _Last) in place to lower case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1273 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $L194744
$L194745:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$L194744:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $L194746

; 1274 : 			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__Tolower
	add	esp, 8
	mov	edx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $L194745
$L194746:

; 1275 : 		return ((const _Elem *)_First);

	mov	eax, DWORD PTR __First$[ebp]

; 1276 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
EXTRN	__Toupper:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1279 : 		{	// convert element to upper case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1280 : 		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	movzx	ecx, BYTE PTR __Ch$[ebp]
	push	ecx
	call	__Toupper
	add	esp, 8

; 1281 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC NEAR	; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 1285 : 		{	// convert [_First, _Last) in place to upper case

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		for (; _First != _Last; ++_First)

	jmp	SHORT $L194756
$L194757:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 1
	mov	DWORD PTR __First$[ebp], eax
$L194756:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $L194758

; 1287 : 			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	__Toupper
	add	esp, 8
	mov	edx, DWORD PTR __First$[ebp]
	mov	BYTE PTR [edx], al
	jmp	SHORT $L194757
$L194758:

; 1288 : 		return ((const _Elem *)_First);

	mov	eax, DWORD PTR __First$[ebp]

; 1289 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC NEAR		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1292 : 		{	// widen char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1293 : 		return (_Byte);

	mov	al, BYTE PTR __Byte$[ebp]

; 1294 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC NEAR	; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 1298 : 		{	// widen chars in [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1299 : 		::memcpy(_Dest, _First, _Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1300 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 1301 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC NEAR		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1304 : 		{	// narrow char

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1305 : 		return (_Ch);

	mov	al, BYTE PTR __Ch$[ebp]

; 1306 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC NEAR	; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 1310 : 		{	// narrow elements in [_First, _Last) to chars

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1311 : 		::memcpy(_Dest, _First, _Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1312 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]

; 1313 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC NEAR			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$ctype@D@std@@MAE@XZ		; std::ctype<char>::~ctype<char>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L194882
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L194882:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224256 DD	0ffffffffH
	DD	FLAT:$L224252
$T224254 DD	019930520H
	DD	01H
	DD	FLAT:$T224256
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$ctype@D@std@@MAE@XZ PROC NEAR			; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 1247 : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$ctype@D@std@@MAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$ctype@D@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1248 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$ctype@D@std@@IAEXXZ		; std::ctype<char>::_Tidy

; 1249 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224252:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ctype_base@std@@UAE@XZ		; std::ctype_base::~ctype_base
__ehhandler$??1?$ctype@D@std@@MAE@XZ:
	mov	eax, OFFSET FLAT:$T224254
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T224269 DD	0ffffffffH
	DD	FLAT:$L224263
	DD	00H
	DD	FLAT:$L224262
$T224267 DD	019930520H
	DD	02H
	DD	FLAT:$T224269
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T224264 = -44						; size = 4
$T224261 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T224264[ebp], 0

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224261[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv77[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T224264[ebp]
	or	eax, 1
	mov	DWORD PTR $T224264[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T224261[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224262:
	lea	ecx, DWORD PTR $T224261[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L224263:
	mov	eax, DWORD PTR $T224264[ebp]
	and	eax, 1
	je	$L224265
	and	DWORD PTR $T224264[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L224265:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
	mov	eax, OFFSET FLAT:$T224267
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC NEAR ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 91   : 	{	// test for string vs. NTCS equality

	push	ebp
	mov	ebp, esp

; 92   : 	return (_Left.compare(_Right) == 0);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
	neg	eax
	sbb	eax, eax
	inc	eax

; 93   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ostream
_TEXT	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z PROC NEAR ; std::operator<<<std::char_traits<char> >, COMDAT

; 882  : 	{	// insert an unsigned char NTBS

	push	ebp
	mov	ebp, esp

; 883  : 	return (_Ostr << (const char *)_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 884  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBE@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?width@ios_base@std@@QBEHXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAEHH@Z			; std::ios_base::width
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224294 DD	0ffffffffH
	DD	FLAT:$L224287
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T224296 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L224286
$T224295 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T224296
$T224289 DD	019930520H
	DD	03H
	DD	FLAT:$T224294
	DD	01H
	DD	FLAT:$T224295
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv209 = -117						; size = 1
tv208 = -116						; size = 4
tv207 = -112						; size = 4
tv206 = -108						; size = 4
tv205 = -101						; size = 1
tv204 = -100						; size = 4
tv203 = -96						; size = 4
tv202 = -89						; size = 1
tv201 = -88						; size = 4
tv200 = -84						; size = 4
tv199 = -80						; size = 4
tv198 = -73						; size = 1
tv83 = -72						; size = 4
tv81 = -68						; size = 4
$T224284 = -64						; size = 4
$T224283 = -60						; size = 4
$T224282 = -56						; size = 4
$T224281 = -52						; size = 4
$T224280 = -48						; size = 4
__Ok$ = -40						; size = 8
__Pad$ = -28						; size = 4
__Count$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC NEAR ; std::operator<<<std::char_traits<char> >, COMDAT

; 700  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-120]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR __$EHRec$[ebp], esp

; 701  : 	typedef char _Elem;
; 702  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 703  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 704  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	mov	DWORD PTR __Count$[ebp], eax

; 705  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 706  : 		? 0 : _Ostr.width() - _Count;

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	test	eax, eax
	jle	SHORT $L224278
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	cmp	eax, DWORD PTR __Count$[ebp]
	jle	SHORT $L224278
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?width@ios_base@std@@QBEHXZ		; std::ios_base::width
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $L224279
$L224278:
	mov	DWORD PTR tv81[ebp], 0
$L224279:
	mov	eax, DWORD PTR tv81[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 707  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 708  : 
; 709  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	edx, al
	test	edx, edx
	jne	SHORT $L218505

; 710  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 711  : 	else

	jmp	$L224285
$L218505:

; 712  : 		{	// state okay, insert
; 713  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 714  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?flags@ios_base@std@@QBEHXZ		; std::ios_base::flags
	mov	DWORD PTR tv83[ebp], eax
	mov	eax, DWORD PTR tv83[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$L218508

; 715  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $L218509
$L218510:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$L218509:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $L218508

; 716  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 717  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv198[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv199[ebp], eax
	mov	al, BYTE PTR tv198[ebp]
	push	eax
	mov	ecx, DWORD PTR tv199[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv200[ebp], eax
	mov	ecx, DWORD PTR tv200[ebp]
	mov	DWORD PTR $T224280[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv201[ebp], eax
	mov	edx, DWORD PTR tv201[ebp]
	mov	DWORD PTR $T224281[ebp], edx
	lea	eax, DWORD PTR $T224280[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224281[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv202[ebp], al
	movzx	edx, BYTE PTR tv202[ebp]
	test	edx, edx
	je	SHORT $L218514

; 718  : 					{	// insertion failed, quit
; 719  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 720  : 					break;

	jmp	SHORT $L218508
$L218514:

; 721  : 					}
; 722  : 
; 723  : 		if (_State == ios_base::goodbit

	jmp	SHORT $L218510
$L218508:

; 724  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $L218515
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv203[ebp], eax
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv203[ebp]
	call	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
	mov	DWORD PTR tv204[ebp], eax
	mov	edx, DWORD PTR tv204[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $L218515

; 725  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$L218515:

; 726  : 
; 727  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$L218516

; 728  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $L218517
$L218518:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$L218517:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $L218516

; 729  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 730  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
	mov	BYTE PTR tv205[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
	mov	DWORD PTR tv206[ebp], eax
	mov	al, BYTE PTR tv205[ebp]
	push	eax
	mov	ecx, DWORD PTR tv206[ebp]
	call	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
	mov	DWORD PTR tv207[ebp], eax
	mov	ecx, DWORD PTR tv207[ebp]
	mov	DWORD PTR $T224282[ebp], ecx
	call	?eof@?$char_traits@D@std@@SAHXZ		; std::char_traits<char>::eof
	mov	DWORD PTR tv208[ebp], eax
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR $T224283[ebp], edx
	lea	eax, DWORD PTR $T224282[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224283[ebp]
	push	ecx
	call	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ; std::char_traits<char>::eq_int_type
	add	esp, 8
	mov	BYTE PTR tv209[ebp], al
	movzx	edx, BYTE PTR tv209[ebp]
	test	edx, edx
	je	SHORT $L218522

; 731  : 					{	// insertion failed, quit
; 732  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 733  : 					break;

	jmp	SHORT $L218516
$L218522:

; 734  : 					}
; 735  : 		_Ostr.width(0);

	jmp	SHORT $L218518
$L218516:
	push	0
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?width@ios_base@std@@QAEHH@Z		; std::ios_base::width
	jmp	SHORT $L224285
$L224286:

; 736  : 		_CATCH_IO_(_Ostr)

	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
	mov	eax, $L224285
	ret	0
$L224285:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 737  : 		}
; 738  : 
; 739  : 	_Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 740  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T224284[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T224284[ebp]

; 741  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L224293
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 120				; 00000078H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L224293:
	DD	1
	DD	$L224292
$L224292:
	DD	-40					; ffffffd8H
	DD	8
	DD	$L224290
$L224290:
	DB	95					; 0000005fH
	DB	79					; 0000004fH
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224287:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	eax, OFFSET FLAT:$T224289
	jmp	___CxxFrameHandler
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBEHXZ PROC NEAR			; std::ios_base::width, COMDAT
; _this$ = ecx

; 369  : 		{	// return width

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 370  : 		return (_Wide);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 371  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?width@ios_base@std@@QBEHXZ ENDP			; std::ios_base::width
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT
__Oldwidth$ = -8					; size = 4
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 4
?width@ios_base@std@@QAEHH@Z PROC NEAR			; std::ios_base::width, COMDAT
; _this$ = ecx

; 374  : 		{	// set width to argument

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		streamsize _Oldwidth = _Wide;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Oldwidth$[ebp], ecx

; 376  : 		_Wide = _Newwidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newwidth$[ebp]
	mov	DWORD PTR [edx+24], eax

; 377  : 		return (_Oldwidth);

	mov	eax, DWORD PTR __Oldwidth$[ebp]

; 378  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?width@ios_base@std@@QAEHH@Z ENDP			; std::ios_base::width
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T224313 DD	0ffffffffH
	DD	FLAT:$L224307
	DD	00H
	DD	FLAT:$L224306
$T224311 DD	019930520H
	DD	02H
	DD	FLAT:$T224313
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T224308 = -44						; size = 4
$T224305 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T224308[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T224305[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv77[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T224308[ebp]
	or	eax, 1
	mov	DWORD PTR $T224308[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T224305[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224306:
	lea	ecx, DWORD PTR $T224305[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L224307:
	mov	eax, DWORD PTR $T224308[ebp]
	and	eax, 1
	je	$L224309
	and	DWORD PTR $T224308[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L224309:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
	mov	eax, OFFSET FLAT:$T224311
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_Glocale@std@@QAEPAXI@Z			; std::locale::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z PROC NEAR ; std::_DebugHeapDelete<std::locale>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L218527

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_Glocale@std@@QAEPAXI@Z

; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L218527:

; 64   : 		}
; 65   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z ENDP ; std::_DebugHeapDelete<std::locale>
_TEXT	ENDS
PUBLIC	??_G_DebugHeapString@std@@QAEPAXI@Z		; std::_DebugHeapString::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z PROC NEAR ; std::_DebugHeapDelete<std::_DebugHeapString>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L218530

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G_DebugHeapString@std@@QAEPAXI@Z

; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L218530:

; 64   : 		}
; 65   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@V_DebugHeapString@std@@@std@@YAXPAV_DebugHeapString@0@@Z ENDP ; std::_DebugHeapDelete<std::_DebugHeapString>
_TEXT	ENDS
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
PUBLIC	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z ; std::codecvt<char,char,int>::_Getcat
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224332 DD	0ffffffffH
	DD	FLAT:$L224324
$T224326 DD	019930520H
	DD	01H
	DD	FLAT:$T224332
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T224323 = -64						; size = 4
$T224322 = -60						; size = 12
__Pfmod$218556 = -48					; size = 4
__Pf$ = -44						; size = 4
__Id$ = -40						; size = 4
__Psave$ = -32						; size = 4
__Lock$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::codecvt<char,char,int> >, COMDAT

; 315  : 	{	// get facet reference from locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

	push	0
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??0_Lockit@std@@QAE@H@Z			; std::_Lockit::_Lockit
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

	mov	eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave
	mov	DWORD PTR __Psave$[ebp], eax

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

	mov	ecx, OFFSET FLAT:?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id
	call	??Bid@locale@std@@QAEIXZ		; std::locale::id::operator unsigned int
	mov	DWORD PTR __Id$[ebp], eax

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

	mov	ecx, DWORD PTR __Id$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Loc$[ebp]
	call	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
	mov	DWORD PTR __Pf$[ebp], eax

; 322  : 
; 323  : 	if (_Pf != 0)

	cmp	DWORD PTR __Pf$[ebp], 0
	je	SHORT $L218547

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

	jmp	SHORT $L218548
$L218547:
	cmp	DWORD PTR __Psave$[ebp], 0
	je	SHORT $L218549

; 326  : 		_Pf = _Psave;	// lazy facet already allocated

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

	jmp	SHORT $L218548
$L218549:
	lea	eax, DWORD PTR __Psave$[ebp]
	push	eax
	call	?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z ; std::codecvt<char,char,int>::_Getcat
	add	esp, 4
	cmp	eax, -1
	jne	SHORT $L218552

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

	push	OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
	lea	ecx, DWORD PTR $T224322[ebp]
	call	??0bad_cast@@QAE@PBD@Z			; bad_cast::bad_cast
	push	OFFSET FLAT:__TI2?AVbad_cast@@
	lea	ecx, DWORD PTR $T224322[ebp]
	push	ecx
	call	__CxxThrowException@8
$L218552:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

	mov	edx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pf$[ebp], edx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

	mov	eax, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDH@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::codecvt<char,char,int> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

	mov	ecx, DWORD PTR __Psave$[ebp]
	mov	DWORD PTR __Pfmod$218556[ebp], ecx

; 342  : 		_Pfmod->_Incref();

	mov	ecx, DWORD PTR __Pfmod$218556[ebp]
	call	?_Incref@facet@locale@std@@QAEXXZ	; std::locale::facet::_Incref

; 343  : 		_Pfmod->_Register();

	mov	ecx, DWORD PTR __Pfmod$218556[ebp]
	call	?_Register@facet@locale@std@@QAEXXZ	; std::locale::facet::_Register
$L218548:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

	mov	edx, DWORD PTR __Pf$[ebp]
	mov	DWORD PTR $T224323[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
	mov	eax, DWORD PTR $T224323[ebp]
$L224321:

; 347  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L224331
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L224331:
	DD	2
	DD	$L224330
$L224330:
	DD	-20					; ffffffecH
	DD	4
	DD	$L224327
	DD	-32					; ffffffe0H
	DD	4
	DD	$L224328
$L224328:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$L224327:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224324:
	lea	ecx, DWORD PTR __Lock$[ebp]
	jmp	??1_Lockit@std@@QAE@XZ			; std::_Lockit::~_Lockit
__ehhandler$??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z:
	mov	eax, OFFSET FLAT:$T224326
	jmp	___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$codecvt@DDH@std@@@std@@YAABV?$codecvt@DDH@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,int> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xdebug
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_DebugHeapDelete@X@std@@YAXPAX@Z PROC NEAR		; std::_DebugHeapDelete<void>, COMDAT

; 57   : 	{	// delete from the debug CRT heap even if operator delete exists

	push	ebp
	mov	ebp, esp

; 58   : 	if (_Ptr != 0)

	cmp	DWORD PTR __Ptr$[ebp], 0
	je	SHORT $L218560

; 59   : 		{	// worth deleting
; 60   : 		_Ptr->~_Ty();
; 61   : 		// delete as _NORMAL_BLOCK, not _CRT_BLOCK, since we might have
; 62   : 		// facets allocated by normal new.
; 63   : 		free(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_free
	add	esp, 4
$L218560:

; 64   : 		}
; 65   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_DebugHeapDelete@X@std@@YAXPAX@Z ENDP		; std::_DebugHeapDelete<void>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *><TempFilePathInfo *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUTempFilePathInfo@@@?$allocator@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *><TempFilePathInfo *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T224346 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *,std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T224346[ebp], eax
	cmp	DWORD PTR $T224346[ebp], 0
	je	SHORT $L224347
	mov	ecx, DWORD PTR $T224346[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T224346[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $L218568
$L224347:
	mov	DWORD PTR tv68[ebp], 0
$L218568:

; 43   : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *,std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z PROC NEAR ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node><TempFilePathInfo *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUTempFilePathInfo@@@?$allocator@U_Node@?$_List_nod@PAUTempFilePathInfo@@V?$allocator@PAUTempFilePathInfo@@@std@@@std@@@std@@QAE@ABV?$allocator@PAUTempFilePathInfo@@@1@@Z ENDP ; std::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node>::allocator<std::_List_nod<TempFilePathInfo *,std::allocator<TempFilePathInfo *> >::_Node><TempFilePathInfo *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glocale@std@@QAEPAXI@Z PROC NEAR			; std::locale::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1locale@std@@QAE@XZ			; std::locale::~locale
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L218589
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L218589:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glocale@std@@QAEPAXI@Z ENDP				; std::locale::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1_DebugHeapString@std@@QAE@XZ			; std::_DebugHeapString::~_DebugHeapString
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G_DebugHeapString@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_DebugHeapString@std@@QAEPAXI@Z PROC NEAR		; std::_DebugHeapString::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_DebugHeapString@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L218592
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L218592:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_DebugHeapString@std@@QAEPAXI@Z ENDP		; std::_DebugHeapString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::~basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_DebugHeapString@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_DebugHeapString@std@@QAE@XZ PROC NEAR		; std::_DebugHeapString::~_DebugHeapString, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::~basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_DebugHeapString@std@@QAE@XZ ENDP			; std::_DebugHeapString::~_DebugHeapString
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::~basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >::~basic_string<char,std::char_traits<char>,std::_DebugHeapAllocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\ios
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC NEAR ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 101  : 		{	// return fill character

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 		return (_Fillch);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+48]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
_TEXT	ENDS
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z PROC NEAR ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 152  : 		{	// put _Count characters from array beginning at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		return (xsputn(_Ptr, _Count));

	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 154  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
PUBLIC	??0?$codecvt@DDH@std@@QAE@I@Z			; std::codecvt<char,char,int>::codecvt<char,char,int>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
xdata$x	SEGMENT
$T224378 DD	0ffffffffH
	DD	FLAT:$L224374
$T224376 DD	019930520H
	DD	01H
	DD	FLAT:$T224378
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT
tv80 = -24						; size = 4
$T224371 = -20						; size = 4
$T224370 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z PROC NEAR ; std::codecvt<char,char,int>::_Getcat, COMDAT

; 597  : 		{	// return locale category mask and construct standard facet

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-24], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-20], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH

; 598  : 		if (_Ppf != 0 && *_Ppf == 0)

	cmp	DWORD PTR __Ppf$[ebp], 0
	je	SHORT $L218618
	mov	eax, DWORD PTR __Ppf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L218618

; 599  : 			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>;

	push	599					; 00000257H
	push	OFFSET FLAT:??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	push	8
	call	??2@YAPAXIABU_DebugHeapTag_t@std@@PADH@Z ; operator new
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T224371[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T224371[ebp], 0
	je	SHORT $L224372
	push	0
	mov	ecx, DWORD PTR $T224371[ebp]
	call	??0?$codecvt@DDH@std@@QAE@I@Z		; std::codecvt<char,char,int>::codecvt<char,char,int>
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L224373
$L224372:
	mov	DWORD PTR tv80[ebp], 0
$L224373:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR $T224370[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR __Ppf$[ebp]
	mov	eax, DWORD PTR $T224370[ebp]
	mov	DWORD PTR [edx], eax
$L218618:

; 600  : 		return (_X_CTYPE);

	mov	eax, 2

; 601  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224374:
	push	599					; 00000257H
	push	OFFSET FLAT:??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
	push	OFFSET FLAT:?_DebugHeapTag@std@@3U_DebugHeapTag_t@1@B ; std::_DebugHeapTag
	mov	eax, DWORD PTR $T224371[ebp]
	push	eax
	call	??3@YAXPAXABU_DebugHeapTag_t@std@@PADH@Z ; operator delete
	add	esp, 16					; 00000010H
	ret	0
__ehhandler$?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z:
	mov	eax, OFFSET FLAT:$T224376
	jmp	___CxxFrameHandler
text$x	ENDS
?_Getcat@?$codecvt@DDH@std@@SAIPAPBVfacet@locale@2@@Z ENDP ; std::codecvt<char,char,int>::_Getcat
PUBLIC	??0codecvt_base@std@@QAE@I@Z			; std::codecvt_base::codecvt_base
PUBLIC	??1codecvt_base@std@@UAE@XZ			; std::codecvt_base::~codecvt_base
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
PUBLIC	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z	; std::codecvt<char,char,int>::_Init
PUBLIC	?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_in
PUBLIC	?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ; std::codecvt<char,char,int>::do_out
PUBLIC	?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ; std::codecvt<char,char,int>::do_unshift
PUBLIC	?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z	; std::codecvt<char,char,int>::do_length
PUBLIC	??_7?$codecvt@DDH@std@@6B@			; std::codecvt<char,char,int>::`vftable'
PUBLIC	??_G?$codecvt@DDH@std@@MAEPAXI@Z		; std::codecvt<char,char,int>::`scalar deleting destructor'
EXTRN	??_E?$codecvt@DDH@std@@MAEPAXI@Z:NEAR		; std::codecvt<char,char,int>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T224389 DD	0ffffffffH
	DD	FLAT:$L224384
	DD	00H
	DD	FLAT:$L224385
$T224387 DD	019930520H
	DD	02H
	DD	FLAT:$T224389
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$codecvt@DDH@std@@6B@
CONST	SEGMENT
??_7?$codecvt@DDH@std@@6B@ DD FLAT:??_E?$codecvt@DDH@std@@MAEPAXI@Z ; std::codecvt<char,char,int>::`vftable'
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$codecvt@DDH@std@@QAE@I@Z
_TEXT	SEGMENT
tv77 = -140						; size = 4
tv65 = -136						; size = 4
$T224383 = -132						; size = 116
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Refs$ = 8						; size = 4
??0?$codecvt@DDH@std@@QAE@I@Z PROC NEAR			; std::codecvt<char,char,int>::codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 586  : 		{	// construct from current locale

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$codecvt@DDH@std@@QAE@I@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 128				; 00000080H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-140]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0codecvt_base@std@@QAE@I@Z		; std::codecvt_base::codecvt_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7?$codecvt@DDH@std@@6B@

; 587  : 		_Init(_Locinfo());

	push	OFFSET FLAT:??_C@_01GFHCPBMG@C?$AA@
	lea	ecx, DWORD PTR $T224383[ebp]
	call	??0_Locinfo@std@@QAE@PBD@Z		; std::_Locinfo::_Locinfo
	mov	DWORD PTR tv65[ebp], eax
	mov	edx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv77[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ; std::codecvt<char,char,int>::_Init
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T224383[ebp]
	call	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo

; 588  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 140				; 0000008cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224384:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1codecvt_base@std@@UAE@XZ		; std::codecvt_base::~codecvt_base
$L224385:
	lea	ecx, DWORD PTR $T224383[ebp]
	jmp	??1_Locinfo@std@@QAE@XZ			; std::_Locinfo::~_Locinfo
__ehhandler$??0?$codecvt@DDH@std@@QAE@I@Z:
	mov	eax, OFFSET FLAT:$T224387
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$codecvt@DDH@std@@QAE@I@Z ENDP			; std::codecvt<char,char,int>::codecvt<char,char,int>
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??_Gcodecvt_base@std@@UAEPAXI@Z			; std::codecvt_base::`scalar deleting destructor'
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:NEAR		; std::codecvt_base::`vector deleting destructor'
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z ; std::codecvt_base::`vftable'
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0codecvt_base@std@@QAE@I@Z PROC NEAR			; std::codecvt_base::codecvt_base, COMDAT
; _this$ = ecx

; 503  : 		{	// default constructor

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Refs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0facet@locale@std@@IAE@I@Z		; std::locale::facet::facet
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7codecvt_base@std@@6B@

; 504  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0codecvt_base@std@@QAE@I@Z ENDP			; std::codecvt_base::codecvt_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1codecvt_base@std@@UAE@XZ PROC NEAR			; std::codecvt_base::~codecvt_base, COMDAT
; _this$ = ecx

; 522  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7codecvt_base@std@@6B@

; 523  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1facet@locale@std@@UAE@XZ		; std::locale::facet::~facet
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1codecvt_base@std@@UAE@XZ ENDP			; std::codecvt_base::~codecvt_base
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC NEAR	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 527  : 		{	// return true if conversions never change input (from codecvt)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 528  : 		return (true);

	mov	al, 1

; 529  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_max_length@codecvt_base@std@@MBEHXZ PROC NEAR	; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 532  : 		{	// return maximum length required for a conversion (from codecvt)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 533  : 		return (1);

	mov	eax, 1

; 534  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_encoding@codecvt_base@std@@MBEHXZ PROC NEAR		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 537  : 		{	// return length of code sequence (from codecvt)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 538  : 		return (1);	// -1 ==> state dependent, 0 ==> varying length

	mov	eax, 1

; 539  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC NEAR		; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1codecvt_base@std@@UAE@XZ		; std::codecvt_base::~codecvt_base
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L194057
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L194057:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::do_in, COMDAT
; _this$ = ecx

; 616  : 		{	// convert bytes [_First1, _Last1) to [_First2, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 617  : 		_Mid1 = _First1, _Mid2 = _First2;

	mov	eax, DWORD PTR __Mid1$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Mid2$[ebp]
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR [edx], eax

; 618  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 619  : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_in@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_in
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
___formal$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
___formal$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::do_out, COMDAT
; _this$ = ecx

; 624  : 		{	// convert [_First1, _Last1) to bytes [_First2, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 625  : 		_Mid1 = _First1, _Mid2 = _First2;

	mov	eax, DWORD PTR __Mid1$[ebp]
	mov	ecx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Mid2$[ebp]
	mov	eax, DWORD PTR __First2$[ebp]
	mov	DWORD PTR [edx], eax

; 626  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 627  : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?do_out@?$codecvt@DDH@std@@MBEHAAHPBD1AAPBDPAD3AAPAD@Z ENDP ; std::codecvt<char,char,int>::do_out
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z PROC NEAR ; std::codecvt<char,char,int>::do_unshift, COMDAT
; _this$ = ecx

; 631  : 		{	// generate bytes to return to default shift state

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 632  : 		return (noconv);	// convert nothing

	mov	eax, 3

; 633  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?do_unshift@?$codecvt@DDH@std@@MBEHAAHPAD1AAPAD@Z ENDP	; std::codecvt<char,char,int>::do_unshift
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z PROC NEAR	; std::codecvt<char,char,int>::do_length, COMDAT
; _this$ = ecx

; 637  : 		{	// return min(_Count, converted length of bytes [_First1, _Last1))

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return ((int)(_Count < (size_t)(_Last1 - _First1)
; 639  : 			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion

	mov	eax, DWORD PTR __Last1$[ebp]
	sub	eax, DWORD PTR __First1$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	jae	SHORT $L224414
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $L224415
$L224414:
	mov	edx, DWORD PTR __Last1$[ebp]
	sub	edx, DWORD PTR __First1$[ebp]
	mov	DWORD PTR tv67[ebp], edx
$L224415:
	mov	eax, DWORD PTR tv67[ebp]

; 640  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?do_length@?$codecvt@DDH@std@@MBEHABHPBD1I@Z ENDP	; std::codecvt<char,char,int>::do_length
_TEXT	ENDS
PUBLIC	??1?$codecvt@DDH@std@@MAE@XZ			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$codecvt@DDH@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$codecvt@DDH@std@@MAEPAXI@Z PROC NEAR		; std::codecvt<char,char,int>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$codecvt@DDH@std@@MAE@XZ		; std::codecvt<char,char,int>::~codecvt<char,char,int>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L217799
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L217799:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$codecvt@DDH@std@@MAEPAXI@Z ENDP			; std::codecvt<char,char,int>::`scalar deleting destructor'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$codecvt@DDH@std@@MAE@XZ PROC NEAR			; std::codecvt<char,char,int>::~codecvt<char,char,int>, COMDAT
; _this$ = ecx

; 605  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$codecvt@DDH@std@@6B@

; 606  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1codecvt_base@std@@UAE@XZ		; std::codecvt_base::~codecvt_base
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$codecvt@DDH@std@@MAE@XZ ENDP			; std::codecvt<char,char,int>::~codecvt<char,char,int>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z PROC NEAR ; std::codecvt<char,char,int>::_Init, COMDAT
; _this$ = ecx

; 610  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 611  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Init@?$codecvt@DDH@std@@IAEXABV_Locinfo@2@@Z ENDP	; std::codecvt<char,char,int>::_Init
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
CRT$XCU	SEGMENT
_$S6	DD	FLAT:_$E4
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.cpp
CRT$XCU	ENDS
;	COMDAT _$E4
text$yc	SEGMENT
_$E4	PROC NEAR					; COMDAT

; 164  : 	"CqD09vDlKUxOwqxJTcGQSrtVoOZzOATyJZYxggEYMBMGCSqGSIb3DQEJFTEGBAQBAAAAMGMGCSsGAQQBgjcRATFWHlQATQBpAGMAcgBvAHMAbwBmAHQAIABCAGEAcwBlACAAQwByAHkAcAB0AG8AZwByAGEAcABoAGkAYwAgAFAAcgBvAHYAaQBkAGUAcgAgAHYAMQAuADAwgZsGCSqGSIb3DQEJFDGBjR6BigAzADkAZgBmAGQAMgAwAGQAZAA1AGIANAAzADUAOQBhADcAOQA1ADQAZgAyAGEAZQA5AGMAYQAzAGYAMQBhADUAXwBjADYANABjAGYAYwBiADIALQA0AGUAOQBkAC0ANAAxAGIAYQAtAGIAZAAyADYALQAyADYAMQBjADkAOABkAGQAMgAwADYAODCCDI8GCSqGSIb3DQEHBqCCDIAwggx8AgEAMIIMdQYJKoZIhvcNAQcBMBwGCiqGSIb3DQEMAQYwDgQIZmD5BywuWgYCAgfQgIIMSCBOXKF4xx6o+dvu45pFLvWjUB44S/1w504WVp4KKUgKFZOvfGIfJbIOlHp/ZbkXjqc5NdJ4KoVLq21ZmSS6ROrMIdKJlcB7AvCmJN0fuZxqe5+azq6va9Kuo7XyGZSd1AMpYwGWA54d4LXCBlnO3iH6tHDe+uTQTuAQizcWATiv59Nby7iFrilGhyO7YqN8v+Z7bVJBIR5L4cudepQeOcWhHDu2ULI14HqPY/pW7biy18OcONcMvojt7MN1A5v5M7xjNI8SOizJlBaTKQ+aFivPXuDLyab5XKEUv4dSfgaine66XLNP+jk1WSTLZHxY7GWUj5PANVLB+is7WOtdm+ALjoVIYpHcnBfArrQPh3qq8a9vKNmI8q5nqCNMlRJ6hiST5D5efZAYF2/qi6CBNPaHaJk17Z0TWgsHK0oQOsFZFERyGUo0oB8fRZHDpuXvFv1Np8/cS7867atVxkxaUIGLX94uBlfsqFXDIrSX";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204898
	mov	ecx, OFFSET FLAT:?FL_LIC2@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E5
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E4	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S9	DD	FLAT:_$E7
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E7
text$yc	SEGMENT
_$E7	PROC NEAR					; COMDAT

; 166  : 	"UHmvkICg2lRPGAMG2AIqs16Hqjnp+j6FGg8VzqioenSNN6HH1VgAZmQq0LN7I9YVseMCx6KK1CkzHeqmyZr3DgNVGofUkzDSNe6KIdc9YVHGaTEoFNT7V2IJQv2L6HytuAMuMDswHzAHBgUrDgMCGgQUa6XzwBso6MhKYmYoywZj78RFceUEFA/6/K0CTxwzEPFw7/6jgBvpSsQJAgIH0A==";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204904
	mov	ecx, OFFSET FLAT:?FL_LIC7@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E8
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E7	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S12	DD	FLAT:_$E10
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E10
text$yc	SEGMENT
_$E10	PROC NEAR					; COMDAT

; 168  : 	"Y8TEQMJMCxXAxf8bPmgzWQLguurAzn6bqxJ+KkLKFGMJx7/oX2DU0wfmqV7YknpsPp9zS8ENH2aJ+9Xe7qPwaaFOW9BcIGOXWNO4uERDLzuir2hO91ex+wKwGb8kommigD+whv6gjqseN9oaKcd8jv+et/UqVBNqKRKrXkTQuXuK0wmF41PfJ4CM9RHn/1Pl3ctyRFS4OMkstDfrtaFx3Op6rmyRORhTjguonQ4+C3kHnjIPo7s3129/0/PhHhuaxTTzWiV1L48Nve6wKMC2nBHEqTuttDxQ3tIhF2O8zpkGFx8g4VPGZRya31Y8iPhH55kqaVUYopAVGbCmnquVgaiydb7wcnKis+BSoaE7kYLT2Ey9JjYlNxIbKNfUxReM4wIwojHQxDTy/xvhbqsMv0yWdBfrz8yFFSkiNjubV+mfhil0eTZ+xshOYydKtoiCLavKqiiShNrbbOaUEgtmG6WeZpVkk6h2pthUUdkuhY7/QCb2TFYyzh9PeqU///IGCIFjjCJ9JLofLGpwWQaNftb7eZ1dNIu/NwG0DsFICT9jEU2Ji7qE5BZ8bSGhY4RCmFMe6oaQodmkfCKMpBjo8sn01/wXvQDuYVSj9Ai8+KfI9nClf+d1Le+1tmLfqf/tJOT+qIpb4lTwpAbhI21KSz2yxLNRYG1FX1Gpi2kGel06feDwH0BbsfwhiSGuBxjXqKCC61mBBbVyqIARbdcLR6GZt1/RqJ3x61Z4lReFhbafKOwKUKmgWvV1xEsSy+HWRJOowAMJRSM1SFycT7m/m6mjBzl0tYCeMslOdgfV+2AOS2N0gnQa+1XTxvfC3h6S6aH1rTckTru7XLS/zQ6uz5Ottf4VWgOOr9lqQViYzFnrWbnopua4uaxX+tjjgOgsav3IaphYgSrmhyGNoia5d5igPwr/S+jw4yPuoeaIqKr6fEFL95X3flGhjNNa/hsg3PmLOJMLh6bMkJSBp3Dhb91qHVnczaUvCRt2BT4c";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204910
	mov	ecx, OFFSET FLAT:?FL_LIC4@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E11
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E10	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S15	DD	FLAT:_$E13
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E13
text$yc	SEGMENT
_$E13	PROC NEAR					; COMDAT

; 170  : 	"pXfQ/mdS7IRdWlYYMCA+WRLHMPh0yJG/1xAtWj7s5tZBR8vjN9u";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204916
	mov	ecx, OFFSET FLAT:?FL_LIC9@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E14
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E13	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S18	DD	FLAT:_$E16
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E16
text$yc	SEGMENT
_$E16	PROC NEAR					; COMDAT

; 172  : 	"C7mkE79KQdPrdI+u0/hc04UTtjvmixSrFrMsyQTj8Qa9/VgNhnAQdVDlpmseg/UN+nRl4aSU1XxNRLJW6mwULWIy2oMkdlUM5EPWZtdkgju06VF8elbmqV83jczP1u9ZmWt1tb4fNnZFXacvDICjsf4v9lywXdMkAdL3R3QC2irH85U/+T5UcXy0GKaHu267dsQ6CvW9KVpQVhmpwG+VKe8GMfa6iVrELK6OzuCZTUPA2NygU4t5WcKzif0k2PphELICpUICyk0lljOl+K6WsbLm9uiP6sDLhZDuAduyUsD1cbk9Ld4aUtICcevJV8HQPdaf6kv1/rwfy5rrMjfQm0R7qOW7nq5NMzIuC2bRTlamu8i/WJ4B2fPNUTyNGip6QzznhrZHLgraw6X+PI73tuuscoXKE0jsLAmAGO6x8LxSNKP9JOCnfqogRoSWWusAqpSbVgrb1a4T5kjSUpTarhPxnTZr0pFOr4gIMh7EAWzP5MrgL00xVkB+YSZO+zh8ERJyk7/eILFWROaGetTO7hw6MqTZJWeaqwt+AUfaR8+s/L7hBRW8f5c3AgMkLYuZ7LT8vTXfx+ZbbWQHqXGA07EvHbcKdcdWuCZPP6tZghstI/TZZko8PD77C6YmKOXAcyaCarxGpxOpB+npXmuUoYq2rvGER6Kp7Oqw9asvDflyxztD7zpEG+xH9PrQutGWrzA7MB8wBwYFKw4DAhoEFAWYQYNKeznyhd4r/ccgvkZC/oQABBQX0hGT3zvy+g96yp80pdWqIjjJ7QICB9A=";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204922
	mov	ecx, OFFSET FLAT:?FL_LIC6@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E17
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E16	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S21	DD	FLAT:_$E19
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E19
text$yc	SEGMENT
_$E19	PROC NEAR					; COMDAT

; 174  : 	"+OvbSsu8av2p9rQBT90eK8ML5zTxR1gdt7at5Xkom+9RI1GKaRlh2gfcN/i38rwjtwotOr7i6";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204928
	mov	ecx, OFFSET FLAT:?FL_LIC10@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E20
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E19	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S24	DD	FLAT:_$E22
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E22
text$yc	SEGMENT
_$E22	PROC NEAR					; COMDAT

; 176  : 	"MIIQ8AIBAzCCEKwGCSqGSIb3DQEHAaCCEJ0EghCZMIIQlTCCA/4GCSqGSIb3DQEHAaCCA+8EggPrMIID5zCCA+MGCyqGSIb3DQEMCgECoIICtjCCArIwHAYKKoZIhvcNAQwBAzAOBAj3HeWAAnVoZAICB9AEggKQZKqxNZ4EGsxyM7X4lFwnjun8KfDj6WESEwbH3bGFdOCGtqS+oy42+ws9En774h9b7i3G3b87zMa+mfBNTH6I/3NqUg+MdF0Kh6kcjGPXjVgD6ojBVwV2JHfj7kWtrV8pGOLNPjLChSh24QJ5ffhiezFUB0Ak4G5wbWCR1OW3MqOMVItLHdKdJzQG3Uj4K8VWbZmz8FlxtJzcog2vTZpkGdBxP5a6+ONyBd95T6UnkPnXqc47YYIMjeCuXb1q2BRVSAG4XZj+I0WY62uCl5dTYnB9UpvJjFlI4F0Heb3BAfUmcEZOB0GytzsWyW2OpnpZJ4chrmZ/XTZ/qqRoHYMdR6QB2eYXeWakdSoIz1feJcBpLI5vb97qU/D+o5yXJsrSwBGRf4Wlby5U82+qSC9qSh0wsEgE5RvV9+anXLaDxXUZz+pq5HF6aQ4vXI3pHiYMpOwBzeoaNMtP0AhRDsBR5ZQ1luTJXRiGnLQBQt9Qh89mD86+zgxY0jqQ705WIqrSMpG4+rlmHWI6qLnqFOttIrN5pn9wT9XVTvC7GJVlUz6+MUCn40/20vhdqYrNzGmTRCMh4Ur59LDXH7cogsME+scbdRTG+SaAFrtdagi/2pxGRS+oun9yauRktgQA3y+R+kBu8y+mj1A80ef2KrBoovsVgSDJBwloujhXoeB1an91A+XRdEfQt98zpkXxEZ4WfYogruySOHrsSeX77bO1TB4fiBQLEc0hJHqLRcPePVT/OcF6ELUt085VPmu7Jsstp3S7uqfxfdmpGDy38BQ70uO/utcP6EBkkOFKXGCrRdGGfc4insahwSvmGhP20UtByso85EK4";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204934
	mov	ecx, OFFSET FLAT:?FL_LIC1@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E23
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E22	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S27	DD	FLAT:_$E25
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E25
text$yc	SEGMENT
_$E25	PROC NEAR					; COMDAT

; 178  : 	"0OQbFpRmbUSxGFsM2IfRPcmTuj6GQIL7HOaBdFDnvFda2G9JBbo6jdYjB1v2Yd/DKCjaTkgeYv23dhOifdTxw8lTwPY4XBAekqYugtJA6HMibY/sLPvlT+TkSONJK2hHYQ/9pU/UqhBQDBfNFLw/mBke9dZatVE2P/3mu7nRb1GvSx1wshJmAiP9iDVp6888+P7GBoJe0aGUhYXbCkO6XaPrGZ6iahVB5641sSHqUAxOE3IjHOqCxaWLMREduSbSRYcCWwqPQfK/NFRYZiE7kZmQ1CMItYp0AFfXDaoLf7TYQQYgltQkrGA2G/BlSveEaXPaaFJBEWq3yR+0GJRRMBUSywVPjAfQB52KJ+AlKjXv4Ljgt5kWCEa4C5Juzj77gu95MlkHZ3zneBpTpylNVN42/LT2Chn5v4s0K+XSPUhmUkSZ/Tgi8g8NZf5Cb8AuVQLXa32ec2g8/almzZf4T4f27BYg3XQNNbymAjxdDM+6Y3X2wgLWUnpJKfztXDgiImZYpB2rcDYhIJcSSPjkX992Frs7nrfWoAMdLIqCXEYtNHC6T4oRxYQV+Kf5SujGNQTaLzbWK2CveoqJEL7JuPHkr8voxTPj4E/MdiMlufzD0pdTx7+DPl82ViudyTFx8vElHmc2XMlgat4pB67IufXvujU2BC5FRqoUhX79gGNK0jhKqr/ZvL7zI46uqwQrsuizNiWRBrVuVdJ/lc6rx1iqqTQvD9IA17/PUwH9d6jcot9xMNHMcCtV4l1Lv0In83IEECp4jPVf7xaiJZ96FiNw9b12UpmYS3ntPKpl/wUzSrRijNwzKxHdzom+h7RiMWClqM+cpAxf2GmFroe823UB1IkUD0NPBNVys+ytl75U8o/i4eOF5EjJOko3IQDzjmPUTtOWZEVo1z14jF2UNR26TaOr037CFY+LmPgkZj7wW53MxEAxx0N0FQikVuLDjNKPdAJjlQyhwg1MPWeDG+pi2yx7AbvgzOQvSFpx";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204940
	mov	ecx, OFFSET FLAT:?FL_LIC5@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E26
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E25	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S30	DD	FLAT:_$E28
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E28
text$yc	SEGMENT
_$E28	PROC NEAR					; COMDAT

; 180  : 	"zCCEewGCSqGSIb3DQEHAaCCEd0EghHZMIIR1TCCA/4GCSqGSIb3DQEHAaCCA+8EggPrMIID5zCCA+MGCyqGSIb3DQEMCgECoIICtjCCArIwHAYKKoZIhvcNAQwBAzAOBAjRCuvybYFG2QICB9AEggKQikDH4PsWWvIs2DLre2xYmcJFvSgR32l";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204946
	mov	ecx, OFFSET FLAT:?FL_LIC8@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E29
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E28	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S33	DD	FLAT:_$E31
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E31
text$yc	SEGMENT
_$E31	PROC NEAR					; COMDAT

; 182  : 	"77kdP1ceKQe/kBTCR6qS9u262fN7H5xIvY3WJxUtJl/33sepuCBwRMApWpR9T45qkFsHUfWJalzWluV+pSauk104QVV43UATFVgLxd2OeEwqSNU7UGqHCe4TnMt6IcMSFHPZhnRdvaZ3hFIURhAuNep357YAa40urJ4kxIAdB2Bezs1OHn4vWbz3NLoxaHE5Jbf2jdyBRKI5RzIOew9vX8Rs6EVBE/aRrOyMcOWTXB+AODKlaCMbMEvDYATFALYfpqOec/62Uqwuz3CaBk/0+kljuEnjWoDzmHa+2ukjOvlfDopdc1f2aed9/RkURfGz5hMlV6zPoKJTi2HtbwZrCB/9jqqM4dvAxmF1057OPDGGM9+I/BGU/Dvh7JMUegFgQ+1oOcZqX9X7tT07qh0qFsMbLkIsZi6ZlW1eNuqpCm3CB9mHy0BGxhE5/ypFMz8R2/qp3iFWEhDrJoJ/tbwB7CAmnrpkMSJliaCauNH/nY91Pil6ATEyOpxDM5+mloM4SomBIBL+5DOFsNlBjnXK/GpIDDmcA+HOWNbP96ymQwt+ZM3eLu2c5pbLIosEMVRfTbL3+42jkrLrJEf2XqptG/7e2dPwKWlENdDBCezl1kvlmUx5uXjTmyiVG614y9YNz4+S3fbJAk1tYdiQfVBu+98qDO9XtnegeoKFnsWdbGVEFkmlLRp6dCuVZYqPnECzM8uRTLxzu0uehdfYufD8BD1eDyCgu79WtmLIR252bgUZ28HaGOKFUUkGPDRefioj+Zh4DJb93r5N4E7/MLLcjsdNIFsGh/7ke+IftJuXreH9P/k6aloptITCOnv/cLfGYDDNmrQ+oguhAC0HtysCO/iP0AxZ8IMExE6RPJ+mKHwZLwCK+CTSLFrp9siVRdCGKK9+HlWKDWsUh7Hqgl14krKRlU7HsEYvoCgkVfTRVWW6DVx1OYSt7egpS6OCP9ADcZrr79Uz6+0xnqMdXeq7ZyW2U1+FpCgPQTT0Nnl+";

	push	ebp
	mov	ebp, esp
	push	OFFSET FLAT:$SG204952
	mov	ecx, OFFSET FLAT:?FL_LIC3@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET FLAT:_$E32
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E31	ENDP
text$yc	ENDS
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
CRT$XCU	SEGMENT
_$S35	DD	FLAT:_$E34
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E34
text$yc	SEGMENT
_$E34	PROC NEAR					; COMDAT

; 610  : 		{	// initialize from _Lobj

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET FLAT:?id@?$codecvt@DDH@std@@2V0locale@2@A ; std::codecvt<char,char,int>::id
	call	??0id@locale@std@@QAE@I@Z		; std::locale::id::id
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E34	ENDP
; Function compile flags: /Odt /RTCsu
text$yc	ENDS
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC NEAR			; std::locale::id::id, COMDAT
; _this$ = ecx

; 66   : 			{	// construct with specified stamp value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	DWORD PTR [eax], ecx

; 67   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T224467 DD	0ffffffffH
	DD	FLAT:$L224463
$T224465 DD	019930520H
	DD	01H
	DD	FLAT:$T224467
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L224463:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T224465
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT _$E5
text$yd	SEGMENT
_$E5	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC2@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E5	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E8
text$yd	SEGMENT
_$E8	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC7@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E8	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E11
text$yd	SEGMENT
_$E11	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC4@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E11	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E14
text$yd	SEGMENT
_$E14	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC9@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E14	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E17
text$yd	SEGMENT
_$E17	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC6@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E17	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E20
text$yd	SEGMENT
_$E20	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC10@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E20	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E23
text$yd	SEGMENT
_$E23	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC1@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E23	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E26
text$yd	SEGMENT
_$E26	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC5@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E26	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E29
text$yd	SEGMENT
_$E29	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC8@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E29	ENDP
; Function compile flags: /Odt /RTCsu
text$yd	ENDS
;	COMDAT _$E32
text$yd	SEGMENT
_$E32	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?FL_LIC3@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E32	ENDP
text$yd	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?FL_LIC2@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC2
PUBLIC	?FL_LIC7@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC7
PUBLIC	?FL_LIC4@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC4
PUBLIC	?FL_LIC9@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC9
PUBLIC	?FL_LIC6@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC6
PUBLIC	?FL_LIC10@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC10
PUBLIC	?FL_LIC1@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC1
PUBLIC	?FL_LIC5@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC5
PUBLIC	?FL_LIC8@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC8
PUBLIC	?FL_LIC3@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CSignature::FL_LIC3
PUBLIC	?id@?$codecvt@DDH@std@@2V0locale@2@A		; std::codecvt<char,char,int>::id
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
?FL_LIC2@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC2
?FL_LIC7@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC7
?FL_LIC4@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC4
?FL_LIC9@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC9
?FL_LIC6@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC6
?FL_LIC10@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC10
?FL_LIC1@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC1
?FL_LIC5@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC5
?FL_LIC8@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC8
?FL_LIC3@CSignature@@2V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 01cH DUP (?) ; CSignature::FL_LIC3
_BSS	ENDS
;	COMDAT ?id@?$codecvt@DDH@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$codecvt@DDH@std@@2V0locale@2@A DD 01H DUP (?)	; std::codecvt<char,char,int>::id
_BSS	ENDS
END
