; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\CertVerify.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAE@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
CONST	SEGMENT
_oid_delta_crl_idicator DB 055H
	DB	01dH
	DB	01bH
	ORG $+1
_oid_issuing_disp_point DB 055H
	DB	01dH
	DB	01cH
	ORG $+1
$SG186916 DB	'ldap:', 00H
	ORG $+2
$SG187709 DB	'pp != 0', 00H
$SG187710 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_UninitUse:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	_setError:NEAR
EXTRN	_base64decodeSize:NEAR
EXTRN	_base64decode:NEAR
EXTRN	_malloc:NEAR
EXTRN	_rFree:NEAR
EXTRN	_CERT_DestroyCertificate:NEAR
EXTRN	_CERT_GetDefaultCertDB:NEAR
EXTRN	_SEC_DeletePermCertificate:NEAR
EXTRN	_memcpy:NEAR
EXTRN	_strlen:NEAR
EXTRN	_CERT_DestroyCertArray:NEAR
EXTRN	_CERT_ImportCerts:NEAR
EXTRN	_crIsPFX:NEAR
EXTRN	_NSS_ImportPKCS12Object:NEAR
;	COMDAT rtc$IMZ
; File c:\activex\xmlsign\certverify.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
$T188496 = -125						; size = 1
_rv$185872 = -124					; size = 4
_realLen$185856 = -120					; size = 4
_pwdBlob$ = -112					; size = 8
_cbData$ = -100						; size = 4
_res$ = -96						; size = 4
_sysTimeStatus$ = -92					; size = 4
_optFlag$ = -88						; size = 4
_rv$ = -84						; size = 4
_pTime$ = -76						; size = 8
_derCerts$ = -64					; size = 4
_certs$ = -56						; size = 4
_hStoreHandle$ = -48					; size = 4
_endPct$ = -44						; size = 4
_pct$ = -40						; size = 4
_pfxBlob$ = -32						; size = 12
_i$ = -16						; size = 4
_err$ = -12						; size = 4
_cbCert$ = -8						; size = 4
_pbCert$ = -4						; size = 4
_certData$ = 8						; size = 4
_certNum$ = 12						; size = 4
_pSysTime$ = 16						; size = 4
_password$ = 20						; size = 4
_certVerParams$ = 24					; size = 4
_pg_sig$ = 28						; size = 4
?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; crVerifyCertificate

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	push	edi
	lea	edi, DWORD PTR [ebp-128]
	mov	ecx, 32					; 00000020H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T188496[ebp], 0

; 130  : BYTE *pbCert=NULL;

	mov	DWORD PTR _pbCert$[ebp], 0

; 131  : DWORD cbCert=0;

	mov	DWORD PTR _cbCert$[ebp], 0

; 132  : int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 133  : UINT i=0;

	mov	DWORD PTR _i$[ebp], 0

; 134  : 
; 135  : #ifdef NSS
; 136  : SECItem pfxBlob;
; 137  : CERTCertificate *pct=NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 138  : CERTCertificate *endPct=NULL;

	mov	DWORD PTR _endPct$[ebp], 0

; 139  : CERTCertDBHandle *hStoreHandle=NULL;

	mov	DWORD PTR _hStoreHandle$[ebp], 0

; 140  : CERTCertificate **certs = NULL;

	mov	DWORD PTR _certs$[ebp], 0

; 141  : SECItem **derCerts = NULL;

	mov	DWORD PTR _derCerts$[ebp], 0

; 142  : int64 pTime=0;

	mov	DWORD PTR _pTime$[ebp], 0
	mov	DWORD PTR _pTime$[ebp+4], 0

; 143  : SECStatus rv;
; 144  : #else
; 145  : HCRYPTPROV hProv;
; 146  : CRYPT_KEY_PROV_INFO *provInfo;
; 147  : CRYPT_DATA_BLOB pfxBlob;
; 148  : PCCERT_CONTEXT pct=NULL;
; 149  : PCCERT_CONTEXT endPct=NULL;
; 150  : HCERTSTORE hStoreHandle=NULL;
; 151  : FILETIME pfTime;
; 152  : LPFILETIME pTime;
; 153  : #endif
; 154  : 
; 155  : int optFlag =0;

	mov	DWORD PTR _optFlag$[ebp], 0

; 156  : BOOL sysTimeStatus=FALSE;

	mov	DWORD PTR _sysTimeStatus$[ebp], 0

; 157  : int res=0;

	mov	DWORD PTR _res$[ebp], 0

; 158  : DWORD cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 159  : DS_DATA_BLOB pwdBlob;
; 160  : 
; 161  : if (password!=NULL) {

	cmp	DWORD PTR _password$[ebp], 0
	je	SHORT $L185831

; 162  : #ifdef NSS
; 163  : 	pwdBlob.cbData= password->len;

	mov	eax, DWORD PTR _password$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pwdBlob$[ebp+4], ecx

; 164  : 	pwdBlob.pbData= password->data;

	mov	edx, DWORD PTR _password$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _pwdBlob$[ebp], eax

; 165  : #else
; 166  : 	pwdBlob.cbData= 0;
; 167  : 	pwdBlob.pbData= (unsigned char *) password;
; 168  : #endif
; 169  : }else{

	jmp	SHORT $L185832
$L185831:

; 170  : 	pwdBlob.cbData= 0;

	mov	DWORD PTR _pwdBlob$[ebp+4], 0

; 171  : 	pwdBlob.pbData= NULL;

	mov	DWORD PTR _pwdBlob$[ebp], 0
$L185832:

; 172  : }
; 173  : 
; 174  : //DebugBreak();
; 175  : 
; 176  : if (!certData) {

	cmp	DWORD PTR _certData$[ebp], 0
	jne	SHORT $L185833

; 177  : 	setError(pg_sig, NO_CERTIFICATE);

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 178  : 	return FALSE;

	xor	eax, eax
	jmp	$L185813
$L185833:

; 179  : }
; 180  : #ifdef NSS
; 181  : 	hStoreHandle = CERT_GetDefaultCertDB();

	call	_CERT_GetDefaultCertDB
	mov	DWORD PTR _hStoreHandle$[ebp], eax

; 182  : 		//(CERTCertDBHandle *)217865; // any non-0 number
; 183  : #endif
; 184  : 
; 185  : 
; 186  : if ((certVerParams->userPolicySetCountOut != 0) && 
; 187  : 	(certVerParams->userPolicySetOut != NULL))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $L185834
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $L185834

; 188  : {
; 189  : 	for (i=0; i < certVerParams->userPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185835
$L185836:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L185835:
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jae	SHORT $L185837

; 190  : 	{
; 191  : 		if (certVerParams->userPolicySetOut[i] != NULL)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L185838

; 192  : 		{
; 193  : 			zFree(certVerParams->userPolicySetOut[i]);

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_rFree
	add	esp, 4

; 194  : 			certVerParams->userPolicySetOut[i] = NULL;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L185838:

; 195  : 		}
; 196  : 	}

	jmp	SHORT $L185836
$L185837:

; 197  : 	zFree(certVerParams->userPolicySetOut);

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_rFree
	add	esp, 4

; 198  : 	certVerParams->userPolicySetCountOut = 0;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 199  : 	certVerParams->userPolicySetOut = NULL;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+48], 0
$L185834:

; 200  : }
; 201  : 
; 202  : if ((certVerParams->authPolicySetCountOut != 0) && 
; 203  : 	(certVerParams->authPolicySetOut != NULL))

	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $L185839
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $L185839

; 204  : {
; 205  : 	for (i=0; i < certVerParams->authPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185840
$L185841:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L185840:
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jae	SHORT $L185842

; 206  : 	{
; 207  : 		if (certVerParams->authPolicySetOut[i] != NULL)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L185843

; 208  : 		{
; 209  : 			zFree(certVerParams->authPolicySetOut[i]);

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_rFree
	add	esp, 4

; 210  : 			certVerParams->authPolicySetOut[i] = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L185843:

; 211  : 		}
; 212  : 	}

	jmp	SHORT $L185841
$L185842:

; 213  : 	zFree(certVerParams->authPolicySetOut);

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_rFree
	add	esp, 4

; 214  : 	certVerParams->authPolicySetCountOut = 0;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+44], 0

; 215  : 	certVerParams->authPolicySetOut = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [eax+40], 0
$L185839:

; 216  : }
; 217  : //DebugBreak();
; 218  : if ((certVerParams->usedCrlCount != 0) &&
; 219  : 	(certVerParams->usedCrlList != NULL))

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $L185844
	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	SHORT $L185844

; 220  : {
; 221  : 	for (i=0; i < certVerParams->usedCrlCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185845
$L185846:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L185845:
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+60]
	jae	SHORT $L185847

; 222  : 	{
; 223  : 		if (certVerParams->usedCrlList[i] != NULL)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L185848

; 224  : 		{
; 225  : 			zFree(certVerParams->usedCrlList[i]);

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_rFree
	add	esp, 4

; 226  : 			certVerParams->usedCrlList[i] = NULL;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], 0
$L185848:

; 227  : 		}
; 228  : 	}

	jmp	SHORT $L185846
$L185847:

; 229  : 	zFree(certVerParams->usedCrlList);

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_rFree
	add	esp, 4

; 230  : 	certVerParams->usedCrlList = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [eax+64], 0

; 231  : 	certVerParams->usedCrlCount = 0;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+60], 0
$L185844:

; 232  : }
; 233  : 
; 234  : if (pSysTime!=NULL) {

	cmp	DWORD PTR _pSysTime$[ebp], 0
	je	SHORT $L185849

; 235  : #ifdef NSS
; 236  : SystemTimeToT64(pSysTime,&pTime);

	lea	edx, DWORD PTR _pTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pSysTime$[ebp]
	push	eax
	call	?SystemTimeToT64@@YAXPAU_SYSTEMTIME@@PA_J@Z ; SystemTimeToT64
	add	esp, 8

; 237  : #else
; 238  : pTime = &pfTime;
; 239  : sysTimeStatus = SystemTimeToFileTime(pSysTime, pTime);
; 240  : #endif
; 241  : } else {

	jmp	SHORT $L185850
$L185849:

; 242  : #ifdef NSS
; 243  : pTime=0;

	mov	DWORD PTR _pTime$[ebp], 0
	mov	DWORD PTR _pTime$[ebp+4], 0
$L185850:

; 244  : #else
; 245  : pTime=NULL;
; 246  : #endif
; 247  : }
; 248  : 
; 249  : #ifdef NSS
; 250  : 	derCerts = (SECItem **) zMalloc (sizeof(SECItem *) * certNum);

	mov	ecx, DWORD PTR _certNum$[ebp]
	shl	ecx, 2
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _derCerts$[ebp], eax

; 251  : #endif
; 252  : 
; 253  : for (i=0;i<certNum;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185853
$L185854:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L185853:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _certNum$[ebp]
	jae	$L185855

; 254  : 	int realLen=0;

	mov	DWORD PTR _realLen$185856[ebp], 0

; 255  : #ifdef NSS	
; 256  : 	pfxBlob.len = base64decodeSize(strlen((const char *)certData[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _pfxBlob$[ebp+8], eax

; 257  : 	pfxBlob.data = (BYTE *)zMalloc (pfxBlob.len+1);

	mov	ecx, DWORD PTR _pfxBlob$[ebp+8]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	BYTE PTR $T188496[ebp], 1
	mov	DWORD PTR _pfxBlob$[ebp+4], eax

; 258  : 	if ((realLen= base64decode(certData[i],pfxBlob.data,pfxBlob.len))==-1) {

	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188497
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188497:
	mov	edx, DWORD PTR _pfxBlob$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _pfxBlob$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _realLen$185856[ebp], eax
	cmp	DWORD PTR _realLen$185856[ebp], -1
	jne	SHORT $L185859

; 259  : 		setError(pg_sig, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 260  : 		err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$185860
$L185859:

; 261  : 	}
; 262  : 	pfxBlob.len = realLen;

	mov	edx, DWORD PTR _realLen$185856[ebp]
	mov	DWORD PTR _pfxBlob$[ebp+8], edx

; 263  : 	derCerts[i] = (SECItem *) zMalloc(sizeof(SECItem));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _derCerts$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 264  : 	derCerts[i]->len = pfxBlob.len;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _derCerts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _pfxBlob$[ebp+8]
	mov	DWORD PTR [edx+8], eax

; 265  : 	derCerts[i]->data = (BYTE *) zMalloc(pfxBlob.len);

	mov	ecx, DWORD PTR _pfxBlob$[ebp+8]
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _derCerts$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+4], eax

; 266  : 	memcpy(derCerts[i]->data,pfxBlob.data,pfxBlob.len);

	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188500
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188500:
	mov	eax, DWORD PTR _pfxBlob$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _pfxBlob$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _derCerts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 267  : 	
; 268  : #else
; 269  : 	pfxBlob.cbData = base64decodeSize(strlen((const char *)certData[i]));
; 270  : 	pfxBlob.pbData = (BYTE *)zMalloc (pfxBlob.cbData+1);
; 271  : 	if ((realLen= base64decode(certData[i],pfxBlob.pbData,pfxBlob.cbData))==-1) {
; 272  : 		setError(pg_sig, BASE64_ERROR);
; 273  : 		err=TRUE; goto retLabel;
; 274  : 	}
; 275  : 	pfxBlob.cbData = realLen;
; 276  : #endif
; 277  : 
; 278  : // special case: if certNum =1 it may be PFX
; 279  : 	if (certNum==1 
; 280  : 		&& crIsPFX(certData[i], &pwdBlob, pg_sig)) {

	cmp	DWORD PTR _certNum$[ebp], 1
	jne	$L185865
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pwdBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certData$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_crIsPFX
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$L185865

; 281  : 		//&& PFXIsPFXBlob(&pfxBlob)) {		
; 282  : #ifdef NSS
; 283  : 		if (!(pct = NSS_ImportPKCS12Object(&pfxBlob, password, pg_sig))) {

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	mov	eax, DWORD PTR _password$[ebp]
	push	eax
	mov	BYTE PTR $T188496[ebp], 1
	lea	ecx, DWORD PTR _pfxBlob$[ebp]
	push	ecx
	call	_NSS_ImportPKCS12Object
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pct$[ebp], eax
	cmp	DWORD PTR _pct$[ebp], 0
	jne	SHORT $L185866

; 284  : 			setError(pg_sig, PFX_BAD_PASSWORD);

	push	57					; 00000039H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 285  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$185860
$L185866:

; 286  : 		}
; 287  : #else
; 288  : 		// check if we have password. For NSS it's already done by crIsPFX.
; 289  : 		if (!PFXVerifyPassword(&pfxBlob, password, CRYPT_MACHINE_KEYSET))
; 290  : 		{
; 291  : 			setError(pg_sig,PFX_BAD_PASSWORD);
; 292  : 			err=TRUE; goto retLabel;
; 293  : 		}
; 294  : 
; 295  : 		if ((hStoreHandle =  PFXImportCertStore(
; 296  : 										&pfxBlob, 
; 297  : 										password, 
; 298  : 										CRYPT_MACHINE_KEYSET | CRYPT_EXPORTABLE
; 299  : 										)) == NULL)
; 300  : 		{
; 301  : 			setError(pg_sig,PFX_IMPORT_FAILED);
; 302  : 			err=TRUE; goto retLabel;
; 303  : 		}
; 304  : 
; 305  : 		// we need CERT_CONTEXT
; 306  : 		while(pct = CertEnumCertificatesInStore(
; 307  : 			 hStoreHandle,
; 308  : 			pct))
; 309  : 		{			
; 310  : 				int optFlag=0;
; 311  : 				if (crFilterCerts(pct,&optFlag,NULL,pg_sig)) 
; 312  : 				{
; 313  : 					cleanupError(pg_sig);
; 314  : 					break;
; 315  : 				}
; 316  : 		}
; 317  : #endif
; 318  : 		if (pct == NULL) {

	cmp	DWORD PTR _pct$[ebp], 0
	jne	SHORT $L185868

; 319  : 			setError(pg_sig, PFX_INVALID_CERTIFICATE);

	push	59					; 0000003bH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 320  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$185860
$L185868:

; 321  : 		}
; 322  : 
; 323  : 		if (!checkCertificate(	pct, 
; 324  : 								hStoreHandle, 
; 325  : 								pTime,
; 326  : 								certVerParams,
; 327  : 								pg_sig)) {

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hStoreHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _pct$[ebp]
	push	eax
	call	?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; checkCertificate
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $L185870

; 328  : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L185870:

; 329  : 		}
; 330  : 
; 331  : // cleanup store
; 332  : #ifdef NSS
; 333  : 	if (pfxBlob.data) zFree (pfxBlob.data);

	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188501
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188501:
	cmp	DWORD PTR _pfxBlob$[ebp+4], 0
	je	SHORT $L185871
	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188502
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188502:
	mov	ecx, DWORD PTR _pfxBlob$[ebp+4]
	push	ecx
	call	_rFree
	add	esp, 4
$L185871:

; 334  : 	pfxBlob.data = NULL;

	mov	BYTE PTR $T188496[ebp], 1
	mov	DWORD PTR _pfxBlob$[ebp+4], 0

; 335  : 	
; 336  : 	// remove certificate from database
; 337  : 	SECStatus rv = SEC_DeletePermCertificate(pct);

	mov	edx, DWORD PTR _pct$[ebp]
	push	edx
	call	_SEC_DeletePermCertificate
	add	esp, 4
	mov	DWORD PTR _rv$185872[ebp], eax

; 338  :     if (rv != SECSuccess) {

	cmp	DWORD PTR _rv$185872[ebp], 0
	je	SHORT $L185873

; 339  : 		setError(pg_sig, PFX_IMPORT_FAILED);

	push	58					; 0000003aH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8
$L185873:

; 340  :     }
; 341  : #else
; 342  : 	res = CertGetCertificateContextProperty(pct,CERT_KEY_PROV_INFO_PROP_ID,NULL,&cbData);
; 343  : 	if (!res) goto retLabel;
; 344  : 	provInfo = (CRYPT_KEY_PROV_INFO *) zMalloc(cbData);
; 345  : 	if (!provInfo) goto retLabel;
; 346  : 	res = CertGetCertificateContextProperty(pct,CERT_KEY_PROV_INFO_PROP_ID,provInfo,&cbData);
; 347  : 	if (!res) goto retLabel;
; 348  : 	res = CryptAcquireContextW(&hProv, 
; 349  : 						 provInfo->pwszContainerName, 
; 350  : 						 provInfo->pwszProvName, 
; 351  : 						 provInfo->dwProvType, 
; 352  : 						 CRYPT_DELETEKEYSET |(provInfo->dwFlags  & CRYPT_MACHINE_KEYSET));
; 353  : 	zFree(provInfo);
; 354  : #endif
; 355  : 	goto retLabel;

	jmp	$retLabel$185860
$L185865:

; 356  :   }
; 357  : #ifndef NSS
; 358  :   else {
; 359  : 
; 360  : 	// have to add certificate to the store
; 361  : 		if (hStoreHandle == NULL) {
; 362  : 			if(!(hStoreHandle = CertOpenStore(
; 363  : 			CERT_STORE_PROV_MEMORY,   // The memory provider type
; 364  : 			0,                        // The encoding type is not needed
; 365  : 			(HCRYPTPROV) NULL,                     // Use the default HCRYPTPROV
; 366  : 			0,                        // Accept the default dwFlags
; 367  : 			NULL                      // pvPara is not used
; 368  : 			))) {
; 369  : 				setError(pg_sig, CAPI_OPEN_STORE);
; 370  : 				err=TRUE; goto retLabel;
; 371  : 			}
; 372  : 		}
; 373  : 
; 374  : 	if(!(CertAddEncodedCertificateToStore(
; 375  : 		hStoreHandle,
; 376  : 		MY_ENCODING_TYPE, // The encoding type
; 377  : 		(const BYTE*) pfxBlob.pbData,   // The encoded data from the certificate retrieved
; 378  : 		pfxBlob.cbData,
; 379  : 		CERT_STORE_ADD_REPLACE_EXISTING,
; 380  : 		&pct	)))  // The length of the encoded data
; 381  : 		{
; 382  : 			setError(pg_sig, CAPI_ADD_CERT);
; 383  : 			err=TRUE; goto retLabel;
; 384  : 		}
; 385  : 	
; 386  : 	if (i==0) endPct = pct;	// end certificate is always the first in array
; 387  : 	else{
; 388  : 		CertFreeCertificateContext(pct);
; 389  : 	}
; 390  :   } // PFX?
; 391  : #endif
; 392  : 
; 393  : #ifdef NSS
; 394  : 	if (pfxBlob.data) zFree (pfxBlob.data);

	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188503
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188503:
	cmp	DWORD PTR _pfxBlob$[ebp+4], 0
	je	SHORT $L185875
	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188504
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188504:
	mov	ecx, DWORD PTR _pfxBlob$[ebp+4]
	push	ecx
	call	_rFree
	add	esp, 4
$L185875:

; 395  : 	pfxBlob.data = NULL;

	mov	BYTE PTR $T188496[ebp], 1
	mov	DWORD PTR _pfxBlob$[ebp+4], 0

; 396  : #else
; 397  : 	if (pfxBlob.pbData) zFree (pfxBlob.pbData);
; 398  : 	pfxBlob.pbData = NULL;
; 399  : #endif
; 400  : 
; 401  : } // for

	jmp	$L185854
$L185855:

; 402  : 
; 403  : #ifdef NSS
; 404  : 	// for NSS, no need in loop - all certificates are imported at once
; 405  : 	// add certificate to the store and CERTList
; 406  : 	pct = NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 407  : 	rv = CERT_ImportCerts(
; 408  : 			hStoreHandle, 
; 409  : 			certUsageObjectSigner,
; 410  : 			certNum, 
; 411  : 			derCerts,
; 412  : 			&certs, 
; 413  : 			PR_FALSE,
; 414  : 			PR_FALSE, 
; 415  : 			NULL);

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _certs$[ebp]
	push	edx
	mov	eax, DWORD PTR _derCerts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certNum$[ebp]
	push	ecx
	push	6
	mov	edx, DWORD PTR _hStoreHandle$[ebp]
	push	edx
	call	_CERT_ImportCerts
	add	esp, 32					; 00000020H
	mov	DWORD PTR _rv$[ebp], eax

; 416  : 	if (rv != SECSuccess) {		

	cmp	DWORD PTR _rv$[ebp], 0
	je	SHORT $L185876

; 417  : 		setError(pg_sig, CAPI_ADD_CERT);

	push	113					; 00000071H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 418  : 		err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	SHORT $retLabel$185860
$L185876:

; 419  : 	}
; 420  : 
; 421  : 	endPct = certs[0];

	mov	ecx, DWORD PTR _certs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _endPct$[ebp], edx

; 422  : 
; 423  : #endif
; 424  : 
; 425  : 	// certificates now in temp store. Take the end certificate and check it.
; 426  : 	if (!checkCertificate(	endPct, 
; 427  : 		hStoreHandle, 
; 428  : 		pTime,
; 429  : 		certVerParams,
; 430  : 		pg_sig)) {

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hStoreHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _endPct$[ebp]
	push	edx
	call	?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; checkCertificate
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $retLabel$185860

; 431  : 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1
$retLabel$185860:

; 432  : 	}
; 433  : 
; 434  : retLabel:
; 435  : #ifdef NSS
; 436  : // cleanup DER list
; 437  : for (i=0;i<certNum;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185879
$L185880:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L185879:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _certNum$[ebp]
	jae	SHORT $L185881

; 438  : 	zFree(derCerts[i]->data);

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _derCerts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_rFree
	add	esp, 4

; 439  : 	zFree(derCerts[i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _derCerts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_rFree
	add	esp, 4

; 440  : }

	jmp	SHORT $L185880
$L185881:

; 441  : zFree(derCerts);

	mov	eax, DWORD PTR _derCerts$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 442  : 
; 443  : // go through cert array and delete all certificates
; 444  : if (certs != NULL) CERT_DestroyCertArray(certs, certNum);

	cmp	DWORD PTR _certs$[ebp], 0
	je	SHORT $L185882
	mov	ecx, DWORD PTR _certNum$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certs$[ebp]
	push	edx
	call	_CERT_DestroyCertArray
	add	esp, 8
$L185882:

; 445  : if (pct) CERT_DestroyCertificate(pct);

	cmp	DWORD PTR _pct$[ebp], 0
	je	SHORT $L185883
	mov	eax, DWORD PTR _pct$[ebp]
	push	eax
	call	_CERT_DestroyCertificate
	add	esp, 4
$L185883:

; 446  : 
; 447  : #else
; 448  : // cleanup store
; 449  : if (endPct) CertFreeCertificateContext(endPct);
; 450  : if (hStoreHandle) {
; 451  : 	CertCloseStore(hStoreHandle,CERT_CLOSE_STORE_FORCE_FLAG);
; 452  : }
; 453  : #endif
; 454  : 
; 455  : #ifdef NSS
; 456  : if (pfxBlob.data) zFree (pfxBlob.data);

	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188505
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188505:
	cmp	DWORD PTR _pfxBlob$[ebp+4], 0
	je	SHORT $L185884
	cmp	BYTE PTR $T188496[ebp], 0
	jne	SHORT $L188506
	push	OFFSET FLAT:$L188498
	call	__RTC_UninitUse
	add	esp, 4
$L188506:
	mov	ecx, DWORD PTR _pfxBlob$[ebp+4]
	push	ecx
	call	_rFree
	add	esp, 4
$L185884:

; 457  : #else
; 458  : if (pfxBlob.pbData) zFree (pfxBlob.pbData);
; 459  : #endif
; 460  : if (err) 

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L185885

; 461  : 	return FALSE;

	xor	eax, eax
	jmp	SHORT $L185813
$L185885:

; 462  : else 
; 463  : 	return TRUE;

	mov	eax, 1
$L185813:

; 464  : 
; 465  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188511
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	add	esp, 128				; 00000080H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188511:
	DD	4
	DD	$L188510
$L188510:
	DD	-32					; ffffffe0H
	DD	12					; 0000000cH
	DD	$L188498
	DD	-56					; ffffffc8H
	DD	4
	DD	$L188507
	DD	-76					; ffffffb4H
	DD	8
	DD	$L188508
	DD	-112					; ffffff90H
	DD	8
	DD	$L188509
$L188509:
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L188508:
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L188507:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	115					; 00000073H
	DB	0
$L188498:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAUSECItemStr@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; crVerifyCertificate
_TEXT	ENDS
PUBLIC	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor'
PUBLIC	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
PUBLIC	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
PUBLIC	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
PUBLIC	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ	; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
PUBLIC	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
PUBLIC	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__PR_Now:NEAR
EXTRN	_strcpy:NEAR
EXTRN	_CERT_VerifyCertificate:NEAR
EXTRN	_PORT_NewArena:NEAR
EXTRN	_DecodeDERCertificate:NEAR
EXTRN	_CERT_CertChainFromCert:NEAR
EXTRN	_CERT_DestroyCertificateList:NEAR
EXTRN	_getCRLDist:NEAR
EXTRN	_certIsNameChainOK:NEAR
EXTRN	_certIsBasicExtensionConstraintOK:NEAR
EXTRN	_certIsPathLengthConstraintOK:NEAR
EXTRN	_certIsKeyUsageOK:NEAR
EXTRN	_getAuthConstrainedPolicySet:NEAR
EXTRN	_getUserConstrainedPolicySet:NEAR
xdata$x	SEGMENT
$T188553 DD	0ffffffffH
	DD	FLAT:$L188537
	DD	0ffffffffH
	DD	FLAT:$L188538
$T188542 DD	019930520H
	DD	02H
	DD	FLAT:$T188553
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv625 = -328						; size = 4
tv504 = -324						; size = 4
tv493 = -320						; size = 4
tv337 = -316						; size = 4
tv133 = -312						; size = 4
$T188534 = -308						; size = 4
$T188533 = -304						; size = 4
$T188532 = -300						; size = 4
$T188531 = -296						; size = 4
$T188530 = -292						; size = 4
$T188527 = -288						; size = 4
$T188526 = -284						; size = 4
$T188523 = -280						; size = 4
$T188522 = -276						; size = 4
$T188521 = -272						; size = 4
$T188520 = -268						; size = 4
$T188519 = -264						; size = 4
$T188516 = -260						; size = 4
$T188515 = -256						; size = 4
_crlIndex$186602 = -252					; size = 4
_iList$186601 = -244					; size = 4
_listSize$186596 = -236					; size = 4
_v_issuer$186587 = -232					; size = 4
_v_cert$186586 = -228					; size = 4
_usedCrlList$186574 = -224				; size = 4
_crlIndex$186559 = -220					; size = 4
_iList$186558 = -212					; size = 4
_listSize$186476 = -204					; size = 4
_v_issuer$186466 = -200					; size = 4
_v_cert0$186453 = -196					; size = 4
_v_cert$186448 = -192					; size = 4
_v_issuer$186440 = -188					; size = 4
_v_cert$186439 = -184					; size = 4
_usedCrlList$185992 = -180				; size = 4
_derCert$185956 = -172					; size = 12
_node$185929 = -156					; size = 4
_certUsage$185926 = -152				; size = 4
_returnedUsages$ = -144					; size = 8
_log$ = -128						; size = 16
_c$ = -108						; size = 4
_res$ = -104						; size = 4
_result$ = -100						; size = 4
_crlFound$ = -92					; size = 4
_trustedRootFound$ = -84				; size = 4
_i$ = -80						; size = 4
_explicitPolicyCount$ = -76				; size = 4
_userConstPolCount$ = -72				; size = 4
_userConstPolSet$ = -68					; size = 4
_authConstPolCount$ = -64				; size = 4
_authConstPolSet$ = -60					; size = 4
_crlCertUrl$ = -56					; size = 4
_crlList$ = -52						; size = 4
_crlCount$ = -48					; size = 4
_checkCRLFailed$ = -44					; size = 4
_issuerIndex$ = -40					; size = 4
_certIndex$ = -36					; size = 4
_err$ = -32						; size = 4
_dwFlag$ = -28						; size = 4
_pct$ = -24						; size = 4
_rootCertificate$ = -20					; size = 4
_chain$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pCertContext$ = 8					; size = 4
_handle$ = 12						; size = 4
_pTime$ = 16						; size = 8
_certVerParams$ = 24					; size = 4
_pg_sig$ = 28						; size = 4
?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; checkCertificate

; 473  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 316				; 0000013cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-328]
	mov	ecx, 79					; 0000004fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 474  : CERTCertificateList *chain=NULL;

	mov	DWORD PTR _chain$[ebp], 0

; 475  : CERTCertificate *rootCertificate=NULL;

	mov	DWORD PTR _rootCertificate$[ebp], 0

; 476  : CERTCertificate *pct = NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 477  : DWORD dwFlag = 0;

	mov	DWORD PTR _dwFlag$[ebp], 0

; 478  : int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 479  : UINT certIndex, issuerIndex;
; 480  : BOOL checkCRLFailed;
; 481  : UINT crlCount;
; 482  : LPSTR *crlList;
; 483  : BYTE *crlCertUrl=NULL;

	mov	DWORD PTR _crlCertUrl$[ebp], 0

; 484  : LPSTR *authConstPolSet=NULL;

	mov	DWORD PTR _authConstPolSet$[ebp], 0

; 485  : UINT	authConstPolCount=0;

	mov	DWORD PTR _authConstPolCount$[ebp], 0

; 486  : LPSTR *userConstPolSet=NULL;

	mov	DWORD PTR _userConstPolSet$[ebp], 0

; 487  : UINT	userConstPolCount=0;

	mov	DWORD PTR _userConstPolCount$[ebp], 0

; 488  : UINT	explicitPolicyCount;
; 489  : int i;
; 490  : BOOL trustedRootFound=FALSE;

	mov	DWORD PTR _trustedRootFound$[ebp], 0

; 491  : BOOL crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 492  : BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 493  : SECStatus res;
; 494  : CERTCertificate *c = NULL;

	mov	DWORD PTR _c$[ebp], 0

; 495  : 
; 496  : 	
; 497  : 	chain = CERT_CertChainFromCert(pCertContext, certUsageObjectSigner, PR_TRUE);

	push	1
	push	6
	mov	eax, DWORD PTR _pCertContext$[ebp]
	push	eax
	call	_CERT_CertChainFromCert
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _chain$[ebp], eax

; 498  :     if (!chain) {

	cmp	DWORD PTR _chain$[ebp], 0
	jne	SHORT $L185916

; 499  : 		return FALSE;

	xor	eax, eax
	jmp	$L185893
$L185916:

; 500  :     }
; 501  : 
; 502  : 	rootCertificate = DecodeDERCertificate(&chain->certs[chain->len-1]);

	mov	ecx, DWORD PTR _chain$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _chain$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _rootCertificate$[ebp], eax

; 503  : 	if (!rootCertificate) {

	cmp	DWORD PTR _rootCertificate$[ebp], 0
	jne	SHORT $L185917

; 504  : 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 505  : 		goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185917:

; 506  : 	}
; 507  : 	CERTVerifyLog log;
; 508  : 	log.arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);

	push	2048					; 00000800H
	call	_PORT_NewArena
	add	esp, 4
	mov	DWORD PTR _log$[ebp], eax

; 509  : 	c = NULL;

	mov	DWORD PTR _c$[ebp], 0

; 510  : 	SECCertificateUsage returnedUsages;
; 511  : 	res = SECFailure;

	mov	DWORD PTR _res$[ebp], -1

; 512  : 
; 513  : 	for (i=chain->len-1; i>=0; i--) {		

	mov	ecx, DWORD PTR _chain$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR _i$[ebp], edx
	jmp	SHORT $L185922
$L185923:
	mov	eax, DWORD PTR _i$[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L185922:
	cmp	DWORD PTR _i$[ebp], 0
	jl	$L185924

; 514  : 		c = DecodeDERCertificate(&chain->certs[i]);

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _chain$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _c$[ebp], eax

; 515  : 		if (!c) {

	cmp	DWORD PTR _c$[ebp], 0
	jne	SHORT $L185925

; 516  : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 517  : 			break;

	jmp	$L185924
$L185925:

; 518  : 		}
; 519  : 		// do basic check
; 520  : 		log.count = 0;

	mov	DWORD PTR _log$[ebp+4], 0

; 521  : 		log.head = NULL;

	mov	DWORD PTR _log$[ebp+8], 0

; 522  : 		log.tail = NULL;		

	mov	DWORD PTR _log$[ebp+12], 0

; 523  : 
; 524  : 		SECCertUsage certUsage = certUsageObjectSigner;

	mov	DWORD PTR _certUsage$185926[ebp], 6

; 525  : 		if (pTime==0) {

	mov	eax, DWORD PTR _pTime$[ebp]
	or	eax, DWORD PTR _pTime$[ebp+4]
	jne	SHORT $L185927

; 526  : 			pTime = PR_Now();

	mov	esi, esp
	call	DWORD PTR __imp__PR_Now
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pTime$[ebp], eax
	mov	DWORD PTR _pTime$[ebp+4], edx
$L185927:

; 527  : 		}
; 528  : 		res = CERT_VerifyCertificate(handle,c,PR_TRUE,0,pTime,pg_sig,&log,&returnedUsages);

	lea	ecx, DWORD PTR _returnedUsages$[ebp]
	push	ecx
	lea	edx, DWORD PTR _log$[ebp]
	push	edx
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp]
	push	edx
	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _c$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	_CERT_VerifyCertificate
	add	esp, 40					; 00000028H
	mov	DWORD PTR _res$[ebp], eax

; 529  : 		if (log.head) {

	cmp	DWORD PTR _log$[ebp+8], 0
	je	$L185928

; 530  : 			CERTVerifyLogNode *node;
; 531  : 			node = log.head;

	mov	edx, DWORD PTR _log$[ebp+8]
	mov	DWORD PTR _node$185929[ebp], edx
$L185931:

; 532  : 			while ( node ) {

	cmp	DWORD PTR _node$185929[ebp], 0
	je	SHORT $L185928

; 533  : 				switch (node->error) {

	mov	eax, DWORD PTR _node$185929[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR tv133[ebp], ecx
	cmp	DWORD PTR tv133[ebp], -8182		; ffffe00aH
	je	SHORT $L185939
	cmp	DWORD PTR tv133[ebp], -8181		; ffffe00bH
	je	SHORT $L185937
	jmp	SHORT $L185934
$L185937:

; 534  : 						case SEC_ERROR_EXPIRED_CERTIFICATE:
; 535  : 							setError(pg_sig, CERT_TIME_INVALID);

	push	76					; 0000004cH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 536  : 							err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 537  : 							break;

	jmp	SHORT $L185934
$L185939:

; 538  : 						case SEC_ERROR_REVOKED_CERTIFICATE:
; 539  : 							//err = TRUE;
; 540  : 							break;
; 541  : 						case SEC_ERROR_BAD_SIGNATURE:
; 542  : 							setError(pg_sig, CERT_SIGNATURE_INVALID);

	push	78					; 0000004eH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 543  : 							err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L185934:

; 544  : 							break;
; 545  : 						case SEC_ERROR_UNTRUSTED_ISSUER:
; 546  : 							//setError(pg_sig, CERT_UNTRUSTED_ROOT);
; 547  : 							//err = TRUE;
; 548  : 							break;
; 549  : 						default:
; 550  : 							//err = TRUE;
; 551  : 							break;
; 552  : 				}
; 553  : 				if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L185942

; 554  : 					break;

	jmp	SHORT $L185928
$L185942:

; 555  : 				}
; 556  : 				node = node->next;

	mov	ecx, DWORD PTR _node$185929[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _node$185929[ebp], edx

; 557  : 			}

	jmp	SHORT $L185931
$L185928:

; 558  : 		}
; 559  : 		if (!err && res!=SECSuccess){

	cmp	DWORD PTR _err$[ebp], 0
	jne	SHORT $L185943
	cmp	DWORD PTR _res$[ebp], 0
	je	SHORT $L185943

; 560  : 			setError (pg_sig, CAPI_GET_CERT_CHAIN);

	push	114					; 00000072H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 561  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L185943:

; 562  : 		}
; 563  : 		CERT_DestroyCertificate(c);	

	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 564  : 		c=NULL;

	mov	DWORD PTR _c$[ebp], 0

; 565  : 		if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L185944

; 566  : 			break;

	jmp	SHORT $L185924
$L185944:

; 567  : 		}
; 568  : 	}

	jmp	$L185923
$L185924:

; 569  : 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L185945

; 570  : 		if (c) CERT_DestroyCertificate(c);		

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $L185947
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L185947:

; 571  : 		goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185945:

; 572  : 	}
; 573  : 
; 574  : 	if (certVerParams->verificationOptions & EXPLICIT_TRUST)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 32					; 00000020H
	je	$L185948

; 575  : 	{
; 576  : 		if ((certVerParams->trustRootCertCount == 0) ||
; 577  : 			(certVerParams->trustRootCerts == NULL))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $L185950
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $L185949
$L185950:

; 578  : 		{
; 579  : 			setError(pg_sig, CERT_UNTRUSTED_ROOT);

	push	81					; 00000051H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 580  : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 581  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185949:

; 582  : 		}			
; 583  : 		for (i=0; i < (int)certVerParams->trustRootCertCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L185953
$L185954:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L185953:
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+36]
	jge	$L185955

; 584  : 		{
; 585  : 			SECItem derCert;
; 586  : 			derCert.len = base64decodeSize(strlen(certVerParams->trustRootCerts[i]));

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _derCert$185956[ebp+8], eax

; 587  : 			derCert.data = (unsigned char *) zMalloc (derCert.len+1);

	mov	eax, DWORD PTR _derCert$185956[ebp+8]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _derCert$185956[ebp+4], eax

; 588  : 			if (derCert.data == NULL)

	cmp	DWORD PTR _derCert$185956[ebp+4], 0
	jne	SHORT $L185958

; 589  : 			{
; 590  : 				setError(pg_sig, MEMORY_FAULT);

	push	7
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 591  : 				err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$185918
$L185958:

; 592  : 			}
; 593  : 			memset(derCert.data,0x00,derCert.len);

	mov	edx, DWORD PTR _derCert$185956[ebp+8]
	push	edx
	push	0
	mov	eax, DWORD PTR _derCert$185956[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 594  : 			derCert.len = base64decode(	(unsigned char *)certVerParams->trustRootCerts[i],
; 595  : 				derCert.data,
; 596  : 				derCert.len);

	mov	ecx, DWORD PTR _derCert$185956[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _derCert$185956[ebp+4]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _derCert$185956[ebp+8], eax

; 597  : 			if (derCert.len == -1) 

	cmp	DWORD PTR _derCert$185956[ebp+8], -1
	jne	SHORT $L185961

; 598  : 			{
; 599  : 				setError(pg_sig, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 600  : 				zFree(derCert.data);

	mov	edx, DWORD PTR _derCert$185956[ebp+4]
	push	edx
	call	_rFree
	add	esp, 4

; 601  : 				err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$185918
$L185961:

; 602  : 			}
; 603  : 			if (!(pct = DecodeDERCertificate(&derCert)))

	lea	eax, DWORD PTR _derCert$185956[ebp]
	push	eax
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _pct$[ebp], eax
	cmp	DWORD PTR _pct$[ebp], 0
	jne	SHORT $L185963

; 604  : 			{
; 605  : 				setError(pg_sig, CAPI_CREATE_CERT_CNTX);

	push	108					; 0000006cH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 606  : 				zFree(derCert.data);

	mov	edx, DWORD PTR _derCert$185956[ebp+4]
	push	edx
	call	_rFree
	add	esp, 4

; 607  : 				err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$185918
$L185963:

; 608  : 			}
; 609  : 
; 610  : 			if (CompareCerts(pct, rootCertificate))

	mov	eax, DWORD PTR _rootCertificate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	call	?CompareCerts@@YAHPAUCERTCertificateStr@@0@Z ; CompareCerts
	add	esp, 8
	test	eax, eax
	je	SHORT $L185965

; 611  : 			{
; 612  : 				trustedRootFound = TRUE;

	mov	DWORD PTR _trustedRootFound$[ebp], 1

; 613  : 				if (pct) CERT_DestroyCertificate(pct);

	cmp	DWORD PTR _pct$[ebp], 0
	je	SHORT $L185966
	mov	edx, DWORD PTR _pct$[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L185966:

; 614  : 				pct = NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 615  : 				zFree(derCert.data);

	mov	eax, DWORD PTR _derCert$185956[ebp+4]
	push	eax
	call	_rFree
	add	esp, 4

; 616  : 				break;

	jmp	SHORT $L185955
$L185965:

; 617  : 			}
; 618  : 			if (pct) CERT_DestroyCertificate(pct);

	cmp	DWORD PTR _pct$[ebp], 0
	je	SHORT $L185967
	mov	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	call	_CERT_DestroyCertificate
	add	esp, 4
$L185967:

; 619  : 			pct = NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 620  : 			zFree(derCert.data);

	mov	edx, DWORD PTR _derCert$185956[ebp+4]
	push	edx
	call	_rFree
	add	esp, 4

; 621  : 		}

	jmp	$L185954
$L185955:

; 622  : 		if (trustedRootFound == FALSE)

	cmp	DWORD PTR _trustedRootFound$[ebp], 0
	jne	SHORT $L185948

; 623  : 		{
; 624  : 			setError(pg_sig, CERT_UNTRUSTED_ROOT);

	push	81					; 00000051H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 625  : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 626  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185948:

; 627  : 		}
; 628  : 	}
; 629  : 
; 630  : 	if (certVerParams->verificationOptions & VERIFY_CHAIN)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 4
	je	$L185970

; 631  : 	{
; 632  : 		if (!certIsBasicExtensionConstraintOK(chain, handle, pg_sig))

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _chain$[ebp]
	push	edx
	call	_certIsBasicExtensionConstraintOK
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L185971

; 633  : 		{
; 634  : 			setError(pg_sig, BASIC_CONSTRAINT_ERR);

	push	84					; 00000054H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 635  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 636  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185971:

; 637  : 		}
; 638  : 
; 639  : 		if (!certIsKeyUsageOK(chain,handle, pg_sig))

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chain$[ebp]
	push	eax
	call	_certIsKeyUsageOK
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L185973

; 640  : 		{
; 641  : 			setError(pg_sig, CERT_KEY_USAGE_ERR);

	push	85					; 00000055H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 642  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 643  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185973:

; 644  : 		}
; 645  : 
; 646  : 		if (!certIsNameChainOK(chain, handle))

	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chain$[ebp]
	push	eax
	call	_certIsNameChainOK
	add	esp, 8
	test	eax, eax
	jne	SHORT $L185970

; 647  : 		{
; 648  : 			setError(pg_sig, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 649  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 650  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185970:

; 651  : 		}
; 652  : 	} // Verify chain
; 653  : 
; 654  : 	if (certVerParams->verificationOptions & VERIFY_PATH_LENGTH)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 8
	je	SHORT $L185977

; 655  : 	{
; 656  : 		if (!certIsPathLengthConstraintOK(chain, handle, pg_sig))

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chain$[ebp]
	push	eax
	call	_certIsPathLengthConstraintOK
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L185977

; 657  : 		{
; 658  : 			setError(pg_sig, CERT_PATHLEN_ERR);

	push	90					; 0000005aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 659  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 660  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185977:

; 661  : 		}
; 662  : 	}
; 663  : 
; 664  : 	if (certVerParams->verificationOptions & VERIFY_POLICY)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 2
	je	$L185980

; 665  : 	{
; 666  : 		if (certVerParams->verificationOptions & POLICY_EXPLICIT)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 16					; 00000010H
	je	SHORT $L185981

; 667  : 			explicitPolicyCount = 0;

	mov	DWORD PTR _explicitPolicyCount$[ebp], 0

; 668  : 		else

	jmp	SHORT $L185982
$L185981:

; 669  : 			explicitPolicyCount = chain->len + 1;

	mov	eax, DWORD PTR _chain$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _explicitPolicyCount$[ebp], ecx
$L185982:

; 670  : 
; 671  : 		certVerParams->authPolicySetOut = getAuthConstrainedPolicySet(chain,
; 672  : 			handle,
; 673  : 			explicitPolicyCount,
; 674  : 			&certVerParams->explicitPolicyInd,// out
; 675  : 			&certVerParams->authPolicySetCountOut);

	mov	edx, DWORD PTR _certVerParams$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _explicitPolicyCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chain$[ebp]
	push	eax
	call	_getAuthConstrainedPolicySet
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 676  : 		if (certVerParams->verificationOptions & POLICY_EXPLICIT)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $L185983

; 677  : 		{
; 678  : 			if (certVerParams->authPolicySetCountOut == 0)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $L185983

; 679  : 			{
; 680  : 				certVerParams->userPolicySetCountOut=0;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+52], 0

; 681  : 				setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 682  : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 683  : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185983:

; 684  : 			}
; 685  : 		}
; 686  : 		// this function returns Auth Constraint policy set if user policy is ANY
; 687  : 		certVerParams->userPolicySetOut = getUserConstrainedPolicySet(chain,
; 688  : 			handle,
; 689  : 			certVerParams->userPolicySet,
; 690  : 			certVerParams->userPolicyCount,
; 691  : 			explicitPolicyCount,
; 692  : 			&certVerParams->explicitPolicyInd,		// out
; 693  : 			&certVerParams->userPolicySetCountOut);			

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _explicitPolicyCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _handle$[ebp]
	push	edx
	mov	eax, DWORD PTR _chain$[ebp]
	push	eax
	call	_getUserConstrainedPolicySet
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 694  : 
; 695  : 		if ((certVerParams->verificationOptions & POLICY_EXPLICIT) && 
; 696  : 			(certVerParams->userPolicySetCountOut == 0))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $L185986
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $L185986

; 697  : 		{
; 698  : 			if (certVerParams->userPolicySetCountOut == 0)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $L185986

; 699  : 			{
; 700  : 				setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 701  : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 702  : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185986:

; 703  : 			}
; 704  : 		}
; 705  : 		if ((certVerParams->explicitPolicyInd == 0) &&
; 706  : 			(certVerParams->userPolicySetCountOut == 0))

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $L185980
	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $L185980

; 707  : 		{
; 708  : 			setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 709  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 710  : 			goto exitCheckCertificate;

	jmp	$exitCheckCertificate$185918
$L185980:

; 711  : 		}
; 712  : 
; 713  : 	} // VerifyPolicy
; 714  : 
; 715  : 
; 716  : 	if (certVerParams->verificationOptions & VERIFY_CRL)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 1
	je	$L185991

; 717  : 	{
; 718  : 		CrlList *usedCrlList = new CrlList();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T188516[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T188516[ebp], 0
	je	SHORT $L188517
	mov	ecx, DWORD PTR $T188516[ebp]
	call	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
	mov	DWORD PTR tv337[ebp], eax
	jmp	SHORT $L188518
$L188517:
	mov	DWORD PTR tv337[ebp], 0
$L188518:
	mov	eax, DWORD PTR tv337[ebp]
	mov	DWORD PTR $T188515[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T188515[ebp]
	mov	DWORD PTR _usedCrlList$185992[ebp], ecx

; 719  : 
; 720  : 		checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 721  : 		for (certIndex=0; certIndex < (UINT) chain->len; certIndex++)

	mov	DWORD PTR _certIndex$[ebp], 0
	jmp	SHORT $L186433
$L186434:
	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _certIndex$[ebp], edx
$L186433:
	mov	eax, DWORD PTR _chain$[ebp]
	mov	ecx, DWORD PTR _certIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	$L186435

; 722  : 		{
; 723  : 			if (certIndex == chain->len - 1)

	mov	edx, DWORD PTR _chain$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	DWORD PTR _certIndex$[ebp], eax
	jne	SHORT $L186436

; 724  : 				issuerIndex = certIndex;

	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	DWORD PTR _issuerIndex$[ebp], ecx

; 725  : 			else

	jmp	SHORT $L186437
$L186436:

; 726  : 				issuerIndex = certIndex+1;

	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _issuerIndex$[ebp], edx
$L186437:

; 727  : 
; 728  : 			if ((certVerParams->altCrlCount != 0) &&
; 729  : 				(certVerParams->crlAltUrl != NULL))//Local CRL Location is given, so use that first

	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$L186438
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$L186438

; 730  : 			{
; 731  : 				crlCount = certVerParams->altCrlCount;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _crlCount$[ebp], eax

; 732  : 				crlList = certVerParams->crlAltUrl;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _crlList$[ebp], edx

; 733  : 				CERTCertificate *v_cert= DecodeDERCertificate(&chain->certs[certIndex]);

	mov	eax, DWORD PTR _certIndex$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _chain$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_cert$186439[ebp], eax

; 734  : 				CERTCertificate *v_issuer= DecodeDERCertificate(&chain->certs[issuerIndex]);

	mov	edx, DWORD PTR _issuerIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _chain$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_issuer$186440[ebp], eax

; 735  : 				if (!v_cert || !v_issuer) {

	cmp	DWORD PTR _v_cert$186439[ebp], 0
	je	SHORT $L186442
	cmp	DWORD PTR _v_issuer$186440[ebp], 0
	jne	SHORT $L186441
$L186442:

; 736  : 					checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 737  : 					break; // At least one of the certificates in the chain has a problem

	jmp	$L186435
$L186441:

; 738  : 				}
; 739  : 				result = check_CRL (handle, 
; 740  : 					v_cert, 
; 741  : 					v_issuer,
; 742  : 					pTime,
; 743  : 					crlList,
; 744  : 					crlCount,
; 745  : 					FALSE,
; 746  : 					&crlFound,
; 747  : 					usedCrlList,
; 748  : 					pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usedCrlList$185992[ebp]
	push	edx
	lea	eax, DWORD PTR _crlFound$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _crlCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v_issuer$186440[ebp]
	push	edx
	mov	eax, DWORD PTR _v_cert$186439[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 749  : 				CERT_DestroyCertificate(v_cert);

	mov	edx, DWORD PTR _v_cert$186439[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 750  : 				CERT_DestroyCertificate(v_issuer);

	mov	eax, DWORD PTR _v_issuer$186440[ebp]
	push	eax
	call	_CERT_DestroyCertificate
	add	esp, 4

; 751  : 				if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L186438

; 752  : 				{
; 753  : 					if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L186444

; 754  : 					{
; 755  : 						checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 756  : 						break; // At least one of the certificates in the chain has a problem

	jmp	$L186435
$L186444:

; 757  : 					}
; 758  : 					else // CRL validation was successful
; 759  : 					{
; 760  : 						crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 761  : 						checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 762  : 						continue; // check the next certificate in the chain

	jmp	$L186434
$L186438:

; 763  : 					}
; 764  : 				}
; 765  : 			}
; 766  : 			if ((crlFound == TRUE) && (checkCRLFailed == FALSE)) // The whole chain validated successfully

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L186446
	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L186446

; 767  : 				break;

	jmp	$L186435
$L186446:

; 768  : 			else
; 769  : 			{// CRL was not found in the given CRL Location list. Try certificate CRL DP
; 770  : 				CERTCertificate *v_cert= DecodeDERCertificate(&chain->certs[certIndex]);

	mov	ecx, DWORD PTR _certIndex$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _chain$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_cert$186448[ebp], eax

; 771  : 				if (!v_cert) {

	cmp	DWORD PTR _v_cert$186448[ebp], 0
	jne	SHORT $L186449

; 772  : 					checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 773  : 					break; 

	jmp	$L186435
$L186449:

; 774  : 				}
; 775  : 				crlCertUrl = getCRLDist(v_cert);					

	mov	eax, DWORD PTR _v_cert$186448[ebp]
	push	eax
	call	_getCRLDist
	add	esp, 4
	mov	DWORD PTR _crlCertUrl$[ebp], eax

; 776  : 				if (crlCertUrl == NULL)

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	jne	$L186450

; 777  : 				{
; 778  : 					if ( certIndex != 0)

	cmp	DWORD PTR _certIndex$[ebp], 0
	je	$L186451

; 779  : 					{
; 780  : 						// If this is the root certificate, then the CRL may be
; 781  : 						// available from the first intermediate certificate
; 782  : 						// since the issuers for both are the root CA
; 783  : 						if (certIndex == chain->len - 1)

	mov	ecx, DWORD PTR _chain$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	cmp	DWORD PTR _certIndex$[ebp], edx
	jne	$L186452

; 784  : 						{
; 785  : 							CERTCertificate *v_cert0= DecodeDERCertificate(&chain->certs[certIndex-1]);

	mov	eax, DWORD PTR _certIndex$[ebp]
	sub	eax, 1
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _chain$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_cert0$186453[ebp], eax

; 786  : 							if (!v_cert0) {

	cmp	DWORD PTR _v_cert0$186453[ebp], 0
	jne	SHORT $L186454

; 787  : 								checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 788  : 								break; 

	jmp	$L186435
$L186454:

; 789  : 							}
; 790  : 							crlCertUrl = getCRLDist(v_cert0);

	mov	edx, DWORD PTR _v_cert0$186453[ebp]
	push	edx
	call	_getCRLDist
	add	esp, 4
	mov	DWORD PTR _crlCertUrl$[ebp], eax

; 791  : 							CERT_DestroyCertificate(v_cert0);

	mov	eax, DWORD PTR _v_cert0$186453[ebp]
	push	eax
	call	_CERT_DestroyCertificate
	add	esp, 4

; 792  : 							if (crlCertUrl == NULL)

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	jne	SHORT $L186455

; 793  : 							{//No CRL DP present and none of the given CRL Locations, if any, matched
; 794  : 								crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 795  : 								checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 796  : 								setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 797  : 								CERT_DestroyCertificate(v_cert);

	mov	edx, DWORD PTR _v_cert$186448[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 798  : 								break;

	jmp	$L186435
$L186455:

; 799  : 							}
; 800  : 							else
; 801  : 							{// CRL Location Found
; 802  : 								crlCount = 1;

	mov	DWORD PTR _crlCount$[ebp], 1

; 803  : 								crlList = (LPSTR *)zMalloc(sizeof (char *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crlList$[ebp], eax

; 804  : 								crlList[0] = (LPSTR)crlCertUrl;

	mov	eax, DWORD PTR _crlList$[ebp]
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	mov	DWORD PTR [eax], ecx

; 805  : 							}
; 806  : 						}
; 807  : 						else

	jmp	SHORT $L186460
$L186452:

; 808  : 						{//No CRL DP present and none of the given CRL Locations, if any, matched
; 809  : 							crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 810  : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 811  : 							setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 812  : 							CERT_DestroyCertificate(v_cert);

	mov	eax, DWORD PTR _v_cert$186448[ebp]
	push	eax
	call	_CERT_DestroyCertificate
	add	esp, 4

; 813  : 							break;

	jmp	$L186435
$L186460:

; 814  : 						}
; 815  : 					}
; 816  : 					else

	jmp	SHORT $L186461
$L186451:

; 817  : 					{//No CRL DP present and none of the given CRL Locations, if any, matched
; 818  : 						crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 819  : 						checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 820  : 						setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 821  : 						CERT_DestroyCertificate(v_cert);

	mov	edx, DWORD PTR _v_cert$186448[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 822  : 						break;

	jmp	$L186435
$L186461:

; 823  : 					}
; 824  : 				}
; 825  : 				else

	jmp	SHORT $L186462
$L186450:

; 826  : 				{// CRL Location Found
; 827  : 					crlCount = 1;

	mov	DWORD PTR _crlCount$[ebp], 1

; 828  : 					crlList = (LPSTR *)zMalloc(sizeof (char *));

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crlList$[ebp], eax

; 829  : 					crlList[0] = (LPSTR)crlCertUrl;

	mov	eax, DWORD PTR _crlList$[ebp]
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	mov	DWORD PTR [eax], ecx
$L186462:

; 830  : 				}
; 831  : 				CERTCertificate *v_issuer= DecodeDERCertificate(&chain->certs[issuerIndex]);

	mov	edx, DWORD PTR _issuerIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _chain$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_issuer$186466[ebp], eax

; 832  : 
; 833  : 				if (!v_issuer) {

	cmp	DWORD PTR _v_issuer$186466[ebp], 0
	jne	SHORT $L186467

; 834  : 					checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 835  : 					if (crlCertUrl) zFree(crlCertUrl);

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	je	SHORT $L186468
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4
$L186468:

; 836  : 					if (crlList) zFree (crlList);

	cmp	DWORD PTR _crlList$[ebp], 0
	je	SHORT $L186469
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L186469:

; 837  : 					break; 

	jmp	$L186435
$L186467:

; 838  : 				}
; 839  : 				result = check_CRL (handle,
; 840  : 					v_cert, 
; 841  : 					v_issuer,
; 842  : 					pTime,
; 843  : 					crlList,
; 844  : 					crlCount,
; 845  : 					FALSE,
; 846  : 					&crlFound,
; 847  : 					usedCrlList,
; 848  : 					pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$185992[ebp]
	push	ecx
	lea	edx, DWORD PTR _crlFound$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _crlCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v_issuer$186466[ebp]
	push	ecx
	mov	edx, DWORD PTR _v_cert$186448[ebp]
	push	edx
	mov	eax, DWORD PTR _handle$[ebp]
	push	eax
	call	?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 849  : 				CERT_DestroyCertificate(v_cert);

	mov	ecx, DWORD PTR _v_cert$186448[ebp]
	push	ecx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 850  : 				CERT_DestroyCertificate(v_issuer);

	mov	edx, DWORD PTR _v_issuer$186466[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 851  : 				if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L186470

; 852  : 				{
; 853  : 					if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L186471

; 854  : 					{
; 855  : 						checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 856  : 						zFree(crlCertUrl);

	mov	eax, DWORD PTR _crlCertUrl$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 857  : 						zFree (crlList);

	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 858  : 						break; // At least one of the certificates in the chain has a problem

	jmp	SHORT $L186435
$L186471:

; 859  : 					}
; 860  : 					else // CRL validation was successful
; 861  : 					{
; 862  : 						crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 863  : 						zFree(crlCertUrl);

	mov	edx, DWORD PTR _crlCertUrl$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 864  : 						zFree (crlList);

	mov	eax, DWORD PTR _crlList$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 865  : 						continue; // check the next certificate in the chain

	jmp	$L186434
$L186470:

; 866  : 					}
; 867  : 				}
; 868  : 				else
; 869  : 				{	//No CRL DP present and none of the given CRL Locations, if any, matched
; 870  : 					crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 871  : 					checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 872  : 					zFree(crlCertUrl);

	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 873  : 					zFree (crlList);

	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L186435:

; 874  : 					break;
; 875  : 				}
; 876  : 			}
; 877  : 		}
; 878  : 		if (checkCRLFailed == FALSE)

	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L186474

; 879  : 			err = FALSE;

	mov	DWORD PTR _err$[ebp], 0

; 880  : 		else

	jmp	SHORT $L186475
$L186474:

; 881  : 			err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L186475:

; 882  : 		//if (err == FALSE)
; 883  : 		//{
; 884  : 		unsigned int listSize = usedCrlList->size();

	mov	ecx, DWORD PTR _usedCrlList$185992[ebp]
	call	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
	mov	DWORD PTR _listSize$186476[ebp], eax

; 885  : 		if (listSize != 0)

	cmp	DWORD PTR _listSize$186476[ebp], 0
	je	$L186477

; 886  : 		{
; 887  : 			certVerParams->usedCrlCount = listSize;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR _listSize$186476[ebp]
	mov	DWORD PTR [eax+60], ecx

; 888  : 			certVerParams->usedCrlList = (LPSTR *) zMalloc(listSize * sizeof(LPSTR *));

	mov	edx, DWORD PTR _listSize$186476[ebp]
	shl	edx, 2
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 889  : 			memset(certVerParams->usedCrlList, 0, listSize * sizeof(LPSTR *));

	mov	edx, DWORD PTR _listSize$186476[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 890  : 			CrlList::iterator iList;

	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator

; 891  : 			unsigned int crlIndex=0;

	mov	DWORD PTR _crlIndex$186559[ebp], 0

; 892  : 			for (iList = usedCrlList->end(), iList--; crlIndex < listSize; iList--, crlIndex++)

	lea	edx, DWORD PTR $T188519[ebp]
	push	edx
	mov	ecx, DWORD PTR _usedCrlList$185992[ebp]
	call	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iList$186558[ebp], eax
	push	0
	lea	ecx, DWORD PTR $T188520[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	jmp	SHORT $L186563
$L186564:
	push	0
	lea	edx, DWORD PTR $T188521[ebp]
	push	edx
	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	eax, DWORD PTR _crlIndex$186559[ebp]
	add	eax, 1
	mov	DWORD PTR _crlIndex$186559[ebp], eax
$L186563:
	mov	ecx, DWORD PTR _crlIndex$186559[ebp]
	cmp	ecx, DWORD PTR _listSize$186476[ebp]
	jae	SHORT $L186477

; 893  : 			{
; 894  : 				certVerParams->usedCrlList[crlIndex] = (LPSTR) zMalloc(strlen((const char *)*iList)+1);

	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _crlIndex$186559[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 895  : 				strcpy((char *)certVerParams->usedCrlList[crlIndex], (const char *)*iList);

	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _crlIndex$186559[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 896  : 				zFree(*iList);

	lea	ecx, DWORD PTR _iList$186558[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4

; 897  : 			}

	jmp	$L186564
$L186477:

; 898  : 		}
; 899  : 		//}
; 900  : 		delete usedCrlList;

	mov	edx, DWORD PTR _usedCrlList$185992[ebp]
	mov	DWORD PTR $T188523[ebp], edx
	mov	eax, DWORD PTR $T188523[ebp]
	mov	DWORD PTR $T188522[ebp], eax
	cmp	DWORD PTR $T188522[ebp], 0
	je	SHORT $L188524
	push	1
	mov	ecx, DWORD PTR $T188522[ebp]
	call	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
	mov	DWORD PTR tv493[ebp], eax
	jmp	SHORT $L188525
$L188524:
	mov	DWORD PTR tv493[ebp], 0
$L188525:

; 901  : 	} // VerifyCRL
; 902  : 	else

	jmp	$exitCheckCertificate$185918
$L185991:

; 903  : 	{
; 904  : 		if (certVerParams->verificationOptions & VERIFY_CRL_REC)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 64					; 00000040H
	je	$exitCheckCertificate$185918

; 905  : 		{
; 906  : 			CrlList *usedCrlList = new CrlList();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T188527[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T188527[ebp], 0
	je	SHORT $L188528
	mov	ecx, DWORD PTR $T188527[ebp]
	call	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
	mov	DWORD PTR tv504[ebp], eax
	jmp	SHORT $L188529
$L188528:
	mov	DWORD PTR tv504[ebp], 0
$L188529:
	mov	eax, DWORD PTR tv504[ebp]
	mov	DWORD PTR $T188526[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T188526[ebp]
	mov	DWORD PTR _usedCrlList$186574[ebp], ecx

; 907  : 			checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 908  : 			if ((certVerParams->recCrlCount != 0) &&
; 909  : 				(certVerParams->recCrlList != NULL)) // Recorded CRL data is available

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$L186579
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$L186579

; 910  : 			{
; 911  : 				crlCount = certVerParams->recCrlCount;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _crlCount$[ebp], edx

; 912  : 				crlList = certVerParams->recCrlList;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _crlList$[ebp], ecx

; 913  : 				for (certIndex=0; certIndex < (UINT) chain->len; certIndex++)

	mov	DWORD PTR _certIndex$[ebp], 0
	jmp	SHORT $L186581
$L186582:
	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _certIndex$[ebp], edx
$L186581:
	mov	eax, DWORD PTR _chain$[ebp]
	mov	ecx, DWORD PTR _certIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	$L186583

; 914  : 				{
; 915  : 					if (certIndex == chain->len - 1)

	mov	edx, DWORD PTR _chain$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, 1
	cmp	DWORD PTR _certIndex$[ebp], eax
	jne	SHORT $L186584

; 916  : 						issuerIndex = certIndex;

	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	DWORD PTR _issuerIndex$[ebp], ecx

; 917  : 					else

	jmp	SHORT $L186585
$L186584:

; 918  : 						issuerIndex = certIndex+1;

	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _issuerIndex$[ebp], edx
$L186585:

; 919  : 					CERTCertificate *v_cert= DecodeDERCertificate(&chain->certs[certIndex]);

	mov	eax, DWORD PTR _certIndex$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _chain$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_cert$186586[ebp], eax

; 920  : 					CERTCertificate *v_issuer= DecodeDERCertificate(&chain->certs[issuerIndex]);

	mov	edx, DWORD PTR _issuerIndex$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _chain$[ebp]
	add	edx, DWORD PTR [eax]
	push	edx
	call	_DecodeDERCertificate
	add	esp, 4
	mov	DWORD PTR _v_issuer$186587[ebp], eax

; 921  : 
; 922  : 					if (!v_cert || !v_issuer) {

	cmp	DWORD PTR _v_cert$186586[ebp], 0
	je	SHORT $L186589
	cmp	DWORD PTR _v_issuer$186587[ebp], 0
	jne	SHORT $L186588
$L186589:

; 923  : 						checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 924  : 						break;

	jmp	$L186583
$L186588:

; 925  : 					}
; 926  : 					result = check_CRL(	handle, 
; 927  : 						v_cert, 
; 928  : 						v_issuer,
; 929  : 						pTime, 
; 930  : 						crlList, 
; 931  : 						crlCount,
; 932  : 						TRUE,
; 933  : 						&crlFound,
; 934  : 						usedCrlList, 
; 935  : 						pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usedCrlList$186574[ebp]
	push	edx
	lea	eax, DWORD PTR _crlFound$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _crlCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v_issuer$186587[ebp]
	push	edx
	mov	eax, DWORD PTR _v_cert$186586[ebp]
	push	eax
	mov	ecx, DWORD PTR _handle$[ebp]
	push	ecx
	call	?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 936  : 					CERT_DestroyCertificate(v_cert);

	mov	edx, DWORD PTR _v_cert$186586[ebp]
	push	edx
	call	_CERT_DestroyCertificate
	add	esp, 4

; 937  : 					CERT_DestroyCertificate(v_issuer);

	mov	eax, DWORD PTR _v_issuer$186587[ebp]
	push	eax
	call	_CERT_DestroyCertificate
	add	esp, 4

; 938  : 
; 939  : 					if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L186590

; 940  : 					{
; 941  : 						if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L186591

; 942  : 						{
; 943  : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 944  : 							break; // At least one of the certificates in the chain has a problem

	jmp	SHORT $L186583
$L186591:

; 945  : 						}
; 946  : 						else // CRL validation was successful
; 947  : 						{
; 948  : 							crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 949  : 							checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 950  : 							continue; // check the next certificate in the chain

	jmp	$L186582
$L186590:

; 951  : 						}
; 952  : 					}
; 953  : 					else
; 954  : 					{
; 955  : 						checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1
$L186583:

; 956  : 						break;
; 957  : 					}
; 958  : 				}// for
; 959  : 				if (checkCRLFailed == FALSE)

	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L186594

; 960  : 					err = FALSE;

	mov	DWORD PTR _err$[ebp], 0

; 961  : 				else

	jmp	SHORT $L186595
$L186594:

; 962  : 					err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L186595:

; 963  : 				//if (err == FALSE)
; 964  : 				//{
; 965  : 				unsigned int listSize = usedCrlList->size();

	mov	ecx, DWORD PTR _usedCrlList$186574[ebp]
	call	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
	mov	DWORD PTR _listSize$186596[ebp], eax

; 966  : 				if (listSize != 0)

	cmp	DWORD PTR _listSize$186596[ebp], 0
	je	$L186579

; 967  : 				{
; 968  : 					certVerParams->usedCrlCount = listSize;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR _listSize$186596[ebp]
	mov	DWORD PTR [ecx+60], edx

; 969  : 					certVerParams->usedCrlList = (LPSTR *) zMalloc(listSize * sizeof(LPSTR *));

	mov	eax, DWORD PTR _listSize$186596[ebp]
	shl	eax, 2
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 970  : 					memset(certVerParams->usedCrlList, 0, listSize * sizeof(LPSTR *));

	mov	edx, DWORD PTR _listSize$186596[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 971  : 					CrlList::iterator iList;

	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator

; 972  : 					unsigned int crlIndex=0;

	mov	DWORD PTR _crlIndex$186602[ebp], 0

; 973  : 					for (iList = usedCrlList->end(), iList--; crlIndex < listSize; iList--, crlIndex++)

	lea	edx, DWORD PTR $T188530[ebp]
	push	edx
	mov	ecx, DWORD PTR _usedCrlList$186574[ebp]
	call	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iList$186601[ebp], eax
	push	0
	lea	ecx, DWORD PTR $T188531[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	jmp	SHORT $L186606
$L186607:
	push	0
	lea	edx, DWORD PTR $T188532[ebp]
	push	edx
	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	eax, DWORD PTR _crlIndex$186602[ebp]
	add	eax, 1
	mov	DWORD PTR _crlIndex$186602[ebp], eax
$L186606:
	mov	ecx, DWORD PTR _crlIndex$186602[ebp]
	cmp	ecx, DWORD PTR _listSize$186596[ebp]
	jae	SHORT $L186579

; 974  : 					{
; 975  : 						certVerParams->usedCrlList[crlIndex] = (LPSTR) zMalloc(strlen((const char *)*iList)+1);

	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _crlIndex$186602[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 976  : 						strcpy((char *)certVerParams->usedCrlList[crlIndex], (const char *)*iList);

	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _crlIndex$186602[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 977  : 						zFree(*iList);

	lea	ecx, DWORD PTR _iList$186601[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4

; 978  : 					}

	jmp	$L186607
$L186579:

; 979  : 				}
; 980  : 				//}
; 981  : 			}// if Recorded CRL Data is available
; 982  : 			delete usedCrlList;

	mov	edx, DWORD PTR _usedCrlList$186574[ebp]
	mov	DWORD PTR $T188534[ebp], edx
	mov	eax, DWORD PTR $T188534[ebp]
	mov	DWORD PTR $T188533[ebp], eax
	cmp	DWORD PTR $T188533[ebp], 0
	je	SHORT $L188535
	push	1
	mov	ecx, DWORD PTR $T188533[ebp]
	call	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
	mov	DWORD PTR tv625[ebp], eax
	jmp	SHORT $exitCheckCertificate$185918
$L188535:
	mov	DWORD PTR tv625[ebp], 0
$exitCheckCertificate$185918:

; 983  : 		} // if VERIFY_CRL_REC enabled
; 984  : 	}
; 985  :     
; 986  : exitCheckCertificate:
; 987  : 	CERT_DestroyCertificateList(chain);

	mov	ecx, DWORD PTR _chain$[ebp]
	push	ecx
	call	_CERT_DestroyCertificateList
	add	esp, 4

; 988  : 	if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L186615

; 989  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L185893
$L186615:

; 990  : 	} else {
; 991  : 		return TRUE;

	mov	eax, 1
$L185893:

; 992  : 	}
; 993  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188552
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 328				; 00000148H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188552:
	DD	6
	DD	$L188551
$L188551:
	DD	-92					; ffffffa4H
	DD	4
	DD	$L188543
	DD	-128					; ffffff80H
	DD	16					; 00000010H
	DD	$L188544
	DD	-144					; ffffff70H
	DD	8
	DD	$L188545
	DD	-172					; ffffff54H
	DD	12					; 0000000cH
	DD	$L188546
	DD	-212					; ffffff2cH
	DD	4
	DD	$L188547
	DD	-244					; ffffff0cH
	DD	4
	DD	$L188548
$L188548:
	DB	105					; 00000069H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L188547:
	DB	105					; 00000069H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L188546:
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L188545:
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	110					; 0000006eH
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	85					; 00000055H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	0
$L188544:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	103					; 00000067H
	DB	0
$L188543:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L188537:
	mov	eax, DWORD PTR $T188516[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L188538:
	mov	eax, DWORD PTR $T188527[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T188542
	jmp	___CxxFrameHandler
text$x	ENDS
?checkCertificate@@YAHPAUCERTCertificateStr@@PAUNSSTrustDomainStr@@_JPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; checkCertificate
PUBLIC	??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ	; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L186620
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L186620:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::vector<SECItemStr *,std::allocator<SECItemStr *> >
PUBLIC	??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::~vector<SECItemStr *,std::allocator<SECItemStr *> >
PUBLIC	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
PUBLIC	?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::at
PUBLIC	?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::push_back
PUBLIC	?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::clear
PUBLIC	?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
PUBLIC	?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert
EXTRN	_FindCertInCRL:NEAR
EXTRN	_SECITEM_FreeItem:NEAR
EXTRN	_base64encodeSize:NEAR
EXTRN	_base64encode:NEAR
EXTRN	_CERT_NameToAscii:NEAR
EXTRN	_CERT_DecodeDERCrl:NEAR
EXTRN	_SEC_DestroyCrl:NEAR
EXTRN	_CERT_VerifySignedData:NEAR
EXTRN	_strncmp:NEAR
EXTRN	_PORT_Free:NEAR
EXTRN	_i_cert_FindExtensionByOID:NEAR
EXTRN	_fetchLDAP_URL:NEAR
EXTRN	_fetch_URL:NEAR
EXTRN	_certIsNameEqual:NEAR
EXTRN	_cleanupError:NEAR
xdata$x	SEGMENT
$T188573 DD	0ffffffffH
	DD	FLAT:$L188561
$T188563 DD	019930520H
	DD	01H
	DD	FLAT:$T188573
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T188560 = -200						; size = 4
$T188559 = -196						; size = 4
$T188558 = -192						; size = 4
_entry$186961 = -188					; size = 4
_b64Crl$186956 = -180					; size = 4
_size$186955 = -172					; size = 4
_encodedExt$186948 = -164				; size = 12
_oid2$186947 = -144					; size = 12
_oid1$186946 = -124					; size = 12
_extensions$186945 = -108				; size = 4
_cName$186938 = -104					; size = 4
_sCrl$186935 = -100					; size = 4
_i$186931 = -96						; size = 4
_pds$186925 = -92					; size = 4
_i$186918 = -88						; size = 4
_pCrl$186917 = -84					; size = 4
_crlBlobList$ = -76					; size = 16
_ss$ = -56						; size = 4
_validCrlFound$ = -52					; size = 4
_crlIndex$ = -48					; size = 4
_crlCount$ = -44					; size = 4
_crl$ = -36						; size = 4
_ret$ = -28						; size = 4
_pCrlEntry$ = -24					; size = 4
_pCrlContext$ = -20					; size = 4
_crlUrl$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hStoreHandle$ = 8					; size = 4
_pCertContext$ = 12					; size = 4
_pIssuerCertContext$ = 16				; size = 4
_pTime$ = 20						; size = 8
_crlAltUrl$ = 28					; size = 4
_altCrlCount$ = 32					; size = 4
_crlUrlIsCrlData$ = 36					; size = 4
_crlFound$ = 40						; size = 4
_usedCrlList$ = 44					; size = 4
_pg_sig$ = 48						; size = 4
?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; check_CRL

; 1588 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 188				; 000000bcH
	push	edi
	lea	edi, DWORD PTR [ebp-200]
	mov	ecx, 47					; 0000002fH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1589 : 	//+++
; 1590 : 	BYTE *crlUrl=NULL;

	mov	DWORD PTR _crlUrl$[ebp], 0

; 1591 : 	CERTCrl *pCrlContext=NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1592 : 	CERTCrlEntry *pCrlEntry = NULL;

	mov	DWORD PTR _pCrlEntry$[ebp], 0

; 1593 : 	int ret=TRUE;

	mov	DWORD PTR _ret$[ebp], 1

; 1594 : 	SECItem *crl=NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1595 : 	UINT crlCount=0;

	mov	DWORD PTR _crlCount$[ebp], 0

; 1596 : 	UINT crlIndex;
; 1597 : 	BOOL validCrlFound = FALSE;

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 1598 : 	SECStatus ss;
; 1599 : 	vector <SECItem *> crlBlobList;

	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::vector<SECItemStr *,std::allocator<SECItemStr *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1600 : 
; 1601 : 		for (crlIndex=0; crlIndex < altCrlCount; crlIndex++)

	mov	DWORD PTR _crlIndex$[ebp], 0
	jmp	SHORT $L186901
$L186902:
	mov	eax, DWORD PTR _crlIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _crlIndex$[ebp], eax
$L186901:
	mov	ecx, DWORD PTR _crlIndex$[ebp]
	cmp	ecx, DWORD PTR _altCrlCount$[ebp]
	jae	$L186903

; 1602 : 		{
; 1603 : 			crlBlobList.clear();

	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::clear

; 1604 : 			if (crlUrlIsCrlData)

	cmp	DWORD PTR _crlUrlIsCrlData$[ebp], 0
	je	$L186904

; 1605 : 			{
; 1606 : 				crl = (SECItem *) zMalloc(sizeof(SECItem));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crl$[ebp], eax

; 1607 : 				crl->len = base64decodeSize(strlen((const char *)crlAltUrl[crlIndex]));

	mov	edx, DWORD PTR _crlIndex$[ebp]
	mov	eax, DWORD PTR _crlAltUrl$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	edx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1608 : 				crl->data = (unsigned char *) zMalloc(crl->len + 1);

	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	edx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [edx+4], eax

; 1609 : 				if ((crl->len = base64decode((unsigned char *)crlAltUrl[crlIndex], crl->data, crl->len+1)) == -1)

	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _crlIndex$[ebp]
	mov	edx, DWORD PTR _crlAltUrl$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx+8], -1
	jne	SHORT $L186910

; 1610 : 				{
; 1611 : 					setError(pg_sig, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1612 : 					continue;

	jmp	$L186902
$L186910:

; 1613 : 				}
; 1614 : 			}
; 1615 : 			else

	jmp	$L186911
$L186904:

; 1616 : 			{
; 1617 : 				crlUrl = (BYTE *) crlAltUrl[crlIndex];

	mov	ecx, DWORD PTR _crlIndex$[ebp]
	mov	edx, DWORD PTR _crlAltUrl$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _crlUrl$[ebp], eax

; 1618 : 				if (!crlUrl) 

	cmp	DWORD PTR _crlUrl$[ebp], 0
	jne	SHORT $L186913

; 1619 : 					continue;

	jmp	$L186902
$L186913:

; 1620 : 
; 1621 : 				if (strncmp((const char *)crlUrl,"ldap:",5)==0) 

	push	5
	push	OFFSET FLAT:$SG186916
	mov	ecx, DWORD PTR _crlUrl$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L186915

; 1622 : 				{
; 1623 : 					PDS_DATA_BLOB *pCrl = fetchLDAP_URL(crlUrl);

	mov	edx, DWORD PTR _crlUrl$[ebp]
	push	edx
	call	_fetchLDAP_URL
	add	esp, 4
	mov	DWORD PTR _pCrl$186917[ebp], eax

; 1624 : 					int i=0;

	mov	DWORD PTR _i$186918[ebp], 0
$L186920:

; 1625 : 					while (pCrl && pCrl[i]) {

	cmp	DWORD PTR _pCrl$186917[ebp], 0
	je	SHORT $L186921
	mov	eax, DWORD PTR _i$186918[ebp]
	mov	ecx, DWORD PTR _pCrl$186917[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $L186921

; 1626 : 						crl = (SECItem *) zMalloc(sizeof(SECItem));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crl$[ebp], eax

; 1627 : 						crl->data = pCrl[i]->pbData;

	mov	edx, DWORD PTR _i$186918[ebp]
	mov	eax, DWORD PTR _pCrl$186917[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx+4], eax

; 1628 : 						crl->len = pCrl[i]->cbData;

	mov	ecx, DWORD PTR _i$186918[ebp]
	mov	edx, DWORD PTR _pCrl$186917[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+8], edx

; 1629 : 						crlBlobList.push_back(crl);

	lea	eax, DWORD PTR _crl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::push_back

; 1630 : 						i++;

	mov	ecx, DWORD PTR _i$186918[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$186918[ebp], ecx

; 1631 : 					}

	jmp	SHORT $L186920
$L186921:

; 1632 : 					zFree (pCrl);

	mov	edx, DWORD PTR _pCrl$186917[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1633 : 				}
; 1634 : 				else

	jmp	SHORT $L186924
$L186915:

; 1635 : 				{
; 1636 : 					PDS_DATA_BLOB pds=NULL;

	mov	DWORD PTR _pds$186925[ebp], 0

; 1637 : 					pds = fetch_URL(crlUrl);

	mov	eax, DWORD PTR _crlUrl$[ebp]
	push	eax
	call	_fetch_URL
	add	esp, 4
	mov	DWORD PTR _pds$186925[ebp], eax

; 1638 : 					if (pds) {

	cmp	DWORD PTR _pds$186925[ebp], 0
	je	SHORT $L186926

; 1639 : 						crl = (SECItem *) zMalloc(sizeof(SECItem));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _crl$[ebp], eax

; 1640 : 						crl->data = pds->pbData;

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR _pds$186925[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 1641 : 						crl->len = pds->cbData;

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR _pds$186925[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 1642 : 						crlBlobList.push_back(crl);

	lea	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::push_back

; 1643 : 					}else{

	jmp	SHORT $L186924
$L186926:

; 1644 : 						crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0
$L186924:

; 1645 : 					}
; 1646 : 				}
; 1647 : 				if (crlBlobList.size()==0) {

	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	test	eax, eax
	jne	SHORT $L186911

; 1648 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_cleanupError
	add	esp, 4

; 1649 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1650 : 					continue;

	jmp	$L186902
$L186911:

; 1651 : 				}
; 1652 : 
; 1653 : 				//if (crl==NULL) {
; 1654 : 				//	cleanupError(pg_sig); // Remove all previous errors from the error stack
; 1655 : 				//	ret=FALSE;
; 1656 : 				//	continue;
; 1657 : 				//}
; 1658 : 			}
; 1659 : 		// list of BLOBs
; 1660 : 		for (UINT i=0; i<crlBlobList.size(); i++) 

	mov	DWORD PTR _i$186931[ebp], 0
	jmp	SHORT $L186932
$L186933:
	mov	eax, DWORD PTR _i$186931[ebp]
	add	eax, 1
	mov	DWORD PTR _i$186931[ebp], eax
$L186932:
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	cmp	DWORD PTR _i$186931[ebp], eax
	jae	$L186934

; 1661 : 		{
; 1662 : 			crl = crlBlobList.at(i);

	mov	ecx, DWORD PTR _i$186931[ebp]
	push	ecx
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::at
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _crl$[ebp], edx

; 1663 : 			// create CRL context
; 1664 : 			CERTSignedCrl *sCrl =
; 1665 : 				CERT_DecodeDERCrl(NULL,crl,SEC_CRL_TYPE);

	push	1
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	push	0
	call	_CERT_DecodeDERCrl
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sCrl$186935[ebp], eax

; 1666 : 			if (sCrl==NULL) 

	cmp	DWORD PTR _sCrl$186935[ebp], 0
	jne	SHORT $L186936

; 1667 : 			{
; 1668 : 				cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 1669 : 				setError(pg_sig,CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1670 : 				ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1671 : 				if (crl->data) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L186937

; 1672 : 					zFree(crl->data);

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_rFree
	add	esp, 4
$L186937:

; 1673 : 				zFree (crl);

	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1674 : 				crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1675 : 				continue;

	jmp	$L186933
$L186936:

; 1676 : 			}			
; 1677 : 
; 1678 : //			ss = CERT_CompleteCRLDecodeEntries(sCrl);
; 1679 : 
; 1680 : 			pCrlContext = &(sCrl->crl);

	mov	ecx, DWORD PTR _sCrl$186935[ebp]
	add	ecx, 4
	mov	DWORD PTR _pCrlContext$[ebp], ecx

; 1681 : 			BYTE *cName = (BYTE *) CERT_NameToAscii(&pCrlContext->name);

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	call	_CERT_NameToAscii
	add	esp, 4
	mov	DWORD PTR _cName$186938[ebp], eax

; 1682 : 
; 1683 : 			// Check to see if the CRL issuer and the certificate issuers are the same
; 1684 : 			if (certIsNameEqual((BYTE *)pCertContext->issuerName, cName) 
; 1685 : 					== TRUE) // certificate and CRL issuers match

	mov	eax, DWORD PTR _cName$186938[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCertContext$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_certIsNameEqual
	add	esp, 8
	cmp	eax, 1
	jne	$L186941

; 1686 : 			{
; 1687 : 				PORT_Free(cName);

	mov	eax, DWORD PTR _cName$186938[ebp]
	push	eax
	call	_PORT_Free
	add	esp, 4

; 1688 : 				validCrlFound = TRUE;

	mov	DWORD PTR _validCrlFound$[ebp], 1

; 1689 : 				ss = CERT_VerifySignedData(&(sCrl->signatureWrap),
; 1690 : 				       pIssuerCertContext,
; 1691 : 				       pTime,
; 1692 : 				       pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIssuerCertContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sCrl$186935[ebp]
	add	edx, 120				; 00000078H
	push	edx
	call	_CERT_VerifySignedData
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ss$[ebp], eax

; 1693 : 
; 1694 : 				
; 1695 : 				if (ss!=SECSuccess)

	cmp	DWORD PTR _ss$[ebp], 0
	je	SHORT $L186942

; 1696 : 				{
; 1697 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 1698 : 					setError(pg_sig,CRL_BAD_SIGNATURE);

	push	72					; 00000048H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1699 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1700 : 					SEC_DestroyCrl(sCrl);

	mov	edx, DWORD PTR _sCrl$186935[ebp]
	push	edx
	call	_SEC_DestroyCrl
	add	esp, 4

; 1701 : 					pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1702 : 					if (crl->data) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L186943

; 1703 : 						zFree(crl->data);

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_rFree
	add	esp, 4
$L186943:

; 1704 : 					zFree (crl);

	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1705 : 					crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1706 : 					continue;

	jmp	$L186933
$L186942:

; 1707 : 				}
; 1708 : 				else // CRL has a valid signature from the cert issuer
; 1709 : 				{
; 1710 : 					CERTCertExtension **extensions = pCrlContext->extensions;

	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	mov	edx, DWORD PTR [ecx+88]
	mov	DWORD PTR _extensions$186945[ebp], edx

; 1711 : 					*crlFound = TRUE;

	mov	eax, DWORD PTR _crlFound$[ebp]
	mov	DWORD PTR [eax], 1

; 1712 : 					SECItem oid1, oid2;
; 1713 : 					SECItem encodedExt;
; 1714 : 					oid1.data = (BYTE *) oid_delta_crl_idicator;

	mov	DWORD PTR _oid1$186946[ebp+4], OFFSET FLAT:_oid_delta_crl_idicator

; 1715 : 					oid1.len = 3;

	mov	DWORD PTR _oid1$186946[ebp+8], 3

; 1716 : 					oid2.data = (BYTE *) oid_issuing_disp_point;

	mov	DWORD PTR _oid2$186947[ebp+4], OFFSET FLAT:_oid_issuing_disp_point

; 1717 : 					oid2.len = 3;

	mov	DWORD PTR _oid2$186947[ebp+8], 3

; 1718 : 
; 1719 : 					encodedExt.data = NULL;

	mov	DWORD PTR _encodedExt$186948[ebp+4], 0

; 1720 : 					encodedExt.len =0;

	mov	DWORD PTR _encodedExt$186948[ebp+8], 0

; 1721 : 
; 1722 : 					/*
; 1723 : 					 * Check for some v2 extensions
; 1724 : 					 */
; 1725 : 					// delta CRL lookup
; 1726 : 					ss = i_cert_FindExtensionByOID(extensions,&oid1,&encodedExt);

	lea	ecx, DWORD PTR _encodedExt$186948[ebp]
	push	ecx
	lea	edx, DWORD PTR _oid1$186946[ebp]
	push	edx
	mov	eax, DWORD PTR _extensions$186945[ebp]
	push	eax
	call	_i_cert_FindExtensionByOID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ss$[ebp], eax

; 1727 : 					if ((ss == SECSuccess) && (encodedExt.len>0))

	cmp	DWORD PTR _ss$[ebp], 0
	jne	SHORT $L186951
	cmp	DWORD PTR _encodedExt$186948[ebp+8], 0
	jbe	SHORT $L186951

; 1728 : 					{
; 1729 : 						SECITEM_FreeItem(&encodedExt,PR_FALSE);

	push	0
	lea	ecx, DWORD PTR _encodedExt$186948[ebp]
	push	ecx
	call	_SECITEM_FreeItem
	add	esp, 8

; 1730 : 						validCrlFound = FALSE; // Set CRL Found to false in order to force a CRL Fetch

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 1731 : 						setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1732 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1733 : 						SEC_DestroyCrl(sCrl);

	mov	eax, DWORD PTR _sCrl$186935[ebp]
	push	eax
	call	_SEC_DestroyCrl
	add	esp, 4

; 1734 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1735 : 						if (crl->data) 

	mov	ecx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L186952

; 1736 : 							zFree(crl->data);

	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_rFree
	add	esp, 4
$L186952:

; 1737 : 						zFree (crl);

	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1738 : 						crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1739 : 						break;

	jmp	$L186934
$L186951:

; 1740 : 					}
; 1741 : 				
; 1742 : 					// issuing disp point lookup
; 1743 : 					ss = i_cert_FindExtensionByOID(extensions,&oid2,&encodedExt);

	lea	edx, DWORD PTR _encodedExt$186948[ebp]
	push	edx
	lea	eax, DWORD PTR _oid2$186947[ebp]
	push	eax
	mov	ecx, DWORD PTR _extensions$186945[ebp]
	push	ecx
	call	_i_cert_FindExtensionByOID
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ss$[ebp], eax

; 1744 : 					if ((ss == SECSuccess) && (encodedExt.len>0))

	cmp	DWORD PTR _ss$[ebp], 0
	jne	SHORT $L186953
	cmp	DWORD PTR _encodedExt$186948[ebp+8], 0
	jbe	SHORT $L186953

; 1745 : 					{
; 1746 : 						SECITEM_FreeItem(&encodedExt,PR_FALSE);

	push	0
	lea	edx, DWORD PTR _encodedExt$186948[ebp]
	push	edx
	call	_SECITEM_FreeItem
	add	esp, 8

; 1747 : 						validCrlFound = FALSE; // Set CRL Found to false in order to force a CRL Fetch

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 1748 : 						setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1749 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1750 : 						SEC_DestroyCrl(sCrl);

	mov	ecx, DWORD PTR _sCrl$186935[ebp]
	push	ecx
	call	_SEC_DestroyCrl
	add	esp, 4

; 1751 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1752 : 						if (crl->data) 

	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L186954

; 1753 : 							zFree(crl->data);

	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_rFree
	add	esp, 4
$L186954:

; 1754 : 						zFree (crl);

	mov	edx, DWORD PTR _crl$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1755 : 						crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1756 : 						break;

	jmp	$L186934
$L186953:

; 1757 : 					}
; 1758 : 
; 1759 : 					// Lets add the base64 encoded CRL to the crl list
; 1760 : 					int size = base64encodeSize(crl->len);

	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _size$186955[ebp], eax

; 1761 : 					unsigned char *b64Crl = (unsigned char *)zMalloc(size+1);

	mov	edx, DWORD PTR _size$186955[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _b64Crl$186956[ebp], eax

; 1762 : 					if ((size = base64encode(crl->data, crl->len, b64Crl, size+1)) == -1)

	mov	eax, DWORD PTR _size$186955[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _b64Crl$186956[ebp]
	push	ecx
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$186955[ebp], eax
	cmp	DWORD PTR _size$186955[ebp], -1
	jne	SHORT $L186958

; 1763 : 					{
; 1764 : 						setError(pg_sig, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1765 : 						zFree(b64Crl);

	mov	ecx, DWORD PTR _b64Crl$186956[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1766 : 						break;

	jmp	$L186934
$L186958:

; 1767 : 					}
; 1768 : 					*(b64Crl + size) = '\0';

	mov	edx, DWORD PTR _b64Crl$186956[ebp]
	add	edx, DWORD PTR _size$186955[ebp]
	mov	BYTE PTR [edx], 0

; 1769 : 					usedCrlList->insert(usedCrlList->begin(), b64Crl);

	lea	eax, DWORD PTR _b64Crl$186956[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188558[ebp]
	push	ecx
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T188559[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert

; 1770 : 					CERTCrlEntry *entry = FindCertInCRL(pCertContext, pCrlContext);

	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	push	edx
	call	_FindCertInCRL
	add	esp, 8
	mov	DWORD PTR _entry$186961[ebp], eax

; 1771 : 					if (entry != NULL) {

	cmp	DWORD PTR _entry$186961[ebp], 0
	je	$L186944

; 1772 : 						// CRL contains this certificate
; 1773 : 						// Compare the revocation time with pTime
; 1774 : 						if (CompareCRLTime(&entry->revocationDate, pTime) <= 0)

	mov	eax, DWORD PTR _pTime$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _entry$186961[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	?CompareCRLTime@@YAHPAUSECItemStr@@_J@Z	; CompareCRLTime
	add	esp, 12					; 0000000cH
	test	eax, eax
	jg	SHORT $L186944

; 1775 : 						{// The certificate was revoked before pTime
; 1776 : 							cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 1777 : 							setError(pg_sig,CRL_CERT_REVOKED);

	push	75					; 0000004bH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1778 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1779 : 							SEC_DestroyCrl(sCrl);

	mov	edx, DWORD PTR _sCrl$186935[ebp]
	push	edx
	call	_SEC_DestroyCrl
	add	esp, 4

; 1780 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1781 : 							if (crl->data) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L186964

; 1782 : 								zFree(crl->data);

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_rFree
	add	esp, 4
$L186964:

; 1783 : 							zFree (crl);

	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1784 : 							crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1785 : 							break;

	jmp	$L186934
$L186944:

; 1786 : 						}
; 1787 : 					}
; 1788 : 				}
; 1789 : 				
; 1790 : 				// -1 means comparision time is after NextUpdate, and CRL is old.
; 1791 : 				if (CompareCRLTime(&(pCrlContext->nextUpdate),pTime)==-1)

	mov	ecx, DWORD PTR _pTime$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	add	eax, 72					; 00000048H
	push	eax
	call	?CompareCRLTime@@YAHPAUSECItemStr@@_J@Z	; CompareCRLTime
	add	esp, 12					; 0000000cH
	cmp	eax, -1
	jne	SHORT $L186965

; 1792 : 				{
; 1793 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 1794 : 					setError(pg_sig,CRL_TOO_OLD);

	push	87					; 00000057H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1795 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1796 : 					SEC_DestroyCrl(sCrl);

	mov	eax, DWORD PTR _sCrl$186935[ebp]
	push	eax
	call	_SEC_DestroyCrl
	add	esp, 4

; 1797 : 					pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1798 : 					if (crl->data) 

	mov	ecx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L186966

; 1799 : 						zFree(crl->data);

	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_rFree
	add	esp, 4
$L186966:

; 1800 : 					zFree (crl);

	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1801 : 					crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1802 : 					break;

	jmp	$L186934
$L186965:

; 1803 : 				}
; 1804 : 				
; 1805 : 				
; 1806 : 				if (crl->data) 

	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L186967

; 1807 : 					zFree(crl->data);

	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_rFree
	add	esp, 4
$L186967:

; 1808 : 				zFree (crl);

	mov	edx, DWORD PTR _crl$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1809 : 				crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1810 : 				SEC_DestroyCrl(sCrl);

	mov	eax, DWORD PTR _sCrl$186935[ebp]
	push	eax
	call	_SEC_DestroyCrl
	add	esp, 4

; 1811 : 				
; 1812 : 				break;

	jmp	SHORT $L186934
$L186941:

; 1813 : 			}
; 1814 : 			else // This CRL is not relevant since it's issuer is not the same as the certificate issuer
; 1815 : 			{
; 1816 : 				PORT_Free(cName);

	mov	ecx, DWORD PTR _cName$186938[ebp]
	push	ecx
	call	_PORT_Free
	add	esp, 4

; 1817 : 				SEC_DestroyCrl(sCrl);

	mov	edx, DWORD PTR _sCrl$186935[ebp]
	push	edx
	call	_SEC_DestroyCrl
	add	esp, 4

; 1818 : 				
; 1819 : 				pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1820 : 				if (crl->data) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L186969

; 1821 : 					zFree(crl->data);

	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_rFree
	add	esp, 4
$L186969:

; 1822 : 				zFree (crl);

	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1823 : 				crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1824 : 				continue;

	jmp	$L186933
$L186934:

; 1825 : 			}
; 1826 : 		}
; 1827 : 	}

	jmp	$L186902
$L186903:

; 1828 : 
; 1829 : 				
; 1830 : 	if (!(validCrlFound))

	cmp	DWORD PTR _validCrlFound$[ebp], 0
	jne	SHORT $L186970

; 1831 : 	{
; 1832 : 		setError(pg_sig,CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1833 : 		ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0
$L186970:

; 1834 : 	}
; 1835 : 	return ret;

	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR $T188560[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	call	??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::~vector<SECItemStr *,std::allocator<SECItemStr *> >
	mov	eax, DWORD PTR $T188560[ebp]

; 1836 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188572
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 200				; 000000c8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188572:
	DD	6
	DD	$L188571
$L188571:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L188564
	DD	-76					; ffffffb4H
	DD	16					; 00000010H
	DD	$L188565
	DD	-124					; ffffff84H
	DD	12					; 0000000cH
	DD	$L188566
	DD	-144					; ffffff70H
	DD	12					; 0000000cH
	DD	$L188567
	DD	-164					; ffffff5cH
	DD	12					; 0000000cH
	DD	$L188568
	DD	-180					; ffffff4cH
	DD	4
	DD	$L188569
$L188569:
	DB	98					; 00000062H
	DB	54					; 00000036H
	DB	52					; 00000034H
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
$L188568:
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$L188567:
	DB	111					; 0000006fH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	50					; 00000032H
	DB	0
$L188566:
	DB	111					; 0000006fH
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	49					; 00000031H
	DB	0
$L188565:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L188564:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L188561:
	lea	ecx, DWORD PTR _crlBlobList$[ebp]
	jmp	??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::~vector<SECItemStr *,std::allocator<SECItemStr *> >
__ehhandler$?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T188563
	jmp	___CxxFrameHandler
text$x	ENDS
?check_CRL@@YAHPAUNSSTrustDomainStr@@PAUCERTCertificateStr@@1_JPAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ENDP ; check_CRL
EXTRN	_SECITEM_CompareItem:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_comp$ = -4						; size = 4
_c1$ = 8						; size = 4
_c2$ = 12						; size = 4
?CompareCerts@@YAHPAUCERTCertificateStr@@0@Z PROC NEAR	; CompareCerts

; 2255 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2256 :     SECComparison comp;
; 2257 :     
; 2258 :     comp = SECITEM_CompareItem(&c1->derCert, &c2->derCert);

	mov	eax, DWORD PTR _c2$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _c1$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	call	_SECITEM_CompareItem
	add	esp, 8
	mov	DWORD PTR _comp$[ebp], eax

; 2259 :     if ( comp == SECEqual ) { /* certs are the same */

	cmp	DWORD PTR _comp$[ebp], 0
	jne	SHORT $L186977

; 2260 : 	return(PR_TRUE);

	mov	eax, 1
	jmp	SHORT $L186975
$L186977:

; 2261 :     } else {
; 2262 : 	return(PR_FALSE);

	xor	eax, eax
$L186975:

; 2263 :     }
; 2264 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CompareCerts@@YAHPAUCERTCertificateStr@@0@Z ENDP	; CompareCerts
_TEXT	ENDS
EXTRN	__imp__SystemTimeToFileTime@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_ft$ = -12						; size = 8
_pst$ = 8						; size = 4
_pt$ = 12						; size = 4
?SystemTimeToT64@@YAXPAU_SYSTEMTIME@@PA_J@Z PROC NEAR	; SystemTimeToT64

; 2269 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2270 :  FILETIME ft;
; 2271 :  SystemTimeToFileTime(pst, &ft);

	mov	esi, esp
	lea	eax, DWORD PTR _ft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pst$[ebp]
	push	ecx
	call	DWORD PTR __imp__SystemTimeToFileTime@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2272 :  FileTimeToT64(&ft,pt);

	mov	edx, DWORD PTR _pt$[ebp]
	push	edx
	lea	eax, DWORD PTR _ft$[ebp]
	push	eax
	call	?FileTimeToT64@@YAXPAU_FILETIME@@PA_J@Z	; FileTimeToT64
	add	esp, 8

; 2273 :  *pt-=FindTimeTBase();

	call	?FindTimeTBase@@YA_JXZ			; FindTimeTBase
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	esi, DWORD PTR [ecx]
	sub	esi, eax
	mov	eax, DWORD PTR [ecx+4]
	sbb	eax, edx
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], eax

; 2274 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188578
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188578:
	DD	1
	DD	$L188577
$L188577:
	DD	-12					; fffffff4H
	DD	8
	DD	$L188576
$L188576:
	DB	102					; 00000066H
	DB	116					; 00000074H
	DB	0
?SystemTimeToT64@@YAXPAU_SYSTEMTIME@@PA_J@Z ENDP	; SystemTimeToT64
; Function compile flags: /Odt /RTCsu
_ft$ = -52						; size = 8
_st$ = -36						; size = 16
_tbase$ = -12						; size = 8
?FindTimeTBase@@YA_JXZ PROC NEAR			; FindTimeTBase

; 2276 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2277 :  // Find 1st Jan 1970 as a FILETIME 
; 2278 :  int64 tbase;
; 2279 :  SYSTEMTIME st;
; 2280 :  FILETIME ft;
; 2281 :  memset(&st,0,sizeof(st));

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _st$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2282 :  st.wYear=1970;

	mov	WORD PTR _st$[ebp], 1970		; 000007b2H

; 2283 :  st.wMonth=1;

	mov	WORD PTR _st$[ebp+2], 1

; 2284 :  st.wDay=1;

	mov	WORD PTR _st$[ebp+6], 1

; 2285 :  SystemTimeToFileTime(&st, &ft);

	mov	esi, esp
	lea	ecx, DWORD PTR _ft$[ebp]
	push	ecx
	lea	edx, DWORD PTR _st$[ebp]
	push	edx
	call	DWORD PTR __imp__SystemTimeToFileTime@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2286 :  FileTimeToT64(&ft,&tbase);

	lea	eax, DWORD PTR _tbase$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ft$[ebp]
	push	ecx
	call	?FileTimeToT64@@YAXPAU_FILETIME@@PA_J@Z	; FileTimeToT64
	add	esp, 8

; 2287 :  return tbase;

	mov	eax, DWORD PTR _tbase$[ebp]
	mov	edx, DWORD PTR _tbase$[ebp+4]

; 2288 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188584
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188584:
	DD	3
	DD	$L188583
$L188583:
	DD	-12					; fffffff4H
	DD	8
	DD	$L188580
	DD	-36					; ffffffdcH
	DD	16					; 00000010H
	DD	$L188581
	DD	-52					; ffffffccH
	DD	8
	DD	$L188582
$L188582:
	DB	102					; 00000066H
	DB	116					; 00000074H
	DB	0
$L188581:
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L188580:
	DB	116					; 00000074H
	DB	98					; 00000062H
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	0
?FindTimeTBase@@YA_JXZ ENDP				; FindTimeTBase
_TEXT	ENDS
EXTRN	__alldiv:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_li$ = -12						; size = 8
_pft$ = 8						; size = 4
_pt$ = 12						; size = 4
?FileTimeToT64@@YAXPAU_FILETIME@@PA_J@Z PROC NEAR	; FileTimeToT64

; 2290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2291 :  LARGE_INTEGER li;    
; 2292 :  li.LowPart = pft->dwLowDateTime;

	mov	eax, DWORD PTR _pft$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _li$[ebp], ecx

; 2293 :  li.HighPart = pft->dwHighDateTime;

	mov	edx, DWORD PTR _pft$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _li$[ebp+4], eax

; 2294 :  *pt=li.QuadPart;

	mov	ecx, DWORD PTR _pt$[ebp]
	mov	edx, DWORD PTR _li$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _li$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 2295 :  *pt/=SECS_TO_FT_MULT;

	mov	ecx, DWORD PTR _pt$[ebp]
	push	0
	push	10					; 0000000aH
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	call	__alldiv
	mov	ecx, DWORD PTR _pt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 2296 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188589
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188589:
	DD	1
	DD	$L188588
$L188588:
	DD	-12					; fffffff4H
	DD	8
	DD	$L188587
$L188587:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	0
?FileTimeToT64@@YAXPAU_FILETIME@@PA_J@Z ENDP		; FileTimeToT64
_TEXT	ENDS
EXTRN	_DER_UTCTimeToTime:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_rv$ = -20						; size = 4
_utcTime$ = -12						; size = 8
_cTime$ = 8						; size = 4
_pTime$ = 12						; size = 8
?CompareCRLTime@@YAHPAUSECItemStr@@_J@Z PROC NEAR	; CompareCRLTime

; 2300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2301 : 	// convert SECItem to int64 time and compare
; 2302 : 	int64 utcTime;
; 2303 : 	int rv = DER_UTCTimeToTime(&utcTime, cTime);

	mov	eax, DWORD PTR _cTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _utcTime$[ebp]
	push	ecx
	call	_DER_UTCTimeToTime
	add	esp, 8
	mov	DWORD PTR _rv$[ebp], eax

; 2304 :     if (rv) {

	cmp	DWORD PTR _rv$[ebp], 0
	je	SHORT $L187002

; 2305 :         return -100;

	mov	eax, -100				; ffffff9cH
	jmp	SHORT $L186999
$L187002:

; 2306 :     }
; 2307 : 	if (utcTime>pTime) {

	mov	edx, DWORD PTR _utcTime$[ebp+4]
	cmp	edx, DWORD PTR _pTime$[ebp+4]
	jl	SHORT $L187003
	jg	SHORT $L188591
	mov	eax, DWORD PTR _utcTime$[ebp]
	cmp	eax, DWORD PTR _pTime$[ebp]
	jbe	SHORT $L187003
$L188591:

; 2308 : 		return 1;

	mov	eax, 1
	jmp	SHORT $L186999
$L187003:

; 2309 : 	}else if (utcTime==pTime){

	mov	ecx, DWORD PTR _utcTime$[ebp]
	cmp	ecx, DWORD PTR _pTime$[ebp]
	jne	SHORT $L187005
	mov	edx, DWORD PTR _utcTime$[ebp+4]
	cmp	edx, DWORD PTR _pTime$[ebp+4]
	jne	SHORT $L187005

; 2310 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L186999
$L187005:

; 2311 : 	}else{
; 2312 : 		return -1;

	or	eax, -1
$L186999:

; 2313 : 	}
; 2314 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188594
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188594:
	DD	1
	DD	$L188593
$L188593:
	DD	-12					; fffffff4H
	DD	8
	DD	$L188592
$L188592:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	99					; 00000063H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
?CompareCRLTime@@YAHPAUSECItemStr@@_J@Z ENDP		; CompareCRLTime
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	??0?$allocator@PAE@std@@QAE@XZ			; std::allocator<unsigned char *>::allocator<unsigned char *>
PUBLIC	??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PAE@std@@QAE@XZ		; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 281  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy

; 366  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
PUBLIC	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::size, COMDAT
; _this$ = ecx

; 430  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 432  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::size
_TEXT	ENDS
PUBLIC	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
PUBLIC	?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert, COMDAT
; _this$ = ecx

; 514  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert

; 516  : 		return (--_Where);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 517  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 229  : 		iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator

; 230  : 			{	// construct with null node
; 231  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*

; 241  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--, COMDAT
; _this$ = ecx

; 268  : 			{	// postdecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 270  : 			--*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--

; 271  : 			return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 272  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188615
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L188615:
	DD	1
	DD	$L188614
$L188614:
	DD	-12					; fffffff4H
	DD	4
	DD	$L188613
$L188613:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z ; std::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >
PUBLIC	??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ	; std::allocator<SECItemStr *>::allocator<SECItemStr *>
PUBLIC	?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Buy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::vector<SECItemStr *,std::allocator<SECItemStr *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ ; std::allocator<SECItemStr *>::allocator<SECItemStr *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z ; std::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >

; 300  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Buy

; 301  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::vector<SECItemStr *,std::allocator<SECItemStr *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::~vector<SECItemStr *,std::allocator<SECItemStr *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Tidy

; 389  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::~vector<SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L188623
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $L188624
$L188623:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$L188624:
	mov	eax, DWORD PTR tv70[ebp]

; 517  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin
PUBLIC	?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xran
PUBLIC	??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
;	COMDAT ?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z
_TEXT	SEGMENT
$T188628 = -12						; size = 4
$T188627 = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::at, COMDAT
; _this$ = ecx

; 542  : 		{	// subscript mutable sequence with checking

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $L187076

; 544  : 			_Xran();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xran
$L187076:

; 545  : 		return (*(begin() + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188628[ebp]
	push	ecx
	lea	edx, DWORD PTR $T188627[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin
	mov	ecx, eax
	call	??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+
	mov	ecx, eax
	call	??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator*

; 546  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?at@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAPAUSECItemStr@@I@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::at
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::capacity
PUBLIC	?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::end
PUBLIC	?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::insert
PUBLIC	?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill
; Function compile flags: /Odt /RTCsu
;	COMDAT ?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z
_TEXT	SEGMENT
$T188632 = -12						; size = 4
$T188631 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::capacity
	cmp	esi, eax
	jae	SHORT $L187197

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 582  : 		else

	jmp	SHORT $L187196
$L187197:

; 583  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T188631[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::end
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T188632[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::insert
$L187196:

; 584  : 		}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXABQAUSECItemStr@@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::push_back
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::clear, COMDAT
; _this$ = ecx

; 743  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 744  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Tidy

; 745  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEXXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::clear
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

	push	ebp
	mov	ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize
PUBLIC	?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
PUBLIC	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z
_TEXT	SEGMENT
__Newnode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert, COMDAT
; _this$ = ecx

; 521  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 524  : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 527  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188650 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T188652 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188643
$T188651 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T188652
$T188645 DD	019930520H
	DD	02H
	DD	FLAT:$T188650
	DD	01H
	DD	FLAT:$T188651
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -44						; size = 4
tv92 = -40						; size = 4
__Linkcnt$ = -36					; size = 4
__Pnode$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv92[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

	mov	eax, DWORD PTR __Linkcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	DWORD PTR tv93[ebp], eax
	lea	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv93[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
	jmp	SHORT $L188642
$L188643:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $L187364

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
$L187364:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 910  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188642:

; 911  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L188640:

; 913  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188649
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188649:
	DD	1
	DD	$L188648
$L188648:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L188646
$L188646:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ:
	mov	eax, OFFSET FLAT:$T188645
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 935  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAE@std@@QAE@ABV01@@Z		; std::allocator<unsigned char *>::allocator<unsigned char *>
PUBLIC	??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>

; 83   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAE@std@@QAE@XZ PROC NEAR		; std::allocator<unsigned char *>::allocator<unsigned char *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAE@std@@QAE@XZ ENDP			; std::allocator<unsigned char *>::allocator<unsigned char *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator

; 236  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--, COMDAT
; _this$ = ecx

; 262  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--

; 264  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 265  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 151  : 			{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 152  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
	add	esp, 4

; 162  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L188672
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $L188673
$L188672:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$L188673:
	mov	eax, DWORD PTR tv70[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::end
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Insert_n
PUBLIC	??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
$T188683 = -16						; size = 4
$T188680 = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	test	eax, eax
	jne	SHORT $L188681
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $L188682
$L188681:
	lea	eax, DWORD PTR $T188680[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator-
	mov	DWORD PTR tv73[ebp], eax
$L188682:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Insert_n

; 623  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	eax, DWORD PTR $T188683[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::begin
	mov	ecx, eax
	call	??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE?AViterator@12@V312@ABQAUSECItemStr@@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::allocate
PUBLIC	?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size
PUBLIC	?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xlen
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $L187401

; 773  : 			return (false);

	xor	al, al
	jmp	SHORT $L187400
$L187401:

; 774  : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $L187403

; 775  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xlen

; 776  : 		else

	jmp	SHORT $L187402
$L187403:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L187402:

; 781  : 			}
; 782  : 		return (true);

	mov	al, 1
$L187400:

; 783  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L187407

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::deallocate
$L187407:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 798  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Uninitialized_fill_n<SECItemStr * *,unsigned int,SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Uninitialized_fill_n<SECItemStr * *,unsigned int,SECItemStr *,std::allocator<SECItemStr *> >
	add	esp, 16					; 00000010H

; 879  : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 880  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill
_TEXT	ENDS
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188698 DD	0ffffffffH
	DD	FLAT:$L188694
$T188696 DD	019930520H
	DD	01H
	DD	FLAT:$T188698
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T188693 = -84						; size = 28
$T188692 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xran, COMDAT
; _this$ = ecx

; 888  : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 889  : 		_THROW(out_of_range, "invalid vector<T> subscript");

	push	OFFSET FLAT:??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
	lea	ecx, DWORD PTR $T188693[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T188693[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188692[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET FLAT:__TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T188692[ebp]
	push	ecx
	call	__CxxThrowException@8
$L188691:

; 890  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188694:
	lea	ecx, DWORD PTR $T188693[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T188696
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xran@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xran
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_7out_of_range@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188711 DD	0ffffffffH
	DD	FLAT:$L188706
$T188709 DD	019930520H
	DD	01H
	DD	FLAT:$T188711
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@XZ			; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 20   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188706:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET FLAT:$T188709
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 28   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L167931
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L167931:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188725 DD	0ffffffffH
	DD	FLAT:$L188720
$T188723 DD	019930520H
	DD	01H
	DD	FLAT:$T188725
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@@UAE@XZ			; exception::~exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188720:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T188723
	jmp	___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L168019
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L168019:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L187205

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L187205:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L187207

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L187207:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L187208

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L187326
$L187208:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L187326

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L187326:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$187333 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L187330

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L187331
$L187330:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L187331

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$187333[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L187334

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$187333[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L187334:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$187333[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L187331:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L188748
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L188749
$L188748:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L188749:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z ; std::allocator<SECItemStr *>::allocator<SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z PROC NEAR ; std::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z ; std::allocator<SECItemStr *>::allocator<SECItemStr *>

; 22   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAE@V?$allocator@PAUSECItemStr@@@1@@Z ENDP ; std::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >::_Vector_val<SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ PROC NEAR	; std::allocator<SECItemStr *>::allocator<SECItemStr *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUSECItemStr@@@std@@QAE@XZ ENDP		; std::allocator<SECItemStr *>::allocator<SECItemStr *>
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator*

; 221  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEAAPAUSECItemStr@@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+=
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+=
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188764
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L188764:
	DD	1
	DD	$L188763
$L188763:
	DD	-12					; fffffff4H
	DD	4
	DD	$L188762
$L188762:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??Hiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188775 DD	0ffffffffH
	DD	FLAT:$L188770
$T188773 DD	019930520H
	DD	01H
	DD	FLAT:$T188775
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@ABV0@@Z		; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188770:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T188773
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$187462 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L187459

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L187459:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L187460

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L187460:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L187461

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$187462[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$187462[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L187461:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T188789 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T188789[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T188789[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L187470

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L187470:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L187471

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L187472
$L187471:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L187473
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L187473

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L188794
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L188795
$L188794:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L188795:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L187472
$L187473:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L187472

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L187472:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L188798
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L188799
$L188798:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L188799:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

	push	ebp
	mov	ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 114  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 119  : 		}

	pop	ebp
	ret	0
?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	jmp	SHORT $L187488
$L187489:
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx
$L187488:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $L187485

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 622  : 			}

	jmp	SHORT $L187489
$L187485:

; 623  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188820 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L188816
	DD	0ffffffffH
	DD	00H
$T188822 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188815
$T188821 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T188822
$T188818 DD	019930520H
	DD	03H
	DD	FLAT:$T188820
	DD	01H
	DD	FLAT:$T188821
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
_TEXT	SEGMENT
tv79 = -40						; size = 4
tv89 = -36						; size = 4
$T188811 = -32						; size = 4
$T188810 = -28						; size = 4
__Pnode$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode, COMDAT
; _this$ = ecx

; 917  : 		{	// allocate a node and set links and value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 919  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T188811[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T188811[ebp], 0
	je	SHORT $L188812
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prev$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T188811[ebp]
	call	??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
	mov	DWORD PTR tv89[ebp], eax
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $L188813
$L188812:
	mov	DWORD PTR tv79[ebp], 0
$L188813:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T188810[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $L188814
$L188815:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 923  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188814:

; 924  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 925  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L188809:

; 926  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188816:
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T188811[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z:
	mov	eax, OFFSET FLAT:$T188818
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 63   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 64   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 65   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 68   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 69   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
xdata$x	SEGMENT
$T188837 DD	0ffffffffH
	DD	FLAT:$L188833
$T188835 DD	019930520H
	DD	01H
	DD	FLAT:$T188837
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T188832 = -84						; size = 28
$T188831 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 957  : 		if (max_size() - _Mysize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L187503

; 958  : 			_THROW(length_error, "list<T> too long");

	push	OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T188832[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T188832[ebp]
	push	edx
	lea	ecx, DWORD PTR $T188831[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T188831[ebp]
	push	eax
	call	__CxxThrowException@8
$L187503:

; 959  : 		_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$L188830:

; 960  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188833:
	lea	ecx, DWORD PTR $T188832[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET FLAT:$T188835
	jmp	___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L167997
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L167997:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>
PUBLIC	??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>

; 65   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAE@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned char *>::allocator<unsigned char *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAE@std@@QAE@ABV01@@Z ENDP		; std::allocator<unsigned char *>::allocator<unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
	add	esp, 8

; 148  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 157  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 183  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 			_Ptr = _Prevnode(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 185  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 206  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 208  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ ; std::allocator<SECItemStr *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ ; std::allocator<SECItemStr *>::max_size

; 522  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
	add	esp, 12					; 0000000cH

; 788  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>
PUBLIC	??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z ; std::fill<SECItemStr * *,SECItemStr *>
PUBLIC	??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z ; std::copy_backward<SECItemStr * *,SECItemStr * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188885 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T188887 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188876
$T188888 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188878
$T188886 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T188887
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T188888
$T188880 DD	019930520H
	DD	04H
	DD	FLAT:$T188885
	DD	02H
	DD	FLAT:$T188886
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z
_TEXT	SEGMENT
tv240 = -60						; size = 4
tv239 = -56						; size = 4
tv85 = -52						; size = 4
__Oldend$187592 = -48					; size = 4
__Ptr$187572 = -44					; size = 4
__Newvec$187571 = -40					; size = 4
__Capacity$ = -36					; size = 4
__Tmp$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $L187565

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

	jmp	$L188872
$L187565:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L187567

; 816  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

	jmp	$L188872
$L187567:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$L187569

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $L188873
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $L188874
$L188873:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv85[ebp], edx
$L188874:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 821  : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $L187570

; 822  : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$L187570:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::allocate
	mov	DWORD PTR __Newvec$187571[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

	mov	edx, DWORD PTR __Newvec$187571[ebp]
	mov	DWORD PTR __Ptr$187572[ebp], edx

; 825  : 
; 826  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR __Newvec$187571[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR __Ptr$187572[ebp], ecx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$187572[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill
	mov	DWORD PTR tv240[ebp], eax
	mov	edx, DWORD PTR tv240[ebp]
	mov	DWORD PTR __Ptr$187572[ebp], edx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	eax, DWORD PTR __Ptr$187572[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>
	jmp	SHORT $L188875
$L188876:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

	mov	ecx, DWORD PTR __Ptr$187572[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$187571[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$187571[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::deallocate

; 834  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188875:

; 835  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEIXZ ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L187579

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z ; std::allocator<SECItemStr *>::deallocate
$L187579:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$187571[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$187571[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$187571[ebp]
	mov	DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	jmp	$L188872
$L187569:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$L187582

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>

; 851  : 
; 852  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU3@IABQAU3@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ufill
	jmp	SHORT $L188877
$L188878:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXPAPAUSECItemStr@@0@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Destroy

; 857  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188877:

; 858  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z ; std::fill<SECItemStr * *,SECItemStr *>
	add	esp, 12					; 0000000cH

; 863  : 			}
; 864  : 		else

	jmp	SHORT $L188872
$L187582:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$187592[ebp], eax

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Oldend$187592[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$187592[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$187592[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$187592[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z ; std::copy_backward<SECItemStr * *,SECItemStr * *>
	add	esp, 12					; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z ; std::fill<SECItemStr * *,SECItemStr *>
	add	esp, 12					; 0000000cH
$L188872:

; 873  : 			}
; 874  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188884
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L188884:
	DD	1
	DD	$L188883
$L188883:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L188881
$L188881:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z:
	mov	eax, OFFSET FLAT:$T188880
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEXViterator@12@IABQAUSECItemStr@@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Insert_n
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188899 DD	0ffffffffH
	DD	FLAT:$L188895
$T188897 DD	019930520H
	DD	01H
	DD	FLAT:$T188899
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T188894 = -84						; size = 28
$T188893 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T188894[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T188894[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188893[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T188893[ebp]
	push	ecx
	call	__CxxThrowException@8
$L188892:

; 885  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188895:
	lea	ecx, DWORD PTR $T188894[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T188897
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IBEXXZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<SECItemStr *>::allocator<SECItemStr *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUSECItemStr@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<SECItemStr *>::allocator<SECItemStr *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z PROC NEAR ; std::allocator<SECItemStr *>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUSECItemStr@@@std@@QAEXPAPAUSECItemStr@@I@Z ENDP ; std::allocator<SECItemStr *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z ; std::_Allocate<SECItemStr *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z PROC NEAR ; std::allocator<SECItemStr *>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z ; std::_Allocate<SECItemStr *>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUSECItemStr@@@std@@QAEPAPAUSECItemStr@@I@Z ENDP ; std::allocator<SECItemStr *>::allocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::const_iterator

; 216  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 257  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 258  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??Yiterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T188914 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T188914[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T188914[ebp]
	call	??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator-

; 280  : 			}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Giterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 83   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEABQAUSECItemStr@@XZ ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L188926
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L188927
$L188926:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L188927:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188937 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T188939 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188933
$T188940 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188931
$T188938 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T188939
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T188940
$T188935 DD	019930520H
	DD	04H
	DD	FLAT:$T188937
	DD	02H
	DD	FLAT:$T188938
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L187639

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L187640
$L187639:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L187640
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L187640

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L187640:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L188930
$L188931:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L188932
$L188933:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188932:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L188930
	ret	0
$L188930:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L187645

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L187645:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L188929:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T188935
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAE@std@@QBEIXZ		; std::allocator<unsigned char *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size, COMDAT
; _this$ = ecx

; 435  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?max_size@?$allocator@PAE@std@@QBEIXZ	; std::allocator<unsigned char *>::max_size

; 437  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
_TEXT	ENDS
PUBLIC	??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>

; 45   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ PROC NEAR ; std::allocator<SECItemStr *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188953
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188954
$L188953:
	mov	DWORD PTR tv65[ebp], 1
$L188954:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUSECItemStr@@@std@@QBEIXZ ENDP	; std::allocator<SECItemStr *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QAE@PAPAUSECItemStr@@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 144  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??Gconst_iterator@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z PROC NEAR ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Nextarg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Prevarg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Myvalarg$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 35   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ENDP ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L187674

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L187673
$L187674:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L187675

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L187675:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L187673:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188967
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188968
$L188967:
	mov	DWORD PTR tv65[ebp], 1
$L188968:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAE@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAE@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned char *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188971
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188972
$L188971:
	mov	DWORD PTR tv65[ebp], 1
$L188972:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAE@std@@QBEIXZ ENDP		; std::allocator<unsigned char *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L187697
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L187696
$L187697:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L187695
$L187696:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L187695:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ; std::_Ptr_cat<SECItemStr>
PUBLIC	??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<SECItemStr *,unsigned int,SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT
$T188977 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<SECItemStr * *,unsigned int,SECItemStr *,std::allocator<SECItemStr *> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ; std::_Ptr_cat<SECItemStr>
	add	esp, 8
	mov	BYTE PTR $T188977[ebp], al
	mov	dl, BYTE PTR $T188977[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<SECItemStr *,unsigned int,SECItemStr *>
	add	esp, 20					; 00000014H

; 258  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_fill_n@PAPAUSECItemStr@@IPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@@Z ENDP ; std::_Uninitialized_fill_n<SECItemStr * *,unsigned int,SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T188984 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T188984[ebp], eax
	cmp	DWORD PTR $T188984[ebp], 0
	je	SHORT $L188985
	mov	ecx, DWORD PTR $T188984[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T188984[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $L187897
$L188985:
	mov	DWORD PTR tv68[ebp], 0
$L187897:

; 43   : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT
$T188991 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z PROC NEAR ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ; std::_Ptr_cat<SECItemStr>
	add	esp, 8
	mov	BYTE PTR $T188991[ebp], al
	mov	dl, BYTE PTR $T188991[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
	add	esp, 16					; 00000010H

; 218  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@@Z ENDP ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Uninitialized_copy<SECItemStr * *,SECItemStr * *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z PROC NEAR ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z ; std::_Uninitialized_copy<SECItemStr * *,SECItemStr * *,std::allocator<SECItemStr *> >
	add	esp, 16					; 00000010H

; 805  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAUSECItemStr@@@?$vector@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@IAEPAPAUSECItemStr@@PAPAU2@00@Z ENDP ; std::vector<SECItemStr *,std::allocator<SECItemStr *> >::_Ucopy<SECItemStr * *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z PROC NEAR ; std::fill<SECItemStr * *,SECItemStr *>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $L187932
$L187933:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$L187932:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $L187931

; 1136 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $L187933
$L187931:

; 1137 : 	}

	pop	ebp
	ret	0
??$fill@PAPAUSECItemStr@@PAU1@@std@@YAXPAPAUSECItemStr@@0ABQAU1@@Z ENDP ; std::fill<SECItemStr * *,SECItemStr *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<SECItemStr * *,SECItemStr * *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z
_TEXT	SEGMENT
$T188998 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z PROC NEAR ; std::copy_backward<SECItemStr * *,SECItemStr * *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ; std::_Ptr_cat<SECItemStr>
	add	esp, 8
	mov	BYTE PTR $T188998[ebp], al
	mov	dl, BYTE PTR $T188998[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<SECItemStr * *,SECItemStr * *>
	add	esp, 16					; 00000010H

; 1070 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00@Z ENDP ; std::copy_backward<SECItemStr * *,SECItemStr * *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z PROC NEAR ; std::_Allocate<SECItemStr *>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@PAUSECItemStr@@@std@@YAPAPAUSECItemStr@@IPAPAU1@@Z ENDP ; std::_Allocate<SECItemStr *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z PROC NEAR ; std::_Ptr_cat<SECItemStr>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 221  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L189011
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
$L189011:
	DD	1
	DD	$L189010
$L189010:
	DD	-5					; fffffffbH
	DD	1
	DD	$L189009
$L189009:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ENDP ; std::_Ptr_cat<SECItemStr>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z ; std::fill_n<SECItemStr * *,unsigned int,SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<SECItemStr *,unsigned int,SECItemStr *>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 237  : 	fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z ; std::fill_n<SECItemStr * *,unsigned int,SECItemStr *>
	add	esp, 12					; 0000000cH

; 238  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Uninit_fill_n@PAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<SECItemStr *,unsigned int,SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 234  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@PAUSECItemStr@@V?$allocator@PAUSECItemStr@@@std@@@std@@YAXPAPAUSECItemStr@@0AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<SECItemStr *,std::allocator<SECItemStr *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<SECItemStr *,SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z
_TEXT	SEGMENT
$T189018 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<SECItemStr * *,SECItemStr * *,std::allocator<SECItemStr *> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@USECItemStr@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAUSECItemStr@@0@Z ; std::_Ptr_cat<SECItemStr>
	add	esp, 8
	mov	BYTE PTR $T189018[ebp], al
	mov	dl, BYTE PTR $T189018[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<SECItemStr *,SECItemStr *>
	add	esp, 20					; 00000014H

; 129  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAUSECItemStr@@PAPAU1@V?$allocator@PAUSECItemStr@@@std@@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@@Z ENDP ; std::_Uninitialized_copy<SECItemStr * *,SECItemStr * *,std::allocator<SECItemStr *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<SECItemStr * *,SECItemStr * *>, COMDAT

; 1058 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1062 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAUSECItemStr@@PAPAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<SECItemStr * *,SECItemStr * *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z PROC NEAR ; std::fill_n<SECItemStr * *,unsigned int,SECItemStr *>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $L188019
$L188020:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$L188019:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188018

; 1161 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $L188020
$L188018:

; 1162 : 	}

	pop	ebp
	ret	0
??$fill_n@PAPAUSECItemStr@@IPAU1@@std@@YAXPAPAUSECItemStr@@IABQAU1@@Z ENDP ; std::fill_n<SECItemStr * *,unsigned int,SECItemStr *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<SECItemStr *,SECItemStr *>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 106  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAUSECItemStr@@PAU1@@std@@YAPAPAUSECItemStr@@PAPAU1@00AAV?$allocator@PAUSECItemStr@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<SECItemStr *,SECItemStr *>
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T189045 DD	0ffffffffH
	DD	FLAT:$L189041
$T189043 DD	019930520H
	DD	01H
	DD	FLAT:$T189045
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L189041:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T189043
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
