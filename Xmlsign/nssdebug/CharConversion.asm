; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\CharConversion.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
_DATA	SEGMENT
_xmlLittleEndian DD 01H
_DATA	ENDS
CONST	SEGMENT
$SG177247 DB	'%d :', 00H
	ORG $+3
$SG177249 DB	'%s', 0aH, 00H
$SG177472 DB	0aH, '%10p ', 00H
	ORG $+1
$SG177476 DB	'%3x', 00H
$SG177480 DB	'   ', 00H
$SG177481 DB	' ', 00H
	ORG $+2
$SG177486 DB	'.', 00H
	ORG $+2
$SG177488 DB	'%c', 00H
	ORG $+1
$SG177493 DB	0aH, '   addr    ', 00H
	ORG $+3
$SG177497 DB	'%3x', 00H
$SG177498 DB	' | 7 bit ascii. |', 00H
	ORG $+2
$SG177505 DB	0aH, 'Start is %10p, Count is %5x, End is %10p', 00H
	ORG $+2
$SG177510 DB	0aH, '"Enter" to continue.', 0aH, 00H
	ORG $+1
$SG177533 DB	'pp != 0', 00H
	ORG $+4
$SG177534 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?FileEncoding@@YAXPAE@Z				; FileEncoding
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
;	COMDAT rtc$IMZ
; File c:\activex\xmlsign\charconversion.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?FileEncoding@@YAXPAE@Z PROC NEAR			; FileEncoding

; 17   : {

	push	ebp
	mov	ebp, esp

; 18   : 	if (xmlLittleEndian)

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177241

; 19   : 	{
; 20   : 		*ptr = 0xFF;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH

; 21   : 		*(ptr + 1) = 0xFE;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx+1], 254			; 000000feH

; 22   : 	}
; 23   : 	else

	jmp	SHORT $L177240
$L177241:

; 24   : 	{
; 25   : 		*ptr = 0xFE;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 254			; 000000feH

; 26   : 		*(ptr + 1) = 0xFF;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
$L177240:

; 27   : 	}
; 28   : }

	pop	ebp
	ret	0
?FileEncoding@@YAXPAE@Z ENDP				; FileEncoding
_TEXT	ENDS
PUBLIC	?PrintBstr@@YAXPAG@Z				; PrintBstr
PUBLIC	?HeapW2A@@YAPAEPAG@Z				; HeapW2A
EXTRN	_rFree:NEAR
EXTRN	__imp__SysStringLen@4:NEAR
EXTRN	_printf:NEAR
EXTRN	__RTC_CheckEsp:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_str$ = -8						; size = 4
_len$ = -4						; size = 4
_bstr$ = 8						; size = 4
?PrintBstr@@YAXPAG@Z PROC NEAR				; PrintBstr

; 31   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 32   :         int len = SysStringLen(bstr);

	mov	esi, esp
	mov	eax, DWORD PTR _bstr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _len$[ebp], eax

; 33   :         printf("%d :", len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG177247
	call	_printf
	add	esp, 8

; 34   :         unsigned char *str = HeapW2A(bstr);

	mov	edx, DWORD PTR _bstr$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax

; 35   :         printf("%s\n", str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET FLAT:$SG177249
	call	_printf
	add	esp, 8

; 36   :         zFree(str);

	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 37   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintBstr@@YAXPAG@Z ENDP				; PrintBstr
_TEXT	ENDS
PUBLIC	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z			; UTF16LEToUTF8
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF16LEToUTF8

; 59   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 60   :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 61   :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 62   :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 63   :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 64   :     unsigned short* inend;
; 65   :     unsigned int c, d, inlen;
; 66   :     unsigned char *tmp;
; 67   :     int bits;
; 68   : 
; 69   :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $L177790
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$L177790:
	cmp	eax, 1
	jne	SHORT $L177267

; 70   :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$L177267:

; 71   :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 72   :     inend = in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$L177269:

; 73   :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$L177270
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	add	eax, 5
	mov	ecx, DWORD PTR _outlen$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jge	$L177270

; 74   :         if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177271

; 75   : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 76   : 	} else {

	jmp	SHORT $L177272
$L177271:

; 77   : 	    tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 78   : 	    c = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 79   : 	    c = c | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 80   : 	    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$L177272:

; 81   : 	}
; 82   :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 55296				; 0000d800H
	jne	$L177275

; 83   : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jb	SHORT $L177276

; 84   : 		break;

	jmp	$L177270
$L177276:

; 85   : 	    }
; 86   : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177277

; 87   : 		d = *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 88   : 	    } else {

	jmp	SHORT $L177278
$L177277:

; 89   : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 90   : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 91   : 		d = d | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], ecx

; 92   : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$L177278:

; 93   : 	    }
; 94   :             if ((d & 0xFC00) == 0xDC00) {

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 56320				; 0000dc00H
	jne	SHORT $L177281

; 95   :                 c &= 0x03FF;

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], ecx

; 96   :                 c <<= 10;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], edx

; 97   :                 c |= d & 0x03FF;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 98   :                 c += 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 99   :             }
; 100  :             else {

	jmp	SHORT $L177275
$L177281:

; 101  : 		*outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 102  : 		*inlenb = processed - inb;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _inb$[ebp]
	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [edx], ecx

; 103  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L177255
$L177275:

; 104  : 	    }
; 105  :         }
; 106  : 
; 107  : 	/* assertion: c is a single UTF-4 value */
; 108  :         if (out >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L177283

; 109  : 	    break;

	jmp	$L177270
$L177283:

; 110  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L177284
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH

; 111  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	jmp	$L177285
$L177284:
	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $L177286
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 0

; 112  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	jmp	SHORT $L177285
$L177286:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L177288
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 6

; 113  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	jmp	SHORT $L177285
$L177288:
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$L177285:

; 114  :  
; 115  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $L177290
$L177291:
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 6
	mov	DWORD PTR _bits$[ebp], ecx
$L177290:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $L177292

; 116  :             if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $L177293

; 117  : 	        break;

	jmp	SHORT $L177292
$L177293:

; 118  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	eax, cl
	and	eax, 63					; 0000003fH
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 119  :         }

	jmp	SHORT $L177291
$L177292:

; 120  : 	processed = (const unsigned char*) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 121  :     }

	jmp	$L177269
$L177270:

; 122  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 123  :     *inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 124  :     return(0);

	xor	eax, eax
$L177255:

; 125  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z ENDP			; UTF16LEToUTF8
_TEXT	ENDS
PUBLIC	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z			; UTF8ToUTF16LE
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv131 = -52						; size = 4
_tmp2$ = -48						; size = 2
_tmp1$ = -44						; size = 2
_tmp$ = -40						; size = 4
_trailing$ = -36					; size = 4
_d$ = -32						; size = 4
_c$ = -28						; size = 4
_inend$ = -24						; size = 4
_outend$ = -20						; size = 4
_outstart$ = -16					; size = 4
_instart$ = -12						; size = 4
_processed$ = -8					; size = 4
_out$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF8ToUTF16LE

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 143  :     unsigned short* out = (unsigned short*) outb;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 144  :     const unsigned char* processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 145  :     const unsigned char *const instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 146  :     unsigned short* outstart= out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 147  :     unsigned short* outend;
; 148  :     const unsigned char* inend= in+*inlen;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _inend$[ebp], edx

; 149  :     unsigned int c, d;
; 150  :     int trailing;
; 151  :     unsigned char *tmp;
; 152  :     unsigned short tmp1, tmp2;
; 153  : 
; 154  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $L177314

; 155  :         /*
; 156  : 	 * initialization, add the Byte Order Mark
; 157  : 	 */
; 158  :         if (*outlen >= 2) {

	mov	eax, DWORD PTR _outlen$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $L177315

; 159  : 	    outb[0] = 0xFF;

	mov	ecx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH

; 160  : 	    outb[1] = 0xFE;

	mov	edx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [edx+1], 254			; 000000feH

; 161  : 	    *outlen = 2;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 2

; 162  : 	    *inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 163  : 	    return(2);

	mov	eax, 2
	jmp	$L177300
$L177315:

; 164  : 	}
; 165  : 	*outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 166  : 	*inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 167  : 	return(0);

	xor	eax, eax
	jmp	$L177300
$L177314:

; 168  :     }
; 169  :     outend = out + (*outlen / 2);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _outend$[ebp], eax
$L177317:

; 170  :     while (in < inend) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	$L177318

; 171  :       d= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 172  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $L177319
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 0

; 173  :       else if (d < 0xC0) {

	jmp	$L177320
$L177319:
	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $L177321

; 174  :           /* trailing byte in leading position */
; 175  : 	  *outlen = (out - outstart) * 2;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	sar	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 176  : 	  *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 177  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L177300
$L177321:

; 178  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $L177323
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 1

; 179  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	jmp	SHORT $L177320
$L177323:
	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $L177325
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 2

; 180  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	jmp	SHORT $L177320
$L177325:
	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $L177327
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 7
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 3

; 181  :       else {

	jmp	SHORT $L177320
$L177327:

; 182  :         /* no chance for this in UTF-16 */
; 183  : 	*outlen = (out - outstart) * 2;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	sar	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 184  : 	*inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 185  : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L177300
$L177320:

; 186  :       }
; 187  : 
; 188  :       if (inend - in < trailing) {

	mov	edx, DWORD PTR _inend$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _trailing$[ebp]
	jge	SHORT $L177329

; 189  :           break;

	jmp	$L177318
$L177329:

; 190  :       } 
; 191  : 
; 192  :       for ( ; trailing; trailing--) {

	jmp	SHORT $L177330
$L177331:
	mov	eax, DWORD PTR _trailing$[ebp]
	sub	eax, 1
	mov	DWORD PTR _trailing$[ebp], eax
$L177330:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $L177332

; 193  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	SHORT $L177334
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
	cmp	ecx, 128				; 00000080H
	je	SHORT $L177792
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $L177793
$L177792:
	mov	DWORD PTR tv131[ebp], 0
$L177793:
	cmp	DWORD PTR tv131[ebp], 0
	je	SHORT $L177333
$L177334:

; 194  : 	      break;

	jmp	SHORT $L177332
$L177333:

; 195  :           c <<= 6;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 6
	mov	DWORD PTR _c$[ebp], eax

; 196  :           c |= d & 0x3F;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 197  :       }

	jmp	SHORT $L177331
$L177332:

; 198  : 
; 199  :       /* assertion: c is a single UTF-4 value */
; 200  :         if (c < 0x10000) {

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L177335

; 201  :             if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $L177336

; 202  : 	        break;

	jmp	$L177318
$L177336:

; 203  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177337

; 204  : 		*out++ = c;

	mov	eax, DWORD PTR _out$[ebp]
	mov	cx, WORD PTR _c$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 205  : 	    } else {

	jmp	SHORT $L177338
$L177337:

; 206  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 207  : 		*tmp = c ;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl

; 208  : 		*(tmp + 1) = c >> 8 ;

	mov	eax, DWORD PTR _c$[ebp]
	shr	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx+1], al

; 209  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$L177338:

; 210  : 	    }
; 211  :         }
; 212  :         else if (c < 0x110000) {

	jmp	$L177340
$L177335:
	cmp	DWORD PTR _c$[ebp], 1114112		; 00110000H
	jae	$L177341

; 213  :             if (out+1 >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L177342

; 214  : 	        break;

	jmp	$L177318
$L177342:

; 215  :             c -= 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 216  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177343

; 217  : 		*out++ = 0xD800 | (c >> 10);

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 10					; 0000000aH
	or	edx, 55296				; 0000d800H
	mov	eax, DWORD PTR _out$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 218  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	or	edx, 56320				; 0000dc00H
	mov	eax, DWORD PTR _out$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 219  : 	    } else {

	jmp	SHORT $L177344
$L177343:

; 220  : 		tmp1 = 0xD800 | (c >> 10);

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 10					; 0000000aH
	or	edx, 55296				; 0000d800H
	mov	WORD PTR _tmp1$[ebp], dx

; 221  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 222  : 		*tmp = (unsigned char) tmp1;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _tmp1$[ebp]
	mov	BYTE PTR [ecx], dl

; 223  : 		*(tmp + 1) = tmp1 >> 8;

	movzx	eax, WORD PTR _tmp1$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx+1], al

; 224  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 225  : 
; 226  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, 56320				; 0000dc00H
	mov	WORD PTR _tmp2$[ebp], ax

; 227  : 		tmp = (unsigned char *) out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], ecx

; 228  : 		*tmp  = (unsigned char) tmp2;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	al, BYTE PTR _tmp2$[ebp]
	mov	BYTE PTR [edx], al

; 229  : 		*(tmp + 1) = tmp2 >> 8;

	movzx	ecx, WORD PTR _tmp2$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [edx+1], cl

; 230  : 		out++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax
$L177344:

; 231  : 	    }
; 232  :         }
; 233  :         else

	jmp	SHORT $L177340
$L177341:

; 234  : 	    break;

	jmp	SHORT $L177318
$L177340:

; 235  : 	processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 236  :     }

	jmp	$L177317
$L177318:

; 237  :     *outlen = (out - outstart) * 2;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	sar	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 238  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 239  :     return(0);

	xor	eax, eax
$L177300:

; 240  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z ENDP			; UTF8ToUTF16LE
_TEXT	ENDS
EXTRN	_malloc:NEAR
EXTRN	__imp__SysStringByteLen@4:NEAR
EXTRN	_memset:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_utf8CharStr$ = -28					; size = 4
_utf8CharStrLen$ = -20					; size = 4
_bstrByteSize$ = -8					; size = 4
_bstrStr$ = 8						; size = 4
?HeapW2A@@YAPAEPAG@Z PROC NEAR				; HeapW2A

; 452  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 453  : #ifdef LOGGING
; 454  : 	char buffer[BUFSIZ];
; 455  : 	memset(buffer, 0, BUFSIZ);
; 456  : #endif
; 457  : 	EnterLog;
; 458  : 	int bstrByteSize = (int)SysStringByteLen(bstrStr);

	mov	esi, esp
	mov	eax, DWORD PTR _bstrStr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrByteSize$[ebp], eax

; 459  : #ifdef LOGGING
; 460  : 	sprintf((char *)buffer, "bstrByteSize = %d", bstrByteSize);
; 461  : 	DebugLog((const char *)buffer);
; 462  : #endif
; 463  : 	if (bstrByteSize==0) {

	cmp	DWORD PTR _bstrByteSize$[ebp], 0
	jne	SHORT $L177455

; 464  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L177452
$L177455:

; 465  : 	}
; 466  : 	int utf8CharStrLen = bstrByteSize * 2;

	mov	ecx, DWORD PTR _bstrByteSize$[ebp]
	shl	ecx, 1
	mov	DWORD PTR _utf8CharStrLen$[ebp], ecx

; 467  : 	if (utf8CharStrLen < 6)

	cmp	DWORD PTR _utf8CharStrLen$[ebp], 6
	jge	SHORT $L177457

; 468  : 		utf8CharStrLen = 6;

	mov	DWORD PTR _utf8CharStrLen$[ebp], 6
$L177457:

; 469  : 	unsigned char *utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _utf8CharStr$[ebp], eax

; 470  : 	memset(utf8CharStr, 0, utf8CharStrLen);

	mov	eax, DWORD PTR _utf8CharStrLen$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _utf8CharStr$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 471  : 	if (xmlLittleEndian)

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177460

; 472  : 		UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)bstrStr, &bstrByteSize);

	lea	edx, DWORD PTR _bstrByteSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$[ebp]
	push	edx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 473  : 	else

	jmp	SHORT $L177462
$L177460:

; 474  : 		UTF16BEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)bstrStr, &bstrByteSize);

	lea	eax, DWORD PTR _bstrByteSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bstrStr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _utf8CharStrLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _utf8CharStr$[ebp]
	push	eax
	call	?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16BEToUTF8
	add	esp, 16					; 00000010H
$L177462:

; 475  : 	ExitLog;
; 476  : 	return utf8CharStr;

	mov	eax, DWORD PTR _utf8CharStr$[ebp]
$L177452:

; 477  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L177798
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 28					; 0000001cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L177798:
	DD	2
	DD	$L177797
$L177797:
	DD	-8					; fffffff8H
	DD	4
	DD	$L177795
	DD	-20					; ffffffecH
	DD	4
	DD	$L177796
$L177796:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L177795:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
?HeapW2A@@YAPAEPAG@Z ENDP				; HeapW2A
; Function compile flags: /Odt /RTCsu
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF16BEToUTF8

; 262  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 263  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 264  :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 265  :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 266  :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 267  :     unsigned short* inend;
; 268  :     unsigned int c, d, inlen;
; 269  :     unsigned char *tmp;
; 270  :     int bits;
; 271  : 
; 272  :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $L177801
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$L177801:
	cmp	eax, 1
	jne	SHORT $L177367

; 273  :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$L177367:

; 274  :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 275  :     inend= in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$L177369:

; 276  :     while (in < inend) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$L177370

; 277  : 	if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177371

; 278  : 	    tmp = (unsigned char *) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 279  : 	    c = *tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax

; 280  : 	    c = c << 8;

	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 8
	mov	DWORD PTR _c$[ebp], ecx

; 281  : 	    c = c | (unsigned int) *tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 282  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 283  : 	} else {

	jmp	SHORT $L177374
$L177371:

; 284  : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx
$L177374:

; 285  : 	} 
; 286  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 64512				; 0000fc00H
	cmp	edx, 55296				; 0000d800H
	jne	$L177375

; 287  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jb	SHORT $L177376

; 288  : 		*outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 289  : 		*inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 290  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L177355
$L177376:

; 291  : 	    }
; 292  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L177377

; 293  : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 294  : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 295  : 		d = d << 8;

	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 8
	mov	DWORD PTR _d$[ebp], eax

; 296  : 		d = d | (unsigned int) *tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 297  : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax

; 298  : 	    } else {

	jmp	SHORT $L177380
$L177377:

; 299  : 		d= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax
$L177380:

; 300  : 	    }
; 301  :             if ((d & 0xFC00) == 0xDC00) {

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 64512				; 0000fc00H
	cmp	ecx, 56320				; 0000dc00H
	jne	SHORT $L177381

; 302  :                 c &= 0x03FF;

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], edx

; 303  :                 c <<= 10;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], eax

; 304  :                 c |= d & 0x03FF;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 1023				; 000003ffH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 305  :                 c += 0x10000;

	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], edx

; 306  :             }
; 307  :             else {

	jmp	SHORT $L177375
$L177381:

; 308  : 		*outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 309  : 		*inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 310  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L177355
$L177375:

; 311  : 	    }
; 312  :         }
; 313  : 
; 314  : 	/* assertion: c is a single UTF-4 value */
; 315  :         if (out >= outend) 

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $L177383

; 316  : 	    break;

	jmp	$L177370
$L177383:

; 317  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L177384
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH

; 318  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	jmp	$L177385
$L177384:
	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $L177386
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 6
	and	edx, 31					; 0000001fH
	or	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 0

; 319  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	jmp	SHORT $L177385
$L177386:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L177388
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 12					; 0000000cH
	and	edx, 15					; 0000000fH
	or	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 6

; 320  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	jmp	SHORT $L177385
$L177388:
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	and	edx, 7
	or	edx, 240				; 000000f0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$L177385:

; 321  :  
; 322  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $L177390
$L177391:
	mov	edx, DWORD PTR _bits$[ebp]
	sub	edx, 6
	mov	DWORD PTR _bits$[ebp], edx
$L177390:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $L177392

; 323  :             if (out >= outend) 

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L177393

; 324  : 	        break;

	jmp	SHORT $L177392
$L177393:

; 325  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	edx, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	edx, cl
	and	edx, 63					; 0000003fH
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 326  :         }

	jmp	SHORT $L177391
$L177392:

; 327  : 	processed = (const unsigned char*) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], edx

; 328  :     }

	jmp	$L177369
$L177370:

; 329  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 330  :     *inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 331  :     return(0);

	xor	eax, eax
$L177355:

; 332  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z ENDP			; UTF16BEToUTF8
_TEXT	ENDS
PUBLIC	?ldump@@YAXPADI@Z				; ldump
EXTRN	_isprint:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv66 = -12						; size = 4
_c$177471 = -5						; size = 1
_i$177470 = -4						; size = 4
_ptr$ = 8						; size = 4
_len$ = 12						; size = 4
?ldump@@YAXPADI@Z PROC NEAR				; ldump

; 487  : ldump(char *ptr, unsigned int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 488  :   if ( len ) {

	cmp	DWORD PTR _len$[ebp], 0
	je	$L177468

; 489  :     int  i;
; 490  :     char c;
; 491  :     len=MIN(16,len);

	cmp	DWORD PTR _len$[ebp], 16		; 00000010H
	jbe	SHORT $L177803
	mov	DWORD PTR tv66[ebp], 16			; 00000010H
	jmp	SHORT $L177804
$L177803:
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv66[ebp], eax
$L177804:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 492  :     /*    printf("\nStart is %10x, Count is %5x, End is %10x",ptr,len,ptr+len); */
; 493  :     printf("\n%10p ",ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	push	OFFSET FLAT:$SG177472
	call	_printf
	add	esp, 8

; 494  : 
; 495  :     for( i = 0 ; i < len ; i++ )  /* Print the hex dump for len

	mov	DWORD PTR _i$177470[ebp], 0
	jmp	SHORT $L177473
$L177474:
	mov	eax, DWORD PTR _i$177470[ebp]
	add	eax, 1
	mov	DWORD PTR _i$177470[ebp], eax
$L177473:
	mov	ecx, DWORD PTR _i$177470[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jae	SHORT $L177475

; 496  :                                      chars. */
; 497  :       printf("%3x",(*(ptr+i)&0xff));

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _i$177470[ebp]
	movsx	eax, BYTE PTR [edx]
	and	eax, 255				; 000000ffH
	push	eax
	push	OFFSET FLAT:$SG177476
	call	_printf
	add	esp, 8
	jmp	SHORT $L177474
$L177475:

; 498  : 
; 499  :     for( i = len ; i < 16 ; i++ ) /* Pad out the dump field to the

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$177470[ebp], ecx
	jmp	SHORT $L177477
$L177478:
	mov	edx, DWORD PTR _i$177470[ebp]
	add	edx, 1
	mov	DWORD PTR _i$177470[ebp], edx
$L177477:
	cmp	DWORD PTR _i$177470[ebp], 16		; 00000010H
	jge	SHORT $L177479

; 500  :                                      ASCII field. */
; 501  :       printf("   ");

	push	OFFSET FLAT:$SG177480
	call	_printf
	add	esp, 4
	jmp	SHORT $L177478
$L177479:

; 502  : 
; 503  :     printf(" ");

	push	OFFSET FLAT:$SG177481
	call	_printf
	add	esp, 4

; 504  :     for( i = 0 ; i < len ; i++ ) { /* Now print the ASCII field. */

	mov	DWORD PTR _i$177470[ebp], 0
	jmp	SHORT $L177482
$L177483:
	mov	eax, DWORD PTR _i$177470[ebp]
	add	eax, 1
	mov	DWORD PTR _i$177470[ebp], eax
$L177482:
	mov	ecx, DWORD PTR _i$177470[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jae	SHORT $L177468

; 505  :       c=0x7f&(*(ptr+i));      /* Mask out bit 7 */

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _i$177470[ebp]
	movsx	eax, BYTE PTR [edx]
	and	eax, 127				; 0000007fH
	mov	BYTE PTR _c$177471[ebp], al

; 506  : 
; 507  :       if (!(isprint(c))) {    /* If not printable */

	movsx	ecx, BYTE PTR _c$177471[ebp]
	push	ecx
	call	_isprint
	add	esp, 4
	test	eax, eax
	jne	SHORT $L177485

; 508  :         printf(".");          /* print a dot */

	push	OFFSET FLAT:$SG177486
	call	_printf
	add	esp, 4

; 509  :       } else {

	jmp	SHORT $L177487
$L177485:

; 510  :         printf("%c",c);  }    /* else display it */

	movsx	edx, BYTE PTR _c$177471[ebp]
	push	edx
	push	OFFSET FLAT:$SG177488
	call	_printf
	add	esp, 8
$L177487:

; 511  :     }

	jmp	SHORT $L177483
$L177468:

; 512  :   }
; 513  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ldump@@YAXPADI@Z ENDP					; ldump
_TEXT	ENDS
PUBLIC	?head@@YAXJ@Z					; head
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
_st$ = 8						; size = 4
?head@@YAXJ@Z PROC NEAR					; head

; 520  : head(long st) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 521  :   int i;
; 522  :   printf("\n   addr    ");

	push	OFFSET FLAT:$SG177493
	call	_printf
	add	esp, 4

; 523  :   for ( i = st&0xf ; i < (st&0xf)+0x10 ; i++ )

	mov	eax, DWORD PTR _st$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L177494
$L177495:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L177494:
	mov	edx, DWORD PTR _st$[ebp]
	and	edx, 15					; 0000000fH
	add	edx, 16					; 00000010H
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $L177496

; 524  :     printf("%3x",(i&0x0f));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 15					; 0000000fH
	push	eax
	push	OFFSET FLAT:$SG177497
	call	_printf
	add	esp, 8
	jmp	SHORT $L177495
$L177496:

; 525  :   printf(" | 7 bit ascii. |");

	push	OFFSET FLAT:$SG177498
	call	_printf
	add	esp, 4

; 526  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?head@@YAXJ@Z ENDP					; head
_TEXT	ENDS
PUBLIC	?dump@@YAXPADI@Z				; dump
EXTRN	_getchar:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv77 = -8						; size = 4
_i$177504 = -4						; size = 4
_ptr$ = 8						; size = 4
_ct$ = 12						; size = 4
?dump@@YAXPADI@Z PROC NEAR				; dump

; 532  : dump(char *ptr, unsigned int ct) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 533  :   if ( ct ) {

	cmp	DWORD PTR _ct$[ebp], 0
	je	$L177502

; 534  :     int i;
; 535  : 
; 536  :     /*  preliminary info for user's benefit. */
; 537  :     printf("\nStart is %10p, Count is %5x, End is %10p",
; 538  :            ptr, ct, ptr + ct);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _ct$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ct$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	push	OFFSET FLAT:$SG177505
	call	_printf
	add	esp, 16					; 00000010H

; 539  :     head((long)ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	?head@@YAXJ@Z				; head
	add	esp, 4

; 540  :     for ( i = 0 ; i <= ct ; i = i+16 , ptr = ptr+16 )

	mov	DWORD PTR _i$177504[ebp], 0
	jmp	SHORT $L177507
$L177508:
	mov	ecx, DWORD PTR _i$177504[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _i$177504[ebp], ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], edx
$L177507:
	mov	eax, DWORD PTR _i$177504[ebp]
	cmp	eax, DWORD PTR _ct$[ebp]
	ja	SHORT $L177509

; 541  :       ldump(ptr,(MIN(16,(ct-i))));

	mov	ecx, DWORD PTR _ct$[ebp]
	sub	ecx, DWORD PTR _i$177504[ebp]
	cmp	ecx, 16					; 00000010H
	jbe	SHORT $L177807
	mov	DWORD PTR tv77[ebp], 16			; 00000010H
	jmp	SHORT $L177808
$L177807:
	mov	edx, DWORD PTR _ct$[ebp]
	sub	edx, DWORD PTR _i$177504[ebp]
	mov	DWORD PTR tv77[ebp], edx
$L177808:
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	?ldump@@YAXPADI@Z			; ldump
	add	esp, 8
	jmp	SHORT $L177508
$L177509:

; 542  : 
; 543  :     printf("\n\"Enter\" to continue.\n"); /* Give him/her/it a chance

	push	OFFSET FLAT:$SG177510
	call	_printf
	add	esp, 4

; 544  :                                              to examine it. */
; 545  :     getchar ();

	call	_getchar
$L177502:

; 546  :   }
; 547  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?dump@@YAXPADI@Z ENDP					; dump
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T177831 DD	0ffffffffH
	DD	FLAT:$L177824
$T177828 DD	019930520H
	DD	01H
	DD	FLAT:$T177831
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L177824:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T177828
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
