; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\CharConversion.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
_DATA	SEGMENT
_xmlLittleEndian DD 01H
_DATA	ENDS
CONST	SEGMENT
$SG161175 DB	'%d :', 00H
	ORG $+3
$SG161177 DB	'%s', 0aH, 00H
$SG161178 DB	'PrintBstr', 00H
	ORG $+2
$SG161179 DB	'.\CharConversion.cpp', 00H
	ORG $+3
$SG161384 DB	'Debug Log', 00H
	ORG $+2
$SG161385 DB	'HeapW2A', 00H
$SG161386 DB	'.\CharConversion.cpp', 00H
	ORG $+3
$SG161390 DB	'bstrByteSize = %d', 00H
	ORG $+2
$SG161392 DB	'Debug Log', 00H
	ORG $+2
$SG161393 DB	'HeapW2A', 00H
$SG161394 DB	'.\CharConversion.cpp', 00H
	ORG $+3
$SG161400 DB	'HeapW2A', 00H
$SG161401 DB	'.\CharConversion.cpp', 00H
	ORG $+3
$SG161406 DB	'Debug Log', 00H
	ORG $+2
$SG161407 DB	'HeapW2A', 00H
$SG161408 DB	'.\CharConversion.cpp', 00H
	ORG $+3
$SG161417 DB	0aH, '%10p ', 00H
	ORG $+1
$SG161421 DB	'%3x', 00H
$SG161425 DB	'   ', 00H
$SG161426 DB	' ', 00H
	ORG $+2
$SG161431 DB	'.', 00H
	ORG $+2
$SG161433 DB	'%c', 00H
	ORG $+1
$SG161438 DB	0aH, '   addr    ', 00H
	ORG $+3
$SG161442 DB	'%3x', 00H
$SG161443 DB	' | 7 bit ascii. |', 00H
	ORG $+2
$SG161450 DB	0aH, 'Start is %10p, Count is %5x, End is %10p', 00H
	ORG $+2
$SG161455 DB	0aH, '"Enter" to continue.', 0aH, 00H
	ORG $+1
$SG161478 DB	'pp != 0', 00H
$SG161479 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?FileEncoding@@YAXPAE@Z				; FileEncoding
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
;	COMDAT rtc$IMZ
; File c:\activex\xmlsign\charconversion.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?FileEncoding@@YAXPAE@Z PROC NEAR			; FileEncoding

; 21   : {

	push	ebp
	mov	ebp, esp

; 22   : 	if (xmlLittleEndian)

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161169

; 23   : 	{
; 24   : 		*ptr = 0xFF;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax], 255			; 000000ffH

; 25   : 		*(ptr + 1) = 0xFE;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [ecx+1], 254			; 000000feH

; 26   : 	}
; 27   : 	else

	jmp	SHORT $L161168
$L161169:

; 28   : 	{
; 29   : 		*ptr = 0xFE;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [edx], 254			; 000000feH

; 30   : 		*(ptr + 1) = 0xFF;

	mov	eax, DWORD PTR _ptr$[ebp]
	mov	BYTE PTR [eax+1], 255			; 000000ffH
$L161168:

; 31   : 	}
; 32   : }

	pop	ebp
	ret	0
?FileEncoding@@YAXPAE@Z ENDP				; FileEncoding
_TEXT	ENDS
PUBLIC	?HeapW2A@@YAPAEPAG@Z				; HeapW2A
PUBLIC	?PrintBstr@@YAXPAG@Z				; PrintBstr
EXTRN	__imp__SysStringLen@4:NEAR
EXTRN	_myFree:NEAR
EXTRN	_printf:NEAR
EXTRN	__RTC_CheckEsp:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_str$ = -8						; size = 4
_len$ = -4						; size = 4
_bstr$ = 8						; size = 4
?PrintBstr@@YAXPAG@Z PROC NEAR				; PrintBstr

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 36   :         int len = SysStringLen(bstr);

	mov	esi, esp
	mov	eax, DWORD PTR _bstr$[ebp]
	push	eax
	call	DWORD PTR __imp__SysStringLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _len$[ebp], eax

; 37   :         printf("%d :", len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG161175
	call	_printf
	add	esp, 8

; 38   :         unsigned char *str = HeapW2A(bstr);

	mov	edx, DWORD PTR _bstr$[ebp]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _str$[ebp], eax

; 39   :         printf("%s\n", str);

	mov	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET FLAT:$SG161177
	call	_printf
	add	esp, 8

; 40   :         zFree(str);

	push	OFFSET FLAT:$SG161178
	push	40					; 00000028H
	push	OFFSET FLAT:$SG161179
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 41   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?PrintBstr@@YAXPAG@Z ENDP				; PrintBstr
_TEXT	ENDS
PUBLIC	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z			; UTF16LEToUTF8
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF16LEToUTF8

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 64   :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 65   :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 66   :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 67   :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 68   :     unsigned short* inend;
; 69   :     unsigned int c, d, inlen;
; 70   :     unsigned char *tmp;
; 71   :     int bits;
; 72   : 
; 73   :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $L161735
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$L161735:
	cmp	eax, 1
	jne	SHORT $L161197

; 74   :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$L161197:

; 75   :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 76   :     inend = in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$L161199:

; 77   :     while ((in < inend) && (out - outstart + 5 < *outlen)) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$L161200
	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	add	eax, 5
	mov	ecx, DWORD PTR _outlen$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jge	$L161200

; 78   :         if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161201

; 79   : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 80   : 	} else {

	jmp	SHORT $L161202
$L161201:

; 81   : 	    tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 82   : 	    c = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _c$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 83   : 	    c = c | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 84   : 	    in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$L161202:

; 85   : 	}
; 86   :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 55296				; 0000d800H
	jne	$L161205

; 87   : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jb	SHORT $L161206

; 88   : 		break;

	jmp	$L161200
$L161206:

; 89   : 	    }
; 90   : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161207

; 91   : 		d = *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 92   : 	    } else {

	jmp	SHORT $L161208
$L161207:

; 93   : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 94   : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 95   : 		d = d | (((unsigned int)*tmp) << 8);

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	shl	ecx, 8
	or	ecx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], ecx

; 96   : 		in++;

	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 2
	mov	DWORD PTR _in$[ebp], edx
$L161208:

; 97   : 	    }
; 98   :             if ((d & 0xFC00) == 0xDC00) {

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 64512				; 0000fc00H
	cmp	eax, 56320				; 0000dc00H
	jne	SHORT $L161211

; 99   :                 c &= 0x03FF;

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], ecx

; 100  :                 c <<= 10;

	mov	edx, DWORD PTR _c$[ebp]
	shl	edx, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], edx

; 101  :                 c |= d & 0x03FF;

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 102  :                 c += 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	add	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 103  :             }
; 104  :             else {

	jmp	SHORT $L161205
$L161211:

; 105  : 		*outlen = out - outstart;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 106  : 		*inlenb = processed - inb;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _inb$[ebp]
	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [edx], ecx

; 107  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161185
$L161205:

; 108  : 	    }
; 109  :         }
; 110  : 
; 111  : 	/* assertion: c is a single UTF-4 value */
; 112  :         if (out >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L161213

; 113  : 	    break;

	jmp	$L161200
$L161213:

; 114  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L161214
	mov	ecx, DWORD PTR _out$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH

; 115  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	jmp	$L161215
$L161214:
	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $L161216
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 6
	and	ecx, 31					; 0000001fH
	or	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 0

; 116  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	jmp	SHORT $L161215
$L161216:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L161218
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 12					; 0000000cH
	and	ecx, 15					; 0000000fH
	or	ecx, 224				; 000000e0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 6

; 117  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	jmp	SHORT $L161215
$L161218:
	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 18					; 00000012H
	and	ecx, 7
	or	ecx, 240				; 000000f0H
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 1
	mov	DWORD PTR _out$[ebp], eax
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$L161215:

; 118  :  
; 119  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $L161220
$L161221:
	mov	ecx, DWORD PTR _bits$[ebp]
	sub	ecx, 6
	mov	DWORD PTR _bits$[ebp], ecx
$L161220:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $L161222

; 120  :             if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $L161223

; 121  : 	        break;

	jmp	SHORT $L161222
$L161223:

; 122  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	eax, cl
	and	eax, 63					; 0000003fH
	or	eax, 128				; 00000080H
	mov	ecx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 1
	mov	DWORD PTR _out$[ebp], edx

; 123  :         }

	jmp	SHORT $L161221
$L161222:

; 124  : 	processed = (const unsigned char*) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], eax

; 125  :     }

	jmp	$L161199
$L161200:

; 126  :     *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 127  :     *inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 128  :     return(0);

	xor	eax, eax
$L161185:

; 129  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z ENDP			; UTF16LEToUTF8
_TEXT	ENDS
PUBLIC	?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z			; UTF8ToUTF16LE
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv131 = -52						; size = 4
_tmp2$ = -48						; size = 2
_tmp1$ = -44						; size = 2
_tmp$ = -40						; size = 4
_trailing$ = -36					; size = 4
_d$ = -32						; size = 4
_c$ = -28						; size = 4
_inend$ = -24						; size = 4
_outend$ = -20						; size = 4
_outstart$ = -16					; size = 4
_instart$ = -12						; size = 4
_processed$ = -8					; size = 4
_out$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF8ToUTF16LE

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 147  :     unsigned short* out = (unsigned short*) outb;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 148  :     const unsigned char* processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 149  :     const unsigned char *const instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 150  :     unsigned short* outstart= out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 151  :     unsigned short* outend;
; 152  :     const unsigned char* inend= in+*inlen;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _inend$[ebp], edx

; 153  :     unsigned int c, d;
; 154  :     int trailing;
; 155  :     unsigned char *tmp;
; 156  :     unsigned short tmp1, tmp2;
; 157  : 
; 158  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $L161244

; 159  :         /*
; 160  : 	 * initialization, add the Byte Order Mark
; 161  : 	 */
; 162  :         if (*outlen >= 2) {

	mov	eax, DWORD PTR _outlen$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $L161245

; 163  : 	    outb[0] = 0xFF;

	mov	ecx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [ecx], 255			; 000000ffH

; 164  : 	    outb[1] = 0xFE;

	mov	edx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [edx+1], 254			; 000000feH

; 165  : 	    *outlen = 2;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 2

; 166  : 	    *inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 167  : 	    return(2);

	mov	eax, 2
	jmp	$L161230
$L161245:

; 168  : 	}
; 169  : 	*outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 170  : 	*inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 171  : 	return(0);

	xor	eax, eax
	jmp	$L161230
$L161244:

; 172  :     }
; 173  :     outend = out + (*outlen / 2);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _outend$[ebp], eax
$L161247:

; 174  :     while (in < inend) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	$L161248

; 175  :       d= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 176  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $L161249
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 0

; 177  :       else if (d < 0xC0) {

	jmp	$L161250
$L161249:
	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $L161251

; 178  :           /* trailing byte in leading position */
; 179  : 	  *outlen = (out - outstart) * 2;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	sar	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 180  : 	  *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 181  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161230
$L161251:

; 182  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $L161253
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 1

; 183  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	jmp	SHORT $L161250
$L161253:
	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $L161255
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 2

; 184  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	jmp	SHORT $L161250
$L161255:
	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $L161257
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 7
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 3

; 185  :       else {

	jmp	SHORT $L161250
$L161257:

; 186  :         /* no chance for this in UTF-16 */
; 187  : 	*outlen = (out - outstart) * 2;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	sar	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 188  : 	*inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 189  : 	return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161230
$L161250:

; 190  :       }
; 191  : 
; 192  :       if (inend - in < trailing) {

	mov	edx, DWORD PTR _inend$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _trailing$[ebp]
	jge	SHORT $L161259

; 193  :           break;

	jmp	$L161248
$L161259:

; 194  :       } 
; 195  : 
; 196  :       for ( ; trailing; trailing--) {

	jmp	SHORT $L161260
$L161261:
	mov	eax, DWORD PTR _trailing$[ebp]
	sub	eax, 1
	mov	DWORD PTR _trailing$[ebp], eax
$L161260:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $L161262

; 197  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	SHORT $L161264
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
	cmp	ecx, 128				; 00000080H
	je	SHORT $L161737
	mov	DWORD PTR tv131[ebp], 1
	jmp	SHORT $L161738
$L161737:
	mov	DWORD PTR tv131[ebp], 0
$L161738:
	cmp	DWORD PTR tv131[ebp], 0
	je	SHORT $L161263
$L161264:

; 198  : 	      break;

	jmp	SHORT $L161262
$L161263:

; 199  :           c <<= 6;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 6
	mov	DWORD PTR _c$[ebp], eax

; 200  :           c |= d & 0x3F;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 201  :       }

	jmp	SHORT $L161261
$L161262:

; 202  : 
; 203  :       /* assertion: c is a single UTF-4 value */
; 204  :         if (c < 0x10000) {

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L161265

; 205  :             if (out >= outend)

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $L161266

; 206  : 	        break;

	jmp	$L161248
$L161266:

; 207  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161267

; 208  : 		*out++ = c;

	mov	eax, DWORD PTR _out$[ebp]
	mov	cx, WORD PTR _c$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 209  : 	    } else {

	jmp	SHORT $L161268
$L161267:

; 210  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 211  : 		*tmp = c ;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [ecx], dl

; 212  : 		*(tmp + 1) = c >> 8 ;

	mov	eax, DWORD PTR _c$[ebp]
	shr	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx+1], al

; 213  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$L161268:

; 214  : 	    }
; 215  :         }
; 216  :         else if (c < 0x110000) {

	jmp	$L161270
$L161265:
	cmp	DWORD PTR _c$[ebp], 1114112		; 00110000H
	jae	$L161271

; 217  :             if (out+1 >= outend)

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L161272

; 218  : 	        break;

	jmp	$L161248
$L161272:

; 219  :             c -= 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 220  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161273

; 221  : 		*out++ = 0xD800 | (c >> 10);

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 10					; 0000000aH
	or	edx, 55296				; 0000d800H
	mov	eax, DWORD PTR _out$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 222  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	or	edx, 56320				; 0000dc00H
	mov	eax, DWORD PTR _out$[ebp]
	mov	WORD PTR [eax], dx
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 2
	mov	DWORD PTR _out$[ebp], ecx

; 223  : 	    } else {

	jmp	SHORT $L161274
$L161273:

; 224  : 		tmp1 = 0xD800 | (c >> 10);

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 10					; 0000000aH
	or	edx, 55296				; 0000d800H
	mov	WORD PTR _tmp1$[ebp], dx

; 225  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 226  : 		*tmp = (unsigned char) tmp1;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _tmp1$[ebp]
	mov	BYTE PTR [ecx], dl

; 227  : 		*(tmp + 1) = tmp1 >> 8;

	movzx	eax, WORD PTR _tmp1$[ebp]
	sar	eax, 8
	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [ecx+1], al

; 228  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 229  : 
; 230  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, 56320				; 0000dc00H
	mov	WORD PTR _tmp2$[ebp], ax

; 231  : 		tmp = (unsigned char *) out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], ecx

; 232  : 		*tmp  = (unsigned char) tmp2;

	mov	edx, DWORD PTR _tmp$[ebp]
	mov	al, BYTE PTR _tmp2$[ebp]
	mov	BYTE PTR [edx], al

; 233  : 		*(tmp + 1) = tmp2 >> 8;

	movzx	ecx, WORD PTR _tmp2$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [edx+1], cl

; 234  : 		out++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax
$L161274:

; 235  : 	    }
; 236  :         }
; 237  :         else

	jmp	SHORT $L161270
$L161271:

; 238  : 	    break;

	jmp	SHORT $L161248
$L161270:

; 239  : 	processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 240  :     }

	jmp	$L161247
$L161248:

; 241  :     *outlen = (out - outstart) * 2;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	sar	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 242  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 243  :     return(0);

	xor	eax, eax
$L161230:

; 244  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF8ToUTF16LE@@YAHPAEPAHPBE1@Z ENDP			; UTF8ToUTF16LE
_TEXT	ENDS
PUBLIC	?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z			; UTF16BEToUTF8
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bits$ = -40						; size = 4
_tmp$ = -36						; size = 4
_inlen$ = -32						; size = 4
_d$ = -28						; size = 4
_c$ = -24						; size = 4
_inend$ = -20						; size = 4
_in$ = -16						; size = 4
_outend$ = -12						; size = 4
_processed$ = -8					; size = 4
_outstart$ = -4						; size = 4
_out$ = 8						; size = 4
_outlen$ = 12						; size = 4
_inb$ = 16						; size = 4
_inlenb$ = 20						; size = 4
?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF16BEToUTF8

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 267  :     unsigned char* outstart = out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 268  :     const unsigned char* processed = inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 269  :     unsigned char* outend = out + *outlen;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _outend$[ebp], eax

; 270  :     unsigned short* in = (unsigned short*) inb;

	mov	ecx, DWORD PTR _inb$[ebp]
	mov	DWORD PTR _in$[ebp], ecx

; 271  :     unsigned short* inend;
; 272  :     unsigned int c, d, inlen;
; 273  :     unsigned char *tmp;
; 274  :     int bits;
; 275  : 
; 276  :     if ((*inlenb % 2) == 1)

	mov	edx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $L161740
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$L161740:
	cmp	eax, 1
	jne	SHORT $L161297

; 277  :         (*inlenb)--;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, 1
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx
$L161297:

; 278  :     inlen = *inlenb / 2;

	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _inlen$[ebp], eax

; 279  :     inend= in + inlen;

	mov	edx, DWORD PTR _inlen$[ebp]
	mov	eax, DWORD PTR _in$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2]
	mov	DWORD PTR _inend$[ebp], ecx
$L161299:

; 280  :     while (in < inend) {

	mov	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _inend$[ebp]
	jae	$L161300

; 281  : 	if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161301

; 282  : 	    tmp = (unsigned char *) in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 283  : 	    c = *tmp++;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _tmp$[ebp]
	add	eax, 1
	mov	DWORD PTR _tmp$[ebp], eax

; 284  : 	    c = c << 8;

	mov	ecx, DWORD PTR _c$[ebp]
	shl	ecx, 8
	mov	DWORD PTR _c$[ebp], ecx

; 285  : 	    c = c | (unsigned int) *tmp;

	mov	edx, DWORD PTR _tmp$[ebp]
	movzx	eax, BYTE PTR [edx]
	or	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 286  : 	    in++;

	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx

; 287  : 	} else {

	jmp	SHORT $L161304
$L161301:

; 288  : 	    c= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	DWORD PTR _c$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 2
	mov	DWORD PTR _in$[ebp], ecx
$L161304:

; 289  : 	} 
; 290  :         if ((c & 0xFC00) == 0xD800) {    /* surrogates */

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 64512				; 0000fc00H
	cmp	edx, 55296				; 0000d800H
	jne	$L161305

; 291  : 	    if (in >= inend) {           /* (in > inend) shouldn't happens */

	mov	eax, DWORD PTR _in$[ebp]
	cmp	eax, DWORD PTR _inend$[ebp]
	jb	SHORT $L161306

; 292  : 		*outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 293  : 		*inlenb = processed - inb;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _inb$[ebp]
	mov	ecx, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [ecx], eax

; 294  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161285
$L161306:

; 295  : 	    }
; 296  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161307

; 297  : 		tmp = (unsigned char *) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _tmp$[ebp], edx

; 298  : 		d = *tmp++;

	mov	eax, DWORD PTR _tmp$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _d$[ebp], ecx
	mov	edx, DWORD PTR _tmp$[ebp]
	add	edx, 1
	mov	DWORD PTR _tmp$[ebp], edx

; 299  : 		d = d << 8;

	mov	eax, DWORD PTR _d$[ebp]
	shl	eax, 8
	mov	DWORD PTR _d$[ebp], eax

; 300  : 		d = d | (unsigned int) *tmp;

	mov	ecx, DWORD PTR _tmp$[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _d$[ebp], edx

; 301  : 		in++;

	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax

; 302  : 	    } else {

	jmp	SHORT $L161310
$L161307:

; 303  : 		d= *in++;

	mov	ecx, DWORD PTR _in$[ebp]
	movzx	edx, WORD PTR [ecx]
	mov	DWORD PTR _d$[ebp], edx
	mov	eax, DWORD PTR _in$[ebp]
	add	eax, 2
	mov	DWORD PTR _in$[ebp], eax
$L161310:

; 304  : 	    }
; 305  :             if ((d & 0xFC00) == 0xDC00) {

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 64512				; 0000fc00H
	cmp	ecx, 56320				; 0000dc00H
	jne	SHORT $L161311

; 306  :                 c &= 0x03FF;

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, 1023				; 000003ffH
	mov	DWORD PTR _c$[ebp], edx

; 307  :                 c <<= 10;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 10					; 0000000aH
	mov	DWORD PTR _c$[ebp], eax

; 308  :                 c |= d & 0x03FF;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 1023				; 000003ffH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 309  :                 c += 0x10000;

	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], edx

; 310  :             }
; 311  :             else {

	jmp	SHORT $L161305
$L161311:

; 312  : 		*outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 313  : 		*inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 314  : 	        return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161285
$L161305:

; 315  : 	    }
; 316  :         }
; 317  : 
; 318  : 	/* assertion: c is a single UTF-4 value */
; 319  :         if (out >= outend) 

	mov	ecx, DWORD PTR _out$[ebp]
	cmp	ecx, DWORD PTR _outend$[ebp]
	jb	SHORT $L161313

; 320  : 	    break;

	jmp	$L161300
$L161313:

; 321  :         if      (c <    0x80) {  *out++=  c;                bits= -6; }

	cmp	DWORD PTR _c$[ebp], 128			; 00000080H
	jae	SHORT $L161314
	mov	edx, DWORD PTR _out$[ebp]
	mov	al, BYTE PTR _c$[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], -6		; fffffffaH

; 322  :         else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }

	jmp	$L161315
$L161314:
	cmp	DWORD PTR _c$[ebp], 2048		; 00000800H
	jae	SHORT $L161316
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 6
	and	edx, 31					; 0000001fH
	or	edx, 192				; 000000c0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 0

; 323  :         else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }

	jmp	SHORT $L161315
$L161316:
	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L161318
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 12					; 0000000cH
	and	edx, 15					; 0000000fH
	or	edx, 224				; 000000e0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 6

; 324  :         else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }

	jmp	SHORT $L161315
$L161318:
	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 18					; 00000012H
	and	edx, 7
	or	edx, 240				; 000000f0H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx
	mov	DWORD PTR _bits$[ebp], 12		; 0000000cH
$L161315:

; 325  :  
; 326  :         for ( ; bits >= 0; bits-= 6) {

	jmp	SHORT $L161320
$L161321:
	mov	edx, DWORD PTR _bits$[ebp]
	sub	edx, 6
	mov	DWORD PTR _bits$[ebp], edx
$L161320:
	cmp	DWORD PTR _bits$[ebp], 0
	jl	SHORT $L161322

; 327  :             if (out >= outend) 

	mov	eax, DWORD PTR _out$[ebp]
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L161323

; 328  : 	        break;

	jmp	SHORT $L161322
$L161323:

; 329  :             *out++= ((c >> bits) & 0x3F) | 0x80;

	mov	edx, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _bits$[ebp]
	shr	edx, cl
	and	edx, 63					; 0000003fH
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _out$[ebp]
	add	ecx, 1
	mov	DWORD PTR _out$[ebp], ecx

; 330  :         }

	jmp	SHORT $L161321
$L161322:

; 331  : 	processed = (const unsigned char*) in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], edx

; 332  :     }

	jmp	$L161299
$L161300:

; 333  :     *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 334  :     *inlenb = processed - inb;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _inb$[ebp]
	mov	eax, DWORD PTR _inlenb$[ebp]
	mov	DWORD PTR [eax], edx

; 335  :     return(0);

	xor	eax, eax
$L161285:

; 336  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z ENDP			; UTF16BEToUTF8
_TEXT	ENDS
PUBLIC	?UTF8ToUTF16BE@@YAHPAEPAHPBE1@Z			; UTF8ToUTF16BE
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv129 = -52						; size = 4
_tmp2$ = -48						; size = 2
_tmp1$ = -44						; size = 2
_tmp$ = -40						; size = 4
_trailing$ = -36					; size = 4
_d$ = -32						; size = 4
_c$ = -28						; size = 4
_inend$ = -24						; size = 4
_outend$ = -20						; size = 4
_outstart$ = -16					; size = 4
_instart$ = -12						; size = 4
_processed$ = -8					; size = 4
_out$ = -4						; size = 4
_outb$ = 8						; size = 4
_outlen$ = 12						; size = 4
_in$ = 16						; size = 4
_inlen$ = 20						; size = 4
?UTF8ToUTF16BE@@YAHPAEPAHPBE1@Z PROC NEAR		; UTF8ToUTF16BE

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 355  :     unsigned short* out = (unsigned short*) outb;

	mov	eax, DWORD PTR _outb$[ebp]
	mov	DWORD PTR _out$[ebp], eax

; 356  :     const unsigned char* processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 357  :     const unsigned char *const instart = in;

	mov	edx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _instart$[ebp], edx

; 358  :     unsigned short* outstart= out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _outstart$[ebp], eax

; 359  :     unsigned short* outend;
; 360  :     const unsigned char* inend= in+*inlen;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _inend$[ebp], edx

; 361  :     unsigned int c, d;
; 362  :     int trailing;
; 363  :     unsigned char *tmp;
; 364  :     unsigned short tmp1, tmp2;
; 365  : 
; 366  :     if (in == NULL) {

	cmp	DWORD PTR _in$[ebp], 0
	jne	SHORT $L161344

; 367  :         /*
; 368  : 	 * initialization, add the Byte Order Mark
; 369  : 	 */
; 370  :         if (*outlen >= 2) {

	mov	eax, DWORD PTR _outlen$[ebp]
	cmp	DWORD PTR [eax], 2
	jl	SHORT $L161345

; 371  : 	    outb[0] = 0xFE;

	mov	ecx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [ecx], 254			; 000000feH

; 372  : 	    outb[1] = 0xFF;

	mov	edx, DWORD PTR _outb$[ebp]
	mov	BYTE PTR [edx+1], 255			; 000000ffH

; 373  : 	    *outlen = 2;

	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], 2

; 374  : 	    *inlen = 0;

	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], 0

; 375  : #ifdef DEBUG_ENCODING
; 376  :             xmlGenericError(xmlGenericErrorContext,
; 377  : 		    "Added FEFF Byte Order Mark\n");
; 378  : #endif
; 379  : 	    return(2);

	mov	eax, 2
	jmp	$L161330
$L161345:

; 380  : 	}
; 381  : 	*outlen = 0;

	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], 0

; 382  : 	*inlen = 0;

	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], 0

; 383  : 	return(0);

	xor	eax, eax
	jmp	$L161330
$L161344:

; 384  :     }
; 385  :     outend = out + (*outlen / 2);

	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	eax, DWORD PTR [ecx]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edx, DWORD PTR _out$[ebp]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	DWORD PTR _outend$[ebp], eax
$L161347:

; 386  :     while (in < inend) {

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	$L161348

; 387  :       d= *in++;

	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _in$[ebp]
	add	ecx, 1
	mov	DWORD PTR _in$[ebp], ecx

; 388  :       if      (d < 0x80)  { c= d; trailing= 0; }

	cmp	DWORD PTR _d$[ebp], 128			; 00000080H
	jae	SHORT $L161349
	mov	edx, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 0

; 389  :       else if (d < 0xC0)  {

	jmp	$L161350
$L161349:
	cmp	DWORD PTR _d$[ebp], 192			; 000000c0H
	jae	SHORT $L161351

; 390  :           /* trailing byte in leading position */
; 391  : 	  *outlen = out - outstart;

	mov	eax, DWORD PTR _out$[ebp]
	sub	eax, DWORD PTR _outstart$[ebp]
	sar	eax, 1
	mov	ecx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 392  : 	  *inlen = processed - instart;

	mov	edx, DWORD PTR _processed$[ebp]
	sub	edx, DWORD PTR _instart$[ebp]
	mov	eax, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [eax], edx

; 393  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161330
$L161351:

; 394  :       } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }

	cmp	DWORD PTR _d$[ebp], 224			; 000000e0H
	jae	SHORT $L161353
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 31					; 0000001fH
	mov	DWORD PTR _c$[ebp], ecx
	mov	DWORD PTR _trailing$[ebp], 1

; 395  :       else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }

	jmp	SHORT $L161350
$L161353:
	cmp	DWORD PTR _d$[ebp], 240			; 000000f0H
	jae	SHORT $L161355
	mov	edx, DWORD PTR _d$[ebp]
	and	edx, 15					; 0000000fH
	mov	DWORD PTR _c$[ebp], edx
	mov	DWORD PTR _trailing$[ebp], 2

; 396  :       else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }

	jmp	SHORT $L161350
$L161355:
	cmp	DWORD PTR _d$[ebp], 248			; 000000f8H
	jae	SHORT $L161357
	mov	eax, DWORD PTR _d$[ebp]
	and	eax, 7
	mov	DWORD PTR _c$[ebp], eax
	mov	DWORD PTR _trailing$[ebp], 3

; 397  :       else {

	jmp	SHORT $L161350
$L161357:

; 398  :           /* no chance for this in UTF-16 */
; 399  : 	  *outlen = out - outstart;

	mov	ecx, DWORD PTR _out$[ebp]
	sub	ecx, DWORD PTR _outstart$[ebp]
	sar	ecx, 1
	mov	edx, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 400  : 	  *inlen = processed - instart;

	mov	eax, DWORD PTR _processed$[ebp]
	sub	eax, DWORD PTR _instart$[ebp]
	mov	ecx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [ecx], eax

; 401  : 	  return(-2);

	mov	eax, -2					; fffffffeH
	jmp	$L161330
$L161350:

; 402  :       }
; 403  : 
; 404  :       if (inend - in < trailing) {

	mov	edx, DWORD PTR _inend$[ebp]
	sub	edx, DWORD PTR _in$[ebp]
	cmp	edx, DWORD PTR _trailing$[ebp]
	jge	SHORT $L161359

; 405  :           break;

	jmp	$L161348
$L161359:

; 406  :       } 
; 407  : 
; 408  :       for ( ; trailing; trailing--) {

	jmp	SHORT $L161360
$L161361:
	mov	eax, DWORD PTR _trailing$[ebp]
	sub	eax, 1
	mov	DWORD PTR _trailing$[ebp], eax
$L161360:
	cmp	DWORD PTR _trailing$[ebp], 0
	je	SHORT $L161362

; 409  :           if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))  break;

	mov	ecx, DWORD PTR _in$[ebp]
	cmp	ecx, DWORD PTR _inend$[ebp]
	jae	SHORT $L161364
	mov	edx, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _d$[ebp], eax
	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 192				; 000000c0H
	mov	edx, DWORD PTR _in$[ebp]
	add	edx, 1
	mov	DWORD PTR _in$[ebp], edx
	cmp	ecx, 128				; 00000080H
	je	SHORT $L161742
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $L161743
$L161742:
	mov	DWORD PTR tv129[ebp], 0
$L161743:
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $L161363
$L161364:
	jmp	SHORT $L161362
$L161363:

; 410  :           c <<= 6;

	mov	eax, DWORD PTR _c$[ebp]
	shl	eax, 6
	mov	DWORD PTR _c$[ebp], eax

; 411  :           c |= d & 0x3F;

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, 63					; 0000003fH
	or	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _c$[ebp], ecx

; 412  :       }

	jmp	SHORT $L161361
$L161362:

; 413  : 
; 414  :       /* assertion: c is a single UTF-4 value */
; 415  :         if (c < 0x10000) {

	cmp	DWORD PTR _c$[ebp], 65536		; 00010000H
	jae	SHORT $L161365

; 416  :             if (out >= outend)  break;

	mov	edx, DWORD PTR _out$[ebp]
	cmp	edx, DWORD PTR _outend$[ebp]
	jb	SHORT $L161366
	jmp	$L161348
$L161366:

; 417  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161367

; 418  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 419  : 		*tmp = c >> 8;

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 8
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [edx], cl

; 420  : 		*(tmp + 1) = c;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR _c$[ebp]
	mov	BYTE PTR [eax+1], cl

; 421  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 422  : 	    } else {

	jmp	SHORT $L161369
$L161367:

; 423  : 		*out++ = c;

	mov	eax, DWORD PTR _out$[ebp]
	mov	cx, WORD PTR _c$[ebp]
	mov	WORD PTR [eax], cx
	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx
$L161369:

; 424  : 	    }
; 425  :         }
; 426  :         else if (c < 0x110000) {

	jmp	$L161370
$L161365:
	cmp	DWORD PTR _c$[ebp], 1114112		; 00110000H
	jae	$L161371

; 427  :             if (out+1 >= outend)  break;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _outend$[ebp]
	jb	SHORT $L161372
	jmp	$L161348
$L161372:

; 428  :             c -= 0x10000;

	mov	ecx, DWORD PTR _c$[ebp]
	sub	ecx, 65536				; 00010000H
	mov	DWORD PTR _c$[ebp], ecx

; 429  : 	    if (xmlLittleEndian) {

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161373

; 430  : 		tmp1 = 0xD800 | (c >> 10);

	mov	edx, DWORD PTR _c$[ebp]
	shr	edx, 10					; 0000000aH
	or	edx, 55296				; 0000d800H
	mov	WORD PTR _tmp1$[ebp], dx

; 431  : 		tmp = (unsigned char *) out;

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], eax

; 432  : 		*tmp = tmp1 >> 8;

	movzx	ecx, WORD PTR _tmp1$[ebp]
	sar	ecx, 8
	mov	edx, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [edx], cl

; 433  : 		*(tmp + 1) = (unsigned char) tmp1;

	mov	eax, DWORD PTR _tmp$[ebp]
	mov	cl, BYTE PTR _tmp1$[ebp]
	mov	BYTE PTR [eax+1], cl

; 434  : 		out++;

	mov	edx, DWORD PTR _out$[ebp]
	add	edx, 2
	mov	DWORD PTR _out$[ebp], edx

; 435  : 
; 436  : 		tmp2 = 0xDC00 | (c & 0x03FF);

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, 1023				; 000003ffH
	or	eax, 56320				; 0000dc00H
	mov	WORD PTR _tmp2$[ebp], ax

; 437  : 		tmp = (unsigned char *) out;

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR _tmp$[ebp], ecx

; 438  : 		*tmp = tmp2 >> 8;

	movzx	edx, WORD PTR _tmp2$[ebp]
	sar	edx, 8
	mov	eax, DWORD PTR _tmp$[ebp]
	mov	BYTE PTR [eax], dl

; 439  : 		*(tmp + 1) = (unsigned char) tmp2;

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR _tmp2$[ebp]
	mov	BYTE PTR [ecx+1], dl

; 440  : 		out++;

	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax

; 441  : 	    } else {

	jmp	SHORT $L161378
$L161373:

; 442  : 		*out++ = 0xD800 | (c >> 10);

	mov	ecx, DWORD PTR _c$[ebp]
	shr	ecx, 10					; 0000000aH
	or	ecx, 55296				; 0000d800H
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax

; 443  : 		*out++ = 0xDC00 | (c & 0x03FF);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, 1023				; 000003ffH
	or	ecx, 56320				; 0000dc00H
	mov	edx, DWORD PTR _out$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _out$[ebp]
	add	eax, 2
	mov	DWORD PTR _out$[ebp], eax
$L161378:

; 444  : 	    }
; 445  :         }
; 446  :         else

	jmp	SHORT $L161370
$L161371:

; 447  : 	    break;

	jmp	SHORT $L161348
$L161370:

; 448  : 	processed = in;

	mov	ecx, DWORD PTR _in$[ebp]
	mov	DWORD PTR _processed$[ebp], ecx

; 449  :     }

	jmp	$L161347
$L161348:

; 450  :     *outlen = (out - outstart) * 2;

	mov	edx, DWORD PTR _out$[ebp]
	sub	edx, DWORD PTR _outstart$[ebp]
	sar	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _outlen$[ebp]
	mov	DWORD PTR [eax], edx

; 451  :     *inlen = processed - instart;

	mov	ecx, DWORD PTR _processed$[ebp]
	sub	ecx, DWORD PTR _instart$[ebp]
	mov	edx, DWORD PTR _inlen$[ebp]
	mov	DWORD PTR [edx], ecx

; 452  :     return(0);

	xor	eax, eax
$L161330:

; 453  : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0
?UTF8ToUTF16BE@@YAHPAEPAHPBE1@Z ENDP			; UTF8ToUTF16BE
_TEXT	ENDS
EXTRN	_AddLogDetailWithMutex:NEAR
EXTRN	_EnteringFunction:DWORD
EXTRN	__imp__SysStringByteLen@4:NEAR
EXTRN	_ExitingFunction:DWORD
EXTRN	_myMalloc:NEAR
EXTRN	_memset:NEAR
EXTRN	_sprintf:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_utf8CharStr$ = -552					; size = 4
_utf8CharStrLen$ = -544					; size = 4
_bstrByteSize$ = -532					; size = 4
_buffer$ = -520						; size = 512
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_bstrStr$ = 8						; size = 4
?HeapW2A@@YAPAEPAG@Z PROC NEAR				; HeapW2A

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-552]
	mov	ecx, 138				; 0000008aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 457  : #ifdef LOGGING
; 458  : 	char buffer[BUFSIZ];
; 459  : 	memset(buffer, 0, BUFSIZ);

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 460  : #endif
; 461  : 	EnterLog;

	mov	ecx, DWORD PTR _EnteringFunction
	push	ecx
	push	OFFSET FLAT:$SG161384
	push	0
	push	0
	push	OFFSET FLAT:$SG161385
	push	461					; 000001cdH
	push	OFFSET FLAT:$SG161386
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 462  : 	int bstrByteSize = (int)SysStringByteLen(bstrStr);

	mov	esi, esp
	mov	edx, DWORD PTR _bstrStr$[ebp]
	push	edx
	call	DWORD PTR __imp__SysStringByteLen@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bstrByteSize$[ebp], eax

; 463  : #ifdef LOGGING
; 464  : 	sprintf((char *)buffer, "bstrByteSize = %d", bstrByteSize);

	mov	eax, DWORD PTR _bstrByteSize$[ebp]
	push	eax
	push	OFFSET FLAT:$SG161390
	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 465  : 	DebugLog((const char *)buffer);

	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	push	OFFSET FLAT:$SG161392
	push	0
	push	0
	push	OFFSET FLAT:$SG161393
	push	465					; 000001d1H
	push	OFFSET FLAT:$SG161394
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 466  : #endif
; 467  : 	if (bstrByteSize==0) {

	cmp	DWORD PTR _bstrByteSize$[ebp], 0
	jne	SHORT $L161395

; 468  : 		return NULL;

	xor	eax, eax
	jmp	$L161382
$L161395:

; 469  : 	}
; 470  : 	int utf8CharStrLen = bstrByteSize * 2;

	mov	eax, DWORD PTR _bstrByteSize$[ebp]
	shl	eax, 1
	mov	DWORD PTR _utf8CharStrLen$[ebp], eax

; 471  : 	if (utf8CharStrLen < 6)

	cmp	DWORD PTR _utf8CharStrLen$[ebp], 6
	jge	SHORT $L161397

; 472  : 		utf8CharStrLen = 6;

	mov	DWORD PTR _utf8CharStrLen$[ebp], 6
$L161397:

; 473  : 	unsigned char *utf8CharStr = (unsigned char *)zMalloc(utf8CharStrLen);

	push	OFFSET FLAT:$SG161400
	push	473					; 000001d9H
	push	OFFSET FLAT:$SG161401
	mov	ecx, DWORD PTR _utf8CharStrLen$[ebp]
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _utf8CharStr$[ebp], eax

; 474  : 	memset(utf8CharStr, 0, utf8CharStrLen);

	mov	edx, DWORD PTR _utf8CharStrLen$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _utf8CharStr$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 475  : 	if (xmlLittleEndian)

	cmp	DWORD PTR _xmlLittleEndian, 0
	je	SHORT $L161402

; 476  : 		UTF16LEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)bstrStr, &bstrByteSize);

	lea	ecx, DWORD PTR _bstrByteSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _bstrStr$[ebp]
	push	edx
	lea	eax, DWORD PTR _utf8CharStrLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _utf8CharStr$[ebp]
	push	ecx
	call	?UTF16LEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16LEToUTF8
	add	esp, 16					; 00000010H

; 477  : 	else

	jmp	SHORT $L161404
$L161402:

; 478  : 		UTF16BEToUTF8(utf8CharStr, &utf8CharStrLen, (const unsigned char *)bstrStr, &bstrByteSize);

	lea	edx, DWORD PTR _bstrByteSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _bstrStr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _utf8CharStrLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _utf8CharStr$[ebp]
	push	edx
	call	?UTF16BEToUTF8@@YAHPAEPAHPBE1@Z		; UTF16BEToUTF8
	add	esp, 16					; 00000010H
$L161404:

; 479  : 	ExitLog;

	mov	eax, DWORD PTR _ExitingFunction
	push	eax
	push	OFFSET FLAT:$SG161406
	push	0
	push	0
	push	OFFSET FLAT:$SG161407
	push	479					; 000001dfH
	push	OFFSET FLAT:$SG161408
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 480  : 	return utf8CharStr;

	mov	eax, DWORD PTR _utf8CharStr$[ebp]
$L161382:

; 481  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L161752
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 552				; 00000228H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L161752:
	DD	3
	DD	$L161751
$L161751:
	DD	-520					; fffffdf8H
	DD	512					; 00000200H
	DD	$L161746
	DD	-532					; fffffdecH
	DD	4
	DD	$L161747
	DD	-544					; fffffde0H
	DD	4
	DD	$L161748
$L161748:
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	102					; 00000066H
	DB	56					; 00000038H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	83					; 00000053H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	76					; 0000004cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
$L161747:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	66					; 00000042H
	DB	121					; 00000079H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L161746:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?HeapW2A@@YAPAEPAG@Z ENDP				; HeapW2A
_TEXT	ENDS
PUBLIC	?ldump@@YAXPADI@Z				; ldump
EXTRN	_isprint:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv66 = -12						; size = 4
_c$161416 = -5						; size = 1
_i$161415 = -4						; size = 4
_ptr$ = 8						; size = 4
_len$ = 12						; size = 4
?ldump@@YAXPADI@Z PROC NEAR				; ldump

; 491  : ldump(char *ptr, unsigned int len) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 492  :   if ( len ) {

	cmp	DWORD PTR _len$[ebp], 0
	je	$L161413

; 493  :     int  i;
; 494  :     char c;
; 495  :     len=MIN(16,len);

	cmp	DWORD PTR _len$[ebp], 16		; 00000010H
	jbe	SHORT $L161756
	mov	DWORD PTR tv66[ebp], 16			; 00000010H
	jmp	SHORT $L161757
$L161756:
	mov	eax, DWORD PTR _len$[ebp]
	mov	DWORD PTR tv66[ebp], eax
$L161757:
	mov	ecx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _len$[ebp], ecx

; 496  :     /*    printf("\nStart is %10x, Count is %5x, End is %10x",ptr,len,ptr+len); */
; 497  :     printf("\n%10p ",ptr);

	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	push	OFFSET FLAT:$SG161417
	call	_printf
	add	esp, 8

; 498  : 
; 499  :     for( i = 0 ; i < len ; i++ )  /* Print the hex dump for len

	mov	DWORD PTR _i$161415[ebp], 0
	jmp	SHORT $L161418
$L161419:
	mov	eax, DWORD PTR _i$161415[ebp]
	add	eax, 1
	mov	DWORD PTR _i$161415[ebp], eax
$L161418:
	mov	ecx, DWORD PTR _i$161415[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jae	SHORT $L161420

; 500  :                                      chars. */
; 501  :       printf("%3x",(*(ptr+i)&0xff));

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _i$161415[ebp]
	movsx	eax, BYTE PTR [edx]
	and	eax, 255				; 000000ffH
	push	eax
	push	OFFSET FLAT:$SG161421
	call	_printf
	add	esp, 8
	jmp	SHORT $L161419
$L161420:

; 502  : 
; 503  :     for( i = len ; i < 16 ; i++ ) /* Pad out the dump field to the

	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR _i$161415[ebp], ecx
	jmp	SHORT $L161422
$L161423:
	mov	edx, DWORD PTR _i$161415[ebp]
	add	edx, 1
	mov	DWORD PTR _i$161415[ebp], edx
$L161422:
	cmp	DWORD PTR _i$161415[ebp], 16		; 00000010H
	jge	SHORT $L161424

; 504  :                                      ASCII field. */
; 505  :       printf("   ");

	push	OFFSET FLAT:$SG161425
	call	_printf
	add	esp, 4
	jmp	SHORT $L161423
$L161424:

; 506  : 
; 507  :     printf(" ");

	push	OFFSET FLAT:$SG161426
	call	_printf
	add	esp, 4

; 508  :     for( i = 0 ; i < len ; i++ ) { /* Now print the ASCII field. */

	mov	DWORD PTR _i$161415[ebp], 0
	jmp	SHORT $L161427
$L161428:
	mov	eax, DWORD PTR _i$161415[ebp]
	add	eax, 1
	mov	DWORD PTR _i$161415[ebp], eax
$L161427:
	mov	ecx, DWORD PTR _i$161415[ebp]
	cmp	ecx, DWORD PTR _len$[ebp]
	jae	SHORT $L161413

; 509  :       c=0x7f&(*(ptr+i));      /* Mask out bit 7 */

	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, DWORD PTR _i$161415[ebp]
	movsx	eax, BYTE PTR [edx]
	and	eax, 127				; 0000007fH
	mov	BYTE PTR _c$161416[ebp], al

; 510  : 
; 511  :       if (!(isprint(c))) {    /* If not printable */

	movsx	ecx, BYTE PTR _c$161416[ebp]
	push	ecx
	call	_isprint
	add	esp, 4
	test	eax, eax
	jne	SHORT $L161430

; 512  :         printf(".");          /* print a dot */

	push	OFFSET FLAT:$SG161431
	call	_printf
	add	esp, 4

; 513  :       } else {

	jmp	SHORT $L161432
$L161430:

; 514  :         printf("%c",c);  }    /* else display it */

	movsx	edx, BYTE PTR _c$161416[ebp]
	push	edx
	push	OFFSET FLAT:$SG161433
	call	_printf
	add	esp, 8
$L161432:

; 515  :     }

	jmp	SHORT $L161428
$L161413:

; 516  :   }
; 517  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ldump@@YAXPADI@Z ENDP					; ldump
_TEXT	ENDS
PUBLIC	?head@@YAXJ@Z					; head
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$ = -4						; size = 4
_st$ = 8						; size = 4
?head@@YAXJ@Z PROC NEAR					; head

; 524  : head(long st) {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 525  :   int i;
; 526  :   printf("\n   addr    ");

	push	OFFSET FLAT:$SG161438
	call	_printf
	add	esp, 4

; 527  :   for ( i = st&0xf ; i < (st&0xf)+0x10 ; i++ )

	mov	eax, DWORD PTR _st$[ebp]
	and	eax, 15					; 0000000fH
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $L161439
$L161440:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L161439:
	mov	edx, DWORD PTR _st$[ebp]
	and	edx, 15					; 0000000fH
	add	edx, 16					; 00000010H
	cmp	DWORD PTR _i$[ebp], edx
	jge	SHORT $L161441

; 528  :     printf("%3x",(i&0x0f));

	mov	eax, DWORD PTR _i$[ebp]
	and	eax, 15					; 0000000fH
	push	eax
	push	OFFSET FLAT:$SG161442
	call	_printf
	add	esp, 8
	jmp	SHORT $L161440
$L161441:

; 529  :   printf(" | 7 bit ascii. |");

	push	OFFSET FLAT:$SG161443
	call	_printf
	add	esp, 4

; 530  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?head@@YAXJ@Z ENDP					; head
_TEXT	ENDS
PUBLIC	?dump@@YAXPADI@Z				; dump
EXTRN	_getchar:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv77 = -8						; size = 4
_i$161449 = -4						; size = 4
_ptr$ = 8						; size = 4
_ct$ = 12						; size = 4
?dump@@YAXPADI@Z PROC NEAR				; dump

; 536  : dump(char *ptr, unsigned int ct) {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 537  :   if ( ct ) {

	cmp	DWORD PTR _ct$[ebp], 0
	je	$L161447

; 538  :     int i;
; 539  : 
; 540  :     /*  preliminary info for user's benefit. */
; 541  :     printf("\nStart is %10p, Count is %5x, End is %10p",
; 542  :            ptr, ct, ptr + ct);

	mov	eax, DWORD PTR _ptr$[ebp]
	add	eax, DWORD PTR _ct$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ct$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	push	edx
	push	OFFSET FLAT:$SG161450
	call	_printf
	add	esp, 16					; 00000010H

; 543  :     head((long)ptr);

	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	?head@@YAXJ@Z				; head
	add	esp, 4

; 544  :     for ( i = 0 ; i <= ct ; i = i+16 , ptr = ptr+16 )

	mov	DWORD PTR _i$161449[ebp], 0
	jmp	SHORT $L161452
$L161453:
	mov	ecx, DWORD PTR _i$161449[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR _i$161449[ebp], ecx
	mov	edx, DWORD PTR _ptr$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _ptr$[ebp], edx
$L161452:
	mov	eax, DWORD PTR _i$161449[ebp]
	cmp	eax, DWORD PTR _ct$[ebp]
	ja	SHORT $L161454

; 545  :       ldump(ptr,(MIN(16,(ct-i))));

	mov	ecx, DWORD PTR _ct$[ebp]
	sub	ecx, DWORD PTR _i$161449[ebp]
	cmp	ecx, 16					; 00000010H
	jbe	SHORT $L161760
	mov	DWORD PTR tv77[ebp], 16			; 00000010H
	jmp	SHORT $L161761
$L161760:
	mov	edx, DWORD PTR _ct$[ebp]
	sub	edx, DWORD PTR _i$161449[ebp]
	mov	DWORD PTR tv77[ebp], edx
$L161761:
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	call	?ldump@@YAXPADI@Z			; ldump
	add	esp, 8
	jmp	SHORT $L161453
$L161454:

; 546  : 
; 547  :     printf("\n\"Enter\" to continue.\n"); /* Give him/her/it a chance

	push	OFFSET FLAT:$SG161455
	call	_printf
	add	esp, 4

; 548  :                                              to examine it. */
; 549  :     getchar ();

	call	_getchar
$L161447:

; 550  :   }
; 551  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?dump@@YAXPADI@Z ENDP					; dump
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T161784 DD	0ffffffffH
	DD	FLAT:$L161777
$T161781 DD	019930520H
	DD	01H
	DD	FLAT:$T161784
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L161777:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T161781
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
