; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\CertVerify.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIDNGAPJ@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5char?$CK?$CJ?5?$CKthis?5?$CB?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@NCNHACCB@s?5?$DN?$DN?50?5?$HM?$HM?5m_Data?5?$DN?$DN?50?5?$HM?$HM?5m_Data?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@LJMJHPFK@m_Data?5?$CB?$DN?50?5?$CG?$CG?5m_Data?9?$DORefCount?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@GKIPNLEE@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5?$CIBSTR@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDNDDDBI@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5pSrc?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EL@EEEMIENH@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5?$CIVT_I1?5?$HM?5VT_BYRE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@IHHPLLAD@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_DISPATCH?5?$HM?$HM?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@LJOMBHMP@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_UNKNOWN?5?$HM?$HM?5pS@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17CGPNFONA@?$AA?7?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19ELGCFCMM@?$AA?$AD?$AA?7?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@CBBHPGMH@?$EA?$AI?$EA?$AD?$EA?$AD?$EA?$AD?$EA?$AD?$AA?7?$AA?7?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@LPGBCEBP@?$AA?$AD?$AA?7?$EA?$AD?$AA?7?$AA?7?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1O@NEHKDCLA@?$EA?$AI?$EA?$AI?$EA?$AI?$EA?$AD?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_15ONFCDLDB@?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19DICFMKI@?$AA?$AD?$AA?$AM?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@FFKIHFKI@?$AA?$AD?$AA?$AM?$AA?7?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_19NKKCEOAE@?$AA?$AD?$AA?$AD?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@KEKDCOCF@?$AA?$AD?$AA?$AD?$AA?7?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17LHDNECBI@?$AA?$AD?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_17CANDCMNE@?$EA?$AL?$EA?$AD?$AA?7?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckError@_com_util@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_bstr_t@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y_bstr_t@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7_bstr_t@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@_bstr_t@@QAEXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Compare@_bstr_t@@ABEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RefCount@Data_t@_bstr_t@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@Data_t@_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@Data_t@_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Data_t@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@Data_t@_bstr_t@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@AAUtagVARIANT@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_variant_t@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8_variant_t@@QBE_NPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@_variant_t@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeType@_variant_t@@QAEXGPBV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_com_error@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UIUnknown@@$1?_GUID_00000000_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@QAE@PAUIUnknown@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UIUnknown@@$1?_GUID_00000000_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UProperty@@$1?_GUID_00000503_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUProperty@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UProperty@@$1?_GUID_00000503_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UProperties@@$1?_GUID_00000504_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUProperties@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UProperties@@$1?_GUID_00000504_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UError@@$1?_GUID_00000500_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUError@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UError@@$1?_GUID_00000500_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UField@@$1?_GUID_00000569_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUField@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UField@@$1?_GUID_00000569_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@U_Parameter@@$1?_GUID_0000050c_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAU_Parameter@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@U_Parameter@@$1?_GUID_0000050c_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@U_Connection@@$1?_GUID_00000550_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAU_Connection@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@U_Connection@@$1?_GUID_00000550_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@U_Recordset@@$1?_GUID_00000556_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAU_Recordset@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@U_Recordset@@$1?_GUID_00000556_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UParameters@@$1?_GUID_0000050d_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUParameters@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UParameters@@$1?_GUID_0000050d_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UErrors@@$1?_GUID_00000501_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUErrors@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UErrors@@$1?_GUID_00000501_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UFields@@$1?_GUID_00000564_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@PAUFields@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UFields@@$1?_GUID_00000564_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_com_ptr_t@V?$_com_IIID@UIDispatch@@$1?_GUID_00020400_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@QAE@PAUIDispatch@@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_com_ptr_t@V?$_com_IIID@UIDispatch@@$1?_GUID_00020400_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UIUnknown@@$1?_GUID_00000000_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UIUnknown@@$1?_GUID_00000000_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UProperty@@$1?_GUID_00000503_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UProperty@@$1?_GUID_00000503_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UProperties@@$1?_GUID_00000504_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UProperties@@$1?_GUID_00000504_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UError@@$1?_GUID_00000500_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UError@@$1?_GUID_00000500_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UField@@$1?_GUID_00000569_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UField@@$1?_GUID_00000569_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@U_Parameter@@$1?_GUID_0000050c_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@U_Parameter@@$1?_GUID_0000050c_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@U_Connection@@$1?_GUID_00000550_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@U_Connection@@$1?_GUID_00000550_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@U_Recordset@@$1?_GUID_00000556_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@U_Recordset@@$1?_GUID_00000556_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UParameters@@$1?_GUID_0000050d_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UParameters@@$1?_GUID_0000050d_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UErrors@@$1?_GUID_00000501_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UErrors@@$1?_GUID_00000501_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UFields@@$1?_GUID_00000564_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UFields@@$1?_GUID_00000564_0000_0010_8000_00aa006d2ea4@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Release@?$_com_ptr_t@V?$_com_IIID@UIDispatch@@$1?_GUID_00020400_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@?$_com_ptr_t@V?$_com_IIID@UIDispatch@@$1?_GUID_00020400_0000_0000_c000_000000000046@@3U__s_GUID@@B@@@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAE@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000562_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000403_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000402_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000556_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000555_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000054f_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000050e_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000550_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000515_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b08400bd_f9d1_4d02_b856_71d5dba123e9
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000054e_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000508_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000505_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000283_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000517_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000568_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000567_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000565_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000516_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000050d_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000050c_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000564_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000054d_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000506_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000569_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000054c_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000501_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000500_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000534_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000504_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000503_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000513_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000512_0000_0010_8000_00aa006d2ea4
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
CONST	SEGMENT
$SG184745 DB	'crVerifyCertificate', 00H
$SG184746 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184747 DB	'crVerifyCertificate', 00H
$SG184748 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184754 DB	'crVerifyCertificate', 00H
$SG184755 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184756 DB	'crVerifyCertificate', 00H
$SG184757 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184763 DB	'crVerifyCertificate', 00H
$SG184764 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184765 DB	'crVerifyCertificate', 00H
$SG184766 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184775 DB	'crVerifyCertificate', 00H
$SG184776 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184796 DB	'crVerifyCertificate', 00H
$SG184797 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184802 DB	'crVerifyCertificate', 00H
$SG184803 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184817 DB	'crVerifyCertificate', 00H
$SG184818 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184823 DB	'crVerifyCertificate', 00H
$SG184824 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184870 DB	'checkCertificate', 00H
	ORG $+3
$SG184871 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184876 DB	'checkCertificate', 00H
	ORG $+3
$SG184877 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184881 DB	'checkCertificate', 00H
	ORG $+3
$SG184882 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184885 DB	'checkCertificate', 00H
	ORG $+3
$SG184886 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG184887 DB	'checkCertificate', 00H
	ORG $+3
$SG184888 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185410 DB	'checkCertificate', 00H
	ORG $+3
$SG185411 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185418 DB	'checkCertificate', 00H
	ORG $+3
$SG185419 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185423 DB	'checkCertificate', 00H
	ORG $+3
$SG185424 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185425 DB	'checkCertificate', 00H
	ORG $+3
$SG185426 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185428 DB	'checkCertificate', 00H
	ORG $+3
$SG185429 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185430 DB	'checkCertificate', 00H
	ORG $+3
$SG185431 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185439 DB	'checkCertificate', 00H
	ORG $+3
$SG185440 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185444 DB	'checkCertificate', 00H
	ORG $+3
$SG185445 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185446 DB	'checkCertificate', 00H
	ORG $+3
$SG185447 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185449 DB	'checkCertificate', 00H
	ORG $+3
$SG185450 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185451 DB	'checkCertificate', 00H
	ORG $+3
$SG185452 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185454 DB	'checkCertificate', 00H
	ORG $+3
$SG185455 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185456 DB	'checkCertificate', 00H
	ORG $+3
$SG185457 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185460 DB	'checkCertificate', 00H
	ORG $+3
$SG185461 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185462 DB	'checkCertificate', 00H
	ORG $+3
$SG185463 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185470 DB	'checkCertificate', 00H
	ORG $+3
$SG185471 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185560 DB	'checkCertificate', 00H
	ORG $+3
$SG185561 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185564 DB	'checkCertificate', 00H
	ORG $+3
$SG185565 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185591 DB	'checkCertificate', 00H
	ORG $+3
$SG185592 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185604 DB	'checkCertificate', 00H
	ORG $+3
$SG185605 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185608 DB	'checkCertificate', 00H
	ORG $+3
$SG185609 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185642 DB	'Debug Log', 00H
	ORG $+2
$SG185643 DB	'check_CRL', 00H
	ORG $+2
$SG185644 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185656 DB	'2.5.29.27', 00H
	ORG $+2
$SG185658 DB	'2.5.29.28', 00H
	ORG $+2
$SG185663 DB	'check_CRL', 00H
	ORG $+2
$SG185664 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185666 DB	'check_CRL', 00H
	ORG $+2
$SG185667 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185682 DB	'check_CRL', 00H
	ORG $+2
$SG185683 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185684 DB	'check_CRL', 00H
	ORG $+2
$SG185685 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185686 DB	'check_CRL', 00H
	ORG $+2
$SG185687 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185954 DB	'check_CRL', 00H
	ORG $+2
$SG185955 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185958 DB	'check_CRL', 00H
	ORG $+2
$SG185959 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185967 DB	'ldap:', 00H
	ORG $+2
$SG185973 DB	'check_CRL', 00H
	ORG $+2
$SG185974 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185983 DB	'c:\temp\fetchedCrl%02d_%02d.crl', 00H
$SG185986 DB	'wb', 00H
	ORG $+1
$SG185990 DB	'check_CRL', 00H
	ORG $+2
$SG185991 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185992 DB	'check_CRL', 00H
	ORG $+2
$SG185993 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG185999 DB	'check_CRL', 00H
	ORG $+2
$SG186000 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186001 DB	'check_CRL', 00H
	ORG $+2
$SG186002 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186005 DB	'2.5.29.27', 00H
	ORG $+2
$SG186008 DB	'check_CRL', 00H
	ORG $+2
$SG186009 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186010 DB	'check_CRL', 00H
	ORG $+2
$SG186011 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186012 DB	'2.5.29.28', 00H
	ORG $+2
$SG186015 DB	'check_CRL', 00H
	ORG $+2
$SG186016 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186017 DB	'check_CRL', 00H
	ORG $+2
$SG186018 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186022 DB	'check_CRL', 00H
	ORG $+2
$SG186023 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186025 DB	'check_CRL', 00H
	ORG $+2
$SG186026 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186031 DB	'check_CRL', 00H
	ORG $+2
$SG186032 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186033 DB	'check_CRL', 00H
	ORG $+2
$SG186034 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186039 DB	'check_CRL', 00H
	ORG $+2
$SG186040 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186041 DB	'check_CRL', 00H
	ORG $+2
$SG186042 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186045 DB	'check_CRL', 00H
	ORG $+2
$SG186046 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186047 DB	'check_CRL', 00H
	ORG $+2
$SG186048 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186050 DB	'check_CRL', 00H
	ORG $+2
$SG186051 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186052 DB	'check_CRL', 00H
	ORG $+2
$SG186053 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186056 DB	'check_CRL', 00H
	ORG $+2
$SG186057 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186058 DB	'check_CRL', 00H
	ORG $+2
$SG186059 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186062 DB	'Debug Log', 00H
	ORG $+2
$SG186063 DB	'check_CRL', 00H
	ORG $+2
$SG186064 DB	'.\CertVerify.cpp', 00H
	ORG $+3
$SG186897 DB	'pp != 0', 00H
	ORG $+4
$SG186898 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; crVerifyCertificate
EXTRN	_setError:NEAR
EXTRN	_base64decodeSize:NEAR
EXTRN	_base64decode:NEAR
EXTRN	__imp__CryptAcquireContextW@20:NEAR
EXTRN	_myMalloc:NEAR
EXTRN	_myFree:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_UninitUse:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	__imp__CertOpenStore@20:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__CertCloseStore@8:NEAR
EXTRN	__imp__CertEnumCertificatesInStore@8:NEAR
EXTRN	_crFilterCerts:NEAR
EXTRN	_crIsPFX:NEAR
EXTRN	_cleanupError:NEAR
EXTRN	__imp__PFXImportCertStore@12:NEAR
EXTRN	__imp__PFXVerifyPassword@12:NEAR
EXTRN	__imp__CertFreeCertificateContext@4:NEAR
EXTRN	__imp__CertGetCertificateContextProperty@16:NEAR
EXTRN	__imp__SystemTimeToFileTime@8:NEAR
EXTRN	__imp__CertAddEncodedCertificateToStore@24:NEAR
;	COMDAT rtc$IMZ
; File c:\activex\xmlsign\certverify.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
$T187870 = -145						; size = 1
_optFlag$184788 = -140					; size = 4
_realLen$184772 = -132					; size = 4
_pwdBlob$ = -124					; size = 8
_cbData$ = -108						; size = 4
_res$ = -100						; size = 4
_sysTimeStatus$ = -96					; size = 4
_optFlag$ = -92						; size = 4
_pTime$ = -88						; size = 4
_pfTime$ = -80						; size = 8
_hStoreHandle$ = -68					; size = 4
_endPct$ = -64						; size = 4
_pct$ = -56						; size = 4
_pfxBlob$ = -44						; size = 8
_provInfo$ = -32					; size = 4
_hProv$ = -24						; size = 4
_i$ = -16						; size = 4
_err$ = -12						; size = 4
_cbCert$ = -8						; size = 4
_pbCert$ = -4						; size = 4
_certData$ = 8						; size = 4
_certNum$ = 12						; size = 4
_pSysTime$ = 16						; size = 4
_password$ = 20						; size = 4
_certVerParams$ = 24					; size = 4
_pg_sig$ = 28						; size = 4
?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; crVerifyCertificate

; 129  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-148]
	mov	ecx, 37					; 00000025H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	BYTE PTR $T187870[ebp], 0

; 130  : BYTE *pbCert=NULL;

	mov	DWORD PTR _pbCert$[ebp], 0

; 131  : DWORD cbCert=0;

	mov	DWORD PTR _cbCert$[ebp], 0

; 132  : int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 133  : UINT i=0;

	mov	DWORD PTR _i$[ebp], 0

; 134  : 
; 135  : #ifdef NSS
; 136  : SECItem pfxBlob;
; 137  : CERTCertificate *pct=NULL;
; 138  : CERTCertificate *endPct=NULL;
; 139  : CERTCertDBHandle *hStoreHandle=NULL;
; 140  : CERTCertificate **certs = NULL;
; 141  : SECItem **derCerts = NULL;
; 142  : int64 pTime=0;
; 143  : SECStatus rv;
; 144  : #else
; 145  : HCRYPTPROV hProv;
; 146  : CRYPT_KEY_PROV_INFO *provInfo;
; 147  : CRYPT_DATA_BLOB pfxBlob;
; 148  : PCCERT_CONTEXT pct=NULL;

	mov	DWORD PTR _pct$[ebp], 0

; 149  : PCCERT_CONTEXT endPct=NULL;

	mov	DWORD PTR _endPct$[ebp], 0

; 150  : HCERTSTORE hStoreHandle=NULL;

	mov	DWORD PTR _hStoreHandle$[ebp], 0

; 151  : FILETIME pfTime;
; 152  : LPFILETIME pTime;
; 153  : #endif
; 154  : 
; 155  : int optFlag =0;

	mov	DWORD PTR _optFlag$[ebp], 0

; 156  : BOOL sysTimeStatus=FALSE;

	mov	DWORD PTR _sysTimeStatus$[ebp], 0

; 157  : int res=0;

	mov	DWORD PTR _res$[ebp], 0

; 158  : DWORD cbData=0;

	mov	DWORD PTR _cbData$[ebp], 0

; 159  : DS_DATA_BLOB pwdBlob;
; 160  : 
; 161  : if (password!=NULL) {

	cmp	DWORD PTR _password$[ebp], 0
	je	SHORT $L184736

; 162  : #ifdef NSS
; 163  : 	pwdBlob.cbData= password->len;
; 164  : 	pwdBlob.pbData= password->data;
; 165  : #else
; 166  : 	pwdBlob.cbData= 0;

	mov	DWORD PTR _pwdBlob$[ebp+4], 0

; 167  : 	pwdBlob.pbData= (unsigned char *) password;

	mov	eax, DWORD PTR _password$[ebp]
	mov	DWORD PTR _pwdBlob$[ebp], eax

; 168  : #endif
; 169  : }else{

	jmp	SHORT $L184738
$L184736:

; 170  : 	pwdBlob.cbData= 0;

	mov	DWORD PTR _pwdBlob$[ebp+4], 0

; 171  : 	pwdBlob.pbData= NULL;

	mov	DWORD PTR _pwdBlob$[ebp], 0
$L184738:

; 172  : }
; 173  : 
; 174  : //DebugBreak();
; 175  : 
; 176  : if (!certData) {

	cmp	DWORD PTR _certData$[ebp], 0
	jne	SHORT $L184739

; 177  : 	setError(pg_sig, NO_CERTIFICATE);

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 178  : 	return FALSE;

	xor	eax, eax
	jmp	$L184718
$L184739:

; 179  : }
; 180  : #ifdef NSS
; 181  : 	hStoreHandle = CERT_GetDefaultCertDB();
; 182  : 		//(CERTCertDBHandle *)217865; // any non-0 number
; 183  : #endif
; 184  : 
; 185  : 
; 186  : if ((certVerParams->userPolicySetCountOut != 0) && 
; 187  : 	(certVerParams->userPolicySetOut != NULL))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	$L184740
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	$L184740

; 188  : {
; 189  : 	for (i=0; i < certVerParams->userPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L184741
$L184742:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L184741:
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jae	SHORT $L184743

; 190  : 	{
; 191  : 		if (certVerParams->userPolicySetOut[i] != NULL)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $L184744

; 192  : 		{
; 193  : 			zFree(certVerParams->userPolicySetOut[i]);

	push	OFFSET FLAT:$SG184745
	push	193					; 000000c1H
	push	OFFSET FLAT:$SG184746
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 194  : 			certVerParams->userPolicySetOut[i] = NULL;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [eax+ecx*4], 0
$L184744:

; 195  : 		}
; 196  : 	}

	jmp	SHORT $L184742
$L184743:

; 197  : 	zFree(certVerParams->userPolicySetOut);

	push	OFFSET FLAT:$SG184747
	push	197					; 000000c5H
	push	OFFSET FLAT:$SG184748
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+48]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 198  : 	certVerParams->userPolicySetCountOut = 0;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+52], 0

; 199  : 	certVerParams->userPolicySetOut = NULL;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+48], 0
$L184740:

; 200  : }
; 201  : 
; 202  : if ((certVerParams->authPolicySetCountOut != 0) && 
; 203  : 	(certVerParams->authPolicySetOut != NULL))

	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$L184749
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$L184749

; 204  : {
; 205  : 	for (i=0; i < certVerParams->authPolicySetCountOut; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L184750
$L184751:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L184750:
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+44]
	jae	SHORT $L184752

; 206  : 	{
; 207  : 		if (certVerParams->authPolicySetOut[i] != NULL)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L184753

; 208  : 		{
; 209  : 			zFree(certVerParams->authPolicySetOut[i]);

	push	OFFSET FLAT:$SG184754
	push	209					; 000000d1H
	push	OFFSET FLAT:$SG184755
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 210  : 			certVerParams->authPolicySetOut[i] = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR [ecx+edx*4], 0
$L184753:

; 211  : 		}
; 212  : 	}

	jmp	SHORT $L184751
$L184752:

; 213  : 	zFree(certVerParams->authPolicySetOut);

	push	OFFSET FLAT:$SG184756
	push	213					; 000000d5H
	push	OFFSET FLAT:$SG184757
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 214  : 	certVerParams->authPolicySetCountOut = 0;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+44], 0

; 215  : 	certVerParams->authPolicySetOut = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [eax+40], 0
$L184749:

; 216  : }
; 217  : //DebugBreak();
; 218  : if ((certVerParams->usedCrlCount != 0) &&
; 219  : 	(certVerParams->usedCrlList != NULL))

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	$L184758
	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+64], 0
	je	$L184758

; 220  : {
; 221  : 	for (i=0; i < certVerParams->usedCrlCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L184759
$L184760:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L184759:
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+60]
	jae	SHORT $L184761

; 222  : 	{
; 223  : 		if (certVerParams->usedCrlList[i] != NULL)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	DWORD PTR [ecx+edx*4], 0
	je	SHORT $L184762

; 224  : 		{
; 225  : 			zFree(certVerParams->usedCrlList[i]);

	push	OFFSET FLAT:$SG184763
	push	225					; 000000e1H
	push	OFFSET FLAT:$SG184764
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 226  : 			certVerParams->usedCrlList[i] = NULL;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR [edx+eax*4], 0
$L184762:

; 227  : 		}
; 228  : 	}

	jmp	SHORT $L184760
$L184761:

; 229  : 	zFree(certVerParams->usedCrlList);

	push	OFFSET FLAT:$SG184765
	push	229					; 000000e5H
	push	OFFSET FLAT:$SG184766
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 230  : 	certVerParams->usedCrlList = NULL;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [eax+64], 0

; 231  : 	certVerParams->usedCrlCount = 0;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+60], 0
$L184758:

; 232  : }
; 233  : 
; 234  : if (pSysTime!=NULL) {

	cmp	DWORD PTR _pSysTime$[ebp], 0
	je	SHORT $L184767

; 235  : #ifdef NSS
; 236  : SystemTimeToT64(pSysTime,&pTime);
; 237  : #else
; 238  : pTime = &pfTime;

	lea	edx, DWORD PTR _pfTime$[ebp]
	mov	DWORD PTR _pTime$[ebp], edx

; 239  : sysTimeStatus = SystemTimeToFileTime(pSysTime, pTime);

	mov	esi, esp
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pSysTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__SystemTimeToFileTime@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _sysTimeStatus$[ebp], eax

; 240  : #endif
; 241  : } else {

	jmp	SHORT $L184768
$L184767:

; 242  : #ifdef NSS
; 243  : pTime=0;
; 244  : #else
; 245  : pTime=NULL;

	mov	DWORD PTR _pTime$[ebp], 0
$L184768:

; 246  : #endif
; 247  : }
; 248  : 
; 249  : #ifdef NSS
; 250  : 	derCerts = (SECItem **) zMalloc (sizeof(SECItem *) * certNum);
; 251  : #endif
; 252  : 
; 253  : for (i=0;i<certNum;i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L184769
$L184770:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L184769:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _certNum$[ebp]
	jae	$L184771

; 254  : 	int realLen=0;

	mov	DWORD PTR _realLen$184772[ebp], 0

; 255  : #ifdef NSS	
; 256  : 	pfxBlob.len = base64decodeSize(strlen((const char *)certData[i]));
; 257  : 	pfxBlob.data = (BYTE *)zMalloc (pfxBlob.len+1);
; 258  : 	if ((realLen= base64decode(certData[i],pfxBlob.data,pfxBlob.len))==-1) {
; 259  : 		setError(pg_sig, BASE64_ERROR);
; 260  : 		err=TRUE; goto retLabel;
; 261  : 	}
; 262  : 	pfxBlob.len = realLen;
; 263  : 	derCerts[i] = (SECItem *) zMalloc(sizeof(SECItem));
; 264  : 	derCerts[i]->len = pfxBlob.len;
; 265  : 	derCerts[i]->data = (BYTE *) zMalloc(pfxBlob.len);
; 266  : 	memcpy(derCerts[i]->data,pfxBlob.data,pfxBlob.len);
; 267  : 	
; 268  : #else
; 269  : 	pfxBlob.cbData = base64decodeSize(strlen((const char *)certData[i]));

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _pfxBlob$[ebp], eax

; 270  : 	pfxBlob.pbData = (BYTE *)zMalloc (pfxBlob.cbData+1);

	push	OFFSET FLAT:$SG184775
	push	270					; 0000010eH
	push	OFFSET FLAT:$SG184776
	mov	ecx, DWORD PTR _pfxBlob$[ebp]
	add	ecx, 1
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	BYTE PTR $T187870[ebp], 1
	mov	DWORD PTR _pfxBlob$[ebp+4], eax

; 271  : 	if ((realLen= base64decode(certData[i],pfxBlob.pbData,pfxBlob.cbData))==-1) {

	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187871
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187871:
	mov	edx, DWORD PTR _pfxBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfxBlob$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _certData$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _realLen$184772[ebp], eax
	cmp	DWORD PTR _realLen$184772[ebp], -1
	jne	SHORT $L184777

; 272  : 		setError(pg_sig, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 273  : 		err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184777:

; 274  : 	}
; 275  : 	pfxBlob.cbData = realLen;

	mov	edx, DWORD PTR _realLen$184772[ebp]
	mov	DWORD PTR _pfxBlob$[ebp], edx

; 276  : #endif
; 277  : 
; 278  : // special case: if certNum =1 it may be PFX
; 279  : 	if (certNum==1 
; 280  : 		&& crIsPFX(certData[i], &pwdBlob, pg_sig)) {

	cmp	DWORD PTR _certNum$[ebp], 1
	jne	$L184780
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pwdBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _certData$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_crIsPFX
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$L184780

; 281  : 		//&& PFXIsPFXBlob(&pfxBlob)) {		
; 282  : #ifdef NSS
; 283  : 		if (!(pct = NSS_ImportPKCS12Object(&pfxBlob, password, pg_sig))) {
; 284  : 			setError(pg_sig, PFX_BAD_PASSWORD);
; 285  : 			err=TRUE; goto retLabel;
; 286  : 		}
; 287  : #else
; 288  : 		// check if we have password. For NSS it's already done by crIsPFX.
; 289  : 		if (!PFXVerifyPassword(&pfxBlob, password, CRYPT_MACHINE_KEYSET))

	mov	esi, esp
	push	32					; 00000020H
	mov	edx, DWORD PTR _password$[ebp]
	push	edx
	mov	BYTE PTR $T187870[ebp], 1
	lea	eax, DWORD PTR _pfxBlob$[ebp]
	push	eax
	call	DWORD PTR __imp__PFXVerifyPassword@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L184781

; 290  : 		{
; 291  : 			setError(pg_sig,PFX_BAD_PASSWORD);

	push	57					; 00000039H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 292  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184781:

; 293  : 		}
; 294  : 
; 295  : 		if ((hStoreHandle =  PFXImportCertStore(
; 296  : 										&pfxBlob, 
; 297  : 										password, 
; 298  : 										CRYPT_MACHINE_KEYSET | CRYPT_EXPORTABLE
; 299  : 										)) == NULL)

	mov	esi, esp
	push	33					; 00000021H
	mov	edx, DWORD PTR _password$[ebp]
	push	edx
	mov	BYTE PTR $T187870[ebp], 1
	lea	eax, DWORD PTR _pfxBlob$[ebp]
	push	eax
	call	DWORD PTR __imp__PFXImportCertStore@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hStoreHandle$[ebp], eax
	cmp	DWORD PTR _hStoreHandle$[ebp], 0
	jne	SHORT $L184786

; 300  : 		{
; 301  : 			setError(pg_sig,PFX_IMPORT_FAILED);

	push	58					; 0000003aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 302  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184786:

; 303  : 		}
; 304  : 
; 305  : 		// we need CERT_CONTEXT
; 306  : 		while(pct = CertEnumCertificatesInStore(
; 307  : 			 hStoreHandle,
; 308  : 			pct))

	mov	esi, esp
	mov	edx, DWORD PTR _pct$[ebp]
	push	edx
	mov	eax, DWORD PTR _hStoreHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__CertEnumCertificatesInStore@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pct$[ebp], eax
	cmp	DWORD PTR _pct$[ebp], 0
	je	SHORT $L184787

; 309  : 		{			
; 310  : 				int optFlag=0;

	mov	DWORD PTR _optFlag$184788[ebp], 0

; 311  : 				if (crFilterCerts(pct,&optFlag,NULL,pg_sig)) 

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _optFlag$184788[ebp]
	push	edx
	mov	eax, DWORD PTR _pct$[ebp]
	push	eax
	call	_crFilterCerts
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $L184789

; 312  : 				{
; 313  : 					cleanupError(pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 314  : 					break;

	jmp	SHORT $L184787
$L184789:

; 315  : 				}
; 316  : 		}

	jmp	SHORT $L184786
$L184787:

; 317  : #endif
; 318  : 		if (pct == NULL) {

	cmp	DWORD PTR _pct$[ebp], 0
	jne	SHORT $L184790

; 319  : 			setError(pg_sig, PFX_INVALID_CERTIFICATE);

	push	59					; 0000003bH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 320  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184790:

; 321  : 		}
; 322  : 
; 323  : 		if (!checkCertificate(	pct, 
; 324  : 								hStoreHandle, 
; 325  : 								pTime,
; 326  : 								certVerParams,
; 327  : 								pg_sig)) {

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _hStoreHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	call	?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; checkCertificate
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $L184792

; 328  : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L184792:

; 329  : 		}
; 330  : 
; 331  : // cleanup store
; 332  : #ifdef NSS
; 333  : 	if (pfxBlob.data) zFree (pfxBlob.data);
; 334  : 	pfxBlob.data = NULL;
; 335  : 	
; 336  : 	// remove certificate from database
; 337  : 	SECStatus rv = SEC_DeletePermCertificate(pct);
; 338  :     if (rv != SECSuccess) {
; 339  : 		setError(pg_sig, PFX_IMPORT_FAILED);
; 340  :     }
; 341  : #else
; 342  : 	res = CertGetCertificateContextProperty(pct,CERT_KEY_PROV_INFO_PROP_ID,NULL,&cbData);

	mov	esi, esp
	lea	edx, DWORD PTR _cbData$[ebp]
	push	edx
	push	0
	push	2
	mov	eax, DWORD PTR _pct$[ebp]
	push	eax
	call	DWORD PTR __imp__CertGetCertificateContextProperty@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 343  : 	if (!res) goto retLabel;

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $L184793
	jmp	$retLabel$184778
$L184793:

; 344  : 	provInfo = (CRYPT_KEY_PROV_INFO *) zMalloc(cbData);

	push	OFFSET FLAT:$SG184796
	push	344					; 00000158H
	push	OFFSET FLAT:$SG184797
	mov	ecx, DWORD PTR _cbData$[ebp]
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _provInfo$[ebp], eax

; 345  : 	if (!provInfo) goto retLabel;

	cmp	DWORD PTR _provInfo$[ebp], 0
	jne	SHORT $L184798
	jmp	$retLabel$184778
$L184798:

; 346  : 	res = CertGetCertificateContextProperty(pct,CERT_KEY_PROV_INFO_PROP_ID,provInfo,&cbData);

	mov	esi, esp
	lea	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _provInfo$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertGetCertificateContextProperty@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 347  : 	if (!res) goto retLabel;

	cmp	DWORD PTR _res$[ebp], 0
	jne	SHORT $L184800
	jmp	$retLabel$184778
$L184800:

; 348  : 	res = CryptAcquireContextW(&hProv, 
; 349  : 						 provInfo->pwszContainerName, 
; 350  : 						 provInfo->pwszProvName, 
; 351  : 						 provInfo->dwProvType, 
; 352  : 						 CRYPT_DELETEKEYSET |(provInfo->dwFlags  & CRYPT_MACHINE_KEYSET));

	mov	edx, DWORD PTR _provInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 32					; 00000020H
	or	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _provInfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _provInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _provInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _hProv$[ebp]
	push	ecx
	call	DWORD PTR __imp__CryptAcquireContextW@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _res$[ebp], eax

; 353  : 	zFree(provInfo);

	push	OFFSET FLAT:$SG184802
	push	353					; 00000161H
	push	OFFSET FLAT:$SG184803
	mov	edx, DWORD PTR _provInfo$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 354  : #endif
; 355  : 	goto retLabel;

	jmp	$retLabel$184778
$L184780:

; 356  :   }
; 357  : #ifndef NSS
; 358  :   else {
; 359  : 
; 360  : 	// have to add certificate to the store
; 361  : 		if (hStoreHandle == NULL) {

	cmp	DWORD PTR _hStoreHandle$[ebp], 0
	jne	SHORT $L184806

; 362  : 			if(!(hStoreHandle = CertOpenStore(
; 363  : 			CERT_STORE_PROV_MEMORY,   // The memory provider type
; 364  : 			0,                        // The encoding type is not needed
; 365  : 			(HCRYPTPROV) NULL,                     // Use the default HCRYPTPROV
; 366  : 			0,                        // Accept the default dwFlags
; 367  : 			NULL                      // pvPara is not used
; 368  : 			))) {

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	push	2
	call	DWORD PTR __imp__CertOpenStore@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hStoreHandle$[ebp], eax
	cmp	DWORD PTR _hStoreHandle$[ebp], 0
	jne	SHORT $L184806

; 369  : 				setError(pg_sig, CAPI_OPEN_STORE);

	push	112					; 00000070H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 370  : 				err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184806:

; 371  : 			}
; 372  : 		}
; 373  : 
; 374  : 	if(!(CertAddEncodedCertificateToStore(
; 375  : 		hStoreHandle,
; 376  : 		MY_ENCODING_TYPE, // The encoding type
; 377  : 		(const BYTE*) pfxBlob.pbData,   // The encoded data from the certificate retrieved
; 378  : 		pfxBlob.cbData,
; 379  : 		CERT_STORE_ADD_REPLACE_EXISTING,
; 380  : 		&pct	)))  // The length of the encoded data

	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187874
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187874:
	mov	esi, esp
	lea	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _pfxBlob$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfxBlob$[ebp+4]
	push	eax
	push	65537					; 00010001H
	mov	ecx, DWORD PTR _hStoreHandle$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertAddEncodedCertificateToStore@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L184812

; 381  : 		{
; 382  : 			setError(pg_sig, CAPI_ADD_CERT);

	push	113					; 00000071H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 383  : 			err=TRUE; goto retLabel;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$retLabel$184778
$L184812:

; 384  : 		}
; 385  : 	
; 386  : 	if (i==0) endPct = pct;	// end certificate is always the first in array

	cmp	DWORD PTR _i$[ebp], 0
	jne	SHORT $L184814
	mov	eax, DWORD PTR _pct$[ebp]
	mov	DWORD PTR _endPct$[ebp], eax

; 387  : 	else{

	jmp	SHORT $L184805
$L184814:

; 388  : 		CertFreeCertificateContext(pct);

	mov	esi, esp
	mov	ecx, DWORD PTR _pct$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCertificateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L184805:

; 389  : 	}
; 390  :   } // PFX?
; 391  : #endif
; 392  : 
; 393  : #ifdef NSS
; 394  : 	if (pfxBlob.data) zFree (pfxBlob.data);
; 395  : 	pfxBlob.data = NULL;
; 396  : #else
; 397  : 	if (pfxBlob.pbData) zFree (pfxBlob.pbData);

	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187875
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187875:
	cmp	DWORD PTR _pfxBlob$[ebp+4], 0
	je	SHORT $L184816
	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187876
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187876:
	push	OFFSET FLAT:$SG184817
	push	397					; 0000018dH
	push	OFFSET FLAT:$SG184818
	mov	edx, DWORD PTR _pfxBlob$[ebp+4]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L184816:

; 398  : 	pfxBlob.pbData = NULL;

	mov	BYTE PTR $T187870[ebp], 1
	mov	DWORD PTR _pfxBlob$[ebp+4], 0

; 399  : #endif
; 400  : 
; 401  : } // for

	jmp	$L184770
$L184771:

; 402  : 
; 403  : #ifdef NSS
; 404  : 	// for NSS, no need in loop - all certificates are imported at once
; 405  : 	// add certificate to the store and CERTList
; 406  : 	pct = NULL;
; 407  : 	rv = CERT_ImportCerts(
; 408  : 			hStoreHandle, 
; 409  : 			certUsageObjectSigner,
; 410  : 			certNum, 
; 411  : 			derCerts,
; 412  : 			&certs, 
; 413  : 			PR_FALSE,
; 414  : 			PR_FALSE, 
; 415  : 			NULL);
; 416  : 	if (rv != SECSuccess) {		
; 417  : 		setError(pg_sig, CAPI_ADD_CERT);
; 418  : 		err=TRUE; goto retLabel;
; 419  : 	}
; 420  : 
; 421  : 	endPct = certs[0];
; 422  : 
; 423  : #endif
; 424  : 
; 425  : 	// certificates now in temp store. Take the end certificate and check it.
; 426  : 	if (!checkCertificate(	endPct, 
; 427  : 		hStoreHandle, 
; 428  : 		pTime,
; 429  : 		certVerParams,
; 430  : 		pg_sig)) {

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _hStoreHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _endPct$[ebp]
	push	ecx
	call	?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ; checkCertificate
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $retLabel$184778

; 431  : 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1
$retLabel$184778:

; 432  : 	}
; 433  : 
; 434  : retLabel:
; 435  : #ifdef NSS
; 436  : // cleanup DER list
; 437  : for (i=0;i<certNum;i++) {
; 438  : 	zFree(derCerts[i]->data);
; 439  : 	zFree(derCerts[i]);
; 440  : }
; 441  : zFree(derCerts);
; 442  : 
; 443  : // go through cert array and delete all certificates
; 444  : if (certs != NULL) CERT_DestroyCertArray(certs, certNum);
; 445  : if (pct) CERT_DestroyCertificate(pct);
; 446  : 
; 447  : #else
; 448  : // cleanup store
; 449  : if (endPct) CertFreeCertificateContext(endPct);

	cmp	DWORD PTR _endPct$[ebp], 0
	je	SHORT $L184820
	mov	esi, esp
	mov	edx, DWORD PTR _endPct$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCertificateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L184820:

; 450  : if (hStoreHandle) {

	cmp	DWORD PTR _hStoreHandle$[ebp], 0
	je	SHORT $L184821

; 451  : 	CertCloseStore(hStoreHandle,CERT_CLOSE_STORE_FORCE_FLAG);

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _hStoreHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__CertCloseStore@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$L184821:

; 452  : }
; 453  : #endif
; 454  : 
; 455  : #ifdef NSS
; 456  : if (pfxBlob.data) zFree (pfxBlob.data);
; 457  : #else
; 458  : if (pfxBlob.pbData) zFree (pfxBlob.pbData);

	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187877
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187877:
	cmp	DWORD PTR _pfxBlob$[ebp+4], 0
	je	SHORT $L184822
	cmp	BYTE PTR $T187870[ebp], 0
	jne	SHORT $L187878
	push	OFFSET FLAT:$L187872
	call	__RTC_UninitUse
	add	esp, 4
$L187878:
	push	OFFSET FLAT:$SG184823
	push	458					; 000001caH
	push	OFFSET FLAT:$SG184824
	mov	ecx, DWORD PTR _pfxBlob$[ebp+4]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H
$L184822:

; 459  : #endif
; 460  : if (err) 

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L184825

; 461  : 	return FALSE;

	xor	eax, eax
	jmp	SHORT $L184718
$L184825:

; 462  : else 
; 463  : 	return TRUE;

	mov	eax, 1
$L184718:

; 464  : 
; 465  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L187887
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 148				; 00000094H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L187887:
	DD	7
	DD	$L187886
$L187886:
	DD	-44					; ffffffd4H
	DD	8
	DD	$L187872
	DD	-24					; ffffffe8H
	DD	4
	DD	$L187880
	DD	-56					; ffffffc8H
	DD	4
	DD	$L187881
	DD	-80					; ffffffb0H
	DD	8
	DD	$L187882
	DD	-108					; ffffff94H
	DD	4
	DD	$L187883
	DD	-124					; ffffff84H
	DD	8
	DD	$L187884
	DD	-140					; ffffff74H
	DD	4
	DD	$L187885
$L187885:
	DB	111					; 0000006fH
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	70					; 00000046H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	0
$L187884:
	DB	112					; 00000070H
	DB	119					; 00000077H
	DB	100					; 00000064H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
$L187883:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	68					; 00000044H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
$L187882:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L187881:
	DB	112					; 00000070H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	0
$L187880:
	DB	104					; 00000068H
	DB	80					; 00000050H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	118					; 00000076H
	DB	0
$L187872:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	120					; 00000078H
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	0
?crVerifyCertificate@@YAHPAPAEIPAU_SYSTEMTIME@@PAGPAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; crVerifyCertificate
_TEXT	ENDS
PUBLIC	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor'
PUBLIC	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
PUBLIC	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
PUBLIC	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
PUBLIC	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ	; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
PUBLIC	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
PUBLIC	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	__imp__CertCompareCertificate@12:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	_memset:NEAR
EXTRN	_strcpy:NEAR
EXTRN	__imp__CertGetCertificateChain@32:NEAR
EXTRN	__imp__CertFreeCertificateChain@4:NEAR
EXTRN	_getCRLDist:NEAR
EXTRN	_certIsNameChainOK:NEAR
EXTRN	_certIsBasicExtensionConstraintOK:NEAR
EXTRN	_certIsPathLengthConstraintOK:NEAR
EXTRN	_certIsKeyUsageOK:NEAR
EXTRN	_getAuthConstrainedPolicySet:NEAR
EXTRN	_getUserConstrainedPolicySet:NEAR
EXTRN	__imp__CertCreateCertificateContext@12:NEAR
xdata$x	SEGMENT
$T187933 DD	0ffffffffH
	DD	FLAT:$L187914
	DD	0ffffffffH
	DD	FLAT:$L187915
$T187919 DD	019930520H
	DD	02H
	DD	FLAT:$T187933
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv811 = -300						; size = 4
tv708 = -296						; size = 4
tv697 = -292						; size = 4
tv361 = -288						; size = 4
tv338 = -284						; size = 4
$T187911 = -280						; size = 4
$T187910 = -276						; size = 4
$T187909 = -272						; size = 4
$T187908 = -268						; size = 4
$T187907 = -264						; size = 4
$T187904 = -260						; size = 4
$T187903 = -256						; size = 4
$T187900 = -252						; size = 4
$T187899 = -248						; size = 4
$T187898 = -244						; size = 4
$T187897 = -240						; size = 4
$T187896 = -236						; size = 4
$T187893 = -232						; size = 4
$T187892 = -228						; size = 4
_crlIndex$185595 = -224					; size = 4
_iList$185594 = -216					; size = 4
_listSize$185587 = -208					; size = 4
_usedCrlList$185570 = -204				; size = 4
_crlIndex$185551 = -200					; size = 4
_iList$185550 = -192					; size = 4
_listSize$185466 = -184					; size = 4
_usedCrlList$184952 = -180				; size = 4
_result$ = -176						; size = 4
_crlFound$ = -168					; size = 4
_rootCertIndex$ = -160					; size = 4
_pct$ = -156						; size = 4
_cbData$ = -152						; size = 4
_pbData$ = -148						; size = 4
_trustedRootFound$ = -144				; size = 4
_i$ = -140						; size = 4
_explicitPolicyCount$ = -136				; size = 4
_userConstPolCount$ = -132				; size = 4
_userConstPolSet$ = -128				; size = 4
_authConstPolCount$ = -124				; size = 4
_authConstPolSet$ = -120				; size = 4
_crlCertUrl$ = -116					; size = 4
_crlList$ = -112					; size = 4
_crlCount$ = -108					; size = 4
_checkCRLFailed$ = -104					; size = 4
_issuerIndex$ = -100					; size = 4
_certIndex$ = -96					; size = 4
_err$ = -92						; size = 4
_dwFlag$ = -88						; size = 4
_pChainContext$ = -80					; size = 4
_CertUsage$ = -68					; size = 12
_EnhkeyUsage$ = -48					; size = 8
_ChainPara$ = -32					; size = 16
__$EHRec$ = -12						; size = 12
_pCertContext$ = 8					; size = 4
_hStoreHandle$ = 12					; size = 4
_pTime$ = 16						; size = 4
_certVerParams$ = 20					; size = 4
_pg_sig$ = 24						; size = 4
?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; checkCertificate

; 1006 : 							 PGLOBAL_SIG pg_sig) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 288				; 00000120H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-300]
	mov	ecx, 72					; 00000048H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1007 : // chain parameters
; 1008 : CERT_CHAIN_PARA ChainPara;
; 1009 : CERT_ENHKEY_USAGE EnhkeyUsage;
; 1010 : CERT_USAGE_MATCH  CertUsage;  
; 1011 : PCCERT_CHAIN_CONTEXT     pChainContext=NULL;

	mov	DWORD PTR _pChainContext$[ebp], 0

; 1012 : DWORD dwFlag = 0;

	mov	DWORD PTR _dwFlag$[ebp], 0

; 1013 : int err=0;

	mov	DWORD PTR _err$[ebp], 0

; 1014 : UINT certIndex, issuerIndex;
; 1015 : BOOL checkCRLFailed;
; 1016 : UINT crlCount;
; 1017 : LPSTR *crlList;
; 1018 : BYTE *crlCertUrl=NULL;

	mov	DWORD PTR _crlCertUrl$[ebp], 0

; 1019 : LPSTR *authConstPolSet=NULL;

	mov	DWORD PTR _authConstPolSet$[ebp], 0

; 1020 : UINT	authConstPolCount=0;

	mov	DWORD PTR _authConstPolCount$[ebp], 0

; 1021 : LPSTR *userConstPolSet=NULL;

	mov	DWORD PTR _userConstPolSet$[ebp], 0

; 1022 : UINT	userConstPolCount=0;

	mov	DWORD PTR _userConstPolCount$[ebp], 0

; 1023 : UINT	explicitPolicyCount;
; 1024 : UINT i;
; 1025 : BOOL trustedRootFound=FALSE;

	mov	DWORD PTR _trustedRootFound$[ebp], 0

; 1026 : unsigned char *pbData;
; 1027 : UINT	cbData;
; 1028 : CERT_CONTEXT *pct;
; 1029 : DWORD rootCertIndex;
; 1030 : BOOL crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1031 : BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 1032 : 
; 1033 : // create chain 
; 1034 : 		EnhkeyUsage.cUsageIdentifier = 0;

	mov	DWORD PTR _EnhkeyUsage$[ebp], 0

; 1035 : 		EnhkeyUsage.rgpszUsageIdentifier=NULL;

	mov	DWORD PTR _EnhkeyUsage$[ebp+4], 0

; 1036 : 		CertUsage.dwType = USAGE_MATCH_TYPE_AND;

	mov	DWORD PTR _CertUsage$[ebp], 0

; 1037 : 		CertUsage.Usage  = EnhkeyUsage;

	mov	eax, DWORD PTR _EnhkeyUsage$[ebp]
	mov	DWORD PTR _CertUsage$[ebp+4], eax
	mov	ecx, DWORD PTR _EnhkeyUsage$[ebp+4]
	mov	DWORD PTR _CertUsage$[ebp+8], ecx

; 1038 : 		ChainPara.cbSize = sizeof(CERT_CHAIN_PARA);

	mov	DWORD PTR _ChainPara$[ebp], 16		; 00000010H

; 1039 : 		ChainPara.RequestedUsage=CertUsage;

	mov	edx, DWORD PTR _CertUsage$[ebp]
	mov	DWORD PTR _ChainPara$[ebp+4], edx
	mov	eax, DWORD PTR _CertUsage$[ebp+4]
	mov	DWORD PTR _ChainPara$[ebp+8], eax
	mov	ecx, DWORD PTR _CertUsage$[ebp+8]
	mov	DWORD PTR _ChainPara$[ebp+12], ecx

; 1040 : 
; 1041 : 		//if ((certVerParams->verificationOptions & VERIFY_CRL) &&
; 1042 : 		//	(certVerParams->altCrlCount == 0))
; 1043 : 		//	dwFlag = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
; 1044 : 
; 1045 : 		if(!CertGetCertificateChain(
; 1046 : 			NULL,                  // Use the default chain engine.
; 1047 : 			pCertContext,          // Pointer to the end certificate.
; 1048 : 			pTime,                 // Use the default time (NULL) or specified
; 1049 : 			hStoreHandle,          // Search the temporary store for PFX files.
; 1050 : 			&ChainPara,            // Use AND logic, and enhanced key usage 
; 1051 : 								   // as indicated in the ChainPara 
; 1052 : 								   // data structure.
; 1053 : 			dwFlag,
; 1054 : 			NULL,                  // Currently reserved.
; 1055 : 			&pChainContext))       // Return a pointer to the chain created.

	mov	esi, esp
	lea	edx, DWORD PTR _pChainContext$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _dwFlag$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ChainPara$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hStoreHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCertContext$[ebp]
	push	ecx
	push	0
	call	DWORD PTR __imp__CertGetCertificateChain@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L184860

; 1056 : 		{
; 1057 : 			setError (pg_sig, CAPI_GET_CERT_CHAIN);

	push	114					; 00000072H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1058 : 			return FALSE;

	xor	eax, eax
	jmp	$L184833
$L184860:

; 1059 : 		}
; 1060 : 
; 1061 : //DebugBreak();
; 1062 : 		if (certVerParams->verificationOptions & EXPLICIT_TRUST)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 32					; 00000020H
	je	$L184861

; 1063 : 		{
; 1064 : 			if ((certVerParams->trustRootCertCount == 0) ||
; 1065 : 				(certVerParams->trustRootCerts == NULL))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $L184863
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $L184862
$L184863:

; 1066 : 			{
; 1067 : 				setError(pg_sig, CERT_UNTRUSTED_ROOT);

	push	81					; 00000051H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1068 : 				err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1069 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184862:

; 1070 : 			}
; 1071 : 			rootCertIndex = pChainContext->rgpChain[0]->cElement - 1;

	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, 1
	mov	DWORD PTR _rootCertIndex$[ebp], edx

; 1072 : 			for (i=0; i < certVerParams->trustRootCertCount; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L184866
$L184867:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L184866:
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jae	$L184868

; 1073 : 			{
; 1074 : 				cbData = base64decodeSize(strlen(certVerParams->trustRootCerts[i]));

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _cbData$[ebp], eax

; 1075 : 				pbData = (unsigned char *) zMalloc (cbData+1);

	push	OFFSET FLAT:$SG184870
	push	1075					; 00000433H
	push	OFFSET FLAT:$SG184871
	mov	ecx, DWORD PTR _cbData$[ebp]
	add	ecx, 1
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pbData$[ebp], eax

; 1076 : 				if (pbData == NULL)

	cmp	DWORD PTR _pbData$[ebp], 0
	jne	SHORT $L184872

; 1077 : 				{
; 1078 : 					setError(pg_sig, MEMORY_FAULT);

	push	7
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1079 : 					err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$184864
$L184872:

; 1080 : 				}
; 1081 : 				memset(pbData,0x00,cbData);

	mov	eax, DWORD PTR _cbData$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1082 : 				cbData = base64decode(	(unsigned char *)certVerParams->trustRootCerts[i],
; 1083 : 									pbData,
; 1084 : 									cbData);

	mov	edx, DWORD PTR _cbData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cbData$[ebp], eax

; 1085 : 				if (cbData == -1) 

	cmp	DWORD PTR _cbData$[ebp], -1
	jne	SHORT $L184875

; 1086 : 				{
; 1087 : 					setError(pg_sig, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1088 : 					zFree(pbData);

	push	OFFSET FLAT:$SG184876
	push	1088					; 00000440H
	push	OFFSET FLAT:$SG184877
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1089 : 					err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$184864
$L184875:

; 1090 : 				}
; 1091 : 				if(!(pct = (CERT_CONTEXT *) CertCreateCertificateContext(
; 1092 : 					MY_ENCODING_TYPE  ,            // The encoding type
; 1093 : 					pbData,   // The encoded data from the certificate retrieved
; 1094 : 					cbData)))  // The length of the encoded data

	mov	esi, esp
	mov	ecx, DWORD PTR _cbData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbData$[ebp]
	push	edx
	push	65537					; 00010001H
	call	DWORD PTR __imp__CertCreateCertificateContext@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pct$[ebp], eax
	cmp	DWORD PTR _pct$[ebp], 0
	jne	SHORT $L184880

; 1095 : 				{
; 1096 : 					setError(pg_sig, CAPI_CREATE_CERT_CNTX);

	push	108					; 0000006cH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1097 : 					zFree(pbData);

	push	OFFSET FLAT:$SG184881
	push	1097					; 00000449H
	push	OFFSET FLAT:$SG184882
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1098 : 					err=TRUE; goto exitCheckCertificate;

	mov	DWORD PTR _err$[ebp], 1
	jmp	$exitCheckCertificate$184864
$L184880:

; 1099 : 				}
; 1100 : 				if (CertCompareCertificate(	MY_ENCODING_TYPE,
; 1101 : 											pct->pCertInfo,
; 1102 : 											pChainContext->rgpChain[0]->rgpElement[rootCertIndex]->pCertContext->pCertInfo
; 1103 : 											))

	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _rootCertIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, esp
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pct$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	push	65537					; 00010001H
	call	DWORD PTR __imp__CertCompareCertificate@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L184884

; 1104 : 				{
; 1105 : 					trustedRootFound = TRUE;

	mov	DWORD PTR _trustedRootFound$[ebp], 1

; 1106 : 					CertFreeCertificateContext(pct);

	mov	esi, esp
	mov	eax, DWORD PTR _pct$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCertificateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1107 : 					zFree(pbData);

	push	OFFSET FLAT:$SG184885
	push	1107					; 00000453H
	push	OFFSET FLAT:$SG184886
	mov	ecx, DWORD PTR _pbData$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1108 : 					break;

	jmp	SHORT $L184868
$L184884:

; 1109 : 				}
; 1110 : 				CertFreeCertificateContext(pct);

	mov	esi, esp
	mov	edx, DWORD PTR _pct$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCertificateContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1111 : 				zFree(pbData);

	push	OFFSET FLAT:$SG184887
	push	1111					; 00000457H
	push	OFFSET FLAT:$SG184888
	mov	eax, DWORD PTR _pbData$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1112 : 			}

	jmp	$L184867
$L184868:

; 1113 : 			if (trustedRootFound == FALSE)

	cmp	DWORD PTR _trustedRootFound$[ebp], 0
	jne	SHORT $L184861

; 1114 : 			{
; 1115 : 				setError(pg_sig, CERT_UNTRUSTED_ROOT);

	push	81					; 00000051H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1116 : 				err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1117 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184861:

; 1118 : 			}
; 1119 : 		}
; 1120 : 
; 1121 : 		if (certVerParams->verificationOptions & VERIFY_CHAIN)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 4
	je	$L184891

; 1122 : 		{
; 1123 : 			if (!certIsBasicExtensionConstraintOK(pChainContext, pg_sig))

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	push	edx
	call	_certIsBasicExtensionConstraintOK
	add	esp, 8
	test	eax, eax
	jne	SHORT $L184892

; 1124 : 			{
; 1125 : 				setError(pg_sig, BASIC_CONSTRAINT_ERR);

	push	84					; 00000054H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1126 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1127 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184892:

; 1128 : 			}
; 1129 : 
; 1130 : 			if (!certIsKeyUsageOK(pChainContext, pg_sig))

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	push	edx
	call	_certIsKeyUsageOK
	add	esp, 8
	test	eax, eax
	jne	SHORT $L184894

; 1131 : 			{
; 1132 : 				setError(pg_sig, CERT_KEY_USAGE_ERR);

	push	85					; 00000055H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1133 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1134 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184894:

; 1135 : 			}
; 1136 : 
; 1137 : 			if (!certIsNameChainOK(pChainContext))

	mov	ecx, DWORD PTR _pChainContext$[ebp]
	push	ecx
	call	_certIsNameChainOK
	add	esp, 4
	test	eax, eax
	jne	SHORT $L184896

; 1138 : 			{
; 1139 : 				setError(pg_sig, CERT_INVALID_CHAIN);

	push	83					; 00000053H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1140 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1141 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184896:

; 1142 : 			}
; 1143 : 
; 1144 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 1
	je	SHORT $L184898

; 1145 : 			{
; 1146 : 				setError(pg_sig, CERT_TIME_INVALID);

	push	76					; 0000004cH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1147 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1148 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184898:

; 1149 : 			}
; 1150 : 
; 1151 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_TIME_NESTED)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 2
	je	SHORT $L184900

; 1152 : 			{
; 1153 : 				setError(pg_sig, CERT_TIME_NOT_NESTED);

	push	77					; 0000004dH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1154 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1155 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184900:

; 1156 : 			}
; 1157 : 
; 1158 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 8
	je	SHORT $L184902

; 1159 : 			{
; 1160 : 				setError(pg_sig, CERT_SIGNATURE_INVALID);

	push	78					; 0000004eH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1161 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1162 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184902:

; 1163 : 			}
; 1164 : 
; 1165 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 16					; 00000010H
	je	SHORT $L184904

; 1166 : 			{
; 1167 : 				setError(pg_sig, CERT_INVALID_USAGE);

	push	79					; 0000004fH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1168 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1169 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184904:

; 1170 : 			}
; 1171 : 
; 1172 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 32					; 00000020H
	je	SHORT $L184906

; 1173 : 			{
; 1174 : 				setError(pg_sig, CERT_UNTRUSTED_ROOT);

	push	81					; 00000051H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1175 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1176 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184906:

; 1177 : 			}
; 1178 : 
; 1179 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_CYCLIC)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 128				; 00000080H
	je	SHORT $L184908

; 1180 : 			{
; 1181 : 				setError(pg_sig, CERT_TRUST_CYCLIC);

	push	82					; 00000052H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1182 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1183 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184908:

; 1184 : 			}
; 1185 : 
; 1186 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_PARTIAL_CHAIN)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 65536				; 00010000H
	je	SHORT $L184910

; 1187 : 			{
; 1188 : 				setError(pg_sig, CERT_PARTIAL_CHAIN);

	push	80					; 00000050H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1189 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1190 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184910:

; 1191 : 			}
; 1192 : 
; 1193 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 131072				; 00020000H
	je	SHORT $L184912

; 1194 : 			{
; 1195 : 				setError(pg_sig, CERT_TIME_INVALID);

	push	76					; 0000004cH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1196 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1197 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184912:

; 1198 : 			}
; 1199 : 
; 1200 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 262144				; 00040000H
	je	SHORT $L184914

; 1201 : 			{
; 1202 : 				setError(pg_sig, CERT_SIGNATURE_INVALID);

	push	78					; 0000004eH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1203 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1204 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184914:

; 1205 : 			}
; 1206 : 
; 1207 : 			if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	and	ecx, 524288				; 00080000H
	je	SHORT $L184891

; 1208 : 			{
; 1209 : 				setError(pg_sig, CERT_INVALID_USAGE);

	push	79					; 0000004fH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1210 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1211 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184891:

; 1212 : 			}
; 1213 : 		}
; 1214 : 
; 1215 : 		if (certVerParams->verificationOptions & VERIFY_PATH_LENGTH)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 8
	je	SHORT $L184918

; 1216 : 		{
; 1217 : 			if (!certIsPathLengthConstraintOK(pChainContext, pg_sig))

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	mov	eax, DWORD PTR _pChainContext$[ebp]
	push	eax
	call	_certIsPathLengthConstraintOK
	add	esp, 8
	test	eax, eax
	jne	SHORT $L184918

; 1218 : 			{
; 1219 : 				setError(pg_sig, CERT_PATHLEN_ERR);

	push	90					; 0000005aH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1220 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1221 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184918:

; 1222 : 			}
; 1223 : 		}
; 1224 : 
; 1225 : 		if (certVerParams->verificationOptions & VERIFY_POLICY)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 2
	je	$L184921

; 1226 : 		{
; 1227 : //DebugBreak();			
; 1228 : 			if (certVerParams->verificationOptions & POLICY_EXPLICIT)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 16					; 00000010H
	je	SHORT $L184922

; 1229 : 				explicitPolicyCount = 0;

	mov	DWORD PTR _explicitPolicyCount$[ebp], 0

; 1230 : 			else

	jmp	SHORT $L184923
$L184922:

; 1231 : 				explicitPolicyCount = pChainContext->rgpChain[0]->cElement + 1;

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 1
	mov	DWORD PTR _explicitPolicyCount$[ebp], eax
$L184923:

; 1232 : 
; 1233 : 			certVerParams->authPolicySetOut = getAuthConstrainedPolicySet(pChainContext,
; 1234 : 															explicitPolicyCount,
; 1235 : 															&certVerParams->explicitPolicyInd,// out
; 1236 : 															&certVerParams->authPolicySetCountOut);

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _explicitPolicyCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainContext$[ebp]
	push	ecx
	call	_getAuthConstrainedPolicySet
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+40], eax

; 1237 : 			if (certVerParams->verificationOptions & POLICY_EXPLICIT)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 16					; 00000010H
	je	SHORT $L184924

; 1238 : 			{
; 1239 : 				if (certVerParams->authPolicySetCountOut == 0)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+44], 0
	jne	SHORT $L184924

; 1240 : 				{
; 1241 : 					certVerParams->userPolicySetCountOut=0;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [eax+52], 0

; 1242 : 					setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1243 : 					err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1244 : 					goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184924:

; 1245 : 				}
; 1246 : 			}
; 1247 : 			// this function returns Auth Constraint policy set if user policy is ANY
; 1248 : 			certVerParams->userPolicySetOut = getUserConstrainedPolicySet(pChainContext,
; 1249 : 															certVerParams->userPolicySet,
; 1250 : 															certVerParams->userPolicyCount,
; 1251 : 															explicitPolicyCount,
; 1252 : 															&certVerParams->explicitPolicyInd,		// out
; 1253 : 															&certVerParams->userPolicySetCountOut);			

	mov	edx, DWORD PTR _certVerParams$[ebp]
	add	edx, 52					; 00000034H
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _explicitPolicyCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _pChainContext$[ebp]
	push	eax
	call	_getUserConstrainedPolicySet
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 1254 : 
; 1255 : 			if ((certVerParams->verificationOptions & POLICY_EXPLICIT) && 
; 1256 : 				(certVerParams->userPolicySetCountOut == 0))

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $L184927
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $L184927

; 1257 : 			{
; 1258 : 				if (certVerParams->userPolicySetCountOut == 0)

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $L184927

; 1259 : 				{
; 1260 : 					setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1261 : 					err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1262 : 					goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184927:

; 1263 : 				}
; 1264 : 			}
; 1265 : 			if ((certVerParams->explicitPolicyInd == 0) &&
; 1266 : 				(certVerParams->userPolicySetCountOut == 0))

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $L184921
	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $L184921

; 1267 : 			{
; 1268 : 				setError(pg_sig, CERT_POLICY_ERROR);

	push	86					; 00000056H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1269 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1270 : 				goto exitCheckCertificate;

	jmp	$exitCheckCertificate$184864
$L184921:

; 1271 : 			}
; 1272 : 											 
; 1273 : 		}
; 1274 : 
; 1275 : 		err=TRUE;

	mov	DWORD PTR _err$[ebp], 1

; 1276 : 
; 1277 : 		switch(pChainContext->TrustStatus.dwErrorStatus)

	mov	ecx, DWORD PTR _pChainContext$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv338[ebp], edx
	cmp	DWORD PTR tv338[ebp], 64		; 00000040H
	ja	SHORT $L187890
	cmp	DWORD PTR tv338[ebp], 64		; 00000040H
	je	$L184943
	cmp	DWORD PTR tv338[ebp], 32		; 00000020H
	ja	$L184950
	mov	eax, DWORD PTR tv338[ebp]
	movzx	ecx, BYTE PTR $L187920[eax]
	jmp	DWORD PTR $L187932[ecx*4]
$L187890:
	cmp	DWORD PTR tv338[ebp], 262144		; 00040000H
	ja	SHORT $L187891
	cmp	DWORD PTR tv338[ebp], 262144		; 00040000H
	je	SHORT $L184947
	cmp	DWORD PTR tv338[ebp], 128		; 00000080H
	je	SHORT $L184944
	cmp	DWORD PTR tv338[ebp], 65536		; 00010000H
	je	SHORT $L184945
	cmp	DWORD PTR tv338[ebp], 131072		; 00020000H
	je	SHORT $L184946
	jmp	SHORT $L184950
$L187891:
	cmp	DWORD PTR tv338[ebp], 524288		; 00080000H
	je	SHORT $L184948
	cmp	DWORD PTR tv338[ebp], 16777216		; 01000000H
	je	SHORT $L184949
	jmp	SHORT $L184950
$L184936:

; 1278 : 		{
; 1279 : 		case CERT_TRUST_NO_ERROR :
; 1280 : 			err=FALSE;

	mov	DWORD PTR _err$[ebp], 0

; 1281 : 			break;

	jmp	SHORT $L184933
$L184937:

; 1282 : 		case CERT_TRUST_IS_NOT_TIME_VALID: 
; 1283 : 			break;

	jmp	SHORT $L184933
$L184938:

; 1284 : 		case CERT_TRUST_IS_NOT_TIME_NESTED: 
; 1285 : 			break;

	jmp	SHORT $L184933
$L184939:

; 1286 : 		case CERT_TRUST_IS_REVOKED:
; 1287 : 			err=TRUE; // Don't pay attention to CAPI. We will validate CRL ourselves

	mov	DWORD PTR _err$[ebp], 1

; 1288 : 			break;

	jmp	SHORT $L184933
$L184940:

; 1289 : 		case CERT_TRUST_IS_NOT_SIGNATURE_VALID:
; 1290 : 			setError(pg_sig,CRL_BAD_SIGNATURE);

	push	72					; 00000048H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1291 : 			break;

	jmp	SHORT $L184933
$L184941:

; 1292 : 		case CERT_TRUST_IS_NOT_VALID_FOR_USAGE:
; 1293 : 			break;

	jmp	SHORT $L184933
$L184942:

; 1294 : 		case CERT_TRUST_IS_UNTRUSTED_ROOT:
; 1295 : 			break;

	jmp	SHORT $L184933
$L184943:

; 1296 : 		case CERT_TRUST_REVOCATION_STATUS_UNKNOWN:
; 1297 : 			break;

	jmp	SHORT $L184933
$L184944:

; 1298 : 		case CERT_TRUST_IS_CYCLIC :
; 1299 : 			break;

	jmp	SHORT $L184933
$L184945:

; 1300 : 		case CERT_TRUST_IS_PARTIAL_CHAIN: 
; 1301 : 			break;

	jmp	SHORT $L184933
$L184946:

; 1302 : 		case CERT_TRUST_CTL_IS_NOT_TIME_VALID: 
; 1303 : 			break;

	jmp	SHORT $L184933
$L184947:

; 1304 : 		case CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID: 
; 1305 : 			break;

	jmp	SHORT $L184933
$L184948:

; 1306 : 		case CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE: 
; 1307 : 			break;

	jmp	SHORT $L184933
$L184949:

; 1308 : 		case CERT_TRUST_IS_OFFLINE_REVOCATION:
; 1309 : 			break;

	jmp	SHORT $L184933
$L184950:

; 1310 : 		default:
; 1311 : 			err=TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L184933:

; 1312 : 			break;
; 1313 : 		} // End switch
; 1314 : 
; 1315 : 
; 1316 : 		if (certVerParams->verificationOptions & VERIFY_CRL)

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 1
	je	$L184951

; 1317 : 		{
; 1318 : //DebugBreak();
; 1319 : 			//if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED)
; 1320 : 			//{
; 1321 : 			//	setError(pg_sig, CRL_CERT_REVOKED);
; 1322 : 			//	err = TRUE;
; 1323 : 			//	goto exitCheckCertificate;
; 1324 : 			//}
; 1325 : 
; 1326 : 			CrlList *usedCrlList = new CrlList();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T187893[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T187893[ebp], 0
	je	SHORT $L187894
	mov	ecx, DWORD PTR $T187893[ebp]
	call	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
	mov	DWORD PTR tv361[ebp], eax
	jmp	SHORT $L187895
$L187894:
	mov	DWORD PTR tv361[ebp], 0
$L187895:
	mov	edx, DWORD PTR tv361[ebp]
	mov	DWORD PTR $T187892[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T187892[ebp]
	mov	DWORD PTR _usedCrlList$184952[ebp], eax

; 1327 : 
; 1328 : 			checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 1329 : 			for (certIndex=0; certIndex < pChainContext->rgpChain[0]->cElement; certIndex++)

	mov	DWORD PTR _certIndex$[ebp], 0
	jmp	SHORT $L185392
$L185393:
	mov	ecx, DWORD PTR _certIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _certIndex$[ebp], ecx
$L185392:
	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _certIndex$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	$L185394

; 1330 : 			{
; 1331 : 				//DebugBreak();
; 1332 : 				if (certIndex == pChainContext->rgpChain[0]->cElement - 1)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	cmp	DWORD PTR _certIndex$[ebp], eax
	jne	SHORT $L185395

; 1333 : 					issuerIndex = certIndex;

	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	DWORD PTR _issuerIndex$[ebp], ecx

; 1334 : 				else

	jmp	SHORT $L185396
$L185395:

; 1335 : 					issuerIndex = certIndex+1;

	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _issuerIndex$[ebp], edx
$L185396:

; 1336 : 
; 1337 : 				if ((certVerParams->altCrlCount != 0) &&
; 1338 : 					(certVerParams->crlAltUrl != NULL))//Local CRL Location is given, so use that first

	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	$L185397
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	$L185397

; 1339 : 				{
; 1340 : 					crlCount = certVerParams->altCrlCount;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _crlCount$[ebp], eax

; 1341 : 					crlList = certVerParams->crlAltUrl;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _crlList$[ebp], edx

; 1342 : 					result = check_CRL (	hStoreHandle, 
; 1343 : 											pChainContext->rgpChain[0]->rgpElement[certIndex]->pCertContext, 
; 1344 : 									pChainContext->rgpChain[0]->rgpElement[issuerIndex]->pCertContext,
; 1345 : 									pTime,
; 1346 : 									certVerParams->pCrlCache,
; 1347 : 									crlList,
; 1348 : 									crlCount,
; 1349 : 									FALSE,
; 1350 : 									&crlFound,
; 1351 : 									usedCrlList,
; 1352 : 									pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$184952[ebp]
	push	ecx
	lea	edx, DWORD PTR _crlFound$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _crlCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _issuerIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _hStoreHandle$[ebp]
	push	ecx
	call	?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 1353 : 					if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L185397

; 1354 : 					{
; 1355 : 						if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L185399

; 1356 : 						{
; 1357 : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1358 : 							break; // At least one of the certificates in the chain has a problem

	jmp	$L185394
$L185399:

; 1359 : 						}
; 1360 : 						else // CRL validation was successful
; 1361 : 						{
; 1362 : 							crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 1363 : 							checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 1364 : 							continue; // check the next certificate in the chain

	jmp	$L185393
$L185397:

; 1365 : 						}
; 1366 : 					}
; 1367 : 				}
; 1368 : 				if ((crlFound == TRUE) && (checkCRLFailed == FALSE)) // The whole chain validated successfully

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L185401
	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L185401

; 1369 : 					break;

	jmp	$L185394
$L185401:

; 1370 : 				else
; 1371 : 				{// CRL was not found in the given CRL Location list. Try certificate CRL DP
; 1372 : //DebugBreak();
; 1373 : 					crlCertUrl = getCRLDist(pChainContext->rgpChain[0]->rgpElement[certIndex]->pCertContext);

	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _certIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_getCRLDist
	add	esp, 4
	mov	DWORD PTR _crlCertUrl$[ebp], eax

; 1374 : 					if (crlCertUrl == NULL)

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	jne	$L185403

; 1375 : 					{
; 1376 : 						if ( certIndex != 0)

	cmp	DWORD PTR _certIndex$[ebp], 0
	je	$L185404

; 1377 : 						{
; 1378 : 							// If this is the root certificate, then the CRL may be
; 1379 : 							// available from the first intermediate certificate
; 1380 : 							// since the issuers for both are the root CA
; 1381 : 							if (certIndex == pChainContext->rgpChain[0]->cElement - 1)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	cmp	DWORD PTR _certIndex$[ebp], eax
	jne	SHORT $L185405

; 1382 : 							{
; 1383 : 								crlCertUrl = getCRLDist(pChainContext->rgpChain[0]->rgpElement[certIndex -1]->pCertContext);

	mov	ecx, DWORD PTR _pChainContext$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _certIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4-4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_getCRLDist
	add	esp, 4
	mov	DWORD PTR _crlCertUrl$[ebp], eax

; 1384 : 								if (crlCertUrl == NULL)

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	jne	SHORT $L185406

; 1385 : 								{//No CRL DP present and none of the given CRL Locations, if any, matched
; 1386 : 									crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1387 : 									checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1388 : 									setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1389 : 									break;

	jmp	$L185394
$L185406:

; 1390 : 								}
; 1391 : 								else
; 1392 : 								{// CRL Location Found
; 1393 : 									crlCount = 1;

	mov	DWORD PTR _crlCount$[ebp], 1

; 1394 : 									crlList = (LPSTR *)zMalloc(sizeof (char *));

	push	OFFSET FLAT:$SG185410
	push	1394					; 00000572H
	push	OFFSET FLAT:$SG185411
	push	4
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _crlList$[ebp], eax

; 1395 : 									crlList[0] = (LPSTR)crlCertUrl;

	mov	eax, DWORD PTR _crlList$[ebp]
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	mov	DWORD PTR [eax], ecx

; 1396 : 								}
; 1397 : 							}
; 1398 : 							else

	jmp	SHORT $L185413
$L185405:

; 1399 : 							{//No CRL DP present and none of the given CRL Locations, if any, matched
; 1400 : 								crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1401 : 								checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1402 : 								setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1403 : 								break;

	jmp	$L185394
$L185413:

; 1404 : 							}
; 1405 : 						}
; 1406 : 						else

	jmp	SHORT $L185414
$L185404:

; 1407 : 						{//No CRL DP present and none of the given CRL Locations, if any, matched
; 1408 : 							crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1409 : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1410 : 							setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1411 : 							break;

	jmp	$L185394
$L185414:

; 1412 : 						}
; 1413 : 					}
; 1414 : 					else

	jmp	SHORT $L185415
$L185403:

; 1415 : 					{// CRL Location Found
; 1416 : 						crlCount = 1;

	mov	DWORD PTR _crlCount$[ebp], 1

; 1417 : 						crlList = (LPSTR *)zMalloc(sizeof (char *));

	push	OFFSET FLAT:$SG185418
	push	1417					; 00000589H
	push	OFFSET FLAT:$SG185419
	push	4
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _crlList$[ebp], eax

; 1418 : 						crlList[0] = (LPSTR)crlCertUrl;

	mov	ecx, DWORD PTR _crlList$[ebp]
	mov	edx, DWORD PTR _crlCertUrl$[ebp]
	mov	DWORD PTR [ecx], edx
$L185415:

; 1419 : 					}
; 1420 : 
; 1421 : 					result = check_CRL (hStoreHandle,
; 1422 : 										pChainContext->rgpChain[0]->rgpElement[certIndex]->pCertContext, 
; 1423 : 									pChainContext->rgpChain[0]->rgpElement[issuerIndex]->pCertContext,
; 1424 : 									pTime,
; 1425 : 									certVerParams->pCrlCache,
; 1426 : 									crlList,
; 1427 : 									crlCount,
; 1428 : 									FALSE,
; 1429 : 									&crlFound,
; 1430 : 									usedCrlList,
; 1431 : 									pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$184952[ebp]
	push	ecx
	lea	edx, DWORD PTR _crlFound$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _crlCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _issuerIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _hStoreHandle$[ebp]
	push	ecx
	call	?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 1432 : 					if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	$L185421

; 1433 : 					{
; 1434 : 						if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L185422

; 1435 : 						{
; 1436 : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1437 : 							zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185423
	push	1437					; 0000059dH
	push	OFFSET FLAT:$SG185424
	mov	edx, DWORD PTR _crlCertUrl$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1438 : 							zFree (crlList);

	push	OFFSET FLAT:$SG185425
	push	1438					; 0000059eH
	push	OFFSET FLAT:$SG185426
	mov	eax, DWORD PTR _crlList$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1439 : 							break; // At least one of the certificates in the chain has a problem

	jmp	$L185394
$L185422:

; 1440 : 						}
; 1441 : 						else // CRL validation was successful
; 1442 : 						{
; 1443 : 							crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 1444 : 							zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185428
	push	1444					; 000005a4H
	push	OFFSET FLAT:$SG185429
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1445 : 							zFree (crlList);

	push	OFFSET FLAT:$SG185430
	push	1445					; 000005a5H
	push	OFFSET FLAT:$SG185431
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1446 : 							continue; // check the next certificate in the chain

	jmp	$L185393
$L185421:

; 1447 : 						}
; 1448 : 					}
; 1449 : 					else
; 1450 : 					{	//No CRL DP present and none of the given CRL Locations, if any, matched
; 1451 : 						if ( certIndex != 0)

	cmp	DWORD PTR _certIndex$[ebp], 0
	je	$L185433

; 1452 : 						{
; 1453 : 							// If this is the root certificate, then the CRL may be
; 1454 : 							// available from the first intermediate certificate
; 1455 : 							// since the issuers for both are the root CA
; 1456 : 							if (certIndex == pChainContext->rgpChain[0]->cElement - 1)

	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	cmp	DWORD PTR _certIndex$[ebp], eax
	jne	$L185434

; 1457 : 							{
; 1458 : 								cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 1459 : 								crlCertUrl = getCRLDist(pChainContext->rgpChain[0]->rgpElement[certIndex -1]->pCertContext);

	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _certIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4-4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_getCRLDist
	add	esp, 4
	mov	DWORD PTR _crlCertUrl$[ebp], eax

; 1460 : 								if (crlCertUrl == NULL)

	cmp	DWORD PTR _crlCertUrl$[ebp], 0
	jne	SHORT $L185435

; 1461 : 								{//No CRL DP present and none of the given CRL Locations, if any, matched
; 1462 : 									crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1463 : 									checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1464 : 									setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1465 : 									break;

	jmp	$L185394
$L185435:

; 1466 : 								}
; 1467 : 								else
; 1468 : 								{// CRL Location Found
; 1469 : 									crlCount = 1;

	mov	DWORD PTR _crlCount$[ebp], 1

; 1470 : 									crlList = (LPSTR *)zMalloc(sizeof (char *));

	push	OFFSET FLAT:$SG185439
	push	1470					; 000005beH
	push	OFFSET FLAT:$SG185440
	push	4
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _crlList$[ebp], eax

; 1471 : 									crlList[0] = (LPSTR)crlCertUrl;

	mov	ecx, DWORD PTR _crlList$[ebp]
	mov	edx, DWORD PTR _crlCertUrl$[ebp]
	mov	DWORD PTR [ecx], edx

; 1472 : 									result = check_CRL (hStoreHandle,
; 1473 : 														pChainContext->rgpChain[0]->rgpElement[certIndex]->pCertContext, 
; 1474 : 													pChainContext->rgpChain[0]->rgpElement[issuerIndex]->pCertContext,
; 1475 : 													pTime,
; 1476 : 													certVerParams->pCrlCache,
; 1477 : 													crlList,
; 1478 : 													crlCount,
; 1479 : 													FALSE,
; 1480 : 													&crlFound,
; 1481 : 													usedCrlList,
; 1482 : 													pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$184952[ebp]
	push	ecx
	lea	edx, DWORD PTR _crlFound$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _crlCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _issuerIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _certIndex$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _hStoreHandle$[ebp]
	push	ecx
	call	?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 1483 : 									if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	$L185442

; 1484 : 									{
; 1485 : 										if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L185443

; 1486 : 										{
; 1487 : 											checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1488 : 											zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185444
	push	1488					; 000005d0H
	push	OFFSET FLAT:$SG185445
	mov	edx, DWORD PTR _crlCertUrl$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1489 : 											zFree (crlList);

	push	OFFSET FLAT:$SG185446
	push	1489					; 000005d1H
	push	OFFSET FLAT:$SG185447
	mov	eax, DWORD PTR _crlList$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1490 : 											break; // At least one of the certificates in the chain has a problem

	jmp	$L185394
$L185443:

; 1491 : 										}
; 1492 : 										else // CRL validation was successful
; 1493 : 										{
; 1494 : 											crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 1495 : 											zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185449
	push	1495					; 000005d7H
	push	OFFSET FLAT:$SG185450
	mov	ecx, DWORD PTR _crlCertUrl$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1496 : 											zFree (crlList);

	push	OFFSET FLAT:$SG185451
	push	1496					; 000005d8H
	push	OFFSET FLAT:$SG185452
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1497 : 											break; // We are done since this was the root certificate

	jmp	$L185394
$L185442:

; 1498 : 										}
; 1499 : 									}
; 1500 : 									else
; 1501 : 									{
; 1502 : 										crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1503 : 										checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1504 : 										zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185454
	push	1504					; 000005e0H
	push	OFFSET FLAT:$SG185455
	mov	eax, DWORD PTR _crlCertUrl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1505 : 										zFree (crlList);

	push	OFFSET FLAT:$SG185456
	push	1505					; 000005e1H
	push	OFFSET FLAT:$SG185457
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1506 : 										break;

	jmp	SHORT $L185394
$L185434:

; 1507 : 									}
; 1508 : 								}
; 1509 : 							}
; 1510 : 							else
; 1511 : 							{//No CRL DP present and none of the given CRL Locations, if any, matched
; 1512 : 								crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1513 : 								checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1514 : 								setError(pg_sig, CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1515 : 								break;

	jmp	SHORT $L185394
$L185433:

; 1516 : 							}
; 1517 : 						}
; 1518 : 						else
; 1519 : 						{
; 1520 : 							crlFound = FALSE;

	mov	DWORD PTR _crlFound$[ebp], 0

; 1521 : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1522 : 							zFree(crlCertUrl);

	push	OFFSET FLAT:$SG185460
	push	1522					; 000005f2H
	push	OFFSET FLAT:$SG185461
	mov	eax, DWORD PTR _crlCertUrl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1523 : 							zFree (crlList);

	push	OFFSET FLAT:$SG185462
	push	1523					; 000005f3H
	push	OFFSET FLAT:$SG185463
	mov	ecx, DWORD PTR _crlList$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H
$L185394:

; 1524 : 							break;
; 1525 : 						}
; 1526 : 					}
; 1527 : 				}
; 1528 : 			}
; 1529 : 			if (checkCRLFailed == FALSE)

	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L185464

; 1530 : 				err = FALSE;

	mov	DWORD PTR _err$[ebp], 0

; 1531 : 			else

	jmp	SHORT $L185465
$L185464:

; 1532 : 				err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L185465:

; 1533 : 			//if (err == FALSE)
; 1534 : 			//{
; 1535 : 				unsigned int listSize = usedCrlList->size();

	mov	ecx, DWORD PTR _usedCrlList$184952[ebp]
	call	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
	mov	DWORD PTR _listSize$185466[ebp], eax

; 1536 : 				if (listSize != 0)

	cmp	DWORD PTR _listSize$185466[ebp], 0
	je	$L185467

; 1537 : 				{
; 1538 : 					certVerParams->usedCrlCount = listSize;

	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	eax, DWORD PTR _listSize$185466[ebp]
	mov	DWORD PTR [edx+60], eax

; 1539 : 					certVerParams->usedCrlList = (LPSTR *) zMalloc(listSize * sizeof(LPSTR *));

	push	OFFSET FLAT:$SG185470
	push	1539					; 00000603H
	push	OFFSET FLAT:$SG185471
	mov	ecx, DWORD PTR _listSize$185466[ebp]
	shl	ecx, 2
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [edx+64], eax

; 1540 : 					memset(certVerParams->usedCrlList, 0, listSize * sizeof(LPSTR *));

	mov	eax, DWORD PTR _listSize$185466[ebp]
	shl	eax, 2
	push	eax
	push	0
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1541 : 					CrlList::iterator iList;

	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator

; 1542 : 					unsigned int crlIndex=0;

	mov	DWORD PTR _crlIndex$185551[ebp], 0

; 1543 : 					for (iList = usedCrlList->end(), iList--; crlIndex < listSize; iList--, crlIndex++)

	lea	eax, DWORD PTR $T187896[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$184952[ebp]
	call	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _iList$185550[ebp], ecx
	push	0
	lea	edx, DWORD PTR $T187897[ebp]
	push	edx
	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	jmp	SHORT $L185555
$L185556:
	push	0
	lea	eax, DWORD PTR $T187898[ebp]
	push	eax
	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	ecx, DWORD PTR _crlIndex$185551[ebp]
	add	ecx, 1
	mov	DWORD PTR _crlIndex$185551[ebp], ecx
$L185555:
	mov	edx, DWORD PTR _crlIndex$185551[ebp]
	cmp	edx, DWORD PTR _listSize$185466[ebp]
	jae	$L185467

; 1544 : 					{
; 1545 : 						certVerParams->usedCrlList[crlIndex] = (LPSTR) zMalloc(strlen((const char *)*iList)+1);

	push	OFFSET FLAT:$SG185560
	push	1545					; 00000609H
	push	OFFSET FLAT:$SG185561
	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	eax, DWORD PTR [eax]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _crlIndex$185551[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1546 : 						strcpy((char *)certVerParams->usedCrlList[crlIndex], (const char *)*iList);

	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _crlIndex$185551[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 1547 : 						zFree(*iList);

	push	OFFSET FLAT:$SG185564
	push	1547					; 0000060bH
	push	OFFSET FLAT:$SG185565
	lea	ecx, DWORD PTR _iList$185550[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1548 : 					}

	jmp	$L185556
$L185467:

; 1549 : 				}
; 1550 : 			//}
; 1551 : 			delete usedCrlList;

	mov	edx, DWORD PTR _usedCrlList$184952[ebp]
	mov	DWORD PTR $T187900[ebp], edx
	mov	eax, DWORD PTR $T187900[ebp]
	mov	DWORD PTR $T187899[ebp], eax
	cmp	DWORD PTR $T187899[ebp], 0
	je	SHORT $L187901
	push	1
	mov	ecx, DWORD PTR $T187899[ebp]
	call	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
	mov	DWORD PTR tv697[ebp], eax
	jmp	SHORT $L187902
$L187901:
	mov	DWORD PTR tv697[ebp], 0
$L187902:

; 1552 : 		}
; 1553 : 		else

	jmp	$exitCheckCertificate$184864
$L184951:

; 1554 : 		{
; 1555 : 			if (certVerParams->verificationOptions & VERIFY_CRL_REC)

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 64					; 00000040H
	je	$exitCheckCertificate$184864

; 1556 : 			{
; 1557 : //				DebugBreak();
; 1558 : 				//if (pChainContext->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED)
; 1559 : 				//{
; 1560 : 				//	setError(pg_sig, CRL_CERT_REVOKED);
; 1561 : 				//	err = TRUE;
; 1562 : 				//	goto exitCheckCertificate;
; 1563 : 				//}
; 1564 : 
; 1565 : 				CrlList *usedCrlList = new CrlList();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T187904[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T187904[ebp], 0
	je	SHORT $L187905
	mov	ecx, DWORD PTR $T187904[ebp]
	call	??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
	mov	DWORD PTR tv708[ebp], eax
	jmp	SHORT $L187906
$L187905:
	mov	DWORD PTR tv708[ebp], 0
$L187906:
	mov	eax, DWORD PTR tv708[ebp]
	mov	DWORD PTR $T187903[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T187903[ebp]
	mov	DWORD PTR _usedCrlList$185570[ebp], ecx

; 1566 : 				checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 1567 : 				if ((certVerParams->recCrlCount != 0) &&
; 1568 : 					(certVerParams->recCrlList != NULL)) // Recorded CRL data is available

	mov	edx, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	$L185575
	mov	eax, DWORD PTR _certVerParams$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	$L185575

; 1569 : 				{
; 1570 : 					crlCount = certVerParams->recCrlCount;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _crlCount$[ebp], edx

; 1571 : 					crlList = certVerParams->recCrlList;

	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _crlList$[ebp], ecx

; 1572 : 					for (certIndex=0; certIndex < pChainContext->rgpChain[0]->cElement; certIndex++)

	mov	DWORD PTR _certIndex$[ebp], 0
	jmp	SHORT $L185576
$L185577:
	mov	edx, DWORD PTR _certIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _certIndex$[ebp], edx
$L185576:
	mov	eax, DWORD PTR _pChainContext$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _certIndex$[ebp]
	cmp	eax, DWORD PTR [edx+12]
	jae	$L185578

; 1573 : 					{
; 1574 : 						if (certIndex == pChainContext->rgpChain[0]->cElement - 1)

	mov	ecx, DWORD PTR _pChainContext$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	sub	ecx, 1
	cmp	DWORD PTR _certIndex$[ebp], ecx
	jne	SHORT $L185579

; 1575 : 							issuerIndex = certIndex;

	mov	edx, DWORD PTR _certIndex$[ebp]
	mov	DWORD PTR _issuerIndex$[ebp], edx

; 1576 : 						else

	jmp	SHORT $L185580
$L185579:

; 1577 : 							issuerIndex = certIndex+1;

	mov	eax, DWORD PTR _certIndex$[ebp]
	add	eax, 1
	mov	DWORD PTR _issuerIndex$[ebp], eax
$L185580:

; 1578 : 
; 1579 : 						result = check_CRL(	hStoreHandle, 
; 1580 : 											pChainContext->rgpChain[0]->rgpElement[certIndex]->pCertContext, 
; 1581 : 										pChainContext->rgpChain[0]->rgpElement[issuerIndex]->pCertContext,
; 1582 : 										pTime, 
; 1583 : 										NULL, // Don't use CrlCache
; 1584 : 										crlList, 
; 1585 : 										crlCount,
; 1586 : 										TRUE,
; 1587 : 										&crlFound,
; 1588 : 										usedCrlList, 
; 1589 : 										pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usedCrlList$185570[ebp]
	push	edx
	lea	eax, DWORD PTR _crlFound$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _crlCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crlList$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pChainContext$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _issuerIndex$[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pChainContext$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _certIndex$[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _hStoreHandle$[ebp]
	push	eax
	call	?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ; check_CRL
	add	esp, 44					; 0000002cH
	mov	DWORD PTR _result$[ebp], eax

; 1590 : 						if (crlFound == TRUE)

	cmp	DWORD PTR _crlFound$[ebp], 1
	jne	SHORT $L185581

; 1591 : 						{
; 1592 : 							if (result == FALSE) //CRL validation failed for some reason

	cmp	DWORD PTR _result$[ebp], 0
	jne	SHORT $L185582

; 1593 : 							{
; 1594 : 								checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1

; 1595 : 								break; // At least one of the certificates in the chain has a problem

	jmp	SHORT $L185578
$L185582:

; 1596 : 							}
; 1597 : 							else // CRL validation was successful
; 1598 : 							{
; 1599 : 								crlFound = FALSE; // reset this boolean for the next certificate in the chain

	mov	DWORD PTR _crlFound$[ebp], 0

; 1600 : 								checkCRLFailed = FALSE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 0

; 1601 : 								continue; // check the next certificate in the chain

	jmp	$L185577
$L185581:

; 1602 : 							}
; 1603 : 						}
; 1604 : 						else
; 1605 : 						{
; 1606 : 							checkCRLFailed = TRUE;

	mov	DWORD PTR _checkCRLFailed$[ebp], 1
$L185578:

; 1607 : 							break;
; 1608 : 						}
; 1609 : 					}// for
; 1610 : 					if (checkCRLFailed == FALSE)

	cmp	DWORD PTR _checkCRLFailed$[ebp], 0
	jne	SHORT $L185585

; 1611 : 						err = FALSE;

	mov	DWORD PTR _err$[ebp], 0

; 1612 : 					else

	jmp	SHORT $L185586
$L185585:

; 1613 : 						err = TRUE;

	mov	DWORD PTR _err$[ebp], 1
$L185586:

; 1614 : 					//if (err == FALSE)
; 1615 : 					//{
; 1616 : 						unsigned int listSize = usedCrlList->size();

	mov	ecx, DWORD PTR _usedCrlList$185570[ebp]
	call	?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::size
	mov	DWORD PTR _listSize$185587[ebp], eax

; 1617 : 						if (listSize != 0)

	cmp	DWORD PTR _listSize$185587[ebp], 0
	je	$L185575

; 1618 : 						{
; 1619 : 							certVerParams->usedCrlCount = listSize;

	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR _listSize$185587[ebp]
	mov	DWORD PTR [ecx+60], edx

; 1620 : 							certVerParams->usedCrlList = (LPSTR *) zMalloc(listSize * sizeof(LPSTR *));

	push	OFFSET FLAT:$SG185591
	push	1620					; 00000654H
	push	OFFSET FLAT:$SG185592
	mov	eax, DWORD PTR _listSize$185587[ebp]
	shl	eax, 2
	push	eax
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 1621 : 							memset(certVerParams->usedCrlList, 0, listSize * sizeof(LPSTR *));

	mov	edx, DWORD PTR _listSize$185587[ebp]
	shl	edx, 2
	push	edx
	push	0
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1622 : 							CrlList::iterator iList;

	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator

; 1623 : 							unsigned int crlIndex=0;

	mov	DWORD PTR _crlIndex$185595[ebp], 0

; 1624 : 							for (iList = usedCrlList->end(), iList--; crlIndex < listSize; iList--, crlIndex++)

	lea	edx, DWORD PTR $T187907[ebp]
	push	edx
	mov	ecx, DWORD PTR _usedCrlList$185570[ebp]
	call	?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _iList$185594[ebp], eax
	push	0
	lea	ecx, DWORD PTR $T187908[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	jmp	SHORT $L185599
$L185600:
	push	0
	lea	edx, DWORD PTR $T187909[ebp]
	push	edx
	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	eax, DWORD PTR _crlIndex$185595[ebp]
	add	eax, 1
	mov	DWORD PTR _crlIndex$185595[ebp], eax
$L185599:
	mov	ecx, DWORD PTR _crlIndex$185595[ebp]
	cmp	ecx, DWORD PTR _listSize$185587[ebp]
	jae	$L185575

; 1625 : 							{
; 1626 : 								certVerParams->usedCrlList[crlIndex] = (LPSTR) zMalloc(strlen((const char *)*iList)+1);

	push	OFFSET FLAT:$SG185604
	push	1626					; 0000065aH
	push	OFFSET FLAT:$SG185605
	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _certVerParams$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	ecx, DWORD PTR _crlIndex$185595[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 1627 : 								strcpy((char *)certVerParams->usedCrlList[crlIndex], (const char *)*iList);

	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _certVerParams$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	mov	edx, DWORD PTR _crlIndex$185595[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	_strcpy
	add	esp, 8

; 1628 : 								zFree(*iList);

	push	OFFSET FLAT:$SG185608
	push	1628					; 0000065cH
	push	OFFSET FLAT:$SG185609
	lea	ecx, DWORD PTR _iList$185594[ebp]
	call	??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1629 : 							}

	jmp	$L185600
$L185575:

; 1630 : 						}
; 1631 : 					//}
; 1632 : 				}// if Recorded CRL Data is available
; 1633 : 				delete usedCrlList;

	mov	edx, DWORD PTR _usedCrlList$185570[ebp]
	mov	DWORD PTR $T187911[ebp], edx
	mov	eax, DWORD PTR $T187911[ebp]
	mov	DWORD PTR $T187910[ebp], eax
	cmp	DWORD PTR $T187910[ebp], 0
	je	SHORT $L187912
	push	1
	mov	ecx, DWORD PTR $T187910[ebp]
	call	??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
	mov	DWORD PTR tv811[ebp], eax
	jmp	SHORT $exitCheckCertificate$184864
$L187912:
	mov	DWORD PTR tv811[ebp], 0
$exitCheckCertificate$184864:

; 1634 : 			} // if VERIFY_CRL_REC enabled
; 1635 : 		}
; 1636 : 
; 1637 : 
; 1638 : exitCheckCertificate:
; 1639 : 		CertFreeCertificateChain(pChainContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pChainContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCertificateChain@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1640 : 
; 1641 : 		if (err) {

	cmp	DWORD PTR _err$[ebp], 0
	je	SHORT $L185612

; 1642 : //			setError(pg_sig,CERT_TRUST_ERROR);
; 1643 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L184833
$L185612:

; 1644 : 		} else {
; 1645 : 			return TRUE;

	mov	eax, 1
$L184833:

; 1646 : 		}
; 1647 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L187931
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L187931:
	DD	7
	DD	$L187930
$L187930:
	DD	-32					; ffffffe0H
	DD	16					; 00000010H
	DD	$L187921
	DD	-48					; ffffffd0H
	DD	8
	DD	$L187922
	DD	-68					; ffffffbcH
	DD	12					; 0000000cH
	DD	$L187923
	DD	-80					; ffffffb0H
	DD	4
	DD	$L187924
	DD	-168					; ffffff58H
	DD	4
	DD	$L187925
	DD	-192					; ffffff40H
	DD	4
	DD	$L187926
	DD	-216					; ffffff28H
	DD	4
	DD	$L187927
$L187927:
	DB	105					; 00000069H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L187926:
	DB	105					; 00000069H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L187925:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	0
$L187924:
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$L187923:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	85					; 00000055H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$L187922:
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	104					; 00000068H
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	85					; 00000055H
	DB	115					; 00000073H
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	0
$L187921:
	DB	67					; 00000043H
	DB	104					; 00000068H
	DB	97					; 00000061H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	0
$L187932:
	DD	$L184936
	DD	$L184937
	DD	$L184938
	DD	$L184939
	DD	$L184940
	DD	$L184941
	DD	$L184942
	DD	$L184950
$L187920:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	7
	DB	7
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_TEXT	ENDS
text$x	SEGMENT
$L187914:
	mov	eax, DWORD PTR $T187893[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L187915:
	mov	eax, DWORD PTR $T187904[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T187919
	jmp	___CxxFrameHandler
text$x	ENDS
?checkCertificate@@YAHPBU_CERT_CONTEXT@@PAXPAU_FILETIME@@PAU_CERTVERIFICATIONPARAMS@@PAU_GLOBAL_SIG@@@Z ENDP ; checkCertificate
PUBLIC	??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ	; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L185617
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L185617:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$list@PAEV?$allocator@PAE@std@@@std@@QAEPAXI@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
PUBLIC	??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::~vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
PUBLIC	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
PUBLIC	?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::at
PUBLIC	?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back
PUBLIC	?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
PUBLIC	?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert
EXTRN	_base64encodeSize:NEAR
EXTRN	_base64encode:NEAR
EXTRN	?FetchCRLFromCRLCache@CRLCache@@QAEPAPAU_DS_DATA_BLOB@@PAU_CRYPTOAPI_BLOB@@PAIPAU_GLOBAL_SIG@@@Z:NEAR ; CRLCache::FetchCRLFromCRLCache
EXTRN	?EnterCRLIntoCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z:NEAR ; CRLCache::EnterCRLIntoCRLCache
EXTRN	?DeleteCRLFromCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z:NEAR ; CRLCache::DeleteCRLFromCRLCache
EXTRN	_AddLogDetailWithMutex:NEAR
EXTRN	_EnteringFunction:DWORD
EXTRN	_ExitingFunction:DWORD
EXTRN	__imp__CryptVerifyCertificateSignature@20:NEAR
EXTRN	_fclose:NEAR
EXTRN	__imp__CertVerifyCRLTimeValidity@8:NEAR
EXTRN	_fopen:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	__imp__CertFindExtension@12:NEAR
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	_fwrite:NEAR
EXTRN	_sprintf:NEAR
EXTRN	_strncmp:NEAR
EXTRN	_fetchLDAP_URL:NEAR
EXTRN	_fetch_URL:NEAR
EXTRN	_certIsNameEqual:NEAR
EXTRN	__imp__CertCreateCRLContext@12:NEAR
EXTRN	__imp__CertFreeCRLContext@4:NEAR
EXTRN	__imp__CertFindCertificateInCRL@20:NEAR
EXTRN	__imp__CompareFileTime@8:NEAR
xdata$x	SEGMENT
$T187959 DD	0ffffffffH
	DD	FLAT:$L187943
$T187945 DD	019930520H
	DD	01H
	DD	FLAT:$T187959
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
$T187942 = -448						; size = 4
$T187941 = -444						; size = 4
$T187940 = -440						; size = 4
$T187939 = -436						; size = 4
_b64Crl$186020 = -428					; size = 4
_size$186019 = -420					; size = 4
_pCertExtInfo$186004 = -416				; size = 4
_fHandle$185984 = -412					; size = 4
_crlFileName$185982 = -404				; size = 260
_i$185977 = -140					; size = 4
_i$185969 = -136					; size = 4
_pCrl$185968 = -132					; size = 4
_crlBlobList$185947 = -124				; size = 16
_i$185676 = -104					; size = 4
_b64Crl$185661 = -96					; size = 4
_size$185660 = -88					; size = 4
_pCertExtInfo$185655 = -84				; size = 4
_validCrlFound$ = -80					; size = 4
_crlIndex$ = -76					; size = 4
_crlCount$ = -68					; size = 4
_crlDataList$ = -60					; size = 4
_crl$ = -52						; size = 4
_ret$ = -44						; size = 4
_ppCrlEntry$ = -40					; size = 4
_pCrlEntry$ = -32					; size = 4
_pCrlContext$ = -24					; size = 4
_crlUrl$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_hStoreHandle$ = 8					; size = 4
_pCertContext$ = 12					; size = 4
_pIssuerCertContext$ = 16				; size = 4
_pTime$ = 20						; size = 4
_pCrlCache$ = 24					; size = 4
_crlAltUrl$ = 28					; size = 4
_altCrlCount$ = 32					; size = 4
_crlUrlIsCrlData$ = 36					; size = 4
_crlFound$ = 40						; size = 4
_usedCrlList$ = 44					; size = 4
_pg_sig$ = 48						; size = 4
?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; check_CRL

; 1929 : 					 PGLOBAL_SIG pg_sig) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 436				; 000001b4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-448]
	mov	ecx, 109				; 0000006dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1930 : 	BYTE *crlUrl=NULL;

	mov	DWORD PTR _crlUrl$[ebp], 0

; 1931 : 	PCCRL_CONTEXT pCrlContext=NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1932 : 	PCRL_ENTRY pCrlEntry = NULL;//(PCRL_ENTRY) zMalloc(sizeof(CRL_ENTRY));

	mov	DWORD PTR _pCrlEntry$[ebp], 0

; 1933 : 	PCRL_ENTRY *ppCrlEntry = &pCrlEntry;

	lea	eax, DWORD PTR _pCrlEntry$[ebp]
	mov	DWORD PTR _ppCrlEntry$[ebp], eax

; 1934 : 	int ret=TRUE;

	mov	DWORD PTR _ret$[ebp], 1

; 1935 : 	PDS_DATA_BLOB crl=NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 1936 : 	PDS_DATA_BLOB *crlDataList=NULL;

	mov	DWORD PTR _crlDataList$[ebp], 0

; 1937 : 	UINT crlCount=0;

	mov	DWORD PTR _crlCount$[ebp], 0

; 1938 : 	UINT crlIndex;
; 1939 : 	BOOL validCrlFound = FALSE;

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 1940 : 
; 1941 : 	EnterPgSigLog;

	mov	ecx, DWORD PTR _EnteringFunction
	push	ecx
	push	OFFSET FLAT:$SG185642
	push	0
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	push	OFFSET FLAT:$SG185643
	push	1941					; 00000795H
	push	OFFSET FLAT:$SG185644
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 1942 : 
; 1943 : //DebugBreak();
; 1944 : 	if (pCrlCache != NULL)

	cmp	DWORD PTR _pCrlCache$[ebp], 0
	je	$L185645

; 1945 : 	{
; 1946 : //		DebugBreak();
; 1947 : 		crlDataList = pCrlCache->FetchCRLFromCRLCache(	&pCertContext->pCertInfo->Issuer,
; 1948 : 														&crlCount,
; 1949 : 														pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	lea	ecx, DWORD PTR _crlCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _pCrlCache$[ebp]
	call	?FetchCRLFromCRLCache@CRLCache@@QAEPAPAU_DS_DATA_BLOB@@PAU_CRYPTOAPI_BLOB@@PAIPAU_GLOBAL_SIG@@@Z ; CRLCache::FetchCRLFromCRLCache
	mov	DWORD PTR _crlDataList$[ebp], eax

; 1950 : 		if ((crlCount != 0) && (crlDataList != NULL))

	cmp	DWORD PTR _crlCount$[ebp], 0
	je	$L185645
	cmp	DWORD PTR _crlDataList$[ebp], 0
	je	$L185645

; 1951 : 		{// A CRL was found in the CRL Cache
; 1952 : 			for (crlIndex=0; crlIndex < crlCount; crlIndex++)

	mov	DWORD PTR _crlIndex$[ebp], 0
	jmp	SHORT $L185647
$L185648:
	mov	ecx, DWORD PTR _crlIndex$[ebp]
	add	ecx, 1
	mov	DWORD PTR _crlIndex$[ebp], ecx
$L185647:
	mov	edx, DWORD PTR _crlIndex$[ebp]
	cmp	edx, DWORD PTR _crlCount$[ebp]
	jae	$L185649

; 1953 : 			{
; 1954 : 				crl = crlDataList[crlIndex];

	mov	eax, DWORD PTR _crlIndex$[ebp]
	mov	ecx, DWORD PTR _crlDataList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _crl$[ebp], edx

; 1955 : 				// create CRL context
; 1956 : 				pCrlContext = CertCreateCRLContext(MY_TYPE,crl->pbData,crl->cbData);

	mov	esi, esp
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	65537					; 00010001H
	call	DWORD PTR __imp__CertCreateCRLContext@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCrlContext$[ebp], eax

; 1957 : 				if (pCrlContext==NULL) 

	cmp	DWORD PTR _pCrlContext$[ebp], 0
	jne	SHORT $L185650

; 1958 : 				{
; 1959 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 1960 : 					setError(pg_sig,CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1961 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1962 : 					continue;

	jmp	SHORT $L185648
$L185650:

; 1963 : 				}
; 1964 : 				// Check to see if the CRL issuer and the certificate issuers are the same
; 1965 : 				if (certIsNameEqual(&pCertContext->pCertInfo->Issuer, 	&pCrlContext->pCrlInfo->Issuer) 
; 1966 : 						== TRUE) // certificate and CRL issuers match

	mov	eax, DWORD PTR _pCrlContext$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 24					; 00000018H
	push	eax
	call	_certIsNameEqual
	add	esp, 8
	cmp	eax, 1
	jne	$L185651

; 1967 : 				{
; 1968 : 					validCrlFound = TRUE;

	mov	DWORD PTR _validCrlFound$[ebp], 1

; 1969 : 					if (!CryptVerifyCertificateSignature(
; 1970 : 						(HCRYPTPROV) NULL,	// CSP
; 1971 : 						MY_TYPE,
; 1972 : 						pCrlContext->pbCrlEncoded,	
; 1973 : 						pCrlContext->cbCrlEncoded,
; 1974 : 						&pIssuerCertContext->pCertInfo->SubjectPublicKeyInfo))

	mov	ecx, DWORD PTR _pIssuerCertContext$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 56					; 00000038H
	mov	esi, esp
	push	edx
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	65537					; 00010001H
	push	0
	call	DWORD PTR __imp__CryptVerifyCertificateSignature@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L185653

; 1975 : 					{
; 1976 : 						cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 1977 : 						setError(pg_sig,CRL_BAD_SIGNATURE);

	push	72					; 00000048H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1978 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1979 : 						CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1980 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1981 : 						continue;

	jmp	$L185648
$L185653:

; 1982 : 					}
; 1983 : 					else // CRL has a valid signature from the cert issuer
; 1984 : 					{
; 1985 : 						PCERT_EXTENSION  pCertExtInfo = NULL;

	mov	DWORD PTR _pCertExtInfo$185655[ebp], 0

; 1986 : 						*crlFound = TRUE;

	mov	ecx, DWORD PTR _crlFound$[ebp]
	mov	DWORD PTR [ecx], 1

; 1987 : 						pCertExtInfo = CertFindExtension(	szOID_DELTA_CRL_INDICATOR,
; 1988 : 															pCrlContext->pCrlInfo->cExtension,
; 1989 : 															pCrlContext->pCrlInfo->rgExtension);

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET FLAT:$SG185656
	call	DWORD PTR __imp__CertFindExtension@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCertExtInfo$185655[ebp], eax

; 1990 : 						if (pCertExtInfo != NULL)

	cmp	DWORD PTR _pCertExtInfo$185655[ebp], 0
	je	SHORT $L185657

; 1991 : 						{
; 1992 : 							validCrlFound = FALSE; // Set CRL Found to false in order to force a CRL Fetch

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 1993 : 							pCrlCache->DeleteCRLFromCRLCache(&pCertContext->pCertInfo->Issuer, crl, pg_sig);

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCertContext$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _pCrlCache$[ebp]
	call	?DeleteCRLFromCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z ; CRLCache::DeleteCRLFromCRLCache

; 1994 : 
; 1995 : 							setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1996 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 1997 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1998 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 1999 : 							break;

	jmp	$L185649
$L185657:

; 2000 : 						}
; 2001 : 						
; 2002 : 						pCertExtInfo = CertFindExtension(	szOID_ISSUING_DIST_POINT,
; 2003 : 															pCrlContext->pCrlInfo->cExtension,
; 2004 : 															pCrlContext->pCrlInfo->rgExtension);

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET FLAT:$SG185658
	call	DWORD PTR __imp__CertFindExtension@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCertExtInfo$185655[ebp], eax

; 2005 : 						if (pCertExtInfo != NULL)

	cmp	DWORD PTR _pCertExtInfo$185655[ebp], 0
	je	SHORT $L185659

; 2006 : 						{
; 2007 : 							validCrlFound = FALSE; // Set CRL Found to false in order to force a CRL Fetch

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 2008 : 							pCrlCache->DeleteCRLFromCRLCache(&pCertContext->pCertInfo->Issuer, crl, pg_sig);

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCertContext$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 24					; 00000018H
	push	edx
	mov	ecx, DWORD PTR _pCrlCache$[ebp]
	call	?DeleteCRLFromCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z ; CRLCache::DeleteCRLFromCRLCache

; 2009 : 
; 2010 : 							setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 2011 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2012 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2013 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2014 : 							break;

	jmp	$L185649
$L185659:

; 2015 : 						}
; 2016 : 						// Lets add the base64 encoded CRL to the crl list
; 2017 : 						int size = base64encodeSize(crl->cbData);

	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _size$185660[ebp], eax

; 2018 : 						unsigned char *b64Crl = (unsigned char *)zMalloc(size+1);

	push	OFFSET FLAT:$SG185663
	push	2018					; 000007e2H
	push	OFFSET FLAT:$SG185664
	mov	ecx, DWORD PTR _size$185660[ebp]
	add	ecx, 1
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _b64Crl$185661[ebp], eax

; 2019 : 						if ((size = base64encode(crl->pbData, crl->cbData, b64Crl, size+1)) == -1)

	mov	edx, DWORD PTR _size$185660[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _b64Crl$185661[ebp]
	push	eax
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$185660[ebp], eax
	cmp	DWORD PTR _size$185660[ebp], -1
	jne	SHORT $L185665

; 2020 : 						{
; 2021 : 							setError(pg_sig, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2022 : 							zFree(b64Crl);

	push	OFFSET FLAT:$SG185666
	push	2022					; 000007e6H
	push	OFFSET FLAT:$SG185667
	mov	eax, DWORD PTR _b64Crl$185661[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2023 : 							break;

	jmp	$L185649
$L185665:

; 2024 : 						}
; 2025 : 						*(b64Crl + size) = '\0';

	mov	ecx, DWORD PTR _b64Crl$185661[ebp]
	add	ecx, DWORD PTR _size$185660[ebp]
	mov	BYTE PTR [ecx], 0

; 2026 : 						usedCrlList->insert(usedCrlList->begin(), b64Crl);

	lea	edx, DWORD PTR _b64Crl$185661[ebp]
	push	edx
	lea	eax, DWORD PTR $T187939[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T187940[ebp]
	push	edx
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert

; 2027 : 
; 2028 : 						if (!CertFindCertificateInCRL(pCertContext,pCrlContext,0,0,ppCrlEntry)) 

	mov	esi, esp
	mov	eax, DWORD PTR _ppCrlEntry$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFindCertificateInCRL@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L185670

; 2029 : 						{
; 2030 : 							// list wasn't searched
; 2031 : 							cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 2032 : 							setError(pg_sig,CRL_ERROR);

	push	73					; 00000049H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 2033 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2034 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2035 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2036 : 							continue;

	jmp	$L185648
$L185670:

; 2037 : 						}
; 2038 : 						//Add this to the Store for faster validation in the future
; 2039 : 						//CertAddCRLContextToStore(hStoreHandle, pCrlContext,CERT_STORE_ADD_NEWER,NULL);
; 2040 : 
; 2041 : 						if (pCrlEntry!=NULL) {

	cmp	DWORD PTR _pCrlEntry$[ebp], 0
	je	SHORT $L185654

; 2042 : 							// CRL contains this certificate
; 2043 : 							// Compare the revocation time with pTime
; 2044 : 							if (CompareFileTime((const FILETIME *)&pCrlEntry->RevocationDate, pTime) <= 0)

	mov	esi, esp
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCrlEntry$[ebp]
	add	ecx, 8
	push	ecx
	call	DWORD PTR __imp__CompareFileTime@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jg	SHORT $L185654

; 2045 : 							{// The certificate was revoked before pTime
; 2046 : 								cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_cleanupError
	add	esp, 4

; 2047 : 								setError(pg_sig,CRL_CERT_REVOKED);

	push	75					; 0000004bH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 2048 : 								ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2049 : 								CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2050 : 								pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2051 : 								pCrlEntry=NULL;

	mov	DWORD PTR _pCrlEntry$[ebp], 0

; 2052 : 								break;

	jmp	$L185649
$L185654:

; 2053 : 							}
; 2054 : 						}
; 2055 : 					}// CRL has a valid signature from the cert issuer
; 2056 : 					if (CertVerifyCRLTimeValidity(pTime, pCrlContext->pCrlInfo) == 1)

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertVerifyCRLTimeValidity@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $L185674

; 2057 : 					{
; 2058 : 						cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_cleanupError
	add	esp, 4

; 2059 : 
; 2060 : 						validCrlFound = FALSE; // Set CRL Found to false in order to force a CRL Fetch

	mov	DWORD PTR _validCrlFound$[ebp], 0

; 2061 : 						pCrlCache->DeleteCRLFromCRLCache(&pCertContext->pCertInfo->Issuer, crl, pg_sig);

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _pCrlCache$[ebp]
	call	?DeleteCRLFromCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z ; CRLCache::DeleteCRLFromCRLCache

; 2062 : 
; 2063 : 						setError(pg_sig,CRL_TOO_OLD);

	push	87					; 00000057H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 2064 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2065 : 						CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2066 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2067 : 						break;

	jmp	SHORT $L185649
$L185674:

; 2068 : 					}
; 2069 : 					//if (crl->pbData) 
; 2070 : 					//	zFree(crl->pbData);
; 2071 : 					//zFree (crl);
; 2072 : 					CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2073 : 					break;

	jmp	SHORT $L185649
$L185651:

; 2074 : 				}//CRL issuer and cert issuers are the same
; 2075 : 				else // This CRL is not relevant since it's issuer is not the same as the certificate issuer
; 2076 : 				{
; 2077 : 					CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2078 : 					pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2079 : 					//if (crl->pbData) 
; 2080 : 					//	zFree(crl->pbData);
; 2081 : 					//zFree (crl);
; 2082 : 					//crl = NULL;
; 2083 : 					continue;

	jmp	$L185648
$L185649:

; 2084 : 				}
; 2085 : 			}//for (crlIndex=0; crlIndex < crlCount; crlIndex++)
; 2086 : 			for (unsigned int i=0; i<crlCount; i++)

	mov	DWORD PTR _i$185676[ebp], 0
	jmp	SHORT $L185677
$L185678:
	mov	edx, DWORD PTR _i$185676[ebp]
	add	edx, 1
	mov	DWORD PTR _i$185676[ebp], edx
$L185677:
	mov	eax, DWORD PTR _i$185676[ebp]
	cmp	eax, DWORD PTR _crlCount$[ebp]
	jae	SHORT $L185679

; 2087 : 			{
; 2088 : 				if (crlDataList[i] != NULL)

	mov	ecx, DWORD PTR _i$185676[ebp]
	mov	edx, DWORD PTR _crlDataList$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L185680

; 2089 : 				{
; 2090 : 					if (crlDataList[i]->pbData != NULL)

	mov	eax, DWORD PTR _i$185676[ebp]
	mov	ecx, DWORD PTR _crlDataList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L185681

; 2091 : 						zFree(crlDataList[i]->pbData);

	push	OFFSET FLAT:$SG185682
	push	2091					; 0000082bH
	push	OFFSET FLAT:$SG185683
	mov	eax, DWORD PTR _i$185676[ebp]
	mov	ecx, DWORD PTR _crlDataList$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H
$L185681:

; 2092 : 					zFree(crlDataList[i]);

	push	OFFSET FLAT:$SG185684
	push	2092					; 0000082cH
	push	OFFSET FLAT:$SG185685
	mov	ecx, DWORD PTR _i$185676[ebp]
	mov	edx, DWORD PTR _crlDataList$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H
$L185680:

; 2093 : 				}
; 2094 : 			}

	jmp	SHORT $L185678
$L185679:

; 2095 : 			zFree(crlDataList);

	push	OFFSET FLAT:$SG185686
	push	2095					; 0000082fH
	push	OFFSET FLAT:$SG185687
	mov	ecx, DWORD PTR _crlDataList$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H
$L185645:

; 2096 : 		}//if ((crlCount != 0) && (crlDataList != NULL))
; 2097 : 	}//pCrlCache!=NULL
; 2098 : //DebugBreak();
; 2099 : 	if (validCrlFound == FALSE)

	cmp	DWORD PTR _validCrlFound$[ebp], 0
	jne	$L185688

; 2100 : 	{
; 2101 : 		vector <PDS_DATA_BLOB> crlBlobList;

	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2102 : 
; 2103 : 		for (crlIndex=0; crlIndex < altCrlCount; crlIndex++)

	mov	DWORD PTR _crlIndex$[ebp], 0
	jmp	SHORT $L185948
$L185949:
	mov	edx, DWORD PTR _crlIndex$[ebp]
	add	edx, 1
	mov	DWORD PTR _crlIndex$[ebp], edx
$L185948:
	mov	eax, DWORD PTR _crlIndex$[ebp]
	cmp	eax, DWORD PTR _altCrlCount$[ebp]
	jae	$L185950

; 2104 : 		{
; 2105 : 			if (crlUrlIsCrlData)

	cmp	DWORD PTR _crlUrlIsCrlData$[ebp], 0
	je	$L185951

; 2106 : 			{
; 2107 : 				crl = (PDS_DATA_BLOB) zMalloc(sizeof(DS_DATA_BLOB));

	push	OFFSET FLAT:$SG185954
	push	2107					; 0000083bH
	push	OFFSET FLAT:$SG185955
	push	8
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _crl$[ebp], eax

; 2108 : 				crl->cbData = base64decodeSize(strlen((const char *)crlAltUrl[crlIndex]));

	mov	ecx, DWORD PTR _crlIndex$[ebp]
	mov	edx, DWORD PTR _crlAltUrl$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	call	_base64decodeSize
	add	esp, 4
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 2109 : 				crl->pbData = (unsigned char *) zMalloc(crl->cbData + 1);

	push	OFFSET FLAT:$SG185958
	push	2109					; 0000083dH
	push	OFFSET FLAT:$SG185959
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	push	eax
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [ecx], eax

; 2110 : 				if ((crl->cbData = base64decode((unsigned char *)crlAltUrl[crlIndex], crl->pbData, crl->cbData+1)) == -1)

	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _crlIndex$[ebp]
	mov	ecx, DWORD PTR _crlAltUrl$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $L185961

; 2111 : 				{
; 2112 : 					setError(pg_sig, BASE64_ERROR);

	push	2
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 2113 : 					continue;

	jmp	$L185949
$L185961:

; 2114 : 				}
; 2115 : 				crlBlobList.push_back(crl);

	lea	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back

; 2116 : 			}
; 2117 : 			else

	jmp	$L185962
$L185951:

; 2118 : 			{
; 2119 : 				crlUrl = (BYTE *) crlAltUrl[crlIndex];

	mov	edx, DWORD PTR _crlIndex$[ebp]
	mov	eax, DWORD PTR _crlAltUrl$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _crlUrl$[ebp], ecx

; 2120 : 				if (!crlUrl) 

	cmp	DWORD PTR _crlUrl$[ebp], 0
	jne	SHORT $L185964

; 2121 : 					continue;

	jmp	$L185949
$L185964:

; 2122 : 
; 2123 : 				if (strncmp((const char *)crlUrl,"ldap:",5)==0) 

	push	5
	push	OFFSET FLAT:$SG185967
	mov	edx, DWORD PTR _crlUrl$[ebp]
	push	edx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$L185966

; 2124 : 				{
; 2125 : 					PDS_DATA_BLOB *pCrl = fetchLDAP_URL(crlUrl);

	mov	eax, DWORD PTR _crlUrl$[ebp]
	push	eax
	call	_fetchLDAP_URL
	add	esp, 4
	mov	DWORD PTR _pCrl$185968[ebp], eax

; 2126 : 					int i=0;

	mov	DWORD PTR _i$185969[ebp], 0
$L185971:

; 2127 : 					while (pCrl && pCrl[i]) {

	cmp	DWORD PTR _pCrl$185968[ebp], 0
	je	SHORT $L185972
	mov	ecx, DWORD PTR _i$185969[ebp]
	mov	edx, DWORD PTR _pCrl$185968[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $L185972

; 2128 : 						crlBlobList.push_back(pCrl[i]);

	mov	eax, DWORD PTR _i$185969[ebp]
	mov	ecx, DWORD PTR _pCrl$185968[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back

; 2129 : 						i++;

	mov	eax, DWORD PTR _i$185969[ebp]
	add	eax, 1
	mov	DWORD PTR _i$185969[ebp], eax

; 2130 : 					}

	jmp	SHORT $L185971
$L185972:

; 2131 : 					zFree (pCrl);

	push	OFFSET FLAT:$SG185973
	push	2131					; 00000853H
	push	OFFSET FLAT:$SG185974
	mov	ecx, DWORD PTR _pCrl$185968[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 2132 : 				}
; 2133 : 				else

	jmp	SHORT $L185975
$L185966:

; 2134 : 				{
; 2135 : 					crl = fetch_URL(crlUrl);

	mov	edx, DWORD PTR _crlUrl$[ebp]
	push	edx
	call	_fetch_URL
	add	esp, 4
	mov	DWORD PTR _crl$[ebp], eax

; 2136 : 					crlBlobList.push_back(crl);

	lea	eax, DWORD PTR _crl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back
$L185975:

; 2137 : 				}
; 2138 : 				if (crlBlobList.size()==0) {

	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	test	eax, eax
	jne	SHORT $L185962

; 2139 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 2140 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2141 : 					continue;

	jmp	$L185949
$L185962:

; 2142 : 				}
; 2143 : 			}
; 2144 : 		}

	jmp	$L185949
$L185950:

; 2145 : 
; 2146 : 		// list of BLOBs
; 2147 : 		for (UINT i=0; i<crlBlobList.size(); i++) 

	mov	DWORD PTR _i$185977[ebp], 0
	jmp	SHORT $L185978
$L185979:
	mov	edx, DWORD PTR _i$185977[ebp]
	add	edx, 1
	mov	DWORD PTR _i$185977[ebp], edx
$L185978:
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	cmp	DWORD PTR _i$185977[ebp], eax
	jae	$L185980

; 2148 : 		{
; 2149 : 			crl = crlBlobList.at(i);

	mov	eax, DWORD PTR _i$185977[ebp]
	push	eax
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::at
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _crl$[ebp], ecx

; 2150 : 			if (crl != NULL)

	cmp	DWORD PTR _crl$[ebp], 0
	je	$L185981

; 2151 : 			{
; 2152 : #ifdef DEBUG
; 2153 : 				char crlFileName[MAX_PATH];
; 2154 : 				sprintf(crlFileName, "c:\\temp\\fetchedCrl%02d_%02d.crl", crlIndex, i);

	mov	edx, DWORD PTR _i$185977[ebp]
	push	edx
	mov	eax, DWORD PTR _crlIndex$[ebp]
	push	eax
	push	OFFSET FLAT:$SG185983
	lea	ecx, DWORD PTR _crlFileName$185982[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2155 : 				FILE *fHandle = fopen((const char *)crlFileName, "wb");

	push	OFFSET FLAT:$SG185986
	lea	edx, DWORD PTR _crlFileName$185982[ebp]
	push	edx
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fHandle$185984[ebp], eax

; 2156 : 				fwrite((const void *)crl->pbData, crl->cbData, 1, fHandle);

	mov	eax, DWORD PTR _fHandle$185984[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fwrite
	add	esp, 16					; 00000010H

; 2157 : 				fclose(fHandle);

	mov	edx, DWORD PTR _fHandle$185984[ebp]
	push	edx
	call	_fclose
	add	esp, 4

; 2158 : #endif
; 2159 : 				// create CRL context
; 2160 : 				pCrlContext = CertCreateCRLContext(MY_TYPE,crl->pbData,crl->cbData);

	mov	esi, esp
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	65537					; 00010001H
	call	DWORD PTR __imp__CertCreateCRLContext@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCrlContext$[ebp], eax

; 2161 : 				if (pCrlContext==NULL) 

	cmp	DWORD PTR _pCrlContext$[ebp], 0
	jne	SHORT $L185988

; 2162 : 				{
; 2163 : 					cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 2164 : 					setError(pg_sig,CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2165 : 					ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2166 : 					if (crl->pbData) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L185989

; 2167 : 						zFree(crl->pbData);

	push	OFFSET FLAT:$SG185990
	push	2167					; 00000877H
	push	OFFSET FLAT:$SG185991
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L185989:

; 2168 : 					zFree (crl);

	push	OFFSET FLAT:$SG185992
	push	2168					; 00000878H
	push	OFFSET FLAT:$SG185993
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2169 : 					crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2170 : 					continue;

	jmp	$L185979
$L185988:

; 2171 : 				}
; 2172 : 				if (pCrlCache != NULL)

	cmp	DWORD PTR _pCrlCache$[ebp], 0
	je	SHORT $L185994

; 2173 : 				{
; 2174 : 					//Enter CRL into the CRL Cache
; 2175 : 					pCrlCache->EnterCRLIntoCRLCache(&pCrlContext->pCrlInfo->Issuer,crl, pg_sig);

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	mov	edx, DWORD PTR _crl$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _pCrlCache$[ebp]
	call	?EnterCRLIntoCRLCache@CRLCache@@QAEXPAU_CRYPTOAPI_BLOB@@PAU_DS_DATA_BLOB@@PAU_GLOBAL_SIG@@@Z ; CRLCache::EnterCRLIntoCRLCache
$L185994:

; 2176 : 				}
; 2177 : 				// Check to see if the CRL issuer and the certificate issuers are the same
; 2178 : 				if (certIsNameEqual(&pCertContext->pCertInfo->Issuer, 	&pCrlContext->pCrlInfo->Issuer) 
; 2179 : 						== TRUE) // certificate and CRL issuers match

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _pCertContext$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	add	edx, 24					; 00000018H
	push	edx
	call	_certIsNameEqual
	add	esp, 8
	cmp	eax, 1
	jne	$L185995

; 2180 : 				{
; 2181 : 					validCrlFound = TRUE;

	mov	DWORD PTR _validCrlFound$[ebp], 1

; 2182 : 					if (!CryptVerifyCertificateSignature(
; 2183 : 						(HCRYPTPROV) NULL,	// CSP
; 2184 : 						MY_TYPE,
; 2185 : 						pCrlContext->pbCrlEncoded,	
; 2186 : 						pCrlContext->cbCrlEncoded,
; 2187 : 						&pIssuerCertContext->pCertInfo->SubjectPublicKeyInfo))

	mov	eax, DWORD PTR _pIssuerCertContext$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, 56					; 00000038H
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	65537					; 00010001H
	push	0
	call	DWORD PTR __imp__CryptVerifyCertificateSignature@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L185997

; 2188 : 					{
; 2189 : 						cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 2190 : 						setError(pg_sig,CRL_BAD_SIGNATURE);

	push	72					; 00000048H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 2191 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2192 : 						CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2193 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2194 : 						if (crl->pbData) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L185998

; 2195 : 							zFree(crl->pbData);

	push	OFFSET FLAT:$SG185999
	push	2195					; 00000893H
	push	OFFSET FLAT:$SG186000
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L185998:

; 2196 : 						zFree (crl);

	push	OFFSET FLAT:$SG186001
	push	2196					; 00000894H
	push	OFFSET FLAT:$SG186002
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2197 : 						crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2198 : 						continue;

	jmp	$L185979
$L185997:

; 2199 : 					}
; 2200 : 					else // CRL has a valid signature from the cert issuer
; 2201 : 					{
; 2202 : 						PCERT_EXTENSION  pCertExtInfo = NULL;

	mov	DWORD PTR _pCertExtInfo$186004[ebp], 0

; 2203 : 						*crlFound = TRUE;

	mov	ecx, DWORD PTR _crlFound$[ebp]
	mov	DWORD PTR [ecx], 1

; 2204 : 						pCertExtInfo = CertFindExtension(	szOID_DELTA_CRL_INDICATOR,
; 2205 : 															pCrlContext->pCrlInfo->cExtension,
; 2206 : 															pCrlContext->pCrlInfo->rgExtension);

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET FLAT:$SG186005
	call	DWORD PTR __imp__CertFindExtension@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCertExtInfo$186004[ebp], eax

; 2207 : 						if (pCertExtInfo != NULL)

	cmp	DWORD PTR _pCertExtInfo$186004[ebp], 0
	je	SHORT $L186006

; 2208 : 						{
; 2209 : 							setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2210 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2211 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2212 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2213 : 							if (crl->pbData) 

	mov	ecx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L186007

; 2214 : 								zFree(crl->pbData);

	push	OFFSET FLAT:$SG186008
	push	2214					; 000008a6H
	push	OFFSET FLAT:$SG186009
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H
$L186007:

; 2215 : 							zFree (crl);

	push	OFFSET FLAT:$SG186010
	push	2215					; 000008a7H
	push	OFFSET FLAT:$SG186011
	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 2216 : 							crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2217 : 							break;

	jmp	$L185980
$L186006:

; 2218 : 						}
; 2219 : 						
; 2220 : 						pCertExtInfo = CertFindExtension(	szOID_ISSUING_DIST_POINT,
; 2221 : 															pCrlContext->pCrlInfo->cExtension,
; 2222 : 															pCrlContext->pCrlInfo->rgExtension);

	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	esi, esp
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	push	OFFSET FLAT:$SG186012
	call	DWORD PTR __imp__CertFindExtension@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pCertExtInfo$186004[ebp], eax

; 2223 : 						if (pCertExtInfo != NULL)

	cmp	DWORD PTR _pCertExtInfo$186004[ebp], 0
	je	SHORT $L186013

; 2224 : 						{
; 2225 : 							setError(pg_sig, CRL_ERROR);

	push	73					; 00000049H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2226 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2227 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2228 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2229 : 							if (crl->pbData) 

	mov	ecx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L186014

; 2230 : 								zFree(crl->pbData);

	push	OFFSET FLAT:$SG186015
	push	2230					; 000008b6H
	push	OFFSET FLAT:$SG186016
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H
$L186014:

; 2231 : 							zFree (crl);

	push	OFFSET FLAT:$SG186017
	push	2231					; 000008b7H
	push	OFFSET FLAT:$SG186018
	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 2232 : 							crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2233 : 							break;

	jmp	$L185980
$L186013:

; 2234 : 						}
; 2235 : 						// Lets add the base64 encoded CRL to the crl list
; 2236 : 						int size = base64encodeSize(crl->cbData);

	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _size$186019[ebp], eax

; 2237 : 						unsigned char *b64Crl = (unsigned char *)zMalloc(size+1);

	push	OFFSET FLAT:$SG186022
	push	2237					; 000008bdH
	push	OFFSET FLAT:$SG186023
	mov	ecx, DWORD PTR _size$186019[ebp]
	add	ecx, 1
	push	ecx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _b64Crl$186020[ebp], eax

; 2238 : 						if ((size = base64encode(crl->pbData, crl->cbData, b64Crl, size+1)) == -1)

	mov	edx, DWORD PTR _size$186019[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _b64Crl$186020[ebp]
	push	eax
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _size$186019[ebp], eax
	cmp	DWORD PTR _size$186019[ebp], -1
	jne	SHORT $L186024

; 2239 : 						{
; 2240 : 							setError(pg_sig, BASE64_ERROR);

	push	2
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2241 : 							zFree(b64Crl);

	push	OFFSET FLAT:$SG186025
	push	2241					; 000008c1H
	push	OFFSET FLAT:$SG186026
	mov	eax, DWORD PTR _b64Crl$186020[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2242 : 							break;

	jmp	$L185980
$L186024:

; 2243 : 						}
; 2244 : 						*(b64Crl + size) = '\0';

	mov	ecx, DWORD PTR _b64Crl$186020[ebp]
	add	ecx, DWORD PTR _size$186019[ebp]
	mov	BYTE PTR [ecx], 0

; 2245 : 						usedCrlList->insert(usedCrlList->begin(), b64Crl);

	lea	edx, DWORD PTR _b64Crl$186020[ebp]
	push	edx
	lea	eax, DWORD PTR $T187941[ebp]
	push	eax
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T187942[ebp]
	push	edx
	mov	ecx, DWORD PTR _usedCrlList$[ebp]
	call	?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert

; 2246 : 
; 2247 : 						if (!CertFindCertificateInCRL(pCertContext,pCrlContext,0,0,ppCrlEntry)) 

	mov	esi, esp
	mov	eax, DWORD PTR _ppCrlEntry$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCertContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFindCertificateInCRL@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L186029

; 2248 : 						{
; 2249 : 							// list wasn't searched
; 2250 : 							cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 2251 : 							setError(pg_sig,CRL_ERROR);

	push	73					; 00000049H
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 2252 : 							ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2253 : 							CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2254 : 							pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2255 : 							if (crl->pbData) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L186030

; 2256 : 								zFree(crl->pbData);

	push	OFFSET FLAT:$SG186031
	push	2256					; 000008d0H
	push	OFFSET FLAT:$SG186032
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L186030:

; 2257 : 							zFree (crl);

	push	OFFSET FLAT:$SG186033
	push	2257					; 000008d1H
	push	OFFSET FLAT:$SG186034
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2258 : 							crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2259 : 							continue;

	jmp	$L185979
$L186029:

; 2260 : 						}
; 2261 : 						//Add this to the Store for faster validation in the future
; 2262 : 						//CertAddCRLContextToStore(hStoreHandle, pCrlContext,CERT_STORE_ADD_NEWER,NULL);
; 2263 : 
; 2264 : 						if (pCrlEntry!=NULL) {

	cmp	DWORD PTR _pCrlEntry$[ebp], 0
	je	$L186003

; 2265 : 							// CRL contains this certificate
; 2266 : 							// Compare the revocation time with pTime
; 2267 : 							if (CompareFileTime((const FILETIME *)&pCrlEntry->RevocationDate, pTime) <= 0)

	mov	esi, esp
	mov	ecx, DWORD PTR _pTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pCrlEntry$[ebp]
	add	edx, 8
	push	edx
	call	DWORD PTR __imp__CompareFileTime@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jg	$L186003

; 2268 : 							{// The certificate was revoked before pTime
; 2269 : 								cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_cleanupError
	add	esp, 4

; 2270 : 								setError(pg_sig,CRL_CERT_REVOKED);

	push	75					; 0000004bH
	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 2271 : 								ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2272 : 								CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	edx, DWORD PTR _pCrlContext$[ebp]
	push	edx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2273 : 								pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2274 : 								pCrlEntry=NULL;

	mov	DWORD PTR _pCrlEntry$[ebp], 0

; 2275 : 								if (crl->pbData) 

	mov	eax, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L186038

; 2276 : 									zFree(crl->pbData);

	push	OFFSET FLAT:$SG186039
	push	2276					; 000008e4H
	push	OFFSET FLAT:$SG186040
	mov	ecx, DWORD PTR _crl$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L186038:

; 2277 : 								zFree (crl);

	push	OFFSET FLAT:$SG186041
	push	2277					; 000008e5H
	push	OFFSET FLAT:$SG186042
	mov	eax, DWORD PTR _crl$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 2278 : 								crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2279 : 								break;

	jmp	$L185980
$L186003:

; 2280 : 							}
; 2281 : 						}
; 2282 : 					}
; 2283 : 					if (CertVerifyCRLTimeValidity(pTime, pCrlContext->pCrlInfo) == 1)

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pTime$[ebp]
	push	eax
	call	DWORD PTR __imp__CertVerifyCRLTimeValidity@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	$L186043

; 2284 : 					{
; 2285 : 						cleanupError(pg_sig); // Remove all previous errors from the error stack

	mov	ecx, DWORD PTR _pg_sig$[ebp]
	push	ecx
	call	_cleanupError
	add	esp, 4

; 2286 : 						setError(pg_sig,CRL_TOO_OLD);

	push	87					; 00000057H
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 2287 : 						ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0

; 2288 : 						CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2289 : 						pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2290 : 						if (crl->pbData) 

	mov	ecx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L186044

; 2291 : 							zFree(crl->pbData);

	push	OFFSET FLAT:$SG186045
	push	2291					; 000008f3H
	push	OFFSET FLAT:$SG186046
	mov	edx, DWORD PTR _crl$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H
$L186044:

; 2292 : 						zFree (crl);

	push	OFFSET FLAT:$SG186047
	push	2292					; 000008f4H
	push	OFFSET FLAT:$SG186048
	mov	ecx, DWORD PTR _crl$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 2293 : 						crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2294 : 						break;

	jmp	$L185980
$L186043:

; 2295 : 					}
; 2296 : 					if (crl->pbData) 

	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L186049

; 2297 : 						zFree(crl->pbData);

	push	OFFSET FLAT:$SG186050
	push	2297					; 000008f9H
	push	OFFSET FLAT:$SG186051
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H
$L186049:

; 2298 : 					zFree (crl);

	push	OFFSET FLAT:$SG186052
	push	2298					; 000008faH
	push	OFFSET FLAT:$SG186053
	mov	edx, DWORD PTR _crl$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 2299 : 					crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2300 : 					CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	eax, DWORD PTR _pCrlContext$[ebp]
	push	eax
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2301 : 					break;

	jmp	SHORT $L185980
$L185995:

; 2302 : 				}
; 2303 : 				else // This CRL is not relevant since it's issuer is not the same as the certificate issuer
; 2304 : 				{
; 2305 : 					CertFreeCRLContext(pCrlContext);

	mov	esi, esp
	mov	ecx, DWORD PTR _pCrlContext$[ebp]
	push	ecx
	call	DWORD PTR __imp__CertFreeCRLContext@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2306 : 					pCrlContext = NULL;

	mov	DWORD PTR _pCrlContext$[ebp], 0

; 2307 : 					if (crl->pbData) 

	mov	edx, DWORD PTR _crl$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L186055

; 2308 : 						zFree(crl->pbData);

	push	OFFSET FLAT:$SG186056
	push	2308					; 00000904H
	push	OFFSET FLAT:$SG186057
	mov	eax, DWORD PTR _crl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H
$L186055:

; 2309 : 					zFree (crl);

	push	OFFSET FLAT:$SG186058
	push	2309					; 00000905H
	push	OFFSET FLAT:$SG186059
	mov	edx, DWORD PTR _crl$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 2310 : 					crl = NULL;

	mov	DWORD PTR _crl$[ebp], 0

; 2311 : 					continue;

	jmp	$L185979
$L185981:

; 2312 : 				}
; 2313 : 			}//if (crl != NULL)
; 2314 : 		}//for (UINT i=0; i<crlBlobList.size(); i++)

	jmp	$L185979
$L185980:

; 2315 : 	}//if (validCrlFound == FALSE)

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	call	??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::~vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
$L185688:

; 2316 : 	if (!(validCrlFound))

	cmp	DWORD PTR _validCrlFound$[ebp], 0
	jne	SHORT $L186060

; 2317 : 	{
; 2318 : 		setError(pg_sig,CRL_NOT_FOUND);

	push	74					; 0000004aH
	mov	eax, DWORD PTR _pg_sig$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 2319 : 		ret=FALSE;

	mov	DWORD PTR _ret$[ebp], 0
$L186060:

; 2320 : 	}
; 2321 : 	ExitPgSigLog;

	mov	ecx, DWORD PTR _ExitingFunction
	push	ecx
	push	OFFSET FLAT:$SG186062
	push	0
	mov	edx, DWORD PTR _pg_sig$[ebp]
	push	edx
	push	OFFSET FLAT:$SG186063
	push	2321					; 00000911H
	push	OFFSET FLAT:$SG186064
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 2322 : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 2323 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L187957
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 448				; 000001c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L187957:
	DD	7
	DD	$L187956
$L187956:
	DD	-32					; ffffffe0H
	DD	4
	DD	$L187946
	DD	-52					; ffffffccH
	DD	4
	DD	$L187947
	DD	-68					; ffffffbcH
	DD	4
	DD	$L187948
	DD	-96					; ffffffa0H
	DD	4
	DD	$L187949
	DD	-124					; ffffff84H
	DD	16					; 00000010H
	DD	$L187950
	DD	-404					; fffffe6cH
	DD	260					; 00000104H
	DD	$L187951
	DD	-428					; fffffe54H
	DD	4
	DD	$L187952
$L187952:
	DB	98					; 00000062H
	DB	54					; 00000036H
	DB	52					; 00000034H
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
$L187951:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L187950:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	66					; 00000042H
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	98					; 00000062H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$L187949:
	DB	98					; 00000062H
	DB	54					; 00000036H
	DB	52					; 00000034H
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
$L187948:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	67					; 00000043H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L187947:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	0
$L187946:
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	114					; 00000072H
	DB	108					; 0000006cH
	DB	69					; 00000045H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L187943:
	lea	ecx, DWORD PTR _crlBlobList$185947[ebp]
	jmp	??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::~vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
__ehhandler$?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T187945
	jmp	___CxxFrameHandler
text$x	ENDS
?check_CRL@@YAHPAXPBU_CERT_CONTEXT@@1PAU_FILETIME@@PAVCRLCache@@PAPADIHPAHPAV?$list@PAEV?$allocator@PAE@std@@@std@@PAU_GLOBAL_SIG@@@Z ENDP ; check_CRL
PUBLIC	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	??0?$allocator@PAE@std@@QAE@XZ			; std::allocator<unsigned char *>::allocator<unsigned char *>
PUBLIC	??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 280  : 		{	// construct empty list

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PAE@std@@QAE@XZ		; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 281  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::list<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 364  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 365  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy

; 366  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::~list<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
PUBLIC	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin, COMDAT
; _this$ = ecx

; 376  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 377  : 		return (iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::end, COMDAT
; _this$ = ecx

; 386  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (iterator(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 388  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::end
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::size, COMDAT
; _this$ = ecx

; 430  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 431  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 432  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ENDP	; std::list<unsigned char *,std::allocator<unsigned char *> >::size
_TEXT	ENDS
PUBLIC	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
PUBLIC	?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert, COMDAT
; _this$ = ecx

; 514  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 515  : 		_Insert(_Where, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert

; 516  : 		return (--_Where);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 517  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AViterator@12@V312@ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::insert
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 229  : 		iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator

; 230  : 			{	// construct with null node
; 231  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*

; 241  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEAAPAEXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--, COMDAT
; _this$ = ecx

; 268  : 			{	// postdecrement

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 270  : 			--*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--

; 271  : 			return (_Tmp);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 272  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L187980
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L187980:
	DD	1
	DD	$L187979
$L187979:
	DD	-12					; fffffff4H
	DD	4
	DD	$L187978
$L187978:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE?AV012@H@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z ; std::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
PUBLIC	??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ	; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>
PUBLIC	?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Buy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT
; _this$ = ecx

; 299  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ ; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z ; std::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >

; 300  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Buy

; 301  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Tidy
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::~vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT
; _this$ = ecx

; 387  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 388  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Tidy

; 389  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::~vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size, COMDAT
; _this$ = ecx

; 515  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L187988
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $L187989
$L187988:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$L187989:
	mov	eax, DWORD PTR tv70[ebp]

; 517  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin
PUBLIC	?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xran
PUBLIC	??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator*
PUBLIC	??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
;	COMDAT ?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT
$T187993 = -12						; size = 4
$T187992 = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::at, COMDAT
; _this$ = ecx

; 542  : 		{	// subscript mutable sequence with checking

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		if (size() <= _Pos)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	cmp	eax, DWORD PTR __Pos$[ebp]
	ja	SHORT $L186194

; 544  : 			_Xran();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xran
$L186194:

; 545  : 		return (*(begin() + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T187993[ebp]
	push	ecx
	lea	edx, DWORD PTR $T187992[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin
	mov	ecx, eax
	call	??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+
	mov	ecx, eax
	call	??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator*

; 546  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?at@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAPAU_DS_DATA_BLOB@@I@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::at
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::capacity
PUBLIC	?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::end
PUBLIC	?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::insert
PUBLIC	?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill
; Function compile flags: /Odt /RTCsu
;	COMDAT ?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT
$T187997 = -12						; size = 4
$T187996 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back, COMDAT
; _this$ = ecx

; 579  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 580  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::capacity
	cmp	esi, eax
	jae	SHORT $L186315

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 582  : 		else

	jmp	SHORT $L186314
$L186315:

; 583  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T187996[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::end
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR $T187997[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::insert
$L186314:

; 584  : 		}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEXABQAU_DS_DATA_BLOB@@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::push_back
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode, COMDAT

; 107  : 		{	// return reference to successor pointer in node

	push	ebp
	mov	ebp, esp

; 108  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 109  : 		}

	pop	ebp
	ret	0
?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
_TEXT	ENDS
PUBLIC	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize
PUBLIC	?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
PUBLIC	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z
_TEXT	SEGMENT
__Newnode$ = -12					; size = 4
__Pnode$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert, COMDAT
; _this$ = ecx

; 521  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 522  : 		_Nodeptr _Pnode = _Where._Mynode();

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 523  : 		_Nodeptr _Newnode = _Buynode(_Pnode, _Prevnode(_Pnode), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 524  : 		_Incsize(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize

; 525  : 		_Prevnode(_Pnode) = _Newnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 526  : 		_Nextnode(_Prevnode(_Newnode)) = _Newnode;

	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx

; 527  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Insert@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXViterator@12@ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate
PUBLIC	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
PUBLIC	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188013 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T188015 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188006
$T188014 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T188015
$T188008 DD	019930520H
	DD	02H
	DD	FLAT:$T188013
	DD	01H
	DD	FLAT:$T188014
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
_TEXT	SEGMENT
tv93 = -44						; size = 4
tv92 = -40						; size = 4
__Linkcnt$ = -36					; size = 4
__Pnode$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode, COMDAT
; _this$ = ecx

; 898  : 		{	// allocate a head node and set links

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 899  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 900  : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 901  : 
; 902  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 903  : 		this->_Alptr.construct(&_Nextnode(_Pnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	DWORD PTR tv92[ebp], eax
	lea	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv92[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct

; 904  : 		++_Linkcnt;

	mov	eax, DWORD PTR __Linkcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR __Linkcnt$[ebp], eax

; 905  : 		this->_Alptr.construct(&_Prevnode(_Pnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	DWORD PTR tv93[ebp], eax
	lea	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	eax, DWORD PTR tv93[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
	jmp	SHORT $L188005
$L188006:

; 906  : 		_CATCH_ALL
; 907  : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $L186552

; 908  : 			this->_Alptr.destroy(&_Nextnode(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
$L186552:

; 909  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 910  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188005:

; 911  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 912  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L188003:

; 913  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188012
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 44					; 0000002cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L188012:
	DD	1
	DD	$L188011
$L188011:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L188009
$L188009:
	DB	95					; 0000005fH
	DB	80					; 00000050H
	DB	110					; 0000006eH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ:
	mov	eax, OFFSET FLAT:$T188008
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
PUBLIC	?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy, COMDAT
; _this$ = ecx

; 929  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 930  : 		clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear

; 931  : 		this->_Alptr.destroy(&_Nextnode(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy

; 932  : 		this->_Alptr.destroy(&_Prevnode(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy

; 933  : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 934  : 		_Myhead = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 935  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$allocator@PAE@std@@QAE@ABV01@@Z		; std::allocator<unsigned char *>::allocator<unsigned char *>
PUBLIC	??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 82   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>

; 83   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_val@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_val<unsigned char *,std::allocator<unsigned char *> >::_List_val<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAE@std@@QAE@XZ PROC NEAR		; std::allocator<unsigned char *>::allocator<unsigned char *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAE@std@@QAE@XZ ENDP			; std::allocator<unsigned char *>::allocator<unsigned char *>
_TEXT	ENDS
PUBLIC	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 235  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator

; 236  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--, COMDAT
; _this$ = ecx

; 262  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--

; 264  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 265  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::iterator::operator--
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 151  : 			{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 152  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 160  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
	add	esp, 4

; 162  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEABQAEXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::capacity, COMDAT
; _this$ = ecx

; 457  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L188035
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $L188036
$L188035:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$L188036:
	mov	eax, DWORD PTR tv70[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::capacity
_TEXT	ENDS
PUBLIC	??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
;	COMDAT ?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin, COMDAT
; _this$ = ecx

; 462  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return (iterator(_Myfirst));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 464  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::end, COMDAT
; _this$ = ecx

; 472  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 473  : 		return (iterator(_Mylast));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::end
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Insert_n
PUBLIC	??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT
tv73 = -20						; size = 4
$T188046 = -16						; size = 4
$T188043 = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::insert, COMDAT
; _this$ = ecx

; 620  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	test	eax, eax
	jne	SHORT $L188044
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $L188045
$L188044:
	lea	eax, DWORD PTR $T188043[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator-
	mov	DWORD PTR tv73[ebp], eax
$L188045:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Insert_n

; 623  : 		return (begin() + _Off);

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	lea	eax, DWORD PTR $T188046[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::begin
	mov	ecx, eax
	call	??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 624  : 		}

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?insert@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE?AViterator@12@V312@ABQAU_DS_DATA_BLOB@@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::allocate
PUBLIC	?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size
PUBLIC	?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xlen
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Buy, COMDAT
; _this$ = ecx

; 770  : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 772  : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $L186589

; 773  : 			return (false);

	xor	al, al
	jmp	SHORT $L186588
$L186589:

; 774  : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $L186591

; 775  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xlen

; 776  : 		else

	jmp	SHORT $L186590
$L186591:

; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 779  : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 780  : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$L186590:

; 781  : 			}
; 782  : 		return (true);

	mov	al, 1
$L186588:

; 783  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::deallocate
PUBLIC	?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Tidy, COMDAT
; _this$ = ecx

; 791  : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 792  : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L186595

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::deallocate
$L186595:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 798  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Uninitialized_fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill, COMDAT
; _this$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Uninitialized_fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
	add	esp, 16					; 00000010H

; 879  : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 880  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ ; `string'
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188061 DD	0ffffffffH
	DD	FLAT:$L188057
$T188059 DD	019930520H
	DD	01H
	DD	FLAT:$T188061
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
CONST	SEGMENT
??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@ DB 'invalid v'
	DB	'ector<T> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T188056 = -84						; size = 28
$T188055 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xran, COMDAT
; _this$ = ecx

; 888  : 		{	// report an out_of_range error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 889  : 		_THROW(out_of_range, "invalid vector<T> subscript");

	push	OFFSET FLAT:??_C@_0BM@NMJKDPPO@invalid?5vector?$DMT?$DO?5subscript?$AA@
	lea	ecx, DWORD PTR $T188056[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T188056[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188055[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET FLAT:__TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T188055[ebp]
	push	ecx
	call	__CxxThrowException@8
$L188054:

; 890  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188057:
	lea	ecx, DWORD PTR $T188056[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T188059
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xran@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xran
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_7out_of_range@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_Eout_of_range@std@@UAEPAXI@Z ; std::out_of_range::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188074 DD	0ffffffffH
	DD	FLAT:$L188069
$T188072 DD	019930520H
	DD	01H
	DD	FLAT:$T188074
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_Elogic_error@std@@UAEPAXI@Z ; std::logic_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@XZ			; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 20   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188069:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET FLAT:$T188072
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 26   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 28   : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L167931
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L167931:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188088 DD	0ffffffffH
	DD	FLAT:$L188083
$T188086 DD	019930520H
	DD	01H
	DD	FLAT:$T188088
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1exception@@UAE@XZ			; exception::~exception
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188083:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T188086
	jmp	___CxxFrameHandler
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7out_of_range@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L168019
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L168019:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
; Function compile flags: /Odt /RTCsu
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L186321

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L186321:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L186323

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L186323:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L186324

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L186442
$L186324:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L186442

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L186442:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$186449 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L186446

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L186447
$L186446:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L186447

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$186449[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L186450

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$186449[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L186450:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$186449[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L186447:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L188111
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L188112
$L188111:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L188112:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z ; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z PROC NEAR ; std::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT
; _this$ = ecx

; 21   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z ; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>

; 22   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAE@V?$allocator@PAU_DS_DATA_BLOB@@@1@@Z ENDP ; std::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Vector_val<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ PROC NEAR	; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@XZ ENDP	; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator*, COMDAT
; _this$ = ecx

; 219  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 220  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator*

; 221  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEAAPAU_DS_DATA_BLOB@@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+=
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Tmp$ = -12						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+, COMDAT
; _this$ = ecx

; 261  : 			{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 263  : 			return (_Tmp += _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+=
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 264  : 			}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188127
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L188127:
	DD	1
	DD	$L188126
$L188126:
	DD	-12					; fffffff4H
	DD	4
	DD	$L188125
$L188125:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
??Hiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188138 DD	0ffffffffH
	DD	FLAT:$L188133
$T188136 DD	019930520H
	DD	01H
	DD	FLAT:$T188138
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0exception@@QAE@ABV0@@Z		; exception::exception
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188133:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T188136
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$186650 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L186647

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L186647:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L186648

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L186648:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L186649

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$186650[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$186650[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L186649:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T188152 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T188152[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T188152[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L186658

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L186658:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L186659

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L186660
$L186659:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L186661
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L186661

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L188157
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L188158
$L188157:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L188158:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L186660
$L186661:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L186660

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L186660:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L188161
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L188162
$L188161:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L188162:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode, COMDAT

; 112  : 		{	// return reference to predecessor pointer in node

	push	ebp
	mov	ebp, esp

; 113  : 		return ((_Nodepref)(*_Pnode)._Prev);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 114  : 		}

	pop	ebp
	ret	0
?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval, COMDAT

; 117  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 118  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 119  : 		}

	pop	ebp
	ret	0
?_Myval@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Myval
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Pnode$ = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear, COMDAT
; _this$ = ecx

; 610  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 611  : 		_Nodeptr _Pnext;
; 612  : 		_Nodeptr _Pnode = _Nextnode(_Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx

; 613  : 		_Nextnode(_Myhead) = _Myhead;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax], ecx

; 614  : 		_Prevnode(_Myhead) = _Myhead;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 615  : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 616  : 
; 617  : 		for (; _Pnode != _Myhead; _Pnode = _Pnext)

	jmp	SHORT $L186676
$L186677:
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	DWORD PTR __Pnode$[ebp], ecx
$L186676:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	je	SHORT $L186673

; 618  : 			{	// delete an element
; 619  : 			_Pnext = _Nextnode(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Nextnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Nextnode
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnext$[ebp], edx

; 620  : 			this->_Alnod.destroy(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy

; 621  : 			this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 622  : 			}

	jmp	SHORT $L186677
$L186673:

; 623  : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$list@PAEV?$allocator@PAE@std@@@std@@QAEXXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::clear
_TEXT	ENDS
PUBLIC	??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188183 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L188179
	DD	0ffffffffH
	DD	00H
$T188185 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188178
$T188184 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T188185
$T188181 DD	019930520H
	DD	03H
	DD	FLAT:$T188183
	DD	01H
	DD	FLAT:$T188184
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
_TEXT	SEGMENT
tv79 = -40						; size = 4
tv89 = -36						; size = 4
$T188174 = -32						; size = 4
$T188173 = -28						; size = 4
__Pnode$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Next$ = 8						; size = 4
__Prev$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode, COMDAT
; _this$ = ecx

; 917  : 		{	// allocate a node and set links and value

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 		_Nodeptr _Pnode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
	mov	DWORD PTR __Pnode$[ebp], eax

; 919  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 920  : 		new ((void *)_Pnode) _Node(_Next, _Prev, _Val);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	push	12					; 0000000cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T188174[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T188174[ebp], 0
	je	SHORT $L188175
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Prev$[ebp]
	push	edx
	mov	eax, DWORD PTR __Next$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T188174[ebp]
	call	??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
	mov	DWORD PTR tv89[ebp], eax
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $L188176
$L188175:
	mov	DWORD PTR tv79[ebp], 0
$L188176:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T188173[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $L188177
$L188178:

; 921  : 		_CATCH_ALL
; 922  : 		this->_Alnod.deallocate(_Pnode, 1);

	push	1
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate

; 923  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188177:

; 924  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 925  : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
$L188172:

; 926  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188179:
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T188174[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z:
	mov	eax, OFFSET FLAT:$T188181
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$list@PAEV?$allocator@PAE@std@@@std@@IAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@0ABQAE@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Buynode
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT

; 63   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 64   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 65   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 68   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 69   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
xdata$x	SEGMENT
$T188200 DD	0ffffffffH
	DD	FLAT:$L188196
$T188198 DD	019930520H
	DD	01H
	DD	FLAT:$T188200
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@ DB 'list<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T188195 = -84						; size = 28
$T188194 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize, COMDAT
; _this$ = ecx

; 956  : 		{	// alter element count, with checking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 957  : 		if (max_size() - _Mysize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L186691

; 958  : 			_THROW(length_error, "list<T> too long");

	push	OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T188195[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T188195[ebp]
	push	edx
	lea	ecx, DWORD PTR $T188194[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T188194[ebp]
	push	eax
	call	__CxxThrowException@8
$L186691:

; 959  : 		_Mysize += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$L188193:

; 960  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188196:
	lea	ecx, DWORD PTR $T188195[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z:
	mov	eax, OFFSET FLAT:$T188198
	jmp	___CxxFrameHandler
text$x	ENDS
?_Incsize@?$list@PAEV?$allocator@PAE@std@@@std@@IAEXI@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Incsize
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
;	COMDAT ??_7length_error@std@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_Elength_error@std@@UAEPAXI@Z ; std::length_error::`vftable'
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7length_error@std@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L167997
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L167997:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>
PUBLIC	??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 64   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAE@std@@QAE@ABV01@@Z	; std::allocator<unsigned char *>::allocator<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>

; 65   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_ptr@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_ptr<unsigned char *,std::allocator<unsigned char *> >::_List_ptr<unsigned char *,std::allocator<unsigned char *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAE@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAE@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<unsigned char *>::allocator<unsigned char *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAE@std@@QAE@ABV01@@Z ENDP		; std::allocator<unsigned char *>::allocator<unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@I@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 146  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
	add	esp, 8

; 148  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::destroy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 156  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 157  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAE@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 183  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 			_Ptr = _Prevnode(_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Prevnode@?$list@PAEV?$allocator@PAE@std@@@std@@KAAAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@PAU342@@Z ; std::list<unsigned char *,std::allocator<unsigned char *> >::_Prevnode
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax

; 185  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 186  : 			}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QAEAAV012@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::operator--
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 206  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 208  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$list@PAEV?$allocator@PAE@std@@@std@@QBEPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@3@XZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ ; std::allocator<_DS_DATA_BLOB *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size, COMDAT
; _this$ = ecx

; 520  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 521  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ ; std::allocator<_DS_DATA_BLOB *>::max_size

; 522  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy, COMDAT
; _this$ = ecx

; 786  : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
	add	esp, 12					; 0000000cH

; 788  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>
PUBLIC	??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z ; std::fill<_DS_DATA_BLOB * *,_DS_DATA_BLOB *>
PUBLIC	??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z ; std::copy_backward<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188248 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T188250 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188239
$T188251 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188241
$T188249 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T188250
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T188251
$T188243 DD	019930520H
	DD	04H
	DD	FLAT:$T188248
	DD	02H
	DD	FLAT:$T188249
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT
tv240 = -60						; size = 4
tv239 = -56						; size = 4
tv85 = -52						; size = 4
__Oldend$186780 = -48					; size = 4
__Ptr$186760 = -44					; size = 4
__Newvec$186759 = -40					; size = 4
__Capacity$ = -36					; size = 4
__Tmp$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Insert_n, COMDAT
; _this$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 11					; 0000000bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 811  : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 812  : 
; 813  : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $L186753

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

	jmp	$L188235
$L186753:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L186755

; 816  : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xlen

; 817  : 		else if (_Capacity < size() + _Count)

	jmp	$L188235
$L186755:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$L186757

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $L188236
	mov	DWORD PTR tv85[ebp], 0
	jmp	SHORT $L188237
$L188236:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv85[ebp], edx
$L188237:
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 821  : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $L186758

; 822  : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$L186758:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::allocate
	mov	DWORD PTR __Newvec$186759[ebp], eax

; 824  : 			pointer _Ptr = _Newvec;

	mov	edx, DWORD PTR __Newvec$186759[ebp]
	mov	DWORD PTR __Ptr$186760[ebp], edx

; 825  : 
; 826  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR __Newvec$186759[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>
	mov	DWORD PTR tv239[ebp], eax
	mov	ecx, DWORD PTR tv239[ebp]
	mov	DWORD PTR __Ptr$186760[ebp], ecx

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$186760[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill
	mov	DWORD PTR tv240[ebp], eax
	mov	edx, DWORD PTR tv240[ebp]
	mov	DWORD PTR __Ptr$186760[ebp], edx

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	eax, DWORD PTR __Ptr$186760[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>
	jmp	SHORT $L188238
$L188239:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

	mov	ecx, DWORD PTR __Ptr$186760[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$186759[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$186759[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::deallocate

; 834  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188238:

; 835  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 836  : 
; 837  : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEIXZ ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 838  : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $L186767

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z ; std::allocator<_DS_DATA_BLOB *>::deallocate
$L186767:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$186759[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 844  : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$186759[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 845  : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$186759[ebp]
	mov	DWORD PTR [edx+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	jmp	$L188235
$L186757:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$L186770

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>

; 851  : 
; 852  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU3@IABQAU3@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ufill
	jmp	SHORT $L188240
$L188241:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXPAPAU_DS_DATA_BLOB@@0@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Destroy

; 857  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188240:

; 858  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 859  : 
; 860  : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z ; std::fill<_DS_DATA_BLOB * *,_DS_DATA_BLOB *>
	add	esp, 12					; 0000000cH

; 863  : 			}
; 864  : 		else

	jmp	SHORT $L188235
$L186770:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$186780[ebp], eax

; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Oldend$186780[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$186780[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$186780[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$186780[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	call	??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z ; std::copy_backward<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
	add	esp, 12					; 0000000cH

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	call	??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z ; std::fill<_DS_DATA_BLOB * *,_DS_DATA_BLOB *>
	add	esp, 12					; 0000000cH
$L188235:

; 873  : 			}
; 874  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188247
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L188247:
	DD	1
	DD	$L188246
$L188246:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L188244
$L188244:
	DB	95					; 0000005fH
	DB	84					; 00000054H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z:
	mov	eax, OFFSET FLAT:$T188243
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEXViterator@12@IABQAU_DS_DATA_BLOB@@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Insert_n
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188262 DD	0ffffffffH
	DD	FLAT:$L188258
$T188260 DD	019930520H
	DD	01H
	DD	FLAT:$T188262
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T188257 = -84						; size = 28
$T188256 = -56						; size = 40
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xlen, COMDAT
; _this$ = ecx

; 883  : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 884  : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T188257[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T188257[ebp]
	push	eax
	lea	ecx, DWORD PTR $T188256[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T188256[ebp]
	push	ecx
	call	__CxxThrowException@8
$L188255:

; 885  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 84					; 00000054H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188258:
	lea	ecx, DWORD PTR $T188257[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T188260
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IBEXXZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAU_DS_DATA_BLOB@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<_DS_DATA_BLOB *>::allocator<_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z PROC NEAR ; std::allocator<_DS_DATA_BLOB *>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEXPAPAU_DS_DATA_BLOB@@I@Z ENDP ; std::allocator<_DS_DATA_BLOB *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z ; std::_Allocate<_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z PROC NEAR ; std::allocator<_DS_DATA_BLOB *>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z ; std::_Allocate<_DS_DATA_BLOB *>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAU_DS_DATA_BLOB@@@std@@QAEPAPAU_DS_DATA_BLOB@@I@Z ENDP ; std::allocator<_DS_DATA_BLOB *>::allocate
_TEXT	ENDS
PUBLIC	??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::iterator, COMDAT
; _this$ = ecx

; 215  : 			{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::const_iterator

; 216  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+=, COMDAT
; _this$ = ecx

; 255  : 			{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 256  : 			this->_Myptr += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 257  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 258  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??Yiterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator+=
_TEXT	ENDS
PUBLIC	??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
;	COMDAT ??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T188277 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator-, COMDAT
; _this$ = ecx

; 278  : 			{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 			return ((const_iterator)*this - _Right);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T188277[ebp], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T188277[ebp]
	call	??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator-

; 280  : 			}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Giterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::iterator::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 79   : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 83   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEABQAU_DS_DATA_BLOB@@XZ ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator*
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L188289
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L188290
$L188289:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L188290:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T188300 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T188302 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188296
$T188303 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L188294
$T188301 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T188302
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T188303
$T188298 DD	019930520H
	DD	04H
	DD	FLAT:$T188300
	DD	02H
	DD	FLAT:$T188301
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L186827

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L186828
$L186827:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L186828
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L186828

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L186828:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L188293
$L188294:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L188295
$L188296:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L188295:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L188293
	ret	0
$L188293:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L186833

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L186833:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L188292:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T188298
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAE@std@@QBEIXZ		; std::allocator<unsigned char *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
;	COMDAT ?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ PROC NEAR ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size, COMDAT
; _this$ = ecx

; 435  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 436  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?max_size@?$allocator@PAE@std@@QBEIXZ	; std::allocator<unsigned char *>::max_size

; 437  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$list@PAEV?$allocator@PAE@std@@@std@@QBEIXZ ENDP ; std::list<unsigned char *,std::allocator<unsigned char *> >::max_size
_TEXT	ENDS
PUBLIC	??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z PROC NEAR ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >, COMDAT
; _this$ = ecx

; 44   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>

; 45   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_List_nod@PAEV?$allocator@PAE@std@@@std@@IAE@V?$allocator@PAE@1@@Z ENDP ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_List_nod<unsigned char *,std::allocator<unsigned char *> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 151  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
	add	esp, 4

; 153  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAEXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@2@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::destroy
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ PROC NEAR ; std::allocator<_DS_DATA_BLOB *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188316
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188317
$L188316:
	mov	DWORD PTR tv65[ebp], 1
$L188317:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAU_DS_DATA_BLOB@@@std@@QBEIXZ ENDP ; std::allocator<_DS_DATA_BLOB *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 73   : 		const_iterator(_Tptr _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0const_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QAE@PAPAU_DS_DATA_BLOB@@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::const_iterator
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator-, COMDAT
; _this$ = ecx

; 140  : 			{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 144  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??Gconst_iterator@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::const_iterator::operator-
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\list
_TEXT	ENDS
;	COMDAT ??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Nextarg$ = 8						; size = 4
__Prevarg$ = 12						; size = 4
__Myvalarg$ = 16					; size = 4
??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z PROC NEAR ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node, COMDAT
; _this$ = ecx

; 34   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Nextarg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Prevarg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Myvalarg$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 35   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@QAE@PAU012@0ABQAE@Z ENDP ; std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L186862

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L186861
$L186862:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L186863

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L186863:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L186861:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188330
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188331
$L188330:
	mov	DWORD PTR tv65[ebp], 1
$L188331:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAE@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@PAE@std@@QBEIXZ PROC NEAR		; std::allocator<unsigned char *>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L188334
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L188335
$L188334:
	mov	DWORD PTR tv65[ebp], 1
$L188335:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAE@std@@QBEIXZ ENDP		; std::allocator<unsigned char *>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L186885
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L186884
$L186885:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L186883
$L186884:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L186883:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ; std::_Ptr_cat<_DS_DATA_BLOB>
PUBLIC	??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<_DS_DATA_BLOB *,unsigned int,_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT
$T188340 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ; std::_Ptr_cat<_DS_DATA_BLOB>
	add	esp, 8
	mov	BYTE PTR $T188340[ebp], al
	mov	dl, BYTE PTR $T188340[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<_DS_DATA_BLOB *,unsigned int,_DS_DATA_BLOB *>
	add	esp, 20					; 00000014H

; 258  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ENDP ; std::_Uninitialized_fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAE@?$allocator@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *><unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 12					; 0000000cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T188347 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>, COMDAT

; 41   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T188347[ebp], eax
	cmp	DWORD PTR $T188347[ebp], 0
	je	SHORT $L188348
	mov	ecx, DWORD PTR $T188347[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR $T188347[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	jmp	SHORT $L187085
$L188348:
	mov	DWORD PTR tv68[ebp], 0
$L187085:

; 43   : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *,std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT
$T188354 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z PROC NEAR ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT

; 216  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ; std::_Ptr_cat<_DS_DATA_BLOB>
	add	esp, 8
	mov	BYTE PTR $T188354[ebp], al
	mov	dl, BYTE PTR $T188354[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
	add	esp, 16					; 00000010H

; 218  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ENDP ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Uninitialized_copy<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z PROC NEAR ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>, COMDAT
; _this$ = ecx

; 801  : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ; std::_Uninitialized_copy<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *,std::allocator<_DS_DATA_BLOB *> >
	add	esp, 16					; 00000010H

; 805  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAU_DS_DATA_BLOB@@@?$vector@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@IAEPAPAU_DS_DATA_BLOB@@PAPAU2@00@Z ENDP ; std::vector<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >::_Ucopy<_DS_DATA_BLOB * *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z PROC NEAR ; std::fill<_DS_DATA_BLOB * *,_DS_DATA_BLOB *>, COMDAT

; 1134 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 1135 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $L187120
$L187121:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$L187120:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $L187119

; 1136 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $L187121
$L187119:

; 1137 : 	}

	pop	ebp
	ret	0
??$fill@PAPAU_DS_DATA_BLOB@@PAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@0ABQAU1@@Z ENDP ; std::fill<_DS_DATA_BLOB * *,_DS_DATA_BLOB *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z
_TEXT	SEGMENT
$T188361 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z PROC NEAR ; std::copy_backward<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>, COMDAT

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ; std::_Ptr_cat<_DS_DATA_BLOB>
	add	esp, 8
	mov	BYTE PTR $T188361[ebp], al
	mov	dl, BYTE PTR $T188361[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
	add	esp, 16					; 00000010H

; 1070 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00@Z ENDP ; std::copy_backward<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z PROC NEAR ; std::_Allocate<_DS_DATA_BLOB *>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@PAU_DS_DATA_BLOB@@@std@@YAPAPAU_DS_DATA_BLOB@@IPAPAU1@@Z ENDP ; std::_Allocate<_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z PROC NEAR ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>, COMDAT
; _this$ = ecx

; 120  : 		allocator(const allocator<_Other>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAE@?$allocator@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@QAE@ABV?$allocator@PAE@1@@Z ENDP ; std::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>::allocator<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node><unsigned char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>, COMDAT

; 48   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@std@@@std@@YAXPAU_Node@?$_List_nod@PAEV?$allocator@PAE@std@@@0@@Z ENDP ; std::_Destroy<std::_List_nod<unsigned char *,std::allocator<unsigned char *> >::_Node>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z
_TEXT	SEGMENT
__Cat$ = -5						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z PROC NEAR ; std::_Ptr_cat<_DS_DATA_BLOB>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 221  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L188374
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	esp, ebp
	pop	ebp
	ret	0
$L188374:
	DD	1
	DD	$L188373
$L188373:
	DD	-5					; fffffffbH
	DD	1
	DD	$L188372
$L188372:
	DB	95					; 0000005fH
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	0
??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ENDP ; std::_Ptr_cat<_DS_DATA_BLOB>
_TEXT	ENDS
PUBLIC	??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z ; std::fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<_DS_DATA_BLOB *,unsigned int,_DS_DATA_BLOB *>, COMDAT

; 236  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 237  : 	fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z ; std::fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *>
	add	esp, 12					; 0000000cH

; 238  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Uninit_fill_n@PAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<_DS_DATA_BLOB *,unsigned int,_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 234  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@PAU_DS_DATA_BLOB@@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAXPAPAU_DS_DATA_BLOB@@0AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<_DS_DATA_BLOB *,std::allocator<_DS_DATA_BLOB *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_DS_DATA_BLOB *,_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z
_TEXT	SEGMENT
$T188381 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *,std::allocator<_DS_DATA_BLOB *> >, COMDAT

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@U_DS_DATA_BLOB@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAU_DS_DATA_BLOB@@0@Z ; std::_Ptr_cat<_DS_DATA_BLOB>
	add	esp, 8
	mov	BYTE PTR $T188381[ebp], al
	mov	dl, BYTE PTR $T188381[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<_DS_DATA_BLOB *,_DS_DATA_BLOB *>
	add	esp, 20					; 00000014H

; 129  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAU_DS_DATA_BLOB@@PAPAU1@V?$allocator@PAU_DS_DATA_BLOB@@@std@@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@@Z ENDP ; std::_Uninitialized_copy<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *,std::allocator<_DS_DATA_BLOB *> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>, COMDAT

; 1058 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1062 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAU_DS_DATA_BLOB@@PAPAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<_DS_DATA_BLOB * *,_DS_DATA_BLOB * *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z PROC NEAR ; std::fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *>, COMDAT

; 1159 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $L187207
$L187208:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$L187207:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L187206

; 1161 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $L187208
$L187206:

; 1162 : 	}

	pop	ebp
	ret	0
??$fill_n@PAPAU_DS_DATA_BLOB@@IPAU1@@std@@YAXPAPAU_DS_DATA_BLOB@@IABQAU1@@Z ENDP ; std::fill_n<_DS_DATA_BLOB * *,unsigned int,_DS_DATA_BLOB *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<_DS_DATA_BLOB *,_DS_DATA_BLOB *>, COMDAT

; 105  : 	{	// copy [_First, _Last) to raw _Dest, (const) scalar type

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 106  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]

; 109  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAU_DS_DATA_BLOB@@PAU1@@std@@YAPAPAU_DS_DATA_BLOB@@PAPAU1@00AAV?$allocator@PAU_DS_DATA_BLOB@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_DS_DATA_BLOB *,_DS_DATA_BLOB *>
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T188408 DD	0ffffffffH
	DD	FLAT:$L188404
$T188406 DD	019930520H
	DD	01H
	DD	FLAT:$T188408
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L188404:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T188406
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
