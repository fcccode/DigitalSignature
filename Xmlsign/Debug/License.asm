; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\License.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFEEKIIE@mbstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JADEDFCN@wcstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DFFCODPF@m_pData?9?$DOnRefs?5?$DN?$DN?5?91?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFNMPDFA@m_pData?9?$DOnDataLength?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JINHKJCC@pData?9?$DOnRefs?5?$DM?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNGMIMJM@pData?9?$DOnRefs?5?$DM?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@EIPLHBJE@CFixedStringMgr?3?3Allocate?$CI?$CJ?5spil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@PINPFILO@CFixedStringMgr?3?3Reallocate?$CI?$CJ?5sp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDHCGOCC@m_pMemMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@ENACCIMA@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KICONMKH@pData?9?$DOpStringMgr?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPMMCKHL@?$CI?$CIWORD?$CJ?$CI?$CIDWORD_PTR?$CJ?$CIpsz?$CJ?5?$DO?$DO?516?$CJ?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BDLMIBLB@pFormat?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGFACAOB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KCADNOJC@?$CF02ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@FKADHJGH@strFormat?4LoadStringA?$CInFormatID?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJEKGMMD@Warning?3?5implicit?5LoadString?$CI?$CFu?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@GDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@GDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@G@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dowiden@?$ctype@G@std@@IBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Donarrow@?$ctype@G@std@@IBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@G@ATL@@CGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@G@ATL@@KGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@G@ATL@@KGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@G@ATL@@KGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@G@ATL@@SAPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTimeSpan@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatGmt@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLicense@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Preallocate@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormat@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendChar@?$CSimpleStringT@D$0A@@ATL@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@G@std@@@std@@YAABV?$ctype@G@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlIsValidString@ATL@@YAHPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CLicense@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBJEMDLA@nRet?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@MLJMCNFJ@pStringMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?wCRC16a@@3PAGA					; wCRC16a
PUBLIC	?wCRC16b@@3PAGA					; wCRC16b
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWThunk
PUBLIC	?LICENSE@CLicense@@2PBEB			; CLicense::LICENSE
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWThunk
PUBLIC	?VERSION@CLicense@@2PBEB			; CLicense::VERSION
PUBLIC	?EXP_DATE@CLicense@@2PBEB			; CLicense::EXP_DATE
PUBLIC	?MAINT_EXP_DATE@CLicense@@2PBEB			; CLicense::MAINT_EXP_DATE
PUBLIC	?ISSUE_DATE@CLicense@@2PBEB			; CLicense::ISSUE_DATE
PUBLIC	?YEAR@CLicense@@2PBEB				; CLicense::YEAR
PUBLIC	?MON@CLicense@@2PBEB				; CLicense::MON
PUBLIC	?DAY@CLicense@@2PBEB				; CLicense::DAY
PUBLIC	?OPERATIONS@CLicense@@2PBEB			; CLicense::OPERATIONS
PUBLIC	?VERIFY@CLicense@@2PBEB				; CLicense::VERIFY
PUBLIC	?CREATE@CLicense@@2PBEB				; CLicense::CREATE
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?ENCRYPT@CLicense@@2PBEB			; CLicense::ENCRYPT
PUBLIC	?DECRYPT@CLicense@@2PBEB			; CLicense::DECRYPT
PUBLIC	?SECURESIGN@CLicense@@2PBEB			; CLicense::SECURESIGN
PUBLIC	?SECURESIGNPROFESSIONAL@CLicense@@2PBEB		; CLicense::SECURESIGNPROFESSIONAL
PUBLIC	?SECURESIGNENTERPRISE@CLicense@@2PBEB		; CLicense::SECURESIGNENTERPRISE
PUBLIC	?SECURESIGNSERVER@CLicense@@2PBEB		; CLicense::SECURESIGNSERVER
PUBLIC	?TYPE@CLicense@@2PBEB				; CLicense::TYPE
PUBLIC	?SERVER@CLicense@@2PBEB				; CLicense::SERVER
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CLIENT@CLicense@@2PBEB				; CLicense::CLIENT
PUBLIC	?DEMO@CLicense@@2PBEB				; CLicense::DEMO
PUBLIC	?DEVELOPMENT@CLicense@@2PBEB			; CLicense::DEVELOPMENT
PUBLIC	?LICENSE_KEY@CLicense@@2PBEB			; CLicense::LICENSE_KEY
PUBLIC	?NUM_LICENSE@CLicense@@2PBEB			; CLicense::NUM_LICENSE
PUBLIC	?WINDOWS_CLIENT@CLicense@@2PBEB			; CLicense::WINDOWS_CLIENT
PUBLIC	?LINUX_CLIENT@CLicense@@2PBEB			; CLicense::LINUX_CLIENT
PUBLIC	?CharLowerWThunk@ATL@@YGPAGPAG@Z		; ATL::CharLowerWThunk
PUBLIC	?MAC_CLIENT@CLicense@@2PBEB			; CLicense::MAC_CLIENT
PUBLIC	?SOLARIS_CLIENT@CLicense@@2PBEB			; CLicense::SOLARIS_CLIENT
PUBLIC	?SIGNATURE@CLicense@@2PBEB			; CLicense::SIGNATURE
PUBLIC	?LICENSEE@CLicense@@2PBEB			; CLicense::LICENSEE
PUBLIC	?LICENSER@CLicense@@2PBEB			; CLicense::LICENSER
PUBLIC	?COMPANY@CLicense@@2PBEB			; CLicense::COMPANY
PUBLIC	?USER@CLicense@@2PBEB				; CLicense::USER
PUBLIC	?CharUpperWThunk@ATL@@YGPAGPAG@Z		; ATL::CharUpperWThunk
PUBLIC	?HOSTNAME@CLicense@@2PBEB			; CLicense::HOSTNAME
PUBLIC	?licenseTimeout@CLicense@@0HB			; CLicense::licenseTimeout
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPBG0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
CONST	SEGMENT
$SG177473 DB	'Invalid DateTime', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:$SG177473		; ATL::szInvalidDateTime
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG177475 DB	'Invalid DateTimeSpan', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:$SG177475	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT
?licenseTimeout@CLicense@@0HB DD 01eH			; CLicense::licenseTimeout
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG178152 DB	'SecureXMLLicense', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSE@CLicense@@2PBEB DD FLAT:$SG178152		; CLicense::LICENSE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178154 DB	'Version', 00H
CONST	ENDS
_DATA	SEGMENT
?VERSION@CLicense@@2PBEB DD FLAT:$SG178154		; CLicense::VERSION
_DATA	ENDS
CONST	SEGMENT
$SG178156 DB	'Expiration', 00H
CONST	ENDS
_DATA	SEGMENT
?EXP_DATE@CLicense@@2PBEB DD FLAT:$SG178156		; CLicense::EXP_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178158 DB	'MaintenanceExpiration', 00H
CONST	ENDS
_DATA	SEGMENT
?MAINT_EXP_DATE@CLicense@@2PBEB DD FLAT:$SG178158	; CLicense::MAINT_EXP_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178160 DB	'IssueDate', 00H
CONST	ENDS
_DATA	SEGMENT
?ISSUE_DATE@CLicense@@2PBEB DD FLAT:$SG178160		; CLicense::ISSUE_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178162 DB	'Year', 00H
CONST	ENDS
_DATA	SEGMENT
?YEAR@CLicense@@2PBEB DD FLAT:$SG178162			; CLicense::YEAR
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178164 DB	'Month', 00H
CONST	ENDS
_DATA	SEGMENT
?MON@CLicense@@2PBEB DD FLAT:$SG178164			; CLicense::MON
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178166 DB	'Day', 00H
CONST	ENDS
_DATA	SEGMENT
?DAY@CLicense@@2PBEB DD FLAT:$SG178166			; CLicense::DAY
_DATA	ENDS
CONST	SEGMENT
$SG178168 DB	'Operations', 00H
CONST	ENDS
_DATA	SEGMENT
?OPERATIONS@CLicense@@2PBEB DD FLAT:$SG178168		; CLicense::OPERATIONS
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178170 DB	'Verify', 00H
CONST	ENDS
_DATA	SEGMENT
?VERIFY@CLicense@@2PBEB DD FLAT:$SG178170		; CLicense::VERIFY
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178172 DB	'Create', 00H
CONST	ENDS
_DATA	SEGMENT
?CREATE@CLicense@@2PBEB DD FLAT:$SG178172		; CLicense::CREATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178174 DB	'Encrypt', 00H
CONST	ENDS
_DATA	SEGMENT
?ENCRYPT@CLicense@@2PBEB DD FLAT:$SG178174		; CLicense::ENCRYPT
_DATA	ENDS
CONST	SEGMENT
$SG178176 DB	'Decrypt', 00H
CONST	ENDS
_DATA	SEGMENT
?DECRYPT@CLicense@@2PBEB DD FLAT:$SG178176		; CLicense::DECRYPT
_DATA	ENDS
CONST	SEGMENT
$SG178178 DB	'SecureSign', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGN@CLicense@@2PBEB DD FLAT:$SG178178		; CLicense::SECURESIGN
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178180 DB	'SecureSignProfessional', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNPROFESSIONAL@CLicense@@2PBEB DD FLAT:$SG178180 ; CLicense::SECURESIGNPROFESSIONAL
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178182 DB	'SecureSignEnterprise', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNENTERPRISE@CLicense@@2PBEB DD FLAT:$SG178182	; CLicense::SECURESIGNENTERPRISE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178184 DB	'SecureSignServer', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNSERVER@CLicense@@2PBEB DD FLAT:$SG178184	; CLicense::SECURESIGNSERVER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178186 DB	'Type', 00H
CONST	ENDS
_DATA	SEGMENT
?TYPE@CLicense@@2PBEB DD FLAT:$SG178186			; CLicense::TYPE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178188 DB	'Server', 00H
CONST	ENDS
_DATA	SEGMENT
?SERVER@CLicense@@2PBEB DD FLAT:$SG178188		; CLicense::SERVER
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178190 DB	'Client', 00H
CONST	ENDS
_DATA	SEGMENT
?CLIENT@CLicense@@2PBEB DD FLAT:$SG178190		; CLicense::CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178192 DB	'Demo', 00H
CONST	ENDS
_DATA	SEGMENT
?DEMO@CLicense@@2PBEB DD FLAT:$SG178192			; CLicense::DEMO
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178194 DB	'Development', 00H
CONST	ENDS
_DATA	SEGMENT
?DEVELOPMENT@CLicense@@2PBEB DD FLAT:$SG178194		; CLicense::DEVELOPMENT
_DATA	ENDS
CONST	SEGMENT
$SG178196 DB	'LicenseKey', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSE_KEY@CLicense@@2PBEB DD FLAT:$SG178196		; CLicense::LICENSE_KEY
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178198 DB	'NumLicense', 00H
CONST	ENDS
_DATA	SEGMENT
?NUM_LICENSE@CLicense@@2PBEB DD FLAT:$SG178198		; CLicense::NUM_LICENSE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG178200 DB	'WindowsClient', 00H
CONST	ENDS
_DATA	SEGMENT
?WINDOWS_CLIENT@CLicense@@2PBEB DD FLAT:$SG178200	; CLicense::WINDOWS_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178202 DB	'LinuxClient', 00H
CONST	ENDS
_DATA	SEGMENT
?LINUX_CLIENT@CLicense@@2PBEB DD FLAT:$SG178202		; CLicense::LINUX_CLIENT
_DATA	ENDS
CONST	SEGMENT
$SG178204 DB	'MacClient', 00H
CONST	ENDS
_DATA	SEGMENT
?MAC_CLIENT@CLicense@@2PBEB DD FLAT:$SG178204		; CLicense::MAC_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178206 DB	'SolarisClient', 00H
CONST	ENDS
_DATA	SEGMENT
?SOLARIS_CLIENT@CLicense@@2PBEB DD FLAT:$SG178206	; CLicense::SOLARIS_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178208 DB	'Signature', 00H
CONST	ENDS
_DATA	SEGMENT
?SIGNATURE@CLicense@@2PBEB DD FLAT:$SG178208		; CLicense::SIGNATURE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178210 DB	'Licensee', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSEE@CLicense@@2PBEB DD FLAT:$SG178210		; CLicense::LICENSEE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178212 DB	'Licensor', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSER@CLicense@@2PBEB DD FLAT:$SG178212		; CLicense::LICENSER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178214 DB	'Company', 00H
CONST	ENDS
_DATA	SEGMENT
?COMPANY@CLicense@@2PBEB DD FLAT:$SG178214		; CLicense::COMPANY
_DATA	ENDS
CONST	SEGMENT
$SG178216 DB	'User', 00H
CONST	ENDS
_DATA	SEGMENT
?USER@CLicense@@2PBEB DD FLAT:$SG178216			; CLicense::USER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178218 DB	'HostName', 00H
CONST	ENDS
_DATA	SEGMENT
?HOSTNAME@CLicense@@2PBEB DD FLAT:$SG178218		; CLicense::HOSTNAME
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG178225 DB	'SysFreeStringLocal', 00H
	ORG $+1
$SG178226 DB	'.\License.cpp', 00H
	ORG $+2
$SG178355 DB	'dwOSVersionInfoSize = %x', 00H
	ORG $+3
$SG178357 DB	'Debug Log', 00H
	ORG $+2
$SG178358 DB	'CLicense::getHostOsType', 00H
$SG178359 DB	'.\License.cpp', 00H
	ORG $+2
$SG178361 DB	'dwBuildNumber = %x', 00H
	ORG $+1
$SG178363 DB	'Debug Log', 00H
	ORG $+2
$SG178364 DB	'CLicense::getHostOsType', 00H
$SG178365 DB	'.\License.cpp', 00H
	ORG $+2
$SG178367 DB	'dwMajorVersion = %x', 00H
$SG178369 DB	'Debug Log', 00H
	ORG $+2
$SG178370 DB	'CLicense::getHostOsType', 00H
$SG178371 DB	'.\License.cpp', 00H
	ORG $+2
$SG178373 DB	'dwMinorVersion = %x', 00H
$SG178375 DB	'Debug Log', 00H
	ORG $+2
$SG178376 DB	'CLicense::getHostOsType', 00H
$SG178377 DB	'.\License.cpp', 00H
	ORG $+2
$SG178379 DB	'dwPlatformId = %x', 00H
	ORG $+2
$SG178381 DB	'Debug Log', 00H
	ORG $+2
$SG178382 DB	'CLicense::getHostOsType', 00H
$SG178383 DB	'.\License.cpp', 00H
	ORG $+2
$SG178385 DB	'wProductType = %x', 00H
	ORG $+2
$SG178387 DB	'Debug Log', 00H
	ORG $+2
$SG178388 DB	'CLicense::getHostOsType', 00H
$SG178389 DB	'.\License.cpp', 00H
	ORG $+2
$SG178406 DB	'MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCB'
	DB	'vzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UECh'
	DB	'MWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWw'
	DB	'gU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENv'
	DB	'cnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxI'
	DB	'zAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEw'
	DB	'JVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZ'
	DB	'JbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBT'
	DB	'aWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlb'
	DB	'nNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jA'
	DB	'CKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2'
	DB	'qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdB'
	DB	'n2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA'
	DB	'1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn'
	DB	'2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA'
	DB	'7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A', 00H
	ORG $+7
$SG178409 DB	'cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0lu'
	DB	'Zm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBA'
	DB	'KcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2'
	DB	'dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/s'
	DB	'XMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzr'
	DB	'rTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5'
	DB	'FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKm'
	DB	'bpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=', 00H
	ORG $+3
$SG178412 DB	'aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTER'
	DB	'MA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yY'
	DB	'XRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbW'
	DB	'VudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArbl'
	DB	'Ppz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9D'
	DB	'Tj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyL'
	DB	'ENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcy'
	DB	'xDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZml'
	DB	'jYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmli'
	DB	'dXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvb'
	DB	'W9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi'
	DB	'5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA'
	DB	'6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJs'
	DB	'aWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0a'
	DB	'W9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYm'
	DB	'plY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmx'
	DB	'odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl', 00H
	ORG $+3
$SG178469 DB	'TrialHost', 00H
	ORG $+2
$SG178473 DB	'CLicense::verifyLicense', 00H
$SG178474 DB	'.\License.cpp', 00H
	ORG $+2
$SG178476 DB	'CLicense::verifyLicense', 00H
$SG178477 DB	'.\License.cpp', 00H
CONST	ENDS
_DATA	SEGMENT
?wCRC16a@@3PAGA DW 00H					; wCRC16a
	DW	0c0c1H
	DW	0c181H
	DW	0140H
	DW	0c301H
	DW	03c0H
	DW	0280H
	DW	0c241H
	DW	0c601H
	DW	06c0H
	DW	0780H
	DW	0c741H
	DW	0500H
	DW	0c5c1H
	DW	0c481H
	DW	0440H
?wCRC16b@@3PAGA DW 00H					; wCRC16b
	DW	0cc01H
	DW	0d801H
	DW	01400H
	DW	0f001H
	DW	03c00H
	DW	02800H
	DW	0e401H
	DW	0a001H
	DW	06c00H
	DW	07800H
	DW	0b401H
	DW	05000H
	DW	09c01H
	DW	08801H
	DW	04600H
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG178509 DB	'LmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbigx'
	DB	'KS5jcnQwDQYJKoZIhvcNAQEFBQADggEBAFrOd7OXXrIwQB5Fz+AZTt2mgvdXk'
	DB	'JlrneuWoyEF3DSoZfSdGqaORmWEdNcWbcxmN+xl81bWwCmdi99emBvH0sIEvS'
	DB	'9u8y4c93zG/qg3+Icu3/KNYDGAXBWJFdnCyTPfBdhTw1AmXOHepQ9i2C51S4w'
	DB	'A8keQoaH1yCwQjcSA3cRAlweg0BkpBM1NRx+jOlMgLmCETb+8iZ1vDQZ0SBul'
	DB	'O60cX7pdD/cQUE5mbeII/enkaECj8eC9CuPrhmL5D3B0xSgXOGryWNIAl1gcI'
	DB	'M2+wt+D92vN8n0WiZ1LA9DNvZPY17DePeEEwxk1Kd33C+F9Tw9q57b4rsjY/P'
	DB	'aM9Gi8FG0=', 00H
	ORG $+7
$SG178512 DB	'b24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5'
	DB	'MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwg'
	DB	'Z8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALgb0p8Fh0O1DwZyXDONau+SqV'
	DB	'vM3IDvqDDjMLQ8uR4BnGXjiGqgjdrH4obZekYYcjWIWu01vPMAYYHH198gmsF'
	DB	'xHphndAsPllBUl0iX4JEhyBtZAo7koED+J+9aMNkVAjkA4AG17Z/MfglAH+/E'
	DB	'wsvI9nPwwsW1P9lFcQsZivIxAgMBAAGjggIzMIICLzAOBgNVHQ8BAf8EBAMCB'
	DB	'PAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAX3Ts8591e+/KCE4j'
	DB	'gHJqKw5EqzMIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYH'
	DB	'EpIHBMIG+MSIwIAYJKoZIhvcNAQkB', 00H
	ORG $+7
$SG178515 DB	'MIIFvzCCBKegAwIBAgIKFDX9YgABAAAG5DANBgkqhkiG9w0BAQUFADCB'
	DB	'vjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1'
	DB	'UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIER'
	DB	'pZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29y'
	DB	'cG9yYXRpb24wHhcNMDMxMDAzMjIyOTUxWhcNMTMxMDAzMjE1OTUzWjCByjEjM'
	DB	'CEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAl'
	DB	'VTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAo'
	DB	'TFkluZm9tb3NhaWMgQ29ycG9yYXRp', 00H
	ORG $+7
$SG178518 DB	'FhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UE'
	DB	'CBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zY'
	DB	'WljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYX'
	DB	'R1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQKiQ'
	DB	'6i/TBzo1KZki1g15oZzBeBgNVHR8EVzBVMFOgUaBPhk1odHRwOi8vaW5mb21v'
	DB	'c2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvSW5mb21vc2FpY'
	DB	'yUyMENvcnBvcmF0aW9uLmNybDCBiwYIKwYBBQUHAQEEfzB9MHsGCCsGAQUFBz'
	DB	'AChm9odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnR'
	DB	'FbnJvbGwvaW5mb21vc2FpYy1zcnZy', 00H
	ORG $+3
$SG178524 DB	'Debug Log', 00H
	ORG $+2
$SG178525 DB	'CLicense::verifyFloatingLicense', 00H
$SG178526 DB	'.\License.cpp', 00H
	ORG $+2
$SG178530 DB	'axVerify() for floating license xml failed', 00H
	ORG $+1
$SG178531 DB	'Debug Log', 00H
	ORG $+2
$SG178532 DB	'CLicense::verifyFloatingLicense', 00H
$SG178533 DB	'.\License.cpp', 00H
	ORG $+2
$SG178535 DB	'signum != 1 from axGetSignature() after axVerify() for f'
	DB	'loating license xml', 00H
$SG178536 DB	'Debug Log', 00H
	ORG $+2
$SG178537 DB	'CLicense::verifyFloatingLicense', 00H
$SG178538 DB	'.\License.cpp', 00H
	ORG $+2
$SG178543 DB	'Certificate not present in the output from axGetSignatur'
	DB	'e()', 00H
$SG178544 DB	'Debug Log', 00H
	ORG $+2
$SG178545 DB	'CLicense::verifyFloatingLicense', 00H
$SG178546 DB	'.\License.cpp', 00H
	ORG $+2
$SG178550 DB	'Checksum validation failed', 00H
	ORG $+1
$SG178551 DB	'Debug Log', 00H
	ORG $+2
$SG178552 DB	'CLicense::verifyFloatingLicense', 00H
$SG178553 DB	'.\License.cpp', 00H
	ORG $+2
$SG178555 DB	'X509 Data not the same as expected in floating license', 00H
	ORG $+1
$SG178556 DB	'Debug Log', 00H
	ORG $+2
$SG178557 DB	'CLicense::verifyFloatingLicense', 00H
$SG178558 DB	'.\License.cpp', 00H
	ORG $+2
$SG178563 DB	'CLicense::verifyFloatingLicense', 00H
$SG178564 DB	'.\License.cpp', 00H
	ORG $+2
$SG178566 DB	'Base64 decode failed', 00H
	ORG $+3
$SG178567 DB	'Debug Log', 00H
	ORG $+2
$SG178568 DB	'CLicense::verifyFloatingLicense', 00H
$SG178569 DB	'.\License.cpp', 00H
	ORG $+2
$SG178579 DB	'MaintExpiryYear', 00H
$SG178585 DB	'MaintExpiryMonth', 00H
	ORG $+3
$SG178591 DB	'MaintExpiryDay', 00H
	ORG $+1
$SG178597 DB	'LinuxClient', 00H
$SG178603 DB	'WindowsClient', 00H
	ORG $+2
$SG178609 DB	'SolarisClient', 00H
	ORG $+2
$SG178615 DB	'MacClient', 00H
	ORG $+2
$SG178628 DB	'WindowsClient is not allowed', 00H
	ORG $+3
$SG178629 DB	'Debug Log', 00H
	ORG $+2
$SG178630 DB	'CLicense::verifyFloatingLicense', 00H
$SG178631 DB	'.\License.cpp', 00H
	ORG $+2
$SG178635 DB	'Time in floating license data = ', 00H
	ORG $+3
$SG178636 DB	'Debug Log', 00H
	ORG $+2
$SG178637 DB	'CLicense::verifyFloatingLicense', 00H
$SG178638 DB	'.\License.cpp', 00H
	ORG $+2
$SG178640 DB	'Debug Log', 00H
	ORG $+2
$SG178641 DB	'CLicense::verifyFloatingLicense', 00H
$SG178642 DB	'.\License.cpp', 00H
	ORG $+2
$SG178644 DB	'CLicense::verifyFloatingLicense', 00H
$SG178645 DB	'.\License.cpp', 00H
	ORG $+2
$SG178646 DB	'CLicense::verifyFloatingLicense', 00H
$SG178647 DB	'.\License.cpp', 00H
	ORG $+2
$SG178648 DB	'Debug Log', 00H
	ORG $+2
$SG178649 DB	'CLicense::verifyFloatingLicense', 00H
$SG178650 DB	'.\License.cpp', 00H
	ORG $+2
$SG178662 DB	'Time difference = %d', 00H
	ORG $+3
$SG178664 DB	'Debug Log', 00H
	ORG $+2
$SG178665 DB	'CLicense::floatingLicenseStatus', 00H
$SG178666 DB	'.\License.cpp', 00H
	ORG $+6
$SG178689 DB	'MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCB'
	DB	'vzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UECh'
	DB	'MWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWw'
	DB	'gU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENv'
	DB	'cnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxI'
	DB	'zAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEw'
	DB	'JVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZ'
	DB	'JbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBT'
	DB	'aWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlb'
	DB	'nNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jA'
	DB	'CKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2'
	DB	'qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdB'
	DB	'n2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA'
	DB	'1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn'
	DB	'2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA'
	DB	'7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A', 00H
	ORG $+7
$SG178692 DB	'cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0lu'
	DB	'Zm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBA'
	DB	'KcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2'
	DB	'dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/s'
	DB	'XMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzr'
	DB	'rTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5'
	DB	'FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKm'
	DB	'bpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=', 00H
	ORG $+3
$SG178695 DB	'aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTER'
	DB	'MA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yY'
	DB	'XRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbW'
	DB	'VudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArbl'
	DB	'Ppz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9D'
	DB	'Tj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyL'
	DB	'ENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcy'
	DB	'xDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZml'
	DB	'jYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmli'
	DB	'dXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvb'
	DB	'W9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi'
	DB	'5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA'
	DB	'6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJs'
	DB	'aWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0a'
	DB	'W9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYm'
	DB	'plY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmx'
	DB	'odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl', 00H
	ORG $+3
$SG178730 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178731 DB	'.\License.cpp', 00H
	ORG $+2
$SG178732 DB	'(//. | //@* | //namespace::*)[self::idsig:Signature | se'
	DB	'lf::SignedObject | self::documentID]', 00H
	ORG $+3
$SG178736 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG178737 DB	'idsig', 00H
	ORG $+2
$SG178738 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178739 DB	'.\License.cpp', 00H
	ORG $+2
$SG178742 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178743 DB	'.\License.cpp', 00H
	ORG $+2
$SG178757 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178758 DB	'.\License.cpp', 00H
	ORG $+2
$SG178759 DB	'(//. | //@* | //namespace::*)[self::SchemaData]', 00H
$SG178762 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178763 DB	'.\License.cpp', 00H
	ORG $+2
$SG178766 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178767 DB	'.\License.cpp', 00H
	ORG $+2
$SG178768 DB	'CLicense::verifyFormSchema', 00H
	ORG $+1
$SG178769 DB	'.\License.cpp', 00H
	ORG $+2
$SG178794 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178795 DB	'.\License.cpp', 00H
	ORG $+2
$SG178796 DB	'TemplateSource', 00H
	ORG $+5
$SG178797 DB	'(//. | //@* | //namespace::*)[ancestor-or-self::ifmc:Sig'
	DB	'nedObject[@Id=''%s'']]', 00H
	ORG $+3
$SG178799 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178800 DB	'.\License.cpp', 00H
	ORG $+2
$SG178804 DB	'http://www.infomosaic.net', 00H
	ORG $+2
$SG178805 DB	'ifmc', 00H
	ORG $+3
$SG178806 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178807 DB	'.\License.cpp', 00H
	ORG $+2
$SG178811 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178812 DB	'.\License.cpp', 00H
	ORG $+2
$SG178815 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178816 DB	'.\License.cpp', 00H
	ORG $+2
$SG178819 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178820 DB	'.\License.cpp', 00H
	ORG $+2
$SG178822 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178823 DB	'.\License.cpp', 00H
	ORG $+2
$SG178824 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178825 DB	'.\License.cpp', 00H
	ORG $+2
$SG178826 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178827 DB	'.\License.cpp', 00H
	ORG $+2
$SG178828 DB	'CLicense::getFormSignAllowed', 00H
	ORG $+3
$SG178829 DB	'.\License.cpp', 00H
	ORG $+2
$SG178848 DB	'CLicense::verifyTemplateSchema', 00H
	ORG $+1
$SG178849 DB	'.\License.cpp', 00H
	ORG $+6
$SG178850 DB	'(//. | //@* | //namespace::*)[self::SchemaData | self::X'
	DB	'mlData]', 00H
$SG178853 DB	'CLicense::verifyTemplateSchema', 00H
	ORG $+1
$SG178854 DB	'.\License.cpp', 00H
	ORG $+2
$SG178858 DB	'XmlData', 00H
$SG178861 DB	'CLicense::verifyTemplateSchema', 00H
	ORG $+1
$SG178862 DB	'.\License.cpp', 00H
	ORG $+2
$SG178863 DB	'CLicense::verifyTemplateSchema', 00H
	ORG $+1
$SG178864 DB	'.\License.cpp', 00H
	ORG $+2
$SG179887 DB	'pp != 0', 00H
$SG179888 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG160733 DB	'pThis != 0', 00H
	ORG $+5
$SG160734 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160741 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160742 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG160758 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG160759 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160782 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG160783 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG160794 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG160795 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG161005 DB	'm_begin == 0', 00H
	ORG $+3
$SG161006 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT rtc$IMZ
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -156						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

	mov	DWORD PTR _ver$[ebp], 148		; 00000094H

; 139  : 	::GetVersionEx( &ver );

	mov	esi, esp
	lea	eax, DWORD PTR _ver$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

	cmp	DWORD PTR _ver$[ebp+16], 2
	jne	SHORT $L75782
	cmp	DWORD PTR _ver$[ebp+4], 5
	jb	SHORT $L75782

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

	jmp	SHORT $L75783
$L75782:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L75783:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	mov	ecx, DWORD PTR _pfnGetThreadACP$[ebp]
	push	ecx
	push	OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 152  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L180900
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L180900:
	DD	1
	DD	$L180899
$L180899:
	DD	-156					; ffffff64H
	DD	148					; 00000094H
	DD	$L180896
$L180896:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

	mov	esi, esp
	mov	eax, DWORD PTR _pNew$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pp$[ebp]
	push	ecx
	call	DWORD PTR __imp__InterlockedExchange@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 93   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$75770 = -32					; size = 4
_szACP$ = -24						; size = 7
_lcidThread$ = -12					; size = 4
_nACP$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

	mov	DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

	mov	esi, esp
	call	DWORD PTR __imp__GetThreadLocale@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

	mov	esi, esp
	push	7
	lea	eax, DWORD PTR _szACP$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _lcidThread$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetLocaleInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L75769

; 111  : 	{
; 112  : 		char* pch = szACP;

	lea	edx, DWORD PTR _szACP$[ebp]
	mov	DWORD PTR _pch$75770[ebp], edx
$L75772:

; 113  : 		while (*pch != '\0')

	mov	eax, DWORD PTR _pch$75770[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L75769

; 114  : 		{
; 115  : 			nACP *= 10;

	mov	edx, DWORD PTR _nACP$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

	mov	eax, DWORD PTR _pch$75770[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _nACP$[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _nACP$[ebp], eax
	mov	ecx, DWORD PTR _pch$75770[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$75770[ebp], ecx

; 117  : 		}

	jmp	SHORT $L75772
$L75769:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

	cmp	DWORD PTR _nACP$[ebp], 0
	jne	SHORT $L75774

; 121  : 		nACP = ::GetACP();

	mov	esi, esp
	call	DWORD PTR __imp__GetACP@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nACP$[ebp], eax
$L75774:

; 122  : 
; 123  : 	return nACP;

	mov	eax, DWORD PTR _nACP$[ebp]

; 124  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L180913
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L180913:
	DD	1
	DD	$L180912
$L180912:
	DD	-24					; ffffffe8H
	DD	7
	DD	$L180910
$L180910:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	67					; 00000043H
	DB	80					; 00000050H
	DB	0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 128  : 	return( CP_THREAD_ACP );

	mov	eax, 3

; 129  : }

	pop	ebp
	ret	0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	mov	eax, DWORD PTR __imp__GetEnvironmentVariableW@12
	push	eax
	push	OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ; ATL::GetEnvironmentVariableWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

	mov	esi, esp
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 188  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	mov	eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	and	eax, 1
	jne	SHORT $L174753
	mov	ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
	mov	esi, esp
	call	DWORD PTR __imp__GetVersion@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483648			; 80000000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L174753:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

	movzx	edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	test	edx, edx
	je	SHORT $L174755

; 125  : 		pfn = pfnWin9x;

	mov	eax, DWORD PTR _pfnWin9x$[ebp]
	mov	DWORD PTR _pfn$[ebp], eax

; 126  : 	else

	jmp	SHORT $L174756
$L174755:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

	mov	ecx, DWORD PTR _pfnNT$[ebp]
	mov	DWORD PTR _pfn$[ebp], ecx
$L174756:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

	mov	edx, DWORD PTR _pfn$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppThunk$[ebp]
	push	eax
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@	; `string'
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__CrtDbgReport:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T180940 DD	0ffffffffH
	DD	FLAT:$L180927
	DD	00H
	DD	FLAT:$L180928
$T180932 DD	019930520H
	DD	02H
	DD	FLAT:$T180940
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT
??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@ DB 'nSize >= nSizeW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\cs'
	DB	'tringt.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
$T180926 = -316						; size = 4
$T180924 = -312						; size = 4
$T180923 = -308						; size = 4
_pszNameA$ = -300					; size = 132
_pszBufferA$ = -160					; size = 132
_nSizeW$ = -24						; size = 4
_nSizeA$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z	; ATL::CW2AEX<128>::CW2AEX<128>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

	cmp	DWORD PTR _nSizeA$[ebp], 0
	jne	SHORT $L174827

; 167  : 		return 0;

	mov	DWORD PTR $T180923[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T180923[ebp]
	jmp	$L174799
$L174827:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

	mov	ecx, DWORD PTR _nSizeA$[ebp]
	shl	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

	mov	esi, esp
	mov	edx, DWORD PTR _nSizeA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

	cmp	DWORD PTR _nSize$[ebp], 0
	jne	SHORT $L174829

; 174  : 		return nSizeW;

	mov	eax, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T180924[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T180924[ebp]
	jmp	$L174799
$L174829:

; 175  : 	ATLASSERT(nSize >= nSizeW);

	mov	ecx, DWORD PTR _nSize$[ebp]
	cmp	ecx, DWORD PTR _nSizeW$[ebp]
	jae	SHORT $L180925
	push	OFFSET FLAT:??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
	push	0
	push	175					; 000000afH
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L180925
	int	3
$L180925:

; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

	mov	esi, esp
	mov	eax, DWORD PTR _nSizeW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$[ebp]
	push	ecx
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  : 
; 178  : 	return nSizeW;

	mov	edx, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T180926[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T180926[ebp]
$L174799:

; 179  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L180939
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L180939:
	DD	2
	DD	$L180938
$L180938:
	DD	-160					; ffffff60H
	DD	132					; 00000084H
	DD	$L180933
	DD	-300					; fffffed4H
	DD	132					; 00000084H
	DD	$L180934
$L180934:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	0
$L180933:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L180927:
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L180928:
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	jmp	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z:
	mov	eax, OFFSET FLAT:$T180932
	jmp	___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 158  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 159  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	mov	eax, DWORD PTR __imp__CompareStringW@24
	push	eax
	push	OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ; ATL::CompareStringWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

	mov	esi, esp
	mov	ecx, DWORD PTR _nLength2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszString2$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLength1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszString1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	24					; 00000018H
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPBGHI@Z			; AtlW2AHelper
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
EXTRN	__alloca_probe:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T180967 DD	0ffffffffH
	DD	FLAT:$L180959
$T180961 DD	019930520H
	DD	01H
	DD	FLAT:$T180967
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
tv147 = -76						; size = 4
tv142 = -72						; size = 4
tv149 = -68						; size = 4
tv89 = -64						; size = 4
tv84 = -60						; size = 4
tv91 = -56						; size = 4
$T180958 = -52						; size = 4
_pszAString2$ = -48					; size = 4
_pszAString1$ = -44					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 193  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

	mov	DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

	cmp	DWORD PTR _pszString1$[ebp], 0
	je	$L174854

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString1$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L180952
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L180953
$L180952:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L180950
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L180950
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv84[ebp], esp
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $L180951
$L180950:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv89[ebp], eax
$L180951:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv91[ebp], eax
$L180953:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

	cmp	DWORD PTR _pszAString1$[ebp], 0
	jne	SHORT $L174854

; 200  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L174854:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

	mov	DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

	cmp	DWORD PTR _pszString2$[ebp], 0
	je	$L174860

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString2$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L180956
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $L180957
$L180956:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L180954
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L180954
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv142[ebp], esp
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv147[ebp], edx
	jmp	SHORT $L180955
$L180954:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv147[ebp], eax
$L180955:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv147[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv149[ebp], eax
$L180957:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

	cmp	DWORD PTR _pszAString2$[ebp], 0
	jne	SHORT $L174860

; 208  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L174860:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

	mov	esi, esp
	mov	eax, DWORD PTR _nLength2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszAString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszAString1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR __imp__CompareStringA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T180958[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T180958[ebp]
$L180949:

; 212  : }

	lea	esp, DWORD PTR [ebp-84]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L180966
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L180966:
	DD	1
	DD	$L180965
$L180965:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L180963
$L180963:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L180959:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z:
	mov	eax, OFFSET FLAT:$T180961
	jmp	___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T180978 DD	0ffffffffH
	DD	FLAT:$L180973
	DD	FLAT:$L180974
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -48						; size = 4
$T180977 = -44						; size = 4
_p$75737 = -36						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET FLAT:$T180978
	push	OFFSET FLAT:__except_handler3
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	add	esp, -32				; ffffffe0H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

	mov	BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 8195				; 00002003H
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv65[ebp], esp
	mov	DWORD PTR __$SEHRec$[ebp], esp
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _p$75737[ebp], eax
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $L180976
$L180973:
$L180985:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T180977[ebp], eax
	mov	eax, DWORD PTR $T180977[ebp]
	sub	eax, -1073741571			; c00000fdH
	neg	eax
	sbb	eax, eax
	inc	eax
$L180975:
$L180984:
	ret	0
$L180974:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

	mov	BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

	call	__resetstkoflw
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
$L180976:

; 345  :     }
; 346  :     return bStackAvailable;

	mov	al, BYTE PTR _bStackAvailable$[ebp]
$L180972:

; 347  : }

	lea	esp, DWORD PTR [ebp-60]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L180983
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L180983:
	DD	1
	DD	$L180982
$L180982:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L180980
$L180980:
	DB	112					; 00000070H
	DB	0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
EXTRN	__imp__WideCharToMultiByte@32:NEAR
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
CONST	SEGMENT
??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@ DB 'lpw != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lconv.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@ DB 'lpa != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPBGHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 574  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L180990
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	574					; 0000023eH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L180990
	int	3
$L180990:

; 575  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L180991
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	575					; 0000023fH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L180991
	int	3
$L180991:

; 576  : 	if (lpa == NULL || lpw == NULL)

	cmp	DWORD PTR _lpa$[ebp], 0
	je	SHORT $L75958
	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L75957
$L75958:

; 577  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75954
$L75957:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

	mov	edx, DWORD PTR _lpa$[ebp]
	mov	BYTE PTR [edx], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpa$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpw$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75960

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L180992
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	585					; 00000249H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L180992
	int	3
$L180992:

; 586  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75954
$L75960:

; 587  : 	}
; 588  : 	return lpa;

	mov	eax, DWORD PTR _lpa$[ebp]
$L75954:

; 589  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlW2AHelper@@YGPADPADPBGHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	?atlTraceException@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceException
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
CONST	SEGMENT
??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ DB 'AtlThrow: hr '
	DB	'= 0x%x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lexcept.h', 00H				; `string'
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T180997 = -16						; size = 4
$T180996 = -12						; size = 4
$T180995 = -8						; size = 8
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceException@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceException
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	62					; 0000003eH
	push	OFFSET FLAT:??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T180995[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T180997[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T180996[ebp], edx
	push	OFFSET FLAT:__TI1?AVCAtlException@ATL@@
	lea	eax, DWORD PTR $T180996[ebp]
	push	eax
	call	__CxxThrowException@8
$L180994:

; 74   : #endif
; 75   : };

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
; Function compile flags: /Odt /RTCsu
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 162  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 163  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
	call	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z	; ATL::CTrace::TraceV
	add	esp, 28					; 0000001cH

; 164  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 165  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_AtlTraceVA
	add	esp, 28					; 0000001cH

; 123  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 41   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	mov	eax, DWORD PTR __imp__GetStringTypeExW@20
	push	eax
	push	OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ; ATL::GetStringTypeExWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

	mov	esi, esp
	mov	ecx, DWORD PTR _pwCharType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwInfoType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 244  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T181023 DD	0ffffffffH
	DD	FLAT:$L181015
$T181017 DD	019930520H
	DD	01H
	DD	FLAT:$T181023
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
$T181014 = -164						; size = 4
_pszA$ = -156						; size = 132
_nLengthA$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

	mov	edx, DWORD PTR _nLengthA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszSrc$[ebp]
	push	edx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : 
; 232  : 	if (nLength == -1)

	cmp	DWORD PTR _nLength$[ebp], -1
	jne	SHORT $L174886

; 233  : 		nLengthA = -1;

	mov	DWORD PTR _nLengthA$[ebp], -1
$L174886:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

	mov	esi, esp
	mov	eax, DWORD PTR _pwCharType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLengthA$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	edx, DWORD PTR _dwInfoType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR __imp__GetStringTypeExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T181014[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T181014[ebp]

; 236  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181022
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L181022:
	DD	1
	DD	$L181021
$L181021:
	DD	-156					; ffffff64H
	DD	132					; 00000084H
	DD	$L181018
$L181018:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L181015:
	lea	ecx, DWORD PTR _pszA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z:
	mov	eax, OFFSET FLAT:$T181017
	jmp	___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPBG0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	mov	eax, DWORD PTR __imp__lstrcmpiW@8
	push	eax
	push	OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPBG0@Z ; ATL::lstrcmpiWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz1$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 258  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?lstrcmpiWThunk@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPBG0@Z PROC NEAR			; ATL::lstrcmpiWFake, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 248  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

	mov	eax, DWORD PTR _psz2$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L181030
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L181031
$L181030:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv76[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv79[ebp], eax
$L181031:
	mov	ecx, DWORD PTR _psz1$[ebp]
	mov	DWORD PTR __lpw$[ebp], ecx
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L181032
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L181033
$L181032:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv91[ebp], esp
	mov	ecx, DWORD PTR __acp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv91[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv94[ebp], eax
$L181033:
	mov	esi, esp
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 251  : }

	lea	esp, DWORD PTR [ebp-36]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?lstrcmpiWFake@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPAGPAG@Z			; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	mov	eax, DWORD PTR __imp__CharLowerW@4
	push	eax
	push	OFFSET FLAT:?CharLowerWFake@ATL@@YGPAGPAG@Z ; ATL::CharLowerWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 277  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharLowerWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPAGPAGPBDHI@Z			; AtlA2WHelper
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	_wcscpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 262  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L181038
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L181039
$L181038:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L181039:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharLowerA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 267  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L181040
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L181041
$L181040:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L181041:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 268  : 
; 269  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 270  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharLowerWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPAGPAGPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 555  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L181044
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	555					; 0000022bH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L181044
	int	3
$L181044:

; 556  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L181045
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	556					; 0000022cH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L181045
	int	3
$L181045:

; 557  : 	if (lpw == NULL || lpa == NULL)

	cmp	DWORD PTR _lpw$[ebp], 0
	je	SHORT $L75944
	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L75943
$L75944:

; 558  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75937
$L75943:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

	mov	edx, DWORD PTR _lpw$[ebp]
	mov	WORD PTR [edx], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

	mov	esi, esp
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpw$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpa$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75946

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L181046
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L181046
	int	3
$L181046:

; 567  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75937
$L75946:

; 568  : 	}		
; 569  : 	return lpw;

	mov	eax, DWORD PTR _lpw$[ebp]
$L75937:

; 570  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlA2WHelper@@YGPAGPAGPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPAGPAG@Z			; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	mov	eax, DWORD PTR __imp__CharUpperW@4
	push	eax
	push	OFFSET FLAT:?CharUpperWFake@ATL@@YGPAGPAG@Z ; ATL::CharUpperWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 296  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharUpperWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 281  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L181051
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L181052
$L181051:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L181052:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 286  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L181053
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L181054
$L181053:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L181054:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 287  : 
; 288  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 289  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharUpperWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	??0CLicense@@QAE@XZ				; CLicense::CLicense
PUBLIC	?getHostOsType@CLicense@@SAJXZ			; CLicense::getHostOsType
PUBLIC	??_7CLicense@@6B@				; CLicense::`vftable'
PUBLIC	??_GCLicense@@UAEPAXI@Z				; CLicense::`scalar deleting destructor'
EXTRN	??0CTime@ATL@@QAE@XZ:NEAR			; ATL::CTime::CTime
EXTRN	??_ECLicense@@UAEPAXI@Z:NEAR			; CLicense::`vector deleting destructor'
;	COMDAT ??_7CLicense@@6B@
; File c:\activex\xmlsign\license.cpp
CONST	SEGMENT
??_7CLicense@@6B@ DD FLAT:??_ECLicense@@UAEPAXI@Z	; CLicense::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
_osType$ = -8						; size = 4
_this$ = -4						; size = 4
??0CLicense@@QAE@XZ PROC NEAR				; CLicense::CLicense
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CLicense@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CTime@ATL@@QAE@XZ			; ATL::CTime::CTime
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0CTime@ATL@@QAE@XZ			; ATL::CTime::CTime

; 109  : 
; 110  : 	licenseFile = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 111  : 	isLicenseValid = TRUE; // By default the license is valid

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 1

; 112  : 
; 113  : 	licenseKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 114  : 	expYear = expMon = expDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 115  : 	issYear = issMon = issDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 116  : 	maintExpYear = maintExpMon = maintExpDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 117  : 	num_of_lic = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 118  : 
; 119  : 
; 120  : 	long osType;
; 121  : 
; 122  : 	osType = getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	DWORD PTR _osType$[ebp], eax

; 123  : 
; 124  : 	if ((osType != 0) && (osType != VER_NT_WORKSTATION))

	cmp	DWORD PTR _osType$[ebp], 0
	je	SHORT $L178231
	cmp	DWORD PTR _osType$[ebp], 1
	je	SHORT $L178231

; 125  : 		 /* It is not a client machine as it is some sort of windows server product */
; 126  : 	{
; 127  : 		isVerifyAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 128  : 		isDecryptAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 129  : 	}
; 130  : 	else

	jmp	SHORT $L178232
$L178231:

; 131  : 	{
; 132  : 		isVerifyAllowed = TRUE; // Verification is always allowed for client machines

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 1

; 133  : 		isDecryptAllowed = TRUE; // Decryption is always allowed for client machines

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 1
$L178232:

; 134  : 	}
; 135  : 	
; 136  : 	isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 137  : 	isEncryptAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 138  : 	isSecureSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 139  : 	isSecureSignProfessionalAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 140  : 	isSecureSignEnterpriseAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 141  : 
; 142  : 	isSecureSignServerAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 143  : 
; 144  : 	isServerLic = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 145  : 	isClientLic = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 146  : 	isDemoLic	= TRUE; /* by default every license is a demo license */

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 1

; 147  : 	isDevelopmentLic = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 148  : 	isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 149  : 
; 150  : 	sigArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 151  : 	signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 152  : 
; 153  : 	licenser = company = user = hostname = version = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 154  : 	num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 155  : 	linuxClient = windowsClient = solarisClient = macClient = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], 0

; 156  : #ifdef WIN32
; 157  : #ifdef FREE_SECURESIGN
; 158  : 	LPSTR commandLine = _strlwr(GetCommandLine());
; 159  : 	if (strstr(commandLine, "securesign.exe") != NULL)
; 160  : 	{
; 161  : 		isSignAllowed = TRUE;
; 162  : 		isVerifyAllowed = TRUE;
; 163  : 		isSecureSignAllowed = TRUE;
; 164  : 		isEncryptAllowed = TRUE;
; 165  : 	}
; 166  : #endif
; 167  : #endif
; 168  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CLicense@@QAE@XZ ENDP				; CLicense::CLicense
_TEXT	ENDS
PUBLIC	??1CLicense@@UAE@XZ				; CLicense::~CLicense
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCLicense@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCLicense@@UAEPAXI@Z PROC NEAR			; CLicense::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CLicense@@UAE@XZ			; CLicense::~CLicense
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L178236
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L178236:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCLicense@@UAEPAXI@Z ENDP				; CLicense::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__SysFreeString@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CLicense@@UAE@XZ PROC NEAR				; CLicense::~CLicense
; _this$ = ecx

; 171  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CLicense@@6B@

; 172  : #ifdef WIN32
; 173  : 	SysFreeString(licenseKey);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 174  : 	SysFreeString(licenser);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 175  : 	SysFreeString(company);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 176  : 	SysFreeString(user);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  : 	SysFreeString(hostname);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 178  : 	SysFreeString(version);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 179  : #else
; 180  : 	SysFreeStringLocal(licenseKey);
; 181  : 	SysFreeStringLocal(licenser);
; 182  : 	SysFreeStringLocal(company);
; 183  : 	SysFreeStringLocal(user);
; 184  : 	SysFreeStringLocal(hostname);
; 185  : 	SysFreeStringLocal(version);
; 186  : #endif
; 187  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CLicense@@UAE@XZ ENDP				; CLicense::~CLicense
_TEXT	ENDS
PUBLIC	?A2WBSTR@@YAPAGPBDH@Z				; A2WBSTR
PUBLIC	?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ; CLicense::getLicenseDetails
EXTRN	_xmlDocGetRootElement:NEAR
EXTRN	_xmlNodeListGetString:NEAR
EXTRN	_setError:NEAR
EXTRN	_atoi:NEAR
EXTRN	_xmlStrcmp:NEAR
EXTRN	_xmlParseFile:NEAR
EXTRN	__imp__xmlFree:DWORD
EXTRN	_xmlFreeDoc:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_tmpInt$178322 = -52					; size = 4
_type$178318 = -48					; size = 4
_tmpInt$178306 = -44					; size = 4
_op$178302 = -40					; size = 4
_date$178291 = -36					; size = 4
_date$178280 = -32					; size = 4
_date$178269 = -28					; size = 4
_licensee$178258 = -24					; size = 4
_curr$ = -20						; size = 4
_root$ = -16						; size = 4
_tmpCharPtr$ = -12					; size = 4
_doc$ = -8						; size = 4
_this$ = -4						; size = 4
_SigHandle$ = 8						; size = 4
?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::getLicenseDetails
; _this$ = ecx

; 199  : BOOL CLicense::getLicenseDetails(PGLOBAL_SIG SigHandle) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 200  : 
; 201  : 	xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 202  : 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 203  : 
; 204  : 	doc = xmlParseFile((const char *)licenseFile);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlParseFile
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 205  : 	if (!doc) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L178247

; 206  : 		// cout << "Couldn't parse the license file" << endl;
; 207  : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 208  : 		return FALSE;

	xor	eax, eax
	jmp	$L178243
$L178247:

; 209  : 	}
; 210  : 
; 211  : 	xmlNodePtr root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 212  : 	xmlNodePtr curr = root->xmlChildrenNode;

	mov	ecx, DWORD PTR _root$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _curr$[ebp], edx

; 213  : 	// cout << "Root element name is " << root->name << endl;
; 214  : 
; 215  : 	for ( ; curr != NULL; curr = curr->next) {

	jmp	SHORT $L178250
$L178251:
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _curr$[ebp], ecx
$L178250:
	cmp	DWORD PTR _curr$[ebp], 0
	je	$L178252

; 216  : 
; 217  : 		if (! xmlStrcmp(curr->name, VERSION)) {

	mov	edx, DWORD PTR ?VERSION@CLicense@@2PBEB	; CLicense::VERSION
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178253

; 218  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 219  : 			version = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 220  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 221  : 			continue;

	jmp	SHORT $L178251
$L178253:

; 222  : 		}
; 223  : 
; 224  : 		if (! xmlStrcmp(curr->name, LICENSER)) {

	mov	ecx, DWORD PTR ?LICENSER@CLicense@@2PBEB ; CLicense::LICENSER
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178255

; 225  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 226  : 			licenser = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], eax

; 227  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 228  : 			continue;

	jmp	$L178251
$L178255:

; 229  : 		}
; 230  : 
; 231  : 		if (! xmlStrcmp(curr->name, LICENSEE)) {

	mov	edx, DWORD PTR ?LICENSEE@CLicense@@2PBEB ; CLicense::LICENSEE
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178257

; 232  : 			xmlNodePtr licensee = curr->xmlChildrenNode;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _licensee$178258[ebp], eax
$L178260:

; 233  : 			while (licensee != NULL) {

	cmp	DWORD PTR _licensee$178258[ebp], 0
	je	$L178261

; 234  : 				if (! xmlStrcmp(licensee->name, COMPANY))

	mov	ecx, DWORD PTR ?COMPANY@CLicense@@2PBEB	; CLicense::COMPANY
	push	ecx
	mov	edx, DWORD PTR _licensee$178258[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178262

; 235  : 				{
; 236  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _licensee$178258[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 237  : 					company = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], eax

; 238  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178262:

; 239  : 				}
; 240  : 				if (! xmlStrcmp(licensee->name, USER))

	mov	edx, DWORD PTR ?USER@CLicense@@2PBEB	; CLicense::USER
	push	edx
	mov	eax, DWORD PTR _licensee$178258[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178264

; 241  : 				{
; 242  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _licensee$178258[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 243  : 					user = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], eax

; 244  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178264:

; 245  : 				}
; 246  : 				if (! xmlStrcmp(licensee->name, HOSTNAME))

	mov	ecx, DWORD PTR ?HOSTNAME@CLicense@@2PBEB ; CLicense::HOSTNAME
	push	ecx
	mov	edx, DWORD PTR _licensee$178258[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178266

; 247  : 				{
; 248  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _licensee$178258[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 249  : 					hostname = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], eax

; 250  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178266:

; 251  : 				}
; 252  : 				licensee = licensee->next;

	mov	edx, DWORD PTR _licensee$178258[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _licensee$178258[ebp], eax

; 253  : 			}

	jmp	$L178260
$L178261:

; 254  : 			continue;

	jmp	$L178251
$L178257:

; 255  : 		}
; 256  : 
; 257  : 		if (! xmlStrcmp(curr->name, EXP_DATE)) {

	mov	ecx, DWORD PTR ?EXP_DATE@CLicense@@2PBEB ; CLicense::EXP_DATE
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178268

; 258  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _date$178269[ebp], edx
$L178271:

; 259  : 			while (date != NULL) {

	cmp	DWORD PTR _date$178269[ebp], 0
	je	$L178272

; 260  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	eax, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	eax
	mov	ecx, DWORD PTR _date$178269[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178273

; 261  : 				{
; 262  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _date$178269[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 263  : 					expYear = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 264  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178273:

; 265  : 				}
; 266  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$178269[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178275

; 267  : 				{
; 268  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$178269[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 269  : 					expMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax

; 270  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178275:

; 271  : 				}
; 272  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$178269[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178277

; 273  : 				{
; 274  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$178269[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 275  : 					expDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 276  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178277:

; 277  : 				}
; 278  : 				date = date->next;

	mov	ecx, DWORD PTR _date$178269[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$178269[ebp], edx

; 279  : 			}

	jmp	$L178271
$L178272:

; 280  : 			continue;

	jmp	$L178251
$L178268:

; 281  : 		}
; 282  : 
; 283  : 		if (! xmlStrcmp(curr->name, MAINT_EXP_DATE)) {

	mov	eax, DWORD PTR ?MAINT_EXP_DATE@CLicense@@2PBEB ; CLicense::MAINT_EXP_DATE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178279

; 284  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _date$178280[ebp], ecx
$L178282:

; 285  : 			while (date != NULL) {

	cmp	DWORD PTR _date$178280[ebp], 0
	je	$L178283

; 286  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	edx, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	edx
	mov	eax, DWORD PTR _date$178280[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178284

; 287  : 				{
; 288  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$178280[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 289  : 					maintExpYear = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 290  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178284:

; 291  : 				}
; 292  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$178280[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178286

; 293  : 				{
; 294  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$178280[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 295  : 					maintExpMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], eax

; 296  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178286:

; 297  : 				}
; 298  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$178280[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178288

; 299  : 				{
; 300  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$178280[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 301  : 					maintExpDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 302  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178288:

; 303  : 				}
; 304  : 				date = date->next;

	mov	ecx, DWORD PTR _date$178280[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$178280[ebp], edx

; 305  : 			}

	jmp	$L178282
$L178283:

; 306  : 			continue;

	jmp	$L178251
$L178279:

; 307  : 		}
; 308  : 
; 309  : 		if (! xmlStrcmp(curr->name, ISSUE_DATE)) {

	mov	eax, DWORD PTR ?ISSUE_DATE@CLicense@@2PBEB ; CLicense::ISSUE_DATE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178290

; 310  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _date$178291[ebp], ecx
$L178293:

; 311  : 			while (date != NULL) {

	cmp	DWORD PTR _date$178291[ebp], 0
	je	$L178294

; 312  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	edx, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	edx
	mov	eax, DWORD PTR _date$178291[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178295

; 313  : 				{
; 314  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$178291[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 315  : 					issYear = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 316  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178295:

; 317  : 				}
; 318  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$178291[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178297

; 319  : 				{
; 320  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$178291[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 321  : 					issMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], eax

; 322  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178297:

; 323  : 				}
; 324  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$178291[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178299

; 325  : 				{
; 326  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$178291[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 327  : 					issDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 328  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L178299:

; 329  : 				}
; 330  : 				date = date->next;

	mov	ecx, DWORD PTR _date$178291[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$178291[ebp], edx

; 331  : 			}

	jmp	$L178293
$L178294:

; 332  : 			continue;

	jmp	$L178251
$L178290:

; 333  : 		}
; 334  : 
; 335  : 		if (! xmlStrcmp(curr->name, OPERATIONS)) {

	mov	eax, DWORD PTR ?OPERATIONS@CLicense@@2PBEB ; CLicense::OPERATIONS
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178301

; 336  : 			xmlNodePtr op = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _op$178302[ebp], ecx
$L178304:

; 337  : 			while (op != NULL) {

	cmp	DWORD PTR _op$178302[ebp], 0
	je	$L178305

; 338  : 				int tmpInt;
; 339  : 
; 340  : 				if (op->xmlChildrenNode != NULL)

	mov	edx, DWORD PTR _op$178302[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$L178307

; 341  : 				{
; 342  : 					tmpCharPtr = xmlNodeListGetString(doc, op->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _op$178302[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 343  : 					tmpInt = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _tmpInt$178306[ebp], eax

; 344  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 345  : 					if (! xmlStrcmp(op->name, VERIFY))

	mov	eax, DWORD PTR ?VERIFY@CLicense@@2PBEB	; CLicense::VERIFY
	push	eax
	mov	ecx, DWORD PTR _op$178302[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178309

; 346  : 						isVerifyAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [eax+64], ecx
$L178309:

; 347  : 
; 348  : 					if (! xmlStrcmp(op->name, CREATE))

	mov	edx, DWORD PTR ?CREATE@CLicense@@2PBEB	; CLicense::CREATE
	push	edx
	mov	eax, DWORD PTR _op$178302[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178310

; 349  : 						isSignAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [edx+68], eax
$L178310:

; 350  : 
; 351  : 					if (! xmlStrcmp(op->name, ENCRYPT))

	mov	ecx, DWORD PTR ?ENCRYPT@CLicense@@2PBEB	; CLicense::ENCRYPT
	push	ecx
	mov	edx, DWORD PTR _op$178302[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178311

; 352  : 						isEncryptAllowed = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [ecx+72], edx
$L178311:

; 353  : 
; 354  : 					if (! xmlStrcmp(op->name, DECRYPT))

	mov	eax, DWORD PTR ?DECRYPT@CLicense@@2PBEB	; CLicense::DECRYPT
	push	eax
	mov	ecx, DWORD PTR _op$178302[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178312

; 355  : 						isDecryptAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [eax+76], ecx
$L178312:

; 356  : 
; 357  : 					if (! xmlStrcmp(op->name, SECURESIGN))

	mov	edx, DWORD PTR ?SECURESIGN@CLicense@@2PBEB ; CLicense::SECURESIGN
	push	edx
	mov	eax, DWORD PTR _op$178302[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178313

; 358  : 						isSecureSignAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [edx+80], eax
$L178313:

; 359  : 
; 360  : 					if (! xmlStrcmp(op->name, SECURESIGNPROFESSIONAL))

	mov	ecx, DWORD PTR ?SECURESIGNPROFESSIONAL@CLicense@@2PBEB ; CLicense::SECURESIGNPROFESSIONAL
	push	ecx
	mov	edx, DWORD PTR _op$178302[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178314

; 361  : 						isSecureSignProfessionalAllowed = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [ecx+84], edx
$L178314:

; 362  : 
; 363  : 					if (! xmlStrcmp(op->name, SECURESIGNENTERPRISE))

	mov	eax, DWORD PTR ?SECURESIGNENTERPRISE@CLicense@@2PBEB ; CLicense::SECURESIGNENTERPRISE
	push	eax
	mov	ecx, DWORD PTR _op$178302[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178315

; 364  : 						isSecureSignEnterpriseAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [eax+88], ecx
$L178315:

; 365  : 
; 366  : 					if (! xmlStrcmp(op->name, SECURESIGNSERVER))

	mov	edx, DWORD PTR ?SECURESIGNSERVER@CLicense@@2PBEB ; CLicense::SECURESIGNSERVER
	push	edx
	mov	eax, DWORD PTR _op$178302[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178307

; 367  : 						isSecureSignServerAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$178306[ebp]
	mov	DWORD PTR [edx+92], eax
$L178307:

; 368  : 				}
; 369  : 				op = op->next;

	mov	ecx, DWORD PTR _op$178302[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _op$178302[ebp], edx

; 370  : 			}

	jmp	$L178304
$L178305:

; 371  : 			continue;

	jmp	$L178251
$L178301:

; 372  : 		}
; 373  : 
; 374  : 		if (! xmlStrcmp(curr->name, TYPE)) {

	mov	eax, DWORD PTR ?TYPE@CLicense@@2PBEB	; CLicense::TYPE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L178317

; 375  : 			xmlNodePtr type = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _type$178318[ebp], ecx
$L178320:

; 376  : 			while (type != NULL) {

	cmp	DWORD PTR _type$178318[ebp], 0
	je	$L178321

; 377  : 				int tmpInt;
; 378  : 
; 379  : 				if (type->xmlChildrenNode != NULL)

	mov	edx, DWORD PTR _type$178318[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$L178323

; 380  : 				{
; 381  : 					tmpCharPtr = xmlNodeListGetString(doc, type->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _type$178318[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 382  : 					tmpInt = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _tmpInt$178322[ebp], eax

; 383  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 384  : 
; 385  : 					if (! xmlStrcmp(type->name, SERVER))

	mov	eax, DWORD PTR ?SERVER@CLicense@@2PBEB	; CLicense::SERVER
	push	eax
	mov	ecx, DWORD PTR _type$178318[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178325

; 386  : 						isServerLic = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$178322[ebp]
	mov	DWORD PTR [eax+96], ecx
$L178325:

; 387  : 
; 388  : 					if (! xmlStrcmp(type->name, CLIENT))

	mov	edx, DWORD PTR ?CLIENT@CLicense@@2PBEB	; CLicense::CLIENT
	push	edx
	mov	eax, DWORD PTR _type$178318[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178326

; 389  : 						isClientLic = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$178322[ebp]
	mov	DWORD PTR [edx+100], eax
$L178326:

; 390  : 
; 391  : 					if (! xmlStrcmp(type->name, DEMO))

	mov	ecx, DWORD PTR ?DEMO@CLicense@@2PBEB	; CLicense::DEMO
	push	ecx
	mov	edx, DWORD PTR _type$178318[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178327

; 392  : 						isDemoLic = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$178322[ebp]
	mov	DWORD PTR [ecx+104], edx
$L178327:

; 393  : 
; 394  : 					if (! xmlStrcmp(type->name, DEVELOPMENT))

	mov	eax, DWORD PTR ?DEVELOPMENT@CLicense@@2PBEB ; CLicense::DEVELOPMENT
	push	eax
	mov	ecx, DWORD PTR _type$178318[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178323

; 395  : 						isDevelopmentLic = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$178322[ebp]
	mov	DWORD PTR [eax+108], ecx
$L178323:

; 396  : 				}
; 397  : 
; 398  : 				type = type->next;

	mov	edx, DWORD PTR _type$178318[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _type$178318[ebp], eax

; 399  : 			}

	jmp	$L178320
$L178321:

; 400  : 			continue;

	jmp	$L178251
$L178317:

; 401  : 		}
; 402  : 
; 403  : 		if (! xmlStrcmp(curr->name, LICENSE_KEY)) {

	mov	ecx, DWORD PTR ?LICENSE_KEY@CLicense@@2PBEB ; CLicense::LICENSE_KEY
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178329

; 404  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 405  : 			licenseKey = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], eax

; 406  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 407  : 			continue;

	jmp	$L178251
$L178329:

; 408  : 		}
; 409  : 
; 410  : 		if (! xmlStrcmp(curr->name, NUM_LICENSE)) {

	mov	edx, DWORD PTR ?NUM_LICENSE@CLicense@@2PBEB ; CLicense::NUM_LICENSE
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178331

; 411  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 412  : 			num_of_lic = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 413  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 414  : 			continue;

	jmp	$L178251
$L178331:

; 415  : 		}
; 416  : 		
; 417  : 		if (! xmlStrcmp(curr->name, WINDOWS_CLIENT)) {

	mov	ecx, DWORD PTR ?WINDOWS_CLIENT@CLicense@@2PBEB ; CLicense::WINDOWS_CLIENT
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178333

; 418  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 419  : 			windowsClient = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], eax

; 420  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 421  : 			continue;

	jmp	$L178251
$L178333:

; 422  : 		}
; 423  : 
; 424  : 		if (! xmlStrcmp(curr->name, SOLARIS_CLIENT)) {

	mov	edx, DWORD PTR ?SOLARIS_CLIENT@CLicense@@2PBEB ; CLicense::SOLARIS_CLIENT
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178335

; 425  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 426  : 			solarisClient = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], eax

; 427  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 428  : 			continue;

	jmp	$L178251
$L178335:

; 429  : 		}
; 430  : 		if (! xmlStrcmp(curr->name, LINUX_CLIENT)) {

	mov	ecx, DWORD PTR ?LINUX_CLIENT@CLicense@@2PBEB ; CLicense::LINUX_CLIENT
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178337

; 431  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 432  : 			linuxClient = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], eax

; 433  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 434  : 			continue;

	jmp	$L178251
$L178337:

; 435  : 		}
; 436  : 		if (! xmlStrcmp(curr->name, MAC_CLIENT)) {

	mov	edx, DWORD PTR ?MAC_CLIENT@CLicense@@2PBEB ; CLicense::MAC_CLIENT
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178339

; 437  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 438  : 			macClient = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax

; 439  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 440  : 			continue;

	jmp	$L178251
$L178339:

; 441  : 		}
; 442  : 	}

	jmp	$L178251
$L178252:

; 443  : 
; 444  : 	xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 445  : 
; 446  : 	return TRUE;

	mov	eax, 1
$L178243:

; 447  : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::getLicenseDetails
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ ; `string'
EXTRN	__imp__SysAllocStringLen@8:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
xdata$x	SEGMENT
$T181072 DD	0ffffffffH
	DD	FLAT:$L181065
$T181067 DD	019930520H
	DD	01H
	DD	FLAT:$T181072
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT
??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ DB 'nResult == nC'
	DB	'onvertedLen', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT
$T181064 = -64						; size = 4
$T181063 = -60						; size = 4
_nResult$76113 = -56					; size = 4
_nAllocLen$ = -52					; size = 4
_nConvertedLen$ = -48					; size = 4
_str$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lp$ = 8						; size = 4
_nLen$ = 12						; size = 4
?A2WBSTR@@YAPAGPBDH@Z PROC NEAR				; A2WBSTR, COMDAT

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?A2WBSTR@@YAPAGPBDH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 776  : 	if (lp == NULL || nLen == 0)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $L76086
	cmp	DWORD PTR _nLen$[ebp], 0
	jne	SHORT $L76085
$L76086:

; 777  : 		return NULL;

	xor	eax, eax
	jmp	$L76084
$L76085:

; 778  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 779  : 	BSTR str = NULL;

	mov	DWORD PTR _str$[ebp], 0

; 780  : 	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
; 781  : 		nLen, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nConvertedLen$[ebp], eax

; 782  : 	int nAllocLen = nConvertedLen;

	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	mov	DWORD PTR _nAllocLen$[ebp], eax

; 783  : 	if (nLen == -1)

	cmp	DWORD PTR _nLen$[ebp], -1
	jne	SHORT $L76111

; 784  : 		nAllocLen -= 1;  // Don't allocate terminating '\0'

	mov	ecx, DWORD PTR _nAllocLen$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nAllocLen$[ebp], ecx
$L76111:

; 785  : 	str = ::SysAllocStringLen(NULL, nAllocLen);

	mov	esi, esp
	mov	edx, DWORD PTR _nAllocLen$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__SysAllocStringLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$[ebp], eax

; 786  : 
; 787  : 	if (str != NULL)

	cmp	DWORD PTR _str$[ebp], 0
	je	$L76112

; 788  : 	{
; 789  : 		int nResult;
; 790  : 		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);

	mov	esi, esp
	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _lp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nResult$76113[ebp], eax

; 791  : 		ATLASSERT(nResult == nConvertedLen);

	mov	edx, DWORD PTR _nResult$76113[ebp]
	cmp	edx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L181062
	push	OFFSET FLAT:??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
	push	0
	push	791					; 00000317H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L181062
	int	3
$L181062:

; 792  : 		if(nResult != nConvertedLen)

	mov	ecx, DWORD PTR _nResult$76113[ebp]
	cmp	ecx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L76112

; 793  : 		{
; 794  : 			SysFreeString(str);

	mov	esi, esp
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 795  : 			return NULL;

	mov	DWORD PTR $T181063[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T181063[ebp]
	jmp	SHORT $L76084
$L76112:

; 796  : 		}
; 797  : 
; 798  : 	}
; 799  : 	return str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR $T181064[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T181064[ebp]
$L76084:

; 800  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181071
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L181071:
	DD	1
	DD	$L181070
$L181070:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L181068
$L181068:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L181065:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?A2WBSTR@@YAPAGPBDH@Z:
	mov	eax, OFFSET FLAT:$T181067
	jmp	___CxxFrameHandler
text$x	ENDS
?A2WBSTR@@YAPAGPBDH@Z ENDP				; A2WBSTR
EXTRN	_AddLogDetailWithMutex:NEAR
EXTRN	_memset:NEAR
EXTRN	_sprintf:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.cpp
_TEXT	SEGMENT
_buffer$ = -688						; size = 512
_osvi$ = -168						; size = 156
_bOsVersionInfoEx$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?getHostOsType@CLicense@@SAJXZ PROC NEAR		; CLicense::getHostOsType

; 450  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 692				; 000002b4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-692]
	mov	ecx, 173				; 000000adH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 451  :     BOOL bOsVersionInfoEx;
; 452  : 	OSVERSIONINFOEX osvi;
; 453  :    // Try calling GetVersionEx using the OSVERSIONINFOEX structure.
; 454  :    // If that fails, try using the OSVERSIONINFO structure.
; 455  : 
; 456  :    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _osvi$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 457  :    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	mov	DWORD PTR _osvi$[ebp], 156		; 0000009cH

; 458  : 
; 459  : #ifdef WIN32
; 460  :    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )

	mov	esi, esp
	lea	ecx, DWORD PTR _osvi$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bOsVersionInfoEx$[ebp], eax
	cmp	DWORD PTR _bOsVersionInfoEx$[ebp], 0
	jne	SHORT $L178349

; 461  :    {
; 462  :       // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
; 463  :       osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	mov	DWORD PTR _osvi$[ebp], 148		; 00000094H

; 464  :       if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 

	mov	esi, esp
	lea	edx, DWORD PTR _osvi$[ebp]
	push	edx
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L178349

; 465  : 	  {
; 466  : 		  return 0;

	xor	eax, eax
	jmp	$L178343
$L178349:

; 467  : 	  }
; 468  :    }
; 469  : #endif
; 470  : #ifdef LOGGING
; 471  :    char buffer[BUFSIZ];
; 472  :    ZeroMemory(buffer, BUFSIZ);

	push	512					; 00000200H
	push	0
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 473  :    sprintf((char *)buffer, "dwOSVersionInfoSize = %x", osvi.dwOSVersionInfoSize);

	mov	ecx, DWORD PTR _osvi$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG178355
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 474  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178357
	push	0
	push	0
	push	OFFSET FLAT:$SG178358
	push	474					; 000001daH
	push	OFFSET FLAT:$SG178359
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 475  :    sprintf((char *)buffer, "dwBuildNumber = %x", osvi.dwBuildNumber);

	mov	ecx, DWORD PTR _osvi$[ebp+12]
	push	ecx
	push	OFFSET FLAT:$SG178361
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 476  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178363
	push	0
	push	0
	push	OFFSET FLAT:$SG178364
	push	476					; 000001dcH
	push	OFFSET FLAT:$SG178365
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 477  :    sprintf((char *)buffer, "dwMajorVersion = %x", osvi.dwMajorVersion);

	mov	ecx, DWORD PTR _osvi$[ebp+4]
	push	ecx
	push	OFFSET FLAT:$SG178367
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 478  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178369
	push	0
	push	0
	push	OFFSET FLAT:$SG178370
	push	478					; 000001deH
	push	OFFSET FLAT:$SG178371
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 479  :    sprintf((char *)buffer, "dwMinorVersion = %x", osvi.dwMinorVersion);

	mov	ecx, DWORD PTR _osvi$[ebp+8]
	push	ecx
	push	OFFSET FLAT:$SG178373
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 480  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178375
	push	0
	push	0
	push	OFFSET FLAT:$SG178376
	push	480					; 000001e0H
	push	OFFSET FLAT:$SG178377
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 481  :    sprintf((char *)buffer, "dwPlatformId = %x", osvi.dwPlatformId);

	mov	ecx, DWORD PTR _osvi$[ebp+16]
	push	ecx
	push	OFFSET FLAT:$SG178379
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 482  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178381
	push	0
	push	0
	push	OFFSET FLAT:$SG178382
	push	482					; 000001e2H
	push	OFFSET FLAT:$SG178383
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 483  :    sprintf((char *)buffer, "wProductType = %x", osvi.wProductType);

	movzx	ecx, BYTE PTR _osvi$[ebp+154]
	push	ecx
	push	OFFSET FLAT:$SG178385
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 484  :    DebugLog((const char *)buffer);

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	push	OFFSET FLAT:$SG178387
	push	0
	push	0
	push	OFFSET FLAT:$SG178388
	push	484					; 000001e4H
	push	OFFSET FLAT:$SG178389
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 485  : #endif
; 486  :    return( (long) osvi.wProductType);

	movzx	eax, BYTE PTR _osvi$[ebp+154]
$L178343:

; 487  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181082
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 692				; 000002b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L181082:
	DD	2
	DD	$L181081
$L181081:
	DD	-168					; ffffff58H
	DD	156					; 0000009cH
	DD	$L181078
	DD	-688					; fffffd50H
	DD	512					; 00000200H
	DD	$L181079
$L181079:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L181078:
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	0
?getHostOsType@CLicense@@SAJXZ ENDP			; CLicense::getHostOsType
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z	; CLicense::verifyLicense
PUBLIC	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z	; CLicense::Get_CRC_CheckSum
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp__GetComputerNameA@8:NEAR
EXTRN	_xsFree:NEAR
EXTRN	?GetYear@CTime@ATL@@QBEHXZ:NEAR			; ATL::CTime::GetYear
EXTRN	?GetMonth@CTime@ATL@@QBEHXZ:NEAR		; ATL::CTime::GetMonth
EXTRN	?GetDay@CTime@ATL@@QBEHXZ:NEAR			; ATL::CTime::GetDay
EXTRN	_myFree:NEAR
EXTRN	_axVerifyFile:NEAR
EXTRN	_axGetSignature:NEAR
EXTRN	_strcmp:NEAR
EXTRN	__imp__GetSystemTime@4:NEAR
EXTRN	?HeapW2A@@YAPAEPAG@Z:NEAR			; HeapW2A
EXTRN	__imp__StrStrIA@8:NEAR
xdata$x	SEGMENT
$T181118 DD	0ffffffffH
	DD	FLAT:$L181095
	DD	00H
	DD	FLAT:$L181096
	DD	01H
	DD	FLAT:$L181097
	DD	02H
	DD	FLAT:$L181098
	DD	03H
	DD	FLAT:$L181099
	DD	04H
	DD	FLAT:$L181100
	DD	03H
	DD	FLAT:$L181100
$T181102 DD	019930520H
	DD	07H
	DD	FLAT:$T181118
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv314 = -688						; size = 4
tv150 = -684						; size = 4
$T181094 = -680						; size = 4
$T181093 = -676						; size = 4
$T181092 = -672						; size = 4
$T181091 = -668						; size = 4
$T181090 = -664						; size = 4
$T181089 = -660						; size = 4
$T181088 = -656						; size = 4
$T181087 = -652						; size = 4
$T181086 = -648						; size = 28
$T181085 = -620						; size = 4
_osType$ = -616						; size = 4
__lpa$ = -612						; size = 4
__lpw$ = -608						; size = 4
__acp$ = -604						; size = 4
__convert$ = -600					; size = 4
_licHostName$ = -596					; size = 4
_lpnSize$ = -588					; size = 4
_lpBuffer$ = -576					; size = 260
_isexp$ = -309						; size = 1
_currDay$ = -308					; size = 4
_currMon$ = -304					; size = 4
_currYear$ = -300					; size = 4
_t$ = -292						; size = 16
_X509Cert$ = -268					; size = 28
_Cert2$ = -232						; size = 28
_junk2$ = -196						; size = 20
_Cert3$ = -168						; size = 28
_junk1$ = -132						; size = 20
_Cert1$ = -104						; size = 28
_cert_in_lic$ = -68					; size = 28
_ret_val$ = -36						; size = 4
_crcValue$ = -28					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_SigHandle$ = 8						; size = 4
?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyLicense
; _this$ = ecx

; 489  : BOOL CLicense::verifyLicense(PGLOBAL_SIG SigHandle) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 676				; 000002a4H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-688]
	mov	ecx, 169				; 000000a9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 490  : 
; 491  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 492  : 	// Here we are verifying the signature of the license file.
; 493  : 	// If license file is modified, the signature verification will fail.
; 494  : 	int ret_val = axVerifyFile((const xmlChar *)licenseFile, NULL, FALSE, -1, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_axVerifyFile
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret_val$[ebp], eax

; 495  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	SHORT $L178398

; 496  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 497  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 498  : 		return FALSE;

	xor	eax, eax
	jmp	$L178394
$L178398:

; 499  : 	}
; 500  : 	// We also need to verify that the license is signed with our certificate
; 501  : 
; 502  : 	// Sizes of the strings 1024 + 1024 + 460
; 503  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 504  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	SHORT $L178399

; 505  : 		// There can't be more than one signature in the license file.
; 506  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 507  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 508  : 		xsFree(SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_xsFree
	add	esp, 4

; 509  : 		return FALSE;

	xor	eax, eax
	jmp	$L178394
$L178399:

; 510  : 	}
; 511  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 512  : 	
; 513  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $L178401
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+2048], 0
	je	SHORT $L178401

; 514  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 515  : 	else {

	jmp	SHORT $L178403
$L178401:

; 516  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 517  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 518  : 		xsFree(SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_xsFree
	add	esp, 4

; 519  : 		return FALSE;

	mov	DWORD PTR $T181085[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181085[ebp]
	jmp	$L178394
$L178403:

; 520  : 	}
; 521  : 	xsFree(SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_xsFree
	add	esp, 4

; 522  : 	// This is the certificate that should be used to create XML Licenses for
; 523  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 524  : 	// executable to check against the license used.
; 525  : 
; 526  : 	const string Cert1 = "MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCBvzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWwgU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxIzAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBTaWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlbnNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jACKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdBn2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A";

	push	OFFSET FLAT:$SG178406
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 527  : // Insert some junk data so that search for X509 cert match in the dll fails
; 528  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 529  : 	const string Cert3 = "cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBAKcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/sXMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzrrTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKmbpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=";	

	push	OFFSET FLAT:$SG178409
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 530  : // Insert some junk data so that search for X509 cert match in the dll fails
; 531  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 532  : 	const string Cert2 = "aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTERMA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbWVudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArblPpz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl";

	push	OFFSET FLAT:$SG178412
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 533  : 
; 534  : 	string X509Cert = Cert1 + Cert2 + Cert3;

	lea	ecx, DWORD PTR _Cert2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Cert1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T181086[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv314[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	edx, DWORD PTR _Cert3$[ebp]
	push	edx
	mov	eax, DWORD PTR tv314[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T181086[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 535  : 
; 536  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	edx, DWORD PTR _crcValue$[ebp]
	push	edx
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 537  : 	if (crcValue != 0xE771) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 59249	; 0000e771H
	je	SHORT $L178425

; 538  : 	{
; 539  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 540  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 541  : 		return FALSE;

	mov	DWORD PTR $T181087[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181087[ebp]
	jmp	$L178394
$L178425:

; 542  : 	}
; 543  : 	if (X509Cert != cert_in_lic) {

	lea	edx, DWORD PTR _cert_in_lic$[ebp]
	push	edx
	lea	eax, DWORD PTR _X509Cert$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L178434

; 544  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 545  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 546  : 		return FALSE;

	mov	DWORD PTR $T181088[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181088[ebp]
	jmp	$L178394
$L178434:

; 547  : 	}
; 548  : 	// Now check the date etc.. of the license.
; 549  : 	SYSTEMTIME t;
; 550  : #ifdef WIN32
; 551  : 	GetSystemTime(&t);

	mov	esi, esp
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 552  : #else
; 553  : 	GetSystemTimeLinux(&t);
; 554  : #endif
; 555  : 	int currYear = t.wYear;

	movzx	edx, WORD PTR _t$[ebp]
	mov	DWORD PTR _currYear$[ebp], edx

; 556  : 	int currMon = t.wMonth;

	movzx	eax, WORD PTR _t$[ebp+2]
	mov	DWORD PTR _currMon$[ebp], eax

; 557  : 	int currDay = t.wDay;

	movzx	ecx, WORD PTR _t$[ebp+6]
	mov	DWORD PTR _currDay$[ebp], ecx

; 558  : 
; 559  : 	bool isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 560  : 	if (currYear < expYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _currYear$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $L178441

; 561  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 562  : 	else if (currYear == expYear)

	jmp	SHORT $L178442
$L178441:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _currYear$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jne	SHORT $L178442

; 563  : 		if (currMon < expMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currMon$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $L178444

; 564  : 			isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 565  : 		else if (currMon == expMon)

	jmp	SHORT $L178442
$L178444:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _currMon$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jne	SHORT $L178442

; 566  : 			if (currDay <= expDay)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _currDay$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jg	SHORT $L178442

; 567  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L178442:

; 568  : 
; 569  : 	if (isexp) {

	movzx	eax, BYTE PTR _isexp$[ebp]
	test	eax, eax
	je	$L178448

; 570  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 571  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 572  : 		num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 573  : 		return FALSE;

	mov	DWORD PTR $T181089[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181089[ebp]
	jmp	$L178394
$L178448:

; 574  : 	}
; 575  : 
; 576  : #ifdef WIN32
; 577  : 	releaseYear = releaseTime.GetYear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetYear@CTime@ATL@@QBEHXZ		; ATL::CTime::GetYear
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 578  : 	releaseMonth = releaseTime.GetMonth();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetMonth@CTime@ATL@@QBEHXZ		; ATL::CTime::GetMonth
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 579  : 	releaseDay = releaseTime.GetDay();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetDay@CTime@ATL@@QBEHXZ		; ATL::CTime::GetDay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 580  : #endif
; 581  : 
; 582  : 	isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 583  : 	if (releaseYear < maintExpYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $L178450

; 584  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 585  : 	else

	jmp	SHORT $L178451
$L178450:

; 586  : 	{
; 587  : 		if (releaseYear == maintExpYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+52]
	jne	SHORT $L178451

; 588  : 		{
; 589  : 			if (releaseMonth < maintExpMon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $L178453

; 590  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 591  : 			else 

	jmp	SHORT $L178451
$L178453:

; 592  : 			{
; 593  : 				if (releaseMonth == maintExpMon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+56]
	jne	SHORT $L178451

; 594  : 				{
; 595  : 					if (releaseDay <= maintExpDay)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+60]
	jg	SHORT $L178451

; 596  : 					{
; 597  : 						isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L178451:

; 598  : 					}
; 599  : 				}
; 600  : 			}
; 601  : 		}
; 602  : 	}
; 603  : 
; 604  : 	if (isexp) {

	movzx	edx, BYTE PTR _isexp$[ebp]
	test	edx, edx
	je	$L178457

; 605  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 606  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 607  : 		isVerifyAllowed = FALSE; // Maintenance has expired so don't allow either sign or verify

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 608  : 		num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 609  : 		return FALSE;

	mov	DWORD PTR $T181090[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181090[ebp]
	jmp	$L178394
$L178457:

; 610  : 	}
; 611  : 
; 612  : 	char lpBuffer[MAX_PATH];
; 613  : 	unsigned long lpnSize=MAX_PATH;

	mov	DWORD PTR _lpnSize$[ebp], 260		; 00000104H

; 614  : 	char *licHostName;
; 615  : 
; 616  : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 617  : 
; 618  : 	licHostName = (char *)HeapW2A(hostname);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _licHostName$[ebp], eax

; 619  : 	if (strcmp((const char *)licHostName,"TrialHost"))

	push	OFFSET FLAT:$SG178469
	mov	eax, DWORD PTR _licHostName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L178468

; 620  : 	{
; 621  : #ifdef WIN32
; 622  : 		GetComputerName( lpBuffer,  // name buffer
; 623  : 						&lpnSize                // size of name buffer
; 624  : 						);

	mov	esi, esp
	lea	ecx, DWORD PTR _lpnSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpBuffer$[ebp]
	push	edx
	call	DWORD PTR __imp__GetComputerNameA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 625  : #else
; 626  : 		gethostname(lpBuffer, MAX_PATH);
; 627  : #endif
; 628  : 		if (!(StrStrI((const char *)licHostName, (const char *)lpBuffer)))

	mov	esi, esp
	lea	eax, DWORD PTR _lpBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _licHostName$[ebp]
	push	ecx
	call	DWORD PTR __imp__StrStrIA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L178468

; 629  : 		{
; 630  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 631  : 			isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 632  : 			zFree(licHostName);

	push	OFFSET FLAT:$SG178473
	push	632					; 00000278H
	push	OFFSET FLAT:$SG178474
	mov	ecx, DWORD PTR _licHostName$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 633  : 			return FALSE;

	mov	DWORD PTR $T181091[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181091[ebp]
	jmp	$L178394
$L178468:

; 634  : 		}
; 635  : 	}
; 636  : 	zFree(licHostName);

	push	OFFSET FLAT:$SG178476
	push	636					; 0000027cH
	push	OFFSET FLAT:$SG178477
	mov	edx, DWORD PTR _licHostName$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 637  : 
; 638  : 	long osType;
; 639  : 
; 640  : 	osType = getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	DWORD PTR _osType$[ebp], eax

; 641  : 	if ((osType != 0) && (osType != VER_NT_WORKSTATION))

	cmp	DWORD PTR _osType$[ebp], 0
	je	$L178479
	cmp	DWORD PTR _osType$[ebp], 1
	je	$L178479

; 642  : 		 /* It is not a client machine as it is some sort of windows server product */
; 643  : 	{
; 644  : 		if (isServerLic == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $L178480

; 645  : 		{
; 646  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 647  : 			isLicenseValid = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 0

; 648  : 			return FALSE;

	mov	DWORD PTR $T181092[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181092[ebp]
	jmp	$L178394
$L178480:

; 649  : 		}
; 650  : 	}
; 651  : 	else

	jmp	SHORT $L178482
$L178479:

; 652  : 	{
; 653  : 		if (isClientLic == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	jne	SHORT $L178482

; 654  : 		{
; 655  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 656  : 			isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 657  : 			return FALSE;

	mov	DWORD PTR $T181093[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181093[ebp]
	jmp	SHORT $L178394
$L178482:

; 658  : 		}
; 659  : 	}
; 660  : 
; 661  : 	// We verified the values in the license file.
; 662  : 
; 663  : 	isLicenseValid = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 1

; 664  : 	return TRUE;

	mov	DWORD PTR $T181094[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181094[ebp]
$L178394:

; 665  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181117
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 688				; 000002b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L181117:
	DD	11					; 0000000bH
	DD	$L181116
$L181116:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L181103
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$L181104
	DD	-104					; ffffff98H
	DD	28					; 0000001cH
	DD	$L181105
	DD	-132					; ffffff7cH
	DD	20					; 00000014H
	DD	$L181106
	DD	-168					; ffffff58H
	DD	28					; 0000001cH
	DD	$L181107
	DD	-196					; ffffff3cH
	DD	20					; 00000014H
	DD	$L181108
	DD	-232					; ffffff18H
	DD	28					; 0000001cH
	DD	$L181109
	DD	-268					; fffffef4H
	DD	28					; 0000001cH
	DD	$L181110
	DD	-292					; fffffedcH
	DD	16					; 00000010H
	DD	$L181111
	DD	-576					; fffffdc0H
	DD	260					; 00000104H
	DD	$L181112
	DD	-588					; fffffdb4H
	DD	4
	DD	$L181113
$L181113:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L181112:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L181111:
	DB	116					; 00000074H
	DB	0
$L181110:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L181109:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L181108:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L181107:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L181106:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L181105:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L181104:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L181103:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L181095:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181096:
	lea	ecx, DWORD PTR _Cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181097:
	lea	ecx, DWORD PTR _Cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181098:
	lea	ecx, DWORD PTR _Cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181099:
	lea	ecx, DWORD PTR $T181086[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181100:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T181102
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ENDP	; CLicense::verifyLicense
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bTmp$ = -5						; size = 1
_pb$ = -4						; size = 4
_pBuffer$ = 8						; size = 4
_ulSize$ = 12						; size = 4
_pulSeed$ = 16						; size = 4
?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z PROC NEAR	; CLicense::Get_CRC_CheckSum

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 682  :   PBYTE    pb;
; 683  :   BYTE    bTmp;
; 684  : 
; 685  :   for (pb=(BYTE *)pBuffer; ulSize; ulSize--, pb++)

	mov	eax, DWORD PTR _pBuffer$[ebp]
	mov	DWORD PTR _pb$[ebp], eax
	jmp	SHORT $L178496
$L178497:
	mov	ecx, DWORD PTR _ulSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulSize$[ebp], ecx
	mov	edx, DWORD PTR _pb$[ebp]
	add	edx, 1
	mov	DWORD PTR _pb$[ebp], edx
$L178496:
	cmp	DWORD PTR _ulSize$[ebp], 0
	je	SHORT $L178492

; 686  :   {
; 687  :     bTmp=(BYTE)(((WORD)*pb)^((WORD)*pulSeed));    // Xor CRC with new char

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pulSeed$[ebp]
	movzx	eax, WORD PTR [edx]
	xor	ecx, eax
	mov	BYTE PTR _bTmp$[ebp], cl

; 688  :     *pulSeed=((*pulSeed)>>8) ^ wCRC16a[bTmp&0x0F] ^ wCRC16b[bTmp>>4];

	mov	ecx, DWORD PTR _pulSeed$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 8
	movzx	eax, BYTE PTR _bTmp$[ebp]
	and	eax, 15					; 0000000fH
	movzx	ecx, WORD PTR ?wCRC16a@@3PAGA[eax*2]
	xor	edx, ecx
	movzx	eax, BYTE PTR _bTmp$[ebp]
	sar	eax, 4
	movzx	ecx, WORD PTR ?wCRC16b@@3PAGA[eax*2]
	xor	edx, ecx
	mov	eax, DWORD PTR _pulSeed$[ebp]
	mov	DWORD PTR [eax], edx

; 689  :   }

	jmp	SHORT $L178497
$L178492:

; 690  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ENDP		; CLicense::Get_CRC_CheckSum
_TEXT	ENDS
PUBLIC	?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z ; CLicense::verifyFloatingLicense
EXTRN	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z:NEAR	; ATL::CTime::CTime
EXTRN	_vbNowTimeToSystem:NEAR
EXTRN	_EnteringFunction:DWORD
EXTRN	_ExitingFunction:DWORD
EXTRN	_myMalloc:NEAR
EXTRN	_base64decodeSize:NEAR
EXTRN	_base64decode:NEAR
EXTRN	_axVerify:NEAR
EXTRN	_strlen:NEAR
EXTRN	_strchr:NEAR
EXTRN	_strstr:NEAR
xdata$x	SEGMENT
$T181149 DD	0ffffffffH
	DD	FLAT:$L181124
	DD	00H
	DD	FLAT:$L181125
	DD	01H
	DD	FLAT:$L181126
	DD	02H
	DD	FLAT:$L181127
	DD	03H
	DD	FLAT:$L181128
	DD	04H
	DD	FLAT:$L181129
	DD	05H
	DD	FLAT:$L181130
	DD	03H
	DD	FLAT:$L181130
	DD	07H
	DD	FLAT:$L181129
	DD	07H
	DD	FLAT:$L181131
$T181133 DD	019930520H
	DD	0aH
	DD	FLAT:$T181149
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv580 = -452						; size = 4
tv73 = -448						; size = 4
tv578 = -444						; size = 4
tv77 = -440						; size = 4
$T181123 = -436						; size = 28
$T181122 = -408						; size = 28
_licTime$ = -376					; size = 8
_floatLicTimeStamp$ = -364				; size = 4
_isexp$ = -357						; size = 1
_i$178572 = -356					; size = 4
_equalPtr$ = -352					; size = 4
_propNumber$ = -348					; size = 4
_timeStr$ = -344					; size = 4
_length$ = -340						; size = 4
_cert_in_lic$ = -332					; size = 28
_ret_val$ = -300					; size = 4
_X509Cert$ = -292					; size = 28
_crcValue$ = -256					; size = 4
_cert3$ = -244						; size = 28
_junk3$ = -208						; size = 20
_cert1$ = -180						; size = 28
_junk2$ = -144						; size = 20
_cert2$ = -116						; size = 28
_junk1$ = -80						; size = 20
_cert4$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_inputXMLStr$ = 8					; size = 4
_size$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyFloatingLicense
; _this$ = ecx

; 693  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 440				; 000001b8H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 694  : 	const string cert4 = "LmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbigxKS5jcnQwDQYJKoZIhvcNAQEFBQADggEBAFrOd7OXXrIwQB5Fz+AZTt2mgvdXkJlrneuWoyEF3DSoZfSdGqaORmWEdNcWbcxmN+xl81bWwCmdi99emBvH0sIEvS9u8y4c93zG/qg3+Icu3/KNYDGAXBWJFdnCyTPfBdhTw1AmXOHepQ9i2C51S4wA8keQoaH1yCwQjcSA3cRAlweg0BkpBM1NRx+jOlMgLmCETb+8iZ1vDQZ0SBulO60cX7pdD/cQUE5mbeII/enkaECj8eC9CuPrhmL5D3B0xSgXOGryWNIAl1gcIM2+wt+D92vN8n0WiZ1LA9DNvZPY17DePeEEwxk1Kd33C+F9Tw9q57b4rsjY/PaM9Gi8FG0=";

	push	OFFSET FLAT:$SG178509
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 695  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 696  : 	const string cert2 = "b24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALgb0p8Fh0O1DwZyXDONau+SqVvM3IDvqDDjMLQ8uR4BnGXjiGqgjdrH4obZekYYcjWIWu01vPMAYYHH198gmsFxHphndAsPllBUl0iX4JEhyBtZAo7koED+J+9aMNkVAjkA4AG17Z/MfglAH+/EwsvI9nPwwsW1P9lFcQsZivIxAgMBAAGjggIzMIICLzAOBgNVHQ8BAf8EBAMCBPAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAX3Ts8591e+/KCE4jgHJqKw5EqzMIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYHEpIHBMIG+MSIwIAYJKoZIhvcNAQkB";

	push	OFFSET FLAT:$SG178512
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 697  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 698  : 	const string cert1 = "MIIFvzCCBKegAwIBAgIKFDX9YgABAAAG5DANBgkqhkiG9w0BAQUFADCBvjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIERpZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24wHhcNMDMxMDAzMjIyOTUxWhcNMTMxMDAzMjE1OTUzWjCByjEjMCEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRp";

	push	OFFSET FLAT:$SG178515
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 699  : 	const int	 junk3[5] = { 0x0112a123, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk3$[ebp], 17998115	; 0112a123H
	mov	DWORD PTR _junk3$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk3$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk3$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk3$[ebp+16], 17497089	; 010afc01H

; 700  : 	const string cert3 = "FhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYXR1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQKiQ6i/TBzo1KZki1g15oZzBeBgNVHR8EVzBVMFOgUaBPhk1odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvSW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLmNybDCBiwYIKwYBBQUHAQEEfzB9MHsGCCsGAQUFBzAChm9odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvaW5mb21vc2FpYy1zcnZy";

	push	OFFSET FLAT:$SG178518
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 701  : 
; 702  : //	const string cert3 = "YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBADkFy7R4bgPZoWi1v0Nro7J0ZSNpa8xAuzgwa9ff5dJDuiB3ER4EAiws5O3DFUv8W0dfsFX262PJKk1jkcIRwox7e5ZzKU+1XUVc6vM9vXk1lvYiNsy5n4h9fUskMJNnotky2Z8SZ/7vL+iGeOP9Wti5U779Ues2BxZMHaFYR+dzWpz6xC64rqwSBDeZq3VIXFfXnS3q7yqEGS287Q4P8jAntM7ImN2brFieSL597nNSW7pEOlFRV462A3IPzTTjQSoS5M99XqIyCfw+NL8oyfOoV8mhVm0JmqlodYAelJpwDswGUuzdSjJl91iBluMJR0uMx4mE+KkeV1+r7HF7A4U=";
; 703  : // Insert some junk data so that search for X509 cert match in the dll fails
; 704  : //	const string cert2 = "/7Ufng45apgE7V1MIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYHEpIHBMIG+MSIwIAYJKoZIhvcNAQkBFhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYXR1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQdOykPAAmzJZAPfFU7pEKWDCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/";
; 705  : // Insert some junk data so that search for X509 cert match in the dll fails
; 706  : //	const string cert1 = "MIIHWjCCBkKgAwIBAgIKGg1iMAAAAAAGsjANBgkqhkiG9w0BAQUFADCBvjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIERpZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24wHhcNMDMwOTEyMDAyMTM5WhcNMDQwOTEyMDAzMTM5WjCByjEjMCEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAOjh54QWn49CV32AgiWGReEAN4VkufrByl0QW8LblTfJu8C5Uge66I31M6puAz9HtXI+EFSIKbahbQpR4uM/wroeD5oEnL3kHiWyRRBipFqF5JkvMShg6x0Y+OTec1ooSEWkBkujsk4vW8wKsQGaxbjlxCfPvIsN7bzX1dpgWvBHAgMBAAGjggPOMIIDyjAOBgNVHQ8BAf8EBAMCBPAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAByQ3GdrZYaO";
; 707  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 708  : 	
; 709  : 	string X509Cert = cert1 + cert2 + cert3 + cert4;

	lea	eax, DWORD PTR _cert2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cert1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T181122[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv77[ebp], eax
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv578[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _cert3$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv578[ebp]
	push	edx
	lea	eax, DWORD PTR $T181123[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv580[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	edx, DWORD PTR _cert4$[ebp]
	push	edx
	mov	eax, DWORD PTR tv580[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T181123[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T181122[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 710  : 
; 711  : 	EnterLog;

	mov	edx, DWORD PTR _EnteringFunction
	push	edx
	push	OFFSET FLAT:$SG178524
	push	0
	push	0
	push	OFFSET FLAT:$SG178525
	push	711					; 000002c7H
	push	OFFSET FLAT:$SG178526
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 712  : //	DebugBreak();
; 713  : 
; 714  : 	// Here we are verifying the signature of the license file.
; 715  : 	// If license file is modified, the signature verification will fail.
; 716  : 	int ret_val = axVerify((const xmlChar *)inputXMLStr, size, NULL, FALSE, -1, 1, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	push	1
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	push	ecx
	mov	edx, DWORD PTR _inputXMLStr$[ebp]
	push	edx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$[ebp], eax

; 717  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	$L178529

; 718  : 		DebugLog("axVerify() for floating license xml failed");

	push	OFFSET FLAT:$SG178530
	push	OFFSET FLAT:$SG178531
	push	0
	push	0
	push	OFFSET FLAT:$SG178532
	push	718					; 000002ceH
	push	OFFSET FLAT:$SG178533
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 719  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 720  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 721  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178529:

; 722  : 	}
; 723  : 
; 724  : 	// We also need to verify that the license is signed with our certificate
; 725  : 
; 726  : 	// Sizes of the strings 1024 + 1024 + 460
; 727  : 
; 728  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 729  : 
; 730  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	$L178534

; 731  : 		// There can't be more than one signature in the license file.
; 732  : 		DebugLog("signum != 1 from axGetSignature() after axVerify() for floating license xml");

	push	OFFSET FLAT:$SG178535
	push	OFFSET FLAT:$SG178536
	push	0
	push	0
	push	OFFSET FLAT:$SG178537
	push	732					; 000002dcH
	push	OFFSET FLAT:$SG178538
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 733  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 734  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 735  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178534:

; 736  : 	}
; 737  : 
; 738  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 739  : 	
; 740  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $L178540
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L178540

; 741  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 742  : 	else {

	jmp	$L178542
$L178540:

; 743  : 		DebugLog("Certificate not present in the output from axGetSignature()");

	push	OFFSET FLAT:$SG178543
	push	OFFSET FLAT:$SG178544
	push	0
	push	0
	push	OFFSET FLAT:$SG178545
	push	743					; 000002e7H
	push	OFFSET FLAT:$SG178546
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 744  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 745  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 746  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178542:

; 747  : 	}
; 748  : 
; 749  : 	// This is the certificate that should be used to create floating Licenses for
; 750  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 751  : 	// executable to check against the license used.
; 752  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	ecx, DWORD PTR _crcValue$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 753  : 	if (crcValue != 0xF3E9) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 62441	; 0000f3e9H
	je	$L178549

; 754  : //	if (crcValue != 0x5C68) // Someone patched the dll with a different X509 cert
; 755  : 	{
; 756  : 		DebugLog("Checksum validation failed");

	push	OFFSET FLAT:$SG178550
	push	OFFSET FLAT:$SG178551
	push	0
	push	0
	push	OFFSET FLAT:$SG178552
	push	756					; 000002f4H
	push	OFFSET FLAT:$SG178553
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 757  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 758  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 759  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178549:

; 760  : 	}
; 761  : 	if (X509Cert != cert_in_lic) {

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	push	ecx
	lea	edx, DWORD PTR _X509Cert$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$L178554

; 762  : 		DebugLog("X509 Data not the same as expected in floating license");

	push	OFFSET FLAT:$SG178555
	push	OFFSET FLAT:$SG178556
	push	0
	push	0
	push	OFFSET FLAT:$SG178557
	push	762					; 000002faH
	push	OFFSET FLAT:$SG178558
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 763  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 764  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 765  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178554:

; 766  : 	}
; 767  : 
; 768  : 	// Now check the date etc.. of the license.
; 769  : 
; 770  : 	unsigned int length = strlen((const char *)(sigArr[0]->refArray[0]->refObject->encodedData));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 771  : 	size = base64decodeSize(length);

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 772  : 	unsigned char *timeStr = (unsigned char *)zMalloc(size+1);

	push	OFFSET FLAT:$SG178563
	push	772					; 00000304H
	push	OFFSET FLAT:$SG178564
	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	push	edx
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _timeStr$[ebp], eax

; 773  : 	if ((size = base64decode(sigArr[0]->refArray[0]->refObject->encodedData, timeStr, size+1)) == -1)

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _timeStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _size$[ebp], eax
	cmp	DWORD PTR _size$[ebp], -1
	jne	$L178565

; 774  : 	{
; 775  : 		DebugLog("Base64 decode failed");

	push	OFFSET FLAT:$SG178566
	push	OFFSET FLAT:$SG178567
	push	0
	push	0
	push	OFFSET FLAT:$SG178568
	push	775					; 00000307H
	push	OFFSET FLAT:$SG178569
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 776  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 777  : 		isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 778  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178565:

; 779  : 	}
; 780  : 	int propNumber = sigArr[0]->propNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _propNumber$[ebp], edx

; 781  : 	char *equalPtr=NULL;

	mov	DWORD PTR _equalPtr$[ebp], 0

; 782  : 	for (int i=0; i<propNumber; i++)

	mov	DWORD PTR _i$178572[ebp], 0
	jmp	SHORT $L178573
$L178574:
	mov	eax, DWORD PTR _i$178572[ebp]
	add	eax, 1
	mov	DWORD PTR _i$178572[ebp], eax
$L178573:
	mov	ecx, DWORD PTR _i$178572[ebp]
	cmp	ecx, DWORD PTR _propNumber$[ebp]
	jge	$L178575

; 783  : 	{
; 784  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryYear") != NULL)

	push	OFFSET FLAT:$SG178579
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178578

; 785  : 		{
; 786  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 787  : 			maintExpYear = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax
$L178578:

; 788  : 		}
; 789  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryMonth") != NULL)

	push	OFFSET FLAT:$SG178585
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178584

; 790  : 		{
; 791  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 792  : 			maintExpMon = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax
$L178584:

; 793  : 		}
; 794  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryDay") != NULL)

	push	OFFSET FLAT:$SG178591
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178590

; 795  : 		{
; 796  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 797  : 			maintExpDay = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax
$L178590:

; 798  : 		}
; 799  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"LinuxClient") != NULL)

	push	OFFSET FLAT:$SG178597
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178596

; 800  : 		{
; 801  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 802  : 			linuxClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax
$L178596:

; 803  : 		}
; 804  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"WindowsClient") != NULL)

	push	OFFSET FLAT:$SG178603
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178602

; 805  : 		{
; 806  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 807  : 			windowsClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+132], eax
$L178602:

; 808  : 		}
; 809  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"SolarisClient") != NULL)

	push	OFFSET FLAT:$SG178609
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178608

; 810  : 		{
; 811  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 812  : 			solarisClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], eax
$L178608:

; 813  : 		}
; 814  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MacClient") != NULL)

	push	OFFSET FLAT:$SG178615
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L178614

; 815  : 		{
; 816  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$178572[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 817  : 			macClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax
$L178614:

; 818  : 		}
; 819  : 	}

	jmp	$L178574
$L178575:

; 820  : 
; 821  : #ifdef WIN32
; 822  : 	releaseYear = releaseTime.GetYear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetYear@CTime@ATL@@QBEHXZ		; ATL::CTime::GetYear
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 823  : 	releaseMonth = releaseTime.GetMonth();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetMonth@CTime@ATL@@QBEHXZ		; ATL::CTime::GetMonth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 824  : 	releaseDay = releaseTime.GetDay();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetDay@CTime@ATL@@QBEHXZ		; ATL::CTime::GetDay
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], eax

; 825  : #endif
; 826  : 	
; 827  : 	bool isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 828  : 	if (releaseYear < maintExpYear)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+52]
	jge	SHORT $L178619

; 829  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 830  : 	else

	jmp	SHORT $L178620
$L178619:

; 831  : 	{
; 832  : 		if (releaseYear == maintExpYear)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+52]
	jne	SHORT $L178620

; 833  : 		{
; 834  : 			if (releaseMonth < maintExpMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+56]
	jge	SHORT $L178622

; 835  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 836  : 			else 

	jmp	SHORT $L178620
$L178622:

; 837  : 			{
; 838  : 				if (releaseMonth == maintExpMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+56]
	jne	SHORT $L178620

; 839  : 				{
; 840  : 					if (releaseDay <= maintExpDay)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+60]
	jg	SHORT $L178620

; 841  : 					{
; 842  : 						isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L178620:

; 843  : 					}
; 844  : 				}
; 845  : 			}
; 846  : 		}
; 847  : 	}
; 848  : 
; 849  : 	if (isexp) {

	movzx	eax, BYTE PTR _isexp$[ebp]
	test	eax, eax
	je	$L178626

; 850  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 851  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 852  : 		isVerifyAllowed = FALSE; // Maintenance has expired so don't allow either sign or verify

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 853  : 		num_of_lic = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 854  : 		isLicenseFloating = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0

; 855  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178626:

; 856  : 	}
; 857  : 
; 858  : #ifdef WIN32
; 859  : 	if (windowsClient == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	$L178627

; 860  : 	{
; 861  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 862  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 863  : 		isVerifyAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 864  : 		isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 865  : 		num_of_lic = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], 0

; 866  : 		DebugLog("WindowsClient is not allowed");

	push	OFFSET FLAT:$SG178628
	push	OFFSET FLAT:$SG178629
	push	0
	push	0
	push	OFFSET FLAT:$SG178630
	push	866					; 00000362H
	push	OFFSET FLAT:$SG178631
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 867  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L178507
$L178627:

; 868  : 	}
; 869  : #endif
; 870  : 
; 871  : 	//DebugBreak();
; 872  : 	LPSYSTEMTIME floatLicTimeStamp = vbNowTimeToSystem((BYTE *)(char *)timeStr);

	mov	eax, DWORD PTR _timeStr$[ebp]
	push	eax
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	DWORD PTR _floatLicTimeStamp$[ebp], eax

; 873  : 	DebugLog("Time in floating license data = ");

	push	OFFSET FLAT:$SG178635
	push	OFFSET FLAT:$SG178636
	push	0
	push	0
	push	OFFSET FLAT:$SG178637
	push	873					; 00000369H
	push	OFFSET FLAT:$SG178638
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 874  : 	DebugLog((const char *)timeStr);

	mov	ecx, DWORD PTR _timeStr$[ebp]
	push	ecx
	push	OFFSET FLAT:$SG178640
	push	0
	push	0
	push	OFFSET FLAT:$SG178641
	push	874					; 0000036aH
	push	OFFSET FLAT:$SG178642
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 875  : 	CTime licTime(*floatLicTimeStamp, -1);

	push	-1
	mov	edx, DWORD PTR _floatLicTimeStamp$[ebp]
	push	edx
	lea	ecx, DWORD PTR _licTime$[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 876  : 
; 877  : 	floatingLicenseTime = licTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _licTime$[ebp]
	mov	DWORD PTR [eax+172], ecx
	mov	edx, DWORD PTR _licTime$[ebp+4]
	mov	DWORD PTR [eax+176], edx

; 878  : 	isLicenseFloating = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 1

; 879  : 	zFree(timeStr);

	push	OFFSET FLAT:$SG178644
	push	879					; 0000036fH
	push	OFFSET FLAT:$SG178645
	mov	ecx, DWORD PTR _timeStr$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 880  : 	zFree(floatLicTimeStamp);

	push	OFFSET FLAT:$SG178646
	push	880					; 00000370H
	push	OFFSET FLAT:$SG178647
	mov	edx, DWORD PTR _floatLicTimeStamp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 881  : 	ExitLog;

	mov	eax, DWORD PTR _ExitingFunction
	push	eax
	push	OFFSET FLAT:$SG178648
	push	0
	push	0
	push	OFFSET FLAT:$SG178649
	push	881					; 00000371H
	push	OFFSET FLAT:$SG178650
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 882  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L178507:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181148
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L181148:
	DD	11					; 0000000bH
	DD	$L181147
$L181147:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$L181134
	DD	-80					; ffffffb0H
	DD	20					; 00000014H
	DD	$L181135
	DD	-116					; ffffff8cH
	DD	28					; 0000001cH
	DD	$L181136
	DD	-144					; ffffff70H
	DD	20					; 00000014H
	DD	$L181137
	DD	-180					; ffffff4cH
	DD	28					; 0000001cH
	DD	$L181138
	DD	-208					; ffffff30H
	DD	20					; 00000014H
	DD	$L181139
	DD	-244					; ffffff0cH
	DD	28					; 0000001cH
	DD	$L181140
	DD	-256					; ffffff00H
	DD	4
	DD	$L181141
	DD	-292					; fffffedcH
	DD	28					; 0000001cH
	DD	$L181142
	DD	-332					; fffffeb4H
	DD	28					; 0000001cH
	DD	$L181143
	DD	-376					; fffffe88H
	DD	8
	DD	$L181144
$L181144:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L181143:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L181142:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L181141:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$L181140:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L181139:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	51					; 00000033H
	DB	0
$L181138:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L181137:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L181136:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L181135:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L181134:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	52					; 00000034H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L181124:
	lea	ecx, DWORD PTR _cert4$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181125:
	lea	ecx, DWORD PTR _cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181126:
	lea	ecx, DWORD PTR _cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181127:
	lea	ecx, DWORD PTR _cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181128:
	lea	ecx, DWORD PTR $T181122[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181129:
	lea	ecx, DWORD PTR $T181123[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181130:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181131:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T181133
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyFloatingLicense
PUBLIC	?floatingLicenseStatus@CLicense@@QAEHXZ		; CLicense::floatingLicenseStatus
EXTRN	?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ:NEAR	; ATL::CTimeSpan::GetTotalMinutes
EXTRN	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z:NEAR	; ATL::CTime::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv158 = -604						; size = 8
tv155 = -596						; size = 8
_timeDiff$178659 = -584					; size = 8
_curTime$178658 = -568					; size = 8
_buffer$178657 = -552					; size = 512
_allowedTimeOut$ = -36					; size = 4
_t$ = -28						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?floatingLicenseStatus@CLicense@@QAEHXZ PROC NEAR	; CLicense::floatingLicenseStatus
; _this$ = ecx

; 885  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-604]
	mov	ecx, 151				; 00000097H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 886  : 	SYSTEMTIME t;
; 887  : 	int allowedTimeOut=licenseTimeout;

	mov	DWORD PTR _allowedTimeOut$[ebp], 30	; 0000001eH

; 888  : //DebugBreak();
; 889  : 	if (isLicenseFloating == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 1
	jne	$L178656

; 890  : 	{
; 891  : #ifdef LOGGING
; 892  : 		unsigned char buffer[BUFSIZ];
; 893  : #endif
; 894  : #ifdef WIN32
; 895  : 		GetSystemTime(&t);

	mov	esi, esp
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 896  : #else
; 897  : 		GetSystemTimeLinux(&t);
; 898  : #endif
; 899  : 		CTime curTime(t, -1);

	push	-1
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	lea	ecx, DWORD PTR _curTime$178658[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 900  : 		CTimeSpan timeDiff = curTime - floatingLicenseTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	mov	edx, DWORD PTR [eax+172]
	push	edx
	lea	eax, DWORD PTR _timeDiff$178659[ebp]
	push	eax
	lea	ecx, DWORD PTR _curTime$178658[ebp]
	call	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z	; ATL::CTime::operator-

; 901  : #ifdef LOGGING
; 902  : 		sprintf((char *)buffer, "Time difference = %d", timeDiff.GetTotalMinutes());

	lea	ecx, DWORD PTR _timeDiff$178659[ebp]
	call	?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ	; ATL::CTimeSpan::GetTotalMinutes
	push	edx
	push	eax
	push	OFFSET FLAT:$SG178662
	lea	ecx, DWORD PTR _buffer$178657[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 903  : 		DebugLog((const char *)buffer);

	lea	edx, DWORD PTR _buffer$178657[ebp]
	push	edx
	push	OFFSET FLAT:$SG178664
	push	0
	push	0
	push	OFFSET FLAT:$SG178665
	push	903					; 00000387H
	push	OFFSET FLAT:$SG178666
	call	_AddLogDetailWithMutex
	add	esp, 28					; 0000001cH

; 904  : #endif
; 905  : 		//if (::dwMinorVersion == 0)
; 906  : 		//	allowedTimeOut += 60;
; 907  : 
; 908  : 		if (timeDiff.GetTotalMinutes() >= allowedTimeOut)

	lea	ecx, DWORD PTR _timeDiff$178659[ebp]
	call	?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ	; ATL::CTimeSpan::GetTotalMinutes
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR _allowedTimeOut$[ebp]
	cdq
	mov	DWORD PTR tv155[ebp], ecx
	mov	DWORD PTR tv155[ebp+4], esi
	mov	DWORD PTR tv158[ebp], eax
	mov	DWORD PTR tv158[ebp+4], edx
	mov	edx, DWORD PTR tv155[ebp+4]
	cmp	edx, DWORD PTR tv158[ebp+4]
	jl	SHORT $L178667
	jg	SHORT $L181152
	mov	eax, DWORD PTR tv155[ebp]
	cmp	eax, DWORD PTR tv158[ebp]
	jb	SHORT $L178667
$L181152:

; 909  : 		{
; 910  : 			isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 911  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L178653
$L178667:

; 912  : 		}
; 913  : 		else
; 914  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L178653
$L178656:

; 915  : 	}
; 916  : 	else
; 917  : 		return FALSE;

	xor	eax, eax
$L178653:

; 918  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181159
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 604				; 0000025cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L181159:
	DD	4
	DD	$L181158
$L181158:
	DD	-28					; ffffffe4H
	DD	16					; 00000010H
	DD	$L181153
	DD	-552					; fffffdd8H
	DD	512					; 00000200H
	DD	$L181154
	DD	-568					; fffffdc8H
	DD	8
	DD	$L181155
	DD	-584					; fffffdb8H
	DD	8
	DD	$L181156
$L181156:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
$L181155:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L181154:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L181153:
	DB	116					; 00000074H
	DB	0
?floatingLicenseStatus@CLicense@@QAEHXZ ENDP		; CLicense::floatingLicenseStatus
_TEXT	ENDS
PUBLIC	?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSignature
xdata$x	SEGMENT
$T181187 DD	0ffffffffH
	DD	FLAT:$L181167
	DD	00H
	DD	FLAT:$L181168
	DD	01H
	DD	FLAT:$L181169
	DD	02H
	DD	FLAT:$L181170
	DD	03H
	DD	FLAT:$L181171
	DD	04H
	DD	FLAT:$L181172
	DD	03H
	DD	FLAT:$L181172
$T181174 DD	019930520H
	DD	07H
	DD	FLAT:$T181187
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv214 = -332						; size = 4
tv145 = -328						; size = 4
$T181166 = -324						; size = 4
$T181165 = -320						; size = 4
$T181164 = -316						; size = 4
$T181163 = -312						; size = 28
$T181162 = -284						; size = 4
_X509Cert$ = -276					; size = 28
_Cert2$ = -240						; size = 28
_junk2$ = -204						; size = 20
_Cert3$ = -176						; size = 28
_junk1$ = -140						; size = 20
_Cert1$ = -112						; size = 28
_cert_in_lic$ = -76					; size = 28
_ret_val$ = -44						; size = 4
_xpathResultPtr$ = -40					; size = 4
_xpathPtr$ = -36					; size = 4
_crcValue$ = -28					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_templateSource$ = 8					; size = 4
_sizeM$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyTemplateSignature
; _this$ = ecx

; 921  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 320				; 00000140H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 80					; 00000050H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 922  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 923  : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 924  : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 925  : 
; 926  : 	int ret_val = axVerify((const xmlChar *)templateSource, sizeM, NULL, FALSE, -1, 1, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	push	1
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _templateSource$[ebp]
	push	edx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$[ebp], eax

; 927  : 
; 928  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	SHORT $L178681

; 929  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 930  : 		return FALSE;

	xor	eax, eax
	jmp	$L178675
$L178681:

; 931  : 	}
; 932  : 
; 933  : 	// We also need to verify that the license is signed with our certificate
; 934  : 
; 935  : 	// Sizes of the strings 1024 + 1024 + 460
; 936  : 
; 937  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 152				; 00000098H
	push	edx
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 938  : 
; 939  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	SHORT $L178682

; 940  : 		// There can't be more than one signature in the license file.
; 941  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 942  : 		return FALSE;

	xor	eax, eax
	jmp	$L178675
$L178682:

; 943  : 	}
; 944  : 
; 945  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 946  : 	
; 947  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L178684
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+2048], 0
	je	SHORT $L178684

; 948  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+2048]
	push	eax
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 949  : 	else {

	jmp	SHORT $L178686
$L178684:

; 950  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 951  : 		return FALSE;

	mov	DWORD PTR $T181162[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181162[ebp]
	jmp	$L178675
$L178686:

; 952  : 	}
; 953  : 
; 954  : 	// This is the certificate that should be used to create XML Licenses for
; 955  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 956  : 	// executable to check against the license used.
; 957  : 
; 958  : 	const string Cert1 = "MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCBvzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWwgU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxIzAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBTaWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlbnNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jACKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdBn2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A";

	push	OFFSET FLAT:$SG178689
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 959  : // Insert some junk data so that search for X509 cert match in the dll fails
; 960  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 961  : 	const string Cert3 = "cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBAKcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/sXMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzrrTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKmbpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=";	

	push	OFFSET FLAT:$SG178692
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 962  : // Insert some junk data so that search for X509 cert match in the dll fails
; 963  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 964  : 	const string Cert2 = "aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTERMA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbWVudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArblPpz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl";

	push	OFFSET FLAT:$SG178695
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 965  : 
; 966  : 	string X509Cert = Cert1 + Cert2 + Cert3;

	lea	edx, DWORD PTR _Cert2$[ebp]
	push	edx
	lea	eax, DWORD PTR _Cert1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T181163[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv214[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR _Cert3$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv214[ebp]
	push	ecx
	lea	edx, DWORD PTR _X509Cert$[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T181163[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 967  : 
; 968  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	eax, DWORD PTR _crcValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 969  : 	if (crcValue != 0xE771) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 59249	; 0000e771H
	je	SHORT $L178701

; 970  : 	{
; 971  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 972  : 		return FALSE;

	mov	DWORD PTR $T181164[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181164[ebp]
	jmp	$L178675
$L178701:

; 973  : 	}
; 974  : 	if (X509Cert != cert_in_lic) {

	lea	edx, DWORD PTR _cert_in_lic$[ebp]
	push	edx
	lea	eax, DWORD PTR _X509Cert$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L178703

; 975  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 976  : 		return FALSE;

	mov	DWORD PTR $T181165[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181165[ebp]
	jmp	SHORT $L178675
$L178703:

; 977  : 	}
; 978  : 	return TRUE;

	mov	DWORD PTR $T181166[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181166[ebp]
$L178675:

; 979  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L181186
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L181186:
	DD	8
	DD	$L181185
$L181185:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L181175
	DD	-76					; ffffffb4H
	DD	28					; 0000001cH
	DD	$L181176
	DD	-112					; ffffff90H
	DD	28					; 0000001cH
	DD	$L181177
	DD	-140					; ffffff74H
	DD	20					; 00000014H
	DD	$L181178
	DD	-176					; ffffff50H
	DD	28					; 0000001cH
	DD	$L181179
	DD	-204					; ffffff34H
	DD	20					; 00000014H
	DD	$L181180
	DD	-240					; ffffff10H
	DD	28					; 0000001cH
	DD	$L181181
	DD	-276					; fffffeecH
	DD	28					; 0000001cH
	DD	$L181182
$L181182:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L181181:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L181180:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L181179:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L181178:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L181177:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L181176:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L181175:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L181167:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181168:
	lea	ecx, DWORD PTR _Cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181169:
	lea	ecx, DWORD PTR _Cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181170:
	lea	ecx, DWORD PTR _Cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181171:
	lea	ecx, DWORD PTR $T181163[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181172:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T181174
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyTemplateSignature
PUBLIC	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
EXTRN	_xmlSchemaNewMemParserCtxt:NEAR
EXTRN	_xmlSchemaFreeParserCtxt:NEAR
EXTRN	_xmlSchemaParse:NEAR
EXTRN	_xmlSchemaFree:NEAR
EXTRN	_xmlSchemaNewValidCtxt:NEAR
EXTRN	_xmlSchemaFreeValidCtxt:NEAR
EXTRN	_xmlSchemaValidateDoc:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_validationResult$ = -20				; size = 4
_schemaValidCtxtPtr$ = -16				; size = 4
_schemaPtr$ = -12					; size = 4
_schemaParserCtxtPtr$ = -8				; size = 4
_this$ = -4						; size = 4
_schemaDataStr$ = 8					; size = 4
_doc$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::validateXmlWithSchema
; _this$ = ecx

; 982  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 983  : 	xmlSchemaParserCtxtPtr schemaParserCtxtPtr = xmlSchemaNewMemParserCtxt((const char *)schemaDataStr, strlen((const char *)schemaDataStr));

	mov	eax, DWORD PTR _schemaDataStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _schemaDataStr$[ebp]
	push	ecx
	call	_xmlSchemaNewMemParserCtxt
	add	esp, 8
	mov	DWORD PTR _schemaParserCtxtPtr$[ebp], eax

; 984  : 	xmlSchemaPtr		   schemaPtr		   = xmlSchemaParse(schemaParserCtxtPtr);

	mov	edx, DWORD PTR _schemaParserCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaParse
	add	esp, 4
	mov	DWORD PTR _schemaPtr$[ebp], eax

; 985  : 	xmlSchemaValidCtxtPtr  schemaValidCtxtPtr = xmlSchemaNewValidCtxt (schemaPtr);

	mov	eax, DWORD PTR _schemaPtr$[ebp]
	push	eax
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _schemaValidCtxtPtr$[ebp], eax

; 986  : 	int validationResult = xmlSchemaValidateDoc(schemaValidCtxtPtr, doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _schemaValidCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaValidateDoc
	add	esp, 8
	mov	DWORD PTR _validationResult$[ebp], eax

; 987  : 	xmlSchemaFreeValidCtxt(schemaValidCtxtPtr);

	mov	eax, DWORD PTR _schemaValidCtxtPtr$[ebp]
	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4

; 988  : 	xmlSchemaFree(schemaPtr);

	mov	ecx, DWORD PTR _schemaPtr$[ebp]
	push	ecx
	call	_xmlSchemaFree
	add	esp, 4

; 989  : 	xmlSchemaFreeParserCtxt(schemaParserCtxtPtr);

	mov	edx, DWORD PTR _schemaParserCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4

; 990  : 
; 991  : //#endif
; 992  : 	// We verified the values in the license file.
; 993  : 	if (validationResult == 0)

	cmp	DWORD PTR _validationResult$[ebp], 0
	jne	SHORT $L178718

; 994  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L178711
$L178718:

; 995  : 	else
; 996  : 		return FALSE;

	xor	eax, eax
$L178711:

; 997  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ENDP ; CLicense::validateXmlWithSchema
_TEXT	ENDS
PUBLIC	?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::verifyFormSchema
EXTRN	_xmlUnlinkNode:NEAR
EXTRN	_xmlFreeNode:NEAR
EXTRN	_xmlNodeGetContent:NEAR
EXTRN	_xmlXPathFreeObject:NEAR
EXTRN	_xmlXPathNewContext:NEAR
EXTRN	_xmlXPathFreeContext:NEAR
EXTRN	_xmlXPathEvalExpression:NEAR
EXTRN	_xmlParseMemory:NEAR
EXTRN	_xmlXPathRegisterNs:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_result$ = -40						; size = 4
_schemaDataNode$ = -36					; size = 4
_schemaData$ = -32					; size = 4
_templateXMLDoc$ = -28					; size = 4
_secureSignNode$178749 = -24				; size = 4
_i$178745 = -20						; size = 4
_ptemp$ = -16						; size = 4
_xpathResultPtr$ = -12					; size = 4
_xpathPtr$ = -8						; size = 4
_this$ = -4						; size = 4
_templateSource$ = 8					; size = 4
_doc$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyFormSchema
; _this$ = ecx

; 1001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1002 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 1003 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 1004 : 
; 1005 : // Now lets verify that the form being signed conforms to the schema in the licensed form template
; 1006 : // In order to do this, we must first remove all SecureSign addded XML elements and signatures
; 1007 : // from the form document.
; 1008 : 	char *ptemp = (char *)zMalloc(4096);

	push	OFFSET FLAT:$SG178730
	push	1008					; 000003f0H
	push	OFFSET FLAT:$SG178731
	push	4096					; 00001000H
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ptemp$[ebp], eax

; 1009 : 
; 1010 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::idsig:Signature | self::SignedObject | self::documentID]");

	push	OFFSET FLAT:$SG178732
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 1011 : 
; 1012 : 	xpathPtr = xmlXPathNewContext(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1013 : 
; 1014 : 	// register additional namespace for the signature
; 1015 : 	if (xmlXPathRegisterNs(xpathPtr,(const unsigned char *)NS_PREFIX,(const unsigned char *)SIGNATURE_URI)!=0)

	push	OFFSET FLAT:$SG178736
	push	OFFSET FLAT:$SG178737
	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L178735

; 1016 : 	{
; 1017 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1018 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178738
	push	1018					; 000003faH
	push	OFFSET FLAT:$SG178739
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1019 : 		return FALSE;

	xor	eax, eax
	jmp	$L178725
$L178735:

; 1020 : 	}
; 1021 : 
; 1022 : 
; 1023 : 	// apply XPath
; 1024 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1025 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L178741

; 1026 : 	{
; 1027 : 		// not found
; 1028 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1029 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178742
	push	1029					; 00000405H
	push	OFFSET FLAT:$SG178743
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1030 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1031 : 		return FALSE;

	xor	eax, eax
	jmp	$L178725
$L178741:

; 1032 : 	}
; 1033 : 
; 1034 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L178744
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L178744

; 1035 : 	{
; 1036 : 		// we found something, try to parse it
; 1037 : 		// start traversing the document, looking for Signature's children elements
; 1038 : 		for (int i = 0; i < xpathResultPtr->nodesetval->nodeNr; i++)

	mov	DWORD PTR _i$178745[ebp], 0
	jmp	SHORT $L178746
$L178747:
	mov	ecx, DWORD PTR _i$178745[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$178745[ebp], ecx
$L178746:
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$178745[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L178744

; 1039 : 		{
; 1040 : 			xmlNodePtr secureSignNode = xpathResultPtr->nodesetval->nodeTab[i];

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$178745[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _secureSignNode$178749[ebp], eax

; 1041 : 			xmlUnlinkNode(secureSignNode);

	mov	ecx, DWORD PTR _secureSignNode$178749[ebp]
	push	ecx
	call	_xmlUnlinkNode
	add	esp, 4

; 1042 : 			xmlFreeNode(secureSignNode);

	mov	edx, DWORD PTR _secureSignNode$178749[ebp]
	push	edx
	call	_xmlFreeNode
	add	esp, 4

; 1043 : 		}

	jmp	SHORT $L178747
$L178744:

; 1044 : 	}
; 1045 :     xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1046 : 	xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1047 : 
; 1048 : 	// Now doc is ready to be processed against the SchemaData present in the licensed form template
; 1049 : //DebugBreak();
; 1050 : 
; 1051 : //#if _DEBUG_
; 1052 : //	xmlChar *mem=NULL;
; 1053 : //	int iSize=0;
; 1054 : //	FILE *hOutFile;
; 1055 : //	xmlDocDumpMemory(doc,&mem,&iSize);
; 1056 : //	// open file in write mode 
; 1057 : //	hOutFile = fopen("C:\\temp\\ObjectsRemoved.xml","wb");
; 1058 : //	fwrite(mem, 1, iSize, hOutFile);
; 1059 : //	fclose(hOutFile);
; 1060 : //	xmlFree(mem);
; 1061 : //#endif
; 1062 : // Now lets verify that the form being signed conforms to the schema in the licensed form template
; 1063 : // In order to do this, we must first remove all SecureSign addded XML elements and signatures
; 1064 : // from the form document.
; 1065 : 
; 1066 : 	xmlDocPtr templateXMLDoc = xmlParseMemory((const char *)templateSource, strlen((const char *)templateSource));

	mov	edx, DWORD PTR _templateSource$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _templateSource$[ebp]
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _templateXMLDoc$[ebp], eax

; 1067 : //#if _DEBUG_
; 1068 : //	// open file in write mode 
; 1069 : //	hOutFile = fopen("C:\\temp\\TemplateSource.xml","wb");
; 1070 : //	fwrite(templateSource, 1, strlen((const char *)templateSource), hOutFile);
; 1071 : //	fclose(hOutFile);
; 1072 : //#endif
; 1073 : 
; 1074 : 	xmlChar *schemaData=NULL;

	mov	DWORD PTR _schemaData$[ebp], 0

; 1075 : 	xmlNodePtr schemaDataNode=NULL;

	mov	DWORD PTR _schemaDataNode$[ebp], 0

; 1076 : 
; 1077 : 	if (!templateXMLDoc) 

	cmp	DWORD PTR _templateXMLDoc$[ebp], 0
	jne	SHORT $L178755

; 1078 : 	{
; 1079 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1080 : 		return FALSE;

	xor	eax, eax
	jmp	$L178725
$L178755:

; 1081 : 	}
; 1082 : 	ptemp = (char *)zMalloc(4096);

	push	OFFSET FLAT:$SG178757
	push	1082					; 0000043aH
	push	OFFSET FLAT:$SG178758
	push	4096					; 00001000H
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ptemp$[ebp], eax

; 1083 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::SchemaData]");

	push	OFFSET FLAT:$SG178759
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 1084 : 	xpathPtr = xmlXPathNewContext(templateXMLDoc);

	mov	eax, DWORD PTR _templateXMLDoc$[ebp]
	push	eax
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1085 : 
; 1086 : 	// apply XPath
; 1087 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1088 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L178761

; 1089 : 	{
; 1090 : 		// not found
; 1091 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1092 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178762
	push	1092					; 00000444H
	push	OFFSET FLAT:$SG178763
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1093 : 		xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1094 : 		xmlFreeDoc(templateXMLDoc);

	mov	eax, DWORD PTR _templateXMLDoc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1095 : 		return FALSE;

	xor	eax, eax
	jmp	$L178725
$L178761:

; 1096 : 	}
; 1097 : 
; 1098 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L178764
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L178764

; 1099 : 	{
; 1100 : 		// we found something, must be the schema data node
; 1101 : 		schemaDataNode = xpathResultPtr->nodesetval->nodeTab[0];

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _schemaDataNode$[ebp], ecx

; 1102 : 		schemaDataNode = schemaDataNode->children;

	mov	edx, DWORD PTR _schemaDataNode$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], eax

; 1103 : 		schemaData = xmlNodeGetContent(schemaDataNode);

	mov	ecx, DWORD PTR _schemaDataNode$[ebp]
	push	ecx
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax

; 1104 : 	}
; 1105 : 	else

	jmp	SHORT $L178765
$L178764:

; 1106 : 	{
; 1107 :         xmlXPathFreeObject(xpathResultPtr);

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1108 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1109 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178766
	push	1109					; 00000455H
	push	OFFSET FLAT:$SG178767
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1110 : 		xmlFreeDoc(templateXMLDoc);

	mov	edx, DWORD PTR _templateXMLDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1111 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L178725
$L178765:

; 1112 : 	}
; 1113 : 
; 1114 :     xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1115 : 	xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1116 : 	zFree(ptemp);

	push	OFFSET FLAT:$SG178768
	push	1116					; 0000045cH
	push	OFFSET FLAT:$SG178769
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1117 : 
; 1118 : 	BOOL result = validateXmlWithSchema(schemaData, doc, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _schemaData$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
	mov	DWORD PTR _result$[ebp], eax

; 1119 : 	xmlFree(schemaData);

	mov	esi, esp
	mov	eax, DWORD PTR _schemaData$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1120 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L178725:

; 1121 : }

	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyFormSchema
_TEXT	ENDS
PUBLIC	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_result$ = -60						; size = 4
_sizeM$ = -56						; size = 4
_base64DecodedTemplateSource$ = -52			; size = 4
_base64EncodedTemplateSource$ = -48			; size = 4
_templateFound$ = -44					; size = 4
_ptemp$ = -40						; size = 4
_xpathResultPtr$ = -36					; size = 4
_xpathPtr$ = -32					; size = 4
_signedInfoNode$ = -28					; size = 4
_sigNode$ = -24						; size = 4
_parent$ = -20						; size = 4
_cur$ = -16						; size = 4
_root$ = -12						; size = 4
_doc$ = -8						; size = 4
_this$ = -4						; size = 4
_inputXML$ = 8						; size = 4
_size$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::getFormSignAllowed
; _this$ = ecx

; 1124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1125 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 1126 : 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 1127 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 1128 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 1129 : 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 1130 : 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 1131 : 	xmlChar *base64EncodedTemplateSource;
; 1132 : 	xmlChar *base64DecodedTemplateSource;
; 1133 : 	unsigned int sizeM;
; 1134 : 	BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 1135 : 
; 1136 : 	// original document
; 1137 : 	doc = xmlParseMemory((const char *)inputXML,size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputXML$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1138 : 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L178792

; 1139 : 	{
; 1140 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1141 : 		return FALSE;

	xor	eax, eax
	jmp	$L178776
$L178792:

; 1142 : 	}
; 1143 : 
; 1144 : 	ptemp = (char *)zMalloc(4096);

	push	OFFSET FLAT:$SG178794
	push	1144					; 00000478H
	push	OFFSET FLAT:$SG178795
	push	4096					; 00001000H
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ptemp$[ebp], eax

; 1145 : 
; 1146 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[ancestor-or-self::ifmc:SignedObject[@Id='%s']]","TemplateSource");

	push	OFFSET FLAT:$SG178796
	push	OFFSET FLAT:$SG178797
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1147 : 
; 1148 : 	xpathPtr = xmlXPathNewContext(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1149 : 
; 1150 : 	if (xpathPtr == NULL)

	cmp	DWORD PTR _xpathPtr$[ebp], 0
	jne	SHORT $L178798

; 1151 : 	{
; 1152 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1153 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178799
	push	1153					; 00000481H
	push	OFFSET FLAT:$SG178800
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1154 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1155 : 		return FALSE;

	xor	eax, eax
	jmp	$L178776
$L178798:

; 1156 : 	}
; 1157 : 
; 1158 : 	// register additional namespace for the signature
; 1159 : 	if (xmlXPathRegisterNs(xpathPtr,(const unsigned char *)"ifmc",(const unsigned char *)"http://www.infomosaic.net")!=0)

	push	OFFSET FLAT:$SG178804
	push	OFFSET FLAT:$SG178805
	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L178803

; 1160 : 	{
; 1161 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1162 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1163 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178806
	push	1163					; 0000048bH
	push	OFFSET FLAT:$SG178807
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1164 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L178776
$L178803:

; 1165 : 	}
; 1166 : 
; 1167 : 	// apply XPath
; 1168 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1169 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L178810

; 1170 : 	{
; 1171 : 		// not found
; 1172 : 		setError(SigHandle, INVALID_XML);

	push	32					; 00000020H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1173 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178811
	push	1173					; 00000495H
	push	OFFSET FLAT:$SG178812
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1174 : 		xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1175 : 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1176 : 		return FALSE;

	xor	eax, eax
	jmp	$L178776
$L178810:

; 1177 : 	}
; 1178 : 
; 1179 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$L178813
	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+8], 0
	je	$L178813

; 1180 : 	{
; 1181 : 		// we found something, try to parse it
; 1182 : 		sigNode = xpathResultPtr->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sigNode$[ebp], eax

; 1183 : 		base64EncodedTemplateSource = xmlNodeGetContent(sigNode);

	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _base64EncodedTemplateSource$[ebp], eax

; 1184 : 
; 1185 : 		if (base64EncodedTemplateSource == NULL)

	cmp	DWORD PTR _base64EncodedTemplateSource$[ebp], 0
	jne	SHORT $L178814

; 1186 : 		{
; 1187 : 			setError(SigHandle, INVALID_XML);

	push	32					; 00000020H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1188 : 			zFree(ptemp);

	push	OFFSET FLAT:$SG178815
	push	1188					; 000004a4H
	push	OFFSET FLAT:$SG178816
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1189 : 			xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1190 : 			xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1191 : 			xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1192 : 			return FALSE;

	xor	eax, eax
	jmp	$L178776
$L178814:

; 1193 : 		}
; 1194 : 
; 1195 : 		sizeM = strlen((const char *)base64EncodedTemplateSource);

	mov	ecx, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 1196 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 1197 : 		base64DecodedTemplateSource = (unsigned char *)zMalloc(sizeM+1);

	push	OFFSET FLAT:$SG178819
	push	1197					; 000004adH
	push	OFFSET FLAT:$SG178820
	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _base64DecodedTemplateSource$[ebp], eax

; 1198 : 		if ((sizeM = base64decode(base64EncodedTemplateSource,base64DecodedTemplateSource,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	edx
	mov	eax, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	$L178821

; 1199 : 		{
; 1200 : 			xmlFree(base64EncodedTemplateSource);

	mov	esi, esp
	mov	ecx, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1201 : 			zFree(base64DecodedTemplateSource);

	push	OFFSET FLAT:$SG178822
	push	1201					; 000004b1H
	push	OFFSET FLAT:$SG178823
	mov	eax, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1202 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1203 : 			zFree(ptemp);

	push	OFFSET FLAT:$SG178824
	push	1203					; 000004b3H
	push	OFFSET FLAT:$SG178825
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1204 : 			xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1205 : 			xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1206 : 			xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1207 : 			return FALSE;

	xor	eax, eax
	jmp	$L178776
$L178821:

; 1208 : 		}
; 1209 : 		xmlFree(base64EncodedTemplateSource);

	mov	esi, esp
	mov	eax, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1210 : 		result = verifyTemplateSignature(base64DecodedTemplateSource, sizeM, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSignature
	mov	DWORD PTR _result$[ebp], eax

; 1211 : 		//if (result != 0)
; 1212 : 		//{
; 1213 : 		//	result = verifyFormSchema(base64DecodedTemplateSource, doc, SigHandle);
; 1214 : 		//}
; 1215 : 		zFree(base64DecodedTemplateSource);

	push	OFFSET FLAT:$SG178826
	push	1215					; 000004bfH
	push	OFFSET FLAT:$SG178827
	mov	edx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H
$L178813:

; 1216 : 	}
; 1217 : 
; 1218 : 	zFree(ptemp);

	push	OFFSET FLAT:$SG178828
	push	1218					; 000004c2H
	push	OFFSET FLAT:$SG178829
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1219 : 	xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1220 : 	xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1221 : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1222 : 
; 1223 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L178776:

; 1224 : }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::getFormSignAllowed
_TEXT	ENDS
PUBLIC	?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSchema
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_instanceXmlStrSize$ = -48				; size = 4
_doc$ = -44						; size = 4
_result$ = -40						; size = 4
_xpathResultPtr$ = -36					; size = 4
_xpathPtr$ = -32					; size = 4
_xmlData$ = -28						; size = 4
_xmlDataNode$ = -24					; size = 4
_schemaDataNode$ = -20					; size = 4
_schemaData$ = -16					; size = 4
_templateXMLDoc$ = -12					; size = 4
_ptemp$ = -8						; size = 4
_this$ = -4						; size = 4
_templateSource$ = 8					; size = 4
_SigHandle$ = 12					; size = 4
?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyTemplateSchema
; _this$ = ecx

; 1226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1227 : 	char *ptemp;
; 1228 : 	xmlDocPtr templateXMLDoc = xmlParseMemory((const char *)templateSource, strlen((const char *)templateSource));

	mov	eax, DWORD PTR _templateSource$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _templateSource$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _templateXMLDoc$[ebp], eax

; 1229 : 	xmlChar *schemaData=NULL;

	mov	DWORD PTR _schemaData$[ebp], 0

; 1230 : 	xmlNodePtr schemaDataNode=NULL;

	mov	DWORD PTR _schemaDataNode$[ebp], 0

; 1231 : 	xmlNodePtr xmlDataNode=NULL;

	mov	DWORD PTR _xmlDataNode$[ebp], 0

; 1232 : 	xmlChar *xmlData;
; 1233 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 1234 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 1235 : 	BOOL result=FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 1236 : 
; 1237 : 	if (!templateXMLDoc) 

	cmp	DWORD PTR _templateXMLDoc$[ebp], 0
	jne	SHORT $L178846

; 1238 : 	{
; 1239 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1240 : 		return FALSE;

	xor	eax, eax
	jmp	$L178834
$L178846:

; 1241 : 	}
; 1242 : 	ptemp = (char *)zMalloc(4096);

	push	OFFSET FLAT:$SG178848
	push	1242					; 000004daH
	push	OFFSET FLAT:$SG178849
	push	4096					; 00001000H
	call	_myMalloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ptemp$[ebp], eax

; 1243 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::SchemaData | self::XmlData]");

	push	OFFSET FLAT:$SG178850
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 1244 : 	xpathPtr = xmlXPathNewContext(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1245 : 
; 1246 : 	// apply XPath
; 1247 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1248 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L178852

; 1249 : 	{
; 1250 : 		// not found
; 1251 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1252 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178853
	push	1252					; 000004e4H
	push	OFFSET FLAT:$SG178854
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_myFree
	add	esp, 16					; 00000010H

; 1253 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1254 : 		xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1255 : 		return FALSE;

	xor	eax, eax
	jmp	$L178834
$L178852:

; 1256 : 	}
; 1257 : 
; 1258 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$L178855
	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+8], 0
	je	$L178855

; 1259 : 	{
; 1260 : 		// we found something, must be schema data  and Xml data nodes
; 1261 : 		if (!strcmp((const char *)xpathResultPtr->nodesetval->nodeTab[0]->name, "XmlData"))

	push	OFFSET FLAT:$SG178858
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L178857

; 1262 : 		{
; 1263 : 			xmlDataNode = xpathResultPtr->nodesetval->nodeTab[0]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _xmlDataNode$[ebp], edx

; 1264 : 			xmlData = xmlNodeGetContent(xmlDataNode);

	mov	eax, DWORD PTR _xmlDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _xmlData$[ebp], eax

; 1265 : 			schemaDataNode = xpathResultPtr->nodesetval->nodeTab[1]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], edx

; 1266 : 			schemaData = xmlNodeGetContent(schemaDataNode);

	mov	eax, DWORD PTR _schemaDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax

; 1267 : 		}
; 1268 : 		else

	jmp	SHORT $L178859
$L178857:

; 1269 : 		{
; 1270 : 			xmlDataNode = xpathResultPtr->nodesetval->nodeTab[1]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _xmlDataNode$[ebp], edx

; 1271 : 			xmlData = xmlNodeGetContent(xmlDataNode);

	mov	eax, DWORD PTR _xmlDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _xmlData$[ebp], eax

; 1272 : 			schemaDataNode = xpathResultPtr->nodesetval->nodeTab[0]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], edx

; 1273 : 			schemaData = xmlNodeGetContent(schemaDataNode);

	mov	eax, DWORD PTR _schemaDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax
$L178859:

; 1274 : 		}
; 1275 : 	}
; 1276 : 	else

	jmp	SHORT $L178860
$L178855:

; 1277 : 	{
; 1278 : 		xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1279 : 		xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1280 : 		zFree(ptemp);

	push	OFFSET FLAT:$SG178861
	push	1280					; 00000500H
	push	OFFSET FLAT:$SG178862
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_myFree
	add	esp, 16					; 00000010H

; 1281 : 		xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1282 : 		return FALSE;

	xor	eax, eax
	jmp	$L178834
$L178860:

; 1283 : 	}
; 1284 : 
; 1285 : 	xmlXPathFreeObject(xpathResultPtr);

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1286 : 	xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1287 : 	zFree(ptemp);

	push	OFFSET FLAT:$SG178863
	push	1287					; 00000507H
	push	OFFSET FLAT:$SG178864
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_myFree
	add	esp, 16					; 00000010H

; 1288 : 
; 1289 : 	xmlDocPtr doc;
; 1290 : 	size_t instanceXmlStrSize = strlen((const char *)xmlData);

	mov	edx, DWORD PTR _xmlData$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _instanceXmlStrSize$[ebp], eax

; 1291 : 	doc = xmlParseMemory((const char *)xmlData, instanceXmlStrSize);

	mov	eax, DWORD PTR _instanceXmlStrSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlData$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1292 : 	xmlFree(xmlData);

	mov	esi, esp
	mov	edx, DWORD PTR _xmlData$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1293 : 
; 1294 : 	result = validateXmlWithSchema(schemaData, doc, SigHandle);

	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _schemaData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
	mov	DWORD PTR _result$[ebp], eax

; 1295 : 	xmlFree(schemaData);

	mov	esi, esp
	mov	ecx, DWORD PTR _schemaData$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1296 : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1297 : 	xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1298 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L178834:

; 1299 : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyTemplateSchema
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 311  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 312  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 313  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 471  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 		return (assign(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 473  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1103 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1105 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z	; ATL::CW2AEX<128>::Init

; 421  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L179211

; 430  : 		{
; 431  : 			free( m_psz );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4
$L179211:

; 432  : 		}
; 433  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 438  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$179431 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L179428

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L179429
$L179428:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L179429

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$179431[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L179432

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$179431[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L179432:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$179431[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L179429:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L181221
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L181222
$L181221:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L181222:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
EXTRN	_malloc:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT
_nLengthA$ = -12					; size = 4
_nLengthW$ = -8						; size = 4
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L179659

; 444  : 		{
; 445  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 446  : 			return;

	jmp	$L181230
$L179659:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

	mov	edx, DWORD PTR _nLengthW$[ebp]
	shl	edx, 1
	mov	DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

	cmp	DWORD PTR _nLengthA$[ebp], 128		; 00000080H
	jle	SHORT $L179662

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L179662

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L179662:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L181230

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$L181230:

; 463  : 		}
; 464  : 	}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 81   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	cmp	DWORD PTR _dwError$[ebp], 0
	jg	SHORT $L181233
	mov	eax, DWORD PTR _dwError$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L181234
$L181233:
	mov	ecx, DWORD PTR _dwError$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv69[ebp], ecx
$L181234:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L181232:

; 83   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L179728

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L179727
$L179728:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L179729

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L179729:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L179727:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L179301

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L179301:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L179303

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L179303:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L179304

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L179422
$L179304:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L179422

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L179422:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$179735 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L179732

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L179732:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L179733

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L179733:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L179734

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$179735[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$179735[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L179734:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T181247 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T181247[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T181247[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L179741

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L179741:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L179742

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L179743
$L179742:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L179744
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L179744

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L181252
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L181253
$L181252:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L181253:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L179743
$L179744:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L179743

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L179743:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L181256
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L181257
$L181256:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L181257:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L181262
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L181263
$L181262:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L181263:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T181273 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T181275 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L181269
$T181276 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L181267
$T181274 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T181275
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T181276
$T181271 DD	019930520H
	DD	04H
	DD	FLAT:$T181273
	DD	02H
	DD	FLAT:$T181274
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L179812

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L179813
$L179812:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L179813
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L179813

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L179813:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L181266
$L181267:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L181268
$L181269:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L181268:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L181266
	ret	0
$L181266:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L179818

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L179818:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L181265:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T181271
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L179822
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L179821
$L179822:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L179820
$L179821:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L179820:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L181285
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L181286
$L181285:
	mov	DWORD PTR tv65[ebp], 1
$L181286:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T181297 DD	0ffffffffH
	DD	FLAT:$L181291
	DD	00H
	DD	FLAT:$L181290
$T181295 DD	019930520H
	DD	02H
	DD	FLAT:$T181297
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T181292 = -44						; size = 4
$T181289 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T181292[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T181289[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv77[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T181292[ebp]
	or	eax, 1
	mov	DWORD PTR $T181292[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T181289[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L181290:
	lea	ecx, DWORD PTR $T181289[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181291:
	mov	eax, DWORD PTR $T181292[ebp]
	and	eax, 1
	je	$L181293
	and	DWORD PTR $T181292[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L181293:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
	mov	eax, OFFSET FLAT:$T181295
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 101  : 	{	// test for string inequality

	push	ebp
	mov	ebp, esp

; 102  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	inc	eax

; 103  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 481  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 483  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 496  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 498  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 502  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L180007

; 504  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L180007:

; 505  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 506  : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L180009

; 507  : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$L180009:

; 508  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $L180010

; 509  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L180010:

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L180011
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L180011

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 515  : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L180011:

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 518  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 71   : 	{	// test for string equality

	push	ebp
	mov	ebp, esp

; 72   : 	return (_Left.compare(_Right) == 0);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
	neg	eax
	sbb	eax, eax
	inc	eax

; 73   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1379 : 		{	// compare [0, _Mysize) with _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
tv87 = -24						; size = 4
tv88 = -20						; size = 4
tv75 = -16						; size = 4
tv82 = -12						; size = 4
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1412 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1413 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L180019

; 1414 : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L180019:

; 1415 : 		if (_Mysize - _Off < _N0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __N0$[ebp]
	jae	SHORT $L180020

; 1416 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __N0$[ebp], edx
$L180020:

; 1417 : 
; 1418 : 		size_type _Ans = _N0 == 0 ? 0
; 1419 : 			: _Traits::compare(_Myptr() + _Off, _Ptr,
; 1420 : 				_N0 < _Count ? _N0 : _Count);

	cmp	DWORD PTR __N0$[ebp], 0
	jne	SHORT $L181321
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $L181322
$L181321:
	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L181319
	mov	ecx, DWORD PTR __N0$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $L181320
$L181319:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv75[ebp], edx
$L181320:
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv82[ebp], eax
$L181322:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR __Ans$[ebp], edx

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

	cmp	DWORD PTR __Ans$[ebp], 0
	je	SHORT $L181325
	mov	eax, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $L181326
$L181325:
	mov	ecx, DWORD PTR __N0$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $L181323
	mov	DWORD PTR tv87[ebp], -1
	jmp	SHORT $L181324
$L181323:
	mov	edx, DWORD PTR __N0$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	setne	al
	mov	DWORD PTR tv87[ebp], eax
$L181324:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$L181326:
	mov	eax, DWORD PTR tv88[ebp]

; 1423 : 		}

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC NEAR	; std::char_traits<char>::compare, COMDAT

; 346  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	push	ebp
	mov	ebp, esp

; 347  : 		return (::memcmp(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH

; 348  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

	mov	eax, DWORD PTR _nRequestedSize$[ebp]
	add	eax, 8
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L159703

; 378  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L159690
$L159703:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L159690:

; 385  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 32   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_p$159709 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L159707:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L159705

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$159709[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

	mov	ecx, DWORD PTR _p$159709[ebp]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 394  : 		}

	jmp	SHORT $L159707
$L159705:

; 395  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp

; 36   : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 37   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L159763

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L159763:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@ DB 'm_p == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lalloc.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L181349
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L181349
	int	3
$L181349:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 128		; 00000080H
	jbe	SHORT $L160415

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L160416
$L160415:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L160416:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 367  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L160603

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L160603:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L181355:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	__imp__AtlWinModuleInit@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR __imp__AtlWinModuleInit@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88081

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88081:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T181376 DD	0ffffffffH
	DD	FLAT:$L181372
$T181374 DD	019930520H
	DD	01H
	DD	FLAT:$T181376
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L181372:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T181374
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	__imp__AtlWinModuleTerm@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	esi, esp
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__AtlWinModuleTerm@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2589 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$160433 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L160432

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$160433[ebp], 0
	jmp	SHORT $L160434
$L160435:
	mov	ecx, DWORD PTR _i$160433[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$160433[ebp], ecx
$L160434:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$160433[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L160436

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L160435
$L160436:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L160432:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
