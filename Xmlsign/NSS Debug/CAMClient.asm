; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\CAMClient.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterWndClassInfoA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PAU_ATL_BASE_MODULE70@1@PAU_ATL_WNDCLASSINFOA@1@PAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamA@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOA@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamA@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DN@BIGELNIF@ERROR?5?3?5Invalid?5Arguments?5to?5Atl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EL@KHCGDDHE@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DK@EAELIHNL@ERROR?5?3?5Could?5not?5obtain?5Window?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadCursorA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAPAUHICON__@@PAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatWindowClassName@AtlModuleRegisterWndClassInfoParamA@ATL@@SAXPADPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09OOFFBKGI@ATL?3?$CF8?48X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetClassInfoExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAHPAUHINSTANCE__@@PBDPAUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterClassExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAGPAU_ATL_WIN_MODULE70@2@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterClassExA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAPAXIPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAXPAXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@ABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOGEFONP@bRet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KAMJMGHJ@pProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIGOECOI@p?9?$DOpWndProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?g_log_name@@3PADA				; g_log_name
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
_BSS	SEGMENT
?g_log_name@@3PADA DD 01H DUP (?)			; g_log_name
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
CONST	SEGMENT
$SG181767 DB	'serialize flat allocation', 00H
	ORG $+2
$SG181807 DB	'%d.%d.%d.%d', 00H
$SG181862 DB	'read bfr', 00H
	ORG $+3
$SG181880 DB	'rb', 00H
	ORG $+1
$SG181927 DB	'pp != 0', 00H
$SG181928 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG164311 DB	'pThis != 0', 00H
	ORG $+5
$SG164312 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164319 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164320 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG164336 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG164337 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164360 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG164361 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164372 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG164373 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164583 DB	'm_begin == 0', 00H
	ORG $+3
$SG164584 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	??0CCAMClient@@QAE@XZ				; CCAMClient::CCAMClient
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
;	COMDAT rtc$IMZ
; File c:\activex\xmlsign\camclient.cpp
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CCAMClient@@QAE@XZ PROC NEAR				; CCAMClient::CCAMClient
; _this$ = ecx

; 25   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 	// init internal state
; 27   : 	ca_ptr_count=0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+2052], 0

; 28   : 	tmpfile_count= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4104], 0

; 29   : 	camServerPortNumber = 7777;

	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx], 7777			; 00001e61H

; 30   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CCAMClient@@QAE@XZ ENDP				; CCAMClient::CCAMClient
_TEXT	ENDS
PUBLIC	??1CCAMClient@@QAE@XZ				; CCAMClient::~CCAMClient
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CCAMClient@@QAE@XZ PROC NEAR				; CCAMClient::~CCAMClient
; _this$ = ecx

; 33   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 34   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CCAMClient@@QAE@XZ ENDP				; CCAMClient::~CCAMClient
_TEXT	ENDS
PUBLIC	?validate@CCAMClient@@QAEJPAE0H0PAHPAPAE121@Z	; CCAMClient::validate
PUBLIC	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z	; CCAMClient::delBinString
PUBLIC	?serialize@CCAMClient@@AAEPAUBinString@@PAXHH@Z	; CCAMClient::serialize
PUBLIC	?deserialize@CCAMClient@@AAEPADPAUBinString@@HH@Z ; CCAMClient::deserialize
PUBLIC	?my_connect@CCAMClient@@AAEIPAD@Z		; CCAMClient::my_connect
PUBLIC	?send_header@CCAMClient@@AAEHIH@Z		; CCAMClient::send_header
PUBLIC	?read_msg@CCAMClient@@AAEPAUBinString@@I@Z	; CCAMClient::read_msg
PUBLIC	?send_bs@CCAMClient@@AAEHIPAUBinString@@@Z	; CCAMClient::send_bs
PUBLIC	?copy_mem_out@CCAMClient@@AAEXPAUBinString@@PAE@Z ; CCAMClient::copy_mem_out
EXTRN	_malloc:NEAR
EXTRN	_base64encodeSize:NEAR
EXTRN	_base64encode:NEAR
EXTRN	_rFree:NEAR
EXTRN	_strlen:NEAR
EXTRN	__imp__closesocket@4:NEAR
EXTRN	__imp__shutdown@8:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	@_RTC_CheckStackVars@8:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_length$ = -68						; size = 4
_respPtr$ = -64						; size = 4
_ptr$ = -60						; size = 4
_resp_wrap$ = -56					; size = 4
_sock$ = -52						; size = 4
_send_wrap$ = -48					; size = 4
_val$ = -40						; size = 20
_encodedDataPtr$ = -16					; size = 4
_encodedDataSize$ = -12					; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_cam_hostname$ = 8					; size = 4
_cert_buffer$ = 12					; size = 4
_cert_buffer_size$ = 16					; size = 4
_aa_id$ = 20						; size = 4
_dest_status$ = 24					; size = 4
_dest_cert_ascii_bfr$ = 28				; size = 4
_destCertAsciiBufSize$ = 32				; size = 4
_dest_ca_msg_bfr$ = 36					; size = 4
_destCaMsgBufSize$ = 40					; size = 4
?validate@CCAMClient@@QAEJPAE0H0PAHPAPAE121@Z PROC NEAR	; CCAMClient::validate
; _this$ = ecx

; 45   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 46   : 	int i;
; 47   : 	DWORD encodedDataSize;
; 48   : 	BYTE *encodedDataPtr;
; 49   : 	// ----------
; 50   : 	// construct the outgoing CAM request
; 51   : //DebugBreak();
; 52   : 	AaCamValidate val;
; 53   : 
; 54   : 	val.msg_type= AA_VALIDATE;

	mov	DWORD PTR _val$[ebp], 512		; 00000200H

; 55   : 	val.aa_id.data= aa_id;

	mov	eax, DWORD PTR _aa_id$[ebp]
	mov	DWORD PTR _val$[ebp+8], eax

; 56   : 	val.aa_id.size= strlen((char*)aa_id);

	mov	ecx, DWORD PTR _aa_id$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _val$[ebp+4], eax

; 57   : 	val.cert.data= (unsigned char*) cert_buffer;

	mov	edx, DWORD PTR _cert_buffer$[ebp]
	mov	DWORD PTR _val$[ebp+16], edx

; 58   : 	val.cert.size= cert_buffer_size;

	mov	eax, DWORD PTR _cert_buffer_size$[ebp]
	mov	DWORD PTR _val$[ebp+12], eax

; 59   : 
; 60   : 	BinString *send_wrap= serialize(&val, sizeof(AaCamValidate), AaCamValidateBSC);

	push	2
	push	20					; 00000014H
	lea	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@CCAMClient@@AAEPAUBinString@@PAXHH@Z ; CCAMClient::serialize
	mov	DWORD PTR _send_wrap$[ebp], eax

; 61   : 
; 62   : 
; 63   : 	// ----------
; 64   : 	// connect to CAM, send request
; 65   : 
; 66   : 	SOCKET sock= my_connect((char*)cam_hostname);

	mov	edx, DWORD PTR _cam_hostname$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?my_connect@CCAMClient@@AAEIPAD@Z	; CCAMClient::my_connect
	mov	DWORD PTR _sock$[ebp], eax

; 67   : 	if (sock==INVALID_SOCKET)

	cmp	DWORD PTR _sock$[ebp], -1
	jne	SHORT $L181698

; 68   : 	{
; 69   : 		*dest_status= CA_REQ_BAD; 

	mov	eax, DWORD PTR _dest_status$[ebp]
	mov	DWORD PTR [eax], 10			; 0000000aH

; 70   : 		delBinString (send_wrap);

	mov	ecx, DWORD PTR _send_wrap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 71   : 		return S_OK;

	xor	eax, eax
	jmp	$L181686
$L181698:

; 72   : 	}
; 73   : 
; 74   : 	i= send_header(sock, send_wrap->size);

	mov	edx, DWORD PTR _send_wrap$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?send_header@CCAMClient@@AAEHIH@Z	; CCAMClient::send_header
	mov	DWORD PTR _i$[ebp], eax

; 75   : 	if (i<0) 

	cmp	DWORD PTR _i$[ebp], 0
	jge	SHORT $L181700

; 76   : 	if (sock==INVALID_SOCKET)

	cmp	DWORD PTR _sock$[ebp], -1
	jne	SHORT $L181700

; 77   : 	{
; 78   : 		*dest_status= CA_REQ_BAD; 

	mov	edx, DWORD PTR _dest_status$[ebp]
	mov	DWORD PTR [edx], 10			; 0000000aH

; 79   : 		delBinString (send_wrap);

	mov	eax, DWORD PTR _send_wrap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 80   : 		return S_OK;

	xor	eax, eax
	jmp	$L181686
$L181700:

; 81   : 		//SEND_ERROR(10, "<> unable to send to specified CAM ", cam_hostname);
; 82   : 	}
; 83   : 
; 84   : 	i= send_bs(sock, send_wrap);

	mov	ecx, DWORD PTR _send_wrap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?send_bs@CCAMClient@@AAEHIPAUBinString@@@Z ; CCAMClient::send_bs
	mov	DWORD PTR _i$[ebp], eax

; 85   : 	if (i<=0) 

	cmp	DWORD PTR _i$[ebp], 0
	jg	SHORT $L181704

; 86   : 	if (sock==INVALID_SOCKET)

	cmp	DWORD PTR _sock$[ebp], -1
	jne	SHORT $L181704

; 87   : 	{
; 88   : 		*dest_status= CA_REQ_BAD; 

	mov	eax, DWORD PTR _dest_status$[ebp]
	mov	DWORD PTR [eax], 10			; 0000000aH

; 89   : 		delBinString (send_wrap);

	mov	ecx, DWORD PTR _send_wrap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 90   : 		return S_OK;

	xor	eax, eax
	jmp	$L181686
$L181704:

; 91   : 		//SEND_ERROR(10, "<> unable to send request to specified CAM: ", cam_hostname);
; 92   : 	}
; 93   : 
; 94   : 	// ----------
; 95   : 	// receive response and close socket
; 96   : 
; 97   : 	BinString *resp_wrap= read_msg(sock);

	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read_msg@CCAMClient@@AAEPAUBinString@@I@Z ; CCAMClient::read_msg
	mov	DWORD PTR _resp_wrap$[ebp], eax

; 98   : 	if (!resp_wrap) 

	cmp	DWORD PTR _resp_wrap$[ebp], 0
	jne	SHORT $L181709

; 99   : 	{
; 100  : 		*dest_status= CA_REQ_BAD; 

	mov	eax, DWORD PTR _dest_status$[ebp]
	mov	DWORD PTR [eax], 10			; 0000000aH

; 101  : 		delBinString (send_wrap);

	mov	ecx, DWORD PTR _send_wrap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 102  : 		return S_OK;

	xor	eax, eax
	jmp	$L181686
$L181709:

; 103  : 		//SEND_ERROR(10, "<> unable to read response from specified CAM: ", cam_hostname);
; 104  : 	}
; 105  : //DebugBreak();
; 106  : 	CamAaValidate *ptr= (CamAaValidate*) deserialize(resp_wrap, sizeof(CamAaValidate), CamAaValidateBSC);

	push	2
	push	28					; 0000001cH
	mov	edx, DWORD PTR _resp_wrap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deserialize@CCAMClient@@AAEPADPAUBinString@@HH@Z ; CCAMClient::deserialize
	mov	DWORD PTR _ptr$[ebp], eax

; 107  : 
; 108  : //	shutdown (sock, SD_BOTH);
; 109  : 	shutdown (sock, 0x02);

	mov	esi, esp
	push	2
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	DWORD PTR __imp__shutdown@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 110  : #ifdef WIN32
; 111  : 	closesocket (sock);

	mov	esi, esp
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	DWORD PTR __imp__closesocket@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 112  : #else
; 113  : 	close(sock);
; 114  : #endif
; 115  : 
; 116  : 	// ----------
; 117  : 	// copy result to dest
; 118  : 
; 119  : 	*dest_status= ptr->status;

	mov	edx, DWORD PTR _dest_status$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx], ecx

; 120  : 
; 121  : 	if (*dest_cert_ascii_bfr != NULL)

	mov	edx, DWORD PTR _dest_cert_ascii_bfr$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L181714

; 122  : 		zFree(*dest_cert_ascii_bfr);

	mov	eax, DWORD PTR _dest_cert_ascii_bfr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4
$L181714:

; 123  : 	*destCertAsciiBufSize = ptr->cert_ascii.size;

	mov	edx, DWORD PTR _destCertAsciiBufSize$[ebp]
	mov	eax, DWORD PTR _ptr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ecx

; 124  : 	*dest_cert_ascii_bfr = (unsigned char *)zMalloc(ptr->cert_ascii.size);

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _dest_cert_ascii_bfr$[ebp]
	mov	DWORD PTR [ecx], eax

; 125  : 	copy_mem_out(&ptr->cert_ascii, *dest_cert_ascii_bfr);

	mov	edx, DWORD PTR _dest_cert_ascii_bfr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _ptr$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy_mem_out@CCAMClient@@AAEXPAUBinString@@PAE@Z ; CCAMClient::copy_mem_out

; 126  : 
; 127  : 	if (*dest_ca_msg_bfr != NULL)

	mov	edx, DWORD PTR _dest_ca_msg_bfr$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L181716

; 128  : 		zFree(*dest_ca_msg_bfr);

	mov	eax, DWORD PTR _dest_ca_msg_bfr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_rFree
	add	esp, 4
$L181716:

; 129  : 
; 130  : 	// The data is binary, so lets base64 encode it
; 131  : //#ifdef _DEBUG_
; 132  : //	FILE *hFile;
; 133  : //	char *szTempName = "C:\\temp\\CamRespBeforeEncode.bin";
; 134  : //	hFile = fopen((const char*)szTempName,"wb");
; 135  : //	fwrite(ptr->ca_signed_msg.data, 1, ptr->ca_signed_msg.size, hFile);
; 136  : //	fclose(hFile);
; 137  : //#endif
; 138  : 	//Lets find out the true size of the response data
; 139  : 
; 140  : 	//char * contentLengthPtr = strstr((const char *)ptr->ca_signed_msg.data, "Content-length: ");
; 141  : 	//char * lengthPtr = NULL;
; 142  : 	char *respPtr= (char *)ptr->ca_signed_msg.data;

	mov	edx, DWORD PTR _ptr$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _respPtr$[ebp], eax

; 143  : 	int length= ptr->ca_signed_msg.size;

	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _length$[ebp], edx

; 144  : 	//if (contentLengthPtr != NULL)
; 145  : 	//{
; 146  : 	//	lengthPtr = contentLengthPtr + strlen((const char *)"Content-length: ");
; 147  : 	//	sscanf((const char *)lengthPtr, "%d\r\n", &length);
; 148  : 	//	respPtr = strstr(lengthPtr, "\r\n\r\n");
; 149  : 	//	respPtr += 4;
; 150  : 	//}
; 151  : 
; 152  : 	encodedDataSize = base64encodeSize(length);

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	call	_base64encodeSize
	add	esp, 4
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 153  : 	encodedDataPtr = (BYTE *)zMalloc(encodedDataSize + 1);

	mov	ecx, DWORD PTR _encodedDataSize$[ebp]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _encodedDataPtr$[ebp], eax

; 154  : 	encodedDataSize = base64encode((unsigned char *)respPtr, length, encodedDataPtr, encodedDataSize + 1);

	mov	edx, DWORD PTR _encodedDataSize$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _encodedDataPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _respPtr$[ebp]
	push	edx
	call	_base64encode
	add	esp, 16					; 00000010H
	mov	DWORD PTR _encodedDataSize$[ebp], eax

; 155  : 	*dest_ca_msg_bfr = (unsigned char *)encodedDataPtr;

	mov	eax, DWORD PTR _dest_ca_msg_bfr$[ebp]
	mov	ecx, DWORD PTR _encodedDataPtr$[ebp]
	mov	DWORD PTR [eax], ecx

; 156  : 	*destCaMsgBufSize = encodedDataSize;

	mov	edx, DWORD PTR _destCaMsgBufSize$[ebp]
	mov	eax, DWORD PTR _encodedDataSize$[ebp]
	mov	DWORD PTR [edx], eax

; 157  : 
; 158  : 	//*destCaMsgBufSize = ptr->ca_signed_msg.size;
; 159  : 	//*dest_ca_msg_bfr = (unsigned char *)zMalloc(ptr->ca_signed_msg.size);
; 160  : 	//copy_mem_out(&ptr->ca_signed_msg, *dest_ca_msg_bfr);
; 161  : 
; 162  : 	delBinString (send_wrap);

	mov	ecx, DWORD PTR _send_wrap$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 163  : 	delBinString (resp_wrap);

	mov	edx, DWORD PTR _resp_wrap$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString

; 164  : 
; 165  : 	return S_OK;

	xor	eax, eax
$L181686:

; 166  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L182235
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 68					; 00000044H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$L182235:
	DD	1
	DD	$L182234
$L182234:
	DD	-40					; ffffffd8H
	DD	20					; 00000014H
	DD	$L182233
$L182233:
	DB	118					; 00000076H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
?validate@CCAMClient@@QAEJPAE0H0PAHPAPAE121@Z ENDP	; CCAMClient::validate
_TEXT	ENDS
PUBLIC	?full_recv@CCAMClient@@AAEHIPADH@Z		; CCAMClient::full_recv
EXTRN	__imp__recv@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_got$ = -12						; size = 4
_have$ = -8						; size = 4
_this$ = -4						; size = 4
_sock$ = 8						; size = 4
_dest$ = 12						; size = 4
_size$ = 16						; size = 4
?full_recv@CCAMClient@@AAEHIPADH@Z PROC NEAR		; CCAMClient::full_recv
; _this$ = ecx

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 	int have=0, got=1;

	mov	DWORD PTR _have$[ebp], 0
	mov	DWORD PTR _got$[ebp], 1
$L181733:

; 176  : 
; 177  : 	while ( (have<size) && (got>0) ) {

	mov	eax, DWORD PTR _have$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jge	SHORT $L181734
	cmp	DWORD PTR _got$[ebp], 0
	jle	SHORT $L181734

; 178  : 		got= recv(sock, dest+have, (size-have), 0);

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, DWORD PTR _have$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	add	edx, DWORD PTR _have$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	DWORD PTR __imp__recv@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _got$[ebp], eax

; 179  : 		have+= got;

	mov	ecx, DWORD PTR _have$[ebp]
	add	ecx, DWORD PTR _got$[ebp]
	mov	DWORD PTR _have$[ebp], ecx

; 180  : 	}

	jmp	SHORT $L181733
$L181734:

; 181  : 
; 182  : 	return have;

	mov	eax, DWORD PTR _have$[ebp]

; 183  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?full_recv@CCAMClient@@AAEHIPADH@Z ENDP			; CCAMClient::full_recv
_TEXT	ENDS
PUBLIC	?newBinString@CCAMClient@@AAEPAUBinString@@HPAD@Z ; CCAMClient::newBinString
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_me$ = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
_name$ = 12						; size = 4
?newBinString@CCAMClient@@AAEPAUBinString@@HPAD@Z PROC NEAR ; CCAMClient::newBinString
; _this$ = ecx

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 189  :   if (size==0) return NULL;

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $L181740
	xor	eax, eax
	jmp	SHORT $L181739
$L181740:

; 190  : 
; 191  :   // given the size of the data string, return a BinString structure with sufficient memory allocated
; 192  :   BinString *me = (BinString*)zMalloc(sizeof(BinString));

	push	8
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _me$[ebp], eax

; 193  : 
; 194  :   // extern memory_object g_mem; is included at bottom of memory.hpp
; 195  :   me->size = size;

	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR _size$[ebp]
	mov	DWORD PTR [eax], ecx

; 196  :   me->data = (unsigned char*)zMalloc(size);

	mov	edx, DWORD PTR _size$[ebp]
	push	edx
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _me$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 197  :   return(me);

	mov	eax, DWORD PTR _me$[ebp]
$L181739:

; 198  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?newBinString@CCAMClient@@AAEPAUBinString@@HPAD@Z ENDP	; CCAMClient::newBinString
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
_me$ = 8						; size = 4
?delBinString@CCAMClient@@AAEXPAUBinString@@@Z PROC NEAR ; CCAMClient::delBinString
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 202  :   if (me == NULL) return;

	cmp	DWORD PTR _me$[ebp], 0
	jne	SHORT $L181749
	jmp	SHORT $L181748
$L181749:

; 203  :   zFree(me->data);

	mov	eax, DWORD PTR _me$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_rFree
	add	esp, 4

; 204  :   zFree(me);

	mov	edx, DWORD PTR _me$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L181748:

; 205  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ENDP	; CCAMClient::delBinString
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_output_ptr$ = -24					; size = 4
_answer$ = -20						; size = 4
_base$ = -16						; size = 4
_ttl_size$ = -12					; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_source$ = 8						; size = 4
_size_struct$ = 12					; size = 4
_num_binstrings$ = 16					; size = 4
?serialize@CCAMClient@@AAEPAUBinString@@PAXHH@Z PROC NEAR ; CCAMClient::serialize
; _this$ = ecx

; 210  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 	int i, ttl_size;
; 212  : 	BinString *base, *answer;
; 213  : 	unsigned char *output_ptr;
; 214  : 
; 215  : 	// set pointer to base of array of BinStrings within the user struct
; 216  : 	base= (BinString*) ((char*)source + size_struct - num_binstrings*sizeof(BinString));

	mov	eax, DWORD PTR _source$[ebp]
	add	eax, DWORD PTR _size_struct$[ebp]
	mov	ecx, DWORD PTR _num_binstrings$[ebp]
	shl	ecx, 3
	sub	eax, ecx
	mov	DWORD PTR _base$[ebp], eax

; 217  : 
; 218  : 	// calculate the total size needed in output structure
; 219  : 	ttl_size= size_struct;

	mov	edx, DWORD PTR _size_struct$[ebp]
	mov	DWORD PTR _ttl_size$[ebp], edx

; 220  : 	for (i=0; i<num_binstrings; i++) ttl_size+= base[i].size;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181764
$L181765:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L181764:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _num_binstrings$[ebp]
	jge	SHORT $L181766
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _base$[ebp]
	mov	ecx, DWORD PTR _ttl_size$[ebp]
	add	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _ttl_size$[ebp], ecx
	jmp	SHORT $L181765
$L181766:

; 221  : 
; 222  : 	// allocate output and copy over existing flat structure
; 223  : 	answer= newBinString(ttl_size, "serialize flat allocation");

	push	OFFSET FLAT:$SG181767
	mov	edx, DWORD PTR _ttl_size$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?newBinString@CCAMClient@@AAEPAUBinString@@HPAD@Z ; CCAMClient::newBinString
	mov	DWORD PTR _answer$[ebp], eax

; 224  : 	memcpy (answer->data, source, size_struct);

	mov	eax, DWORD PTR _size_struct$[ebp]
	push	eax
	mov	ecx, DWORD PTR _source$[ebp]
	push	ecx
	mov	edx, DWORD PTR _answer$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 225  : 
; 226  : 	// now append the attached BinString data
; 227  : 	output_ptr= answer->data + size_struct;

	mov	ecx, DWORD PTR _answer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _size_struct$[ebp]
	mov	DWORD PTR _output_ptr$[ebp], edx

; 228  : 	for (i=0; i<num_binstrings; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181768
$L181769:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L181768:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _num_binstrings$[ebp]
	jge	SHORT $L181770

; 229  : 		if ((base[i].size==0)||(!base[i].data)) continue;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _base$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	je	SHORT $L181772
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _base$[ebp]
	cmp	DWORD PTR [edx+ecx*8+4], 0
	jne	SHORT $L181771
$L181772:
	jmp	SHORT $L181769
$L181771:

; 230  : 
; 231  : 		memcpy (output_ptr, base[i].data, base[i].size);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _base$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	push	edx
	mov	eax, DWORD PTR _output_ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 232  : 		output_ptr+= base[i].size;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _output_ptr$[ebp]
	add	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _output_ptr$[ebp], eax

; 233  : 	}

	jmp	SHORT $L181769
$L181770:

; 234  : 
; 235  : 	// finally, "null-out" the useless data pointers in the serialized struct
; 236  : 	// (make sure local memory pointers do not make it into the serialized data)
; 237  : 	base= (BinString*) ((char*)answer->data + size_struct - num_binstrings*sizeof(BinString));

	mov	ecx, DWORD PTR _answer$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _size_struct$[ebp]
	mov	eax, DWORD PTR _num_binstrings$[ebp]
	shl	eax, 3
	sub	edx, eax
	mov	DWORD PTR _base$[ebp], edx

; 238  : 	for (i=0; i<num_binstrings; i++) base[i].data= NULL;

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181776
$L181777:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L181776:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _num_binstrings$[ebp]
	jge	SHORT $L181778
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _base$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], 0
	jmp	SHORT $L181777
$L181778:

; 239  : 
; 240  : 	return answer;

	mov	eax, DWORD PTR _answer$[ebp]

; 241  : }

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?serialize@CCAMClient@@AAEPAUBinString@@PAXHH@Z ENDP	; CCAMClient::serialize
; Function compile flags: /Odt /RTCsu
_data_ptr$ = -16					; size = 4
_base$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_source$ = 8						; size = 4
_size_struct$ = 12					; size = 4
_num_binstrings$ = 16					; size = 4
?deserialize@CCAMClient@@AAEPADPAUBinString@@HH@Z PROC NEAR ; CCAMClient::deserialize
; _this$ = ecx

; 245  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 	int i;
; 247  : 	BinString *base;
; 248  : 	unsigned char *data_ptr;
; 249  : 
; 250  : 	// set pointer to base of array of BinStrings within the user struct
; 251  : 	base= (BinString*) ((char*)source->data + size_struct - num_binstrings*sizeof(BinString));

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _size_struct$[ebp]
	mov	edx, DWORD PTR _num_binstrings$[ebp]
	shl	edx, 3
	sub	ecx, edx
	mov	DWORD PTR _base$[ebp], ecx

; 252  : 
; 253  : 	// walk through the BinStrings, updating their data pointers
; 254  : 	data_ptr= source->data + size_struct;

	mov	eax, DWORD PTR _source$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _size_struct$[ebp]
	mov	DWORD PTR _data_ptr$[ebp], ecx

; 255  : 	for (i=0; i<num_binstrings; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181791
$L181792:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L181791:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _num_binstrings$[ebp]
	jge	SHORT $L181793

; 256  : 		base[i].data= data_ptr;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _data_ptr$[ebp]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 257  : 		data_ptr+= base[i].size;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _base$[ebp]
	mov	eax, DWORD PTR _data_ptr$[ebp]
	add	eax, DWORD PTR [edx+ecx*8]
	mov	DWORD PTR _data_ptr$[ebp], eax

; 258  : 	}

	jmp	SHORT $L181792
$L181793:

; 259  : 
; 260  : 	return (char*) source->data;

	mov	ecx, DWORD PTR _source$[ebp]
	mov	eax, DWORD PTR [ecx+4]

; 261  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?deserialize@CCAMClient@@AAEPADPAUBinString@@HH@Z ENDP	; CCAMClient::deserialize
_TEXT	ENDS
PUBLIC	?get_ip_from_hostname@@YAKPAD@Z			; get_ip_from_hostname
EXTRN	_sscanf:NEAR
EXTRN	__imp__gethostbyname@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_temp$181806 = -44					; size = 16
_i$ = -24						; size = 4
_lookup_response$ = -20					; size = 4
_x$ = -16						; size = 4
_answer$ = -8						; size = 4
_hostname$ = 8						; size = 4
?get_ip_from_hostname@@YAKPAD@Z PROC NEAR		; get_ip_from_hostname

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 268  : 	unsigned long answer;
; 269  : 	char *x= (char*) &answer;

	lea	eax, DWORD PTR _answer$[ebp]
	mov	DWORD PTR _x$[ebp], eax

; 270  : 	hostent *lookup_response;
; 271  : 	int i;
; 272  : 
; 273  : 	// handle NULL => use local loopback
; 274  : 
; 275  : 	if (!hostname || !*hostname)

	cmp	DWORD PTR _hostname$[ebp], 0
	je	SHORT $L181804
	mov	ecx, DWORD PTR _hostname$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L181803
$L181804:

; 276  : 	{
; 277  : 		x[0]= 127; x[1]= x[2]= 0; x[3]= 1;

	mov	eax, DWORD PTR _x$[ebp]
	mov	BYTE PTR [eax], 127			; 0000007fH
	mov	ecx, DWORD PTR _x$[ebp]
	mov	BYTE PTR [ecx+2], 0
	mov	edx, DWORD PTR _x$[ebp]
	mov	BYTE PTR [edx+1], 0
	mov	eax, DWORD PTR _x$[ebp]
	mov	BYTE PTR [eax+3], 1

; 278  : 		return answer;

	mov	eax, DWORD PTR _answer$[ebp]
	jmp	$L181797
$L181803:

; 279  : 	}
; 280  : 
; 281  :   	// handle numeric IP
; 282  : 
; 283  : 	if ( (*hostname>='0') && (*hostname<='9') )

	mov	ecx, DWORD PTR _hostname$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $L181805
	mov	eax, DWORD PTR _hostname$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jg	SHORT $L181805

; 284  : 	{
; 285  : 		int temp[4];
; 286  : 		i= sscanf (hostname, "%d.%d.%d.%d", &temp[0], &temp[1], &temp[2], &temp[3]);

	lea	edx, DWORD PTR _temp$181806[ebp+12]
	push	edx
	lea	eax, DWORD PTR _temp$181806[ebp+8]
	push	eax
	lea	ecx, DWORD PTR _temp$181806[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _temp$181806[ebp]
	push	edx
	push	OFFSET FLAT:$SG181807
	mov	eax, DWORD PTR _hostname$[ebp]
	push	eax
	call	_sscanf
	add	esp, 24					; 00000018H
	mov	DWORD PTR _i$[ebp], eax

; 287  : 		if (i!=4) return -1;

	cmp	DWORD PTR _i$[ebp], 4
	je	SHORT $L181808
	or	eax, -1
	jmp	$L181797
$L181808:

; 288  : 		for (i=0; i<4; i++) x[i]= temp[i];

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181809
$L181810:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$L181809:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L181811
	mov	edx, DWORD PTR _x$[ebp]
	add	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR _temp$181806[ebp+eax*4]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $L181810
$L181811:

; 289  : 
; 290  : 		return answer;

	mov	eax, DWORD PTR _answer$[ebp]
	jmp	SHORT $L181797
$L181805:

; 291  : 	}
; 292  : 
; 293  : 	// handle real hostname
; 294  : 
; 295  : 	lookup_response=gethostbyname(hostname);

	mov	esi, esp
	mov	edx, DWORD PTR _hostname$[ebp]
	push	edx
	call	DWORD PTR __imp__gethostbyname@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lookup_response$[ebp], eax

; 296  : 	if (!lookup_response) return -2;

	cmp	DWORD PTR _lookup_response$[ebp], 0
	jne	SHORT $L181812
	mov	eax, -2					; fffffffeH
	jmp	SHORT $L181797
$L181812:

; 297  : 	for (i=0; i<4; i++) x[i]=lookup_response->h_addr[i];

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181813
$L181814:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$L181813:
	cmp	DWORD PTR _i$[ebp], 4
	jge	SHORT $L181815
	mov	ecx, DWORD PTR _lookup_response$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _x$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	al, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $L181814
$L181815:

; 298  : 
; 299  : 	return answer;

	mov	eax, DWORD PTR _answer$[ebp]
$L181797:

; 300  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L182246
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L182246:
	DD	2
	DD	$L182245
$L182245:
	DD	-8					; fffffff8H
	DD	4
	DD	$L182243
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$L182244
$L182244:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	0
$L182243:
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	115					; 00000073H
	DB	119					; 00000077H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?get_ip_from_hostname@@YAKPAD@Z ENDP			; get_ip_from_hostname
_TEXT	ENDS
EXTRN	__imp__connect@12:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__setsockopt@20:NEAR
EXTRN	__imp__socket@12:NEAR
EXTRN	__imp__WSAStartup@8:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_timeout_ms$ = -464					; size = 4
_addr$ = -452						; size = 16
_sock$ = -432						; size = 4
_dest_ip$ = -428					; size = 4
_d$ = -420						; size = 400
_ver$ = -16						; size = 2
_i$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hostname$ = 8						; size = 4
?my_connect@CCAMClient@@AAEIPAD@Z PROC NEAR		; CCAMClient::my_connect
; _this$ = ecx

; 306  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-468]
	mov	ecx, 117				; 00000075H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 307  : 	int i;
; 308  : 
; 309  : 	// start up sockets
; 310  : 	
; 311  : 	WORD ver= MAKEWORD (2,0);

	mov	WORD PTR _ver$[ebp], 2

; 312  : #ifdef WIN32
; 313  : 	WSAData d;
; 314  : #else
; 315  : 	WSADATA d;
; 316  : #endif
; 317  : 	WSAStartup(ver, &d);

	mov	esi, esp
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	cx, WORD PTR _ver$[ebp]
	push	ecx
	call	DWORD PTR __imp__WSAStartup@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 318  : 
; 319  : 	// resolve given hostname
; 320  : 
; 321  : 	unsigned long dest_ip = ::get_ip_from_hostname(hostname);

	mov	edx, DWORD PTR _hostname$[ebp]
	push	edx
	call	?get_ip_from_hostname@@YAKPAD@Z		; get_ip_from_hostname
	add	esp, 4
	mov	DWORD PTR _dest_ip$[ebp], eax

; 322  : 
; 323  :     SOCKET sock;
; 324  : #ifdef WIN32
; 325  :     struct sockaddr_in addr;
; 326  : #else
; 327  :     SOCKADDR_IN addr;
; 328  : #endif
; 329  : 
; 330  :     sock = socket(AF_INET, SOCK_STREAM, 0);

	mov	esi, esp
	push	0
	push	1
	push	2
	call	DWORD PTR __imp__socket@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _sock$[ebp], eax

; 331  : 
; 332  :     addr.sin_family= AF_INET;

	mov	WORD PTR _addr$[ebp], 2

; 333  :     addr.sin_port= htons(camServerPortNumber);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__htons@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	WORD PTR _addr$[ebp+2], ax

; 334  :     addr.sin_addr.S_un.S_addr= dest_ip;

	mov	edx, DWORD PTR _dest_ip$[ebp]
	mov	DWORD PTR _addr$[ebp+4], edx

; 335  : 
; 336  :     // connect
; 337  :     i = connect(sock, (struct sockaddr*) &addr, sizeof(addr));

	mov	esi, esp
	push	16					; 00000010H
	lea	eax, DWORD PTR _addr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	DWORD PTR __imp__connect@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _i$[ebp], eax

; 338  : 	if (i!=0) return INVALID_SOCKET;

	cmp	DWORD PTR _i$[ebp], 0
	je	SHORT $L181833
	or	eax, -1
	jmp	SHORT $L181819
$L181833:

; 339  : 
; 340  :     int timeout_ms=10000;

	mov	DWORD PTR _timeout_ms$[ebp], 10000	; 00002710H

; 341  : 	setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char*) &timeout_ms, sizeof(timeout_ms));

	mov	esi, esp
	push	4
	lea	edx, DWORD PTR _timeout_ms$[ebp]
	push	edx
	push	4101					; 00001005H
	push	65535					; 0000ffffH
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	DWORD PTR __imp__setsockopt@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 342  :     setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (char*) &timeout_ms, sizeof(timeout_ms));

	mov	esi, esp
	push	4
	lea	ecx, DWORD PTR _timeout_ms$[ebp]
	push	ecx
	push	4102					; 00001006H
	push	65535					; 0000ffffH
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	call	DWORD PTR __imp__setsockopt@20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 343  : 
; 344  : 	return sock;

	mov	eax, DWORD PTR _sock$[ebp]
$L181819:

; 345  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L182255
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 468				; 000001d4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L182255:
	DD	3
	DD	$L182254
$L182254:
	DD	-420					; fffffe5cH
	DD	400					; 00000190H
	DD	$L182249
	DD	-452					; fffffe3cH
	DD	16					; 00000010H
	DD	$L182250
	DD	-464					; fffffe30H
	DD	4
	DD	$L182251
$L182251:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	109					; 0000006dH
	DB	115					; 00000073H
	DB	0
$L182250:
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	100					; 00000064H
	DB	114					; 00000072H
	DB	0
$L182249:
	DB	100					; 00000064H
	DB	0
?my_connect@CCAMClient@@AAEIPAD@Z ENDP			; CCAMClient::my_connect
_TEXT	ENDS
EXTRN	__imp__send@16:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$ = -24						; size = 4
_header$ = -16						; size = 8
_this$ = -4						; size = 4
_sock$ = 8						; size = 4
_size$ = 12						; size = 4
?send_header@CCAMClient@@AAEHIH@Z PROC NEAR		; CCAMClient::send_header
; _this$ = ecx

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 352  : 	xmit_header header;
; 353  : 
; 354  : 	header.header_proto_ver= 3;

	mov	DWORD PTR _header$[ebp], 3

; 355  : 	header.header_msg_len = size;

	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR _header$[ebp+4], eax

; 356  : 
; 357  : 	int i= send(sock, (char*)&header, sizeof(header), 0);

	mov	esi, esp
	push	0
	push	8
	lea	ecx, DWORD PTR _header$[ebp]
	push	ecx
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	call	DWORD PTR __imp__send@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _i$[ebp], eax

; 358  : 	return (i<=0)? -1 : 0;

	xor	eax, eax
	cmp	DWORD PTR _i$[ebp], 0
	setg	al
	dec	eax

; 359  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L182260
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L182260:
	DD	1
	DD	$L182259
$L182259:
	DD	-16					; fffffff0H
	DD	8
	DD	$L182258
$L182258:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?send_header@CCAMClient@@AAEHIH@Z ENDP			; CCAMClient::send_header
_TEXT	ENDS
PUBLIC	?read_header@CCAMClient@@AAEHI@Z		; CCAMClient::read_header
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_i$ = -24						; size = 4
_header$ = -16						; size = 8
_this$ = -4						; size = 4
_sock$ = 8						; size = 4
?read_header@CCAMClient@@AAEHI@Z PROC NEAR		; CCAMClient::read_header
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 	xmit_header header;
; 365  : 
; 366  : 	int i= full_recv(sock, (char*)&header, sizeof(header));

	push	8
	lea	eax, DWORD PTR _header$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?full_recv@CCAMClient@@AAEHIPADH@Z	; CCAMClient::full_recv
	mov	DWORD PTR _i$[ebp], eax

; 367  : 	if (i<sizeof(header)) return -1;

	cmp	DWORD PTR _i$[ebp], 8
	jae	SHORT $L181853
	or	eax, -1
	jmp	SHORT $L181849
$L181853:

; 368  : 
; 369  : 	return header.header_msg_len;

	mov	eax, DWORD PTR _header$[ebp+4]
$L181849:

; 370  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L182264
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L182264:
	DD	1
	DD	$L182263
$L182263:
	DD	-16					; fffffff0H
	DD	8
	DD	$L182262
$L182262:
	DB	104					; 00000068H
	DB	101					; 00000065H
	DB	97					; 00000061H
	DB	100					; 00000064H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?read_header@CCAMClient@@AAEHI@Z ENDP			; CCAMClient::read_header
; Function compile flags: /Odt /RTCsu
_answer$ = -16						; size = 4
_s$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_sock$ = 8						; size = 4
?read_msg@CCAMClient@@AAEPAUBinString@@I@Z PROC NEAR	; CCAMClient::read_msg
; _this$ = ecx

; 373  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 374  : 	int i,s= read_header(sock);

	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read_header@CCAMClient@@AAEHI@Z	; CCAMClient::read_header
	mov	DWORD PTR _s$[ebp], eax

; 375  : 	if (s<=0) return NULL;

	cmp	DWORD PTR _s$[ebp], 0
	jg	SHORT $L181860
	xor	eax, eax
	jmp	SHORT $L181857
$L181860:

; 376  : 
; 377  : 	BinString *answer= newBinString(s, "read bfr");

	push	OFFSET FLAT:$SG181862
	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?newBinString@CCAMClient@@AAEPAUBinString@@HPAD@Z ; CCAMClient::newBinString
	mov	DWORD PTR _answer$[ebp], eax

; 378  : 	i= full_recv(sock, (char*)answer->data, s);

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	eax, DWORD PTR _answer$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?full_recv@CCAMClient@@AAEHIPADH@Z	; CCAMClient::full_recv
	mov	DWORD PTR _i$[ebp], eax

; 379  : 	if (i!=s) { delBinString(answer); return NULL; }

	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _s$[ebp]
	je	SHORT $L181864
	mov	ecx, DWORD PTR _answer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?delBinString@CCAMClient@@AAEXPAUBinString@@@Z ; CCAMClient::delBinString
	xor	eax, eax
	jmp	SHORT $L181857
$L181864:

; 380  : 
; 381  : 	return answer;

	mov	eax, DWORD PTR _answer$[ebp]
$L181857:

; 382  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?read_msg@CCAMClient@@AAEPAUBinString@@I@Z ENDP		; CCAMClient::read_msg
; Function compile flags: /Odt /RTCsu
tv71 = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_sock$ = 8						; size = 4
_s$ = 12						; size = 4
?send_bs@CCAMClient@@AAEHIPAUBinString@@@Z PROC NEAR	; CCAMClient::send_bs
; _this$ = ecx

; 385  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 	unsigned int i= send(sock, (char*)s->data, s->size, 0);

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _sock$[ebp]
	push	ecx
	call	DWORD PTR __imp__send@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _i$[ebp], eax

; 387  : 	return (i==s->size)? i : -1;

	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $L182267
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR tv71[ebp], ecx
	jmp	SHORT $L182268
$L182267:
	mov	DWORD PTR tv71[ebp], -1
$L182268:
	mov	eax, DWORD PTR tv71[ebp]

; 388  : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?send_bs@CCAMClient@@AAEHIPAUBinString@@@Z ENDP		; CCAMClient::send_bs
_TEXT	ENDS
PUBLIC	?read_file@CCAMClient@@AAEHPAD0H@Z		; CCAMClient::read_file
EXTRN	_fclose:NEAR
EXTRN	_fopen:NEAR
EXTRN	_fread:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_fil$ = -12						; size = 4
_got$ = -8						; size = 4
_this$ = -4						; size = 4
_fname$ = 8						; size = 4
_bfr$ = 12						; size = 4
_maxsize$ = 16						; size = 4
?read_file@CCAMClient@@AAEHPAD0H@Z PROC NEAR		; CCAMClient::read_file
; _this$ = ecx

; 393  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 394  : 	int got;
; 395  : 	FILE *fil= fopen(fname, "rb");

	push	OFFSET FLAT:$SG181880
	mov	eax, DWORD PTR _fname$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _fil$[ebp], eax

; 396  : 	if (!fil) return -1;

	cmp	DWORD PTR _fil$[ebp], 0
	jne	SHORT $L181881
	or	eax, -1
	jmp	SHORT $L181877
$L181881:

; 397  : 
; 398  : 	got= fread(bfr, 1, maxsize, fil);

	mov	ecx, DWORD PTR _fil$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxsize$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _bfr$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR _got$[ebp], eax

; 399  : 	fclose(fil);

	mov	ecx, DWORD PTR _fil$[ebp]
	push	ecx
	call	_fclose
	add	esp, 4

; 400  : 
; 401  : 	return got;

	mov	eax, DWORD PTR _got$[ebp]
$L181877:

; 402  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?read_file@CCAMClient@@AAEHPAD0H@Z ENDP			; CCAMClient::read_file
_TEXT	ENDS
PUBLIC	?copy_str_out@CCAMClient@@AAEXPAUBinString@@PAE@Z ; CCAMClient::copy_str_out
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_p$ = -12						; size = 4
_i$ = -8						; size = 4
_this$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?copy_str_out@CCAMClient@@AAEXPAUBinString@@PAE@Z PROC NEAR ; CCAMClient::copy_str_out
; _this$ = ecx

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 408  : 	if (!src || !src->data || !dest) return;

	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $L181888
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L181888
	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $L181887
$L181888:
	jmp	SHORT $L181886
$L181887:

; 409  : 	int i;
; 410  : 
; 411  : 	char *p= (char*)dest;

	mov	ecx, DWORD PTR _dest$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 412  : 
; 413  : 	for (i=0; i<(int)src->size; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $L181893
$L181894:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$L181893:
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L181895

; 414  : 		if (src->data[i] != 0x0a) *p++= src->data[i];

	mov	edx, DWORD PTR _src$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$[ebp]
	movzx	edx, BYTE PTR [eax+ecx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $L181896
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	cl, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx

; 415  : 		else { *p++=13; *p++=10; }

	jmp	SHORT $L181897
$L181896:
	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 13			; 0000000dH
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], 10			; 0000000aH
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$L181897:

; 416  : 	}

	jmp	SHORT $L181894
$L181895:

; 417  : 	*p++= 0;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
$L181886:

; 418  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?copy_str_out@CCAMClient@@AAEXPAUBinString@@PAE@Z ENDP	; CCAMClient::copy_str_out
; Function compile flags: /Odt /RTCsu
_this$ = -4						; size = 4
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?copy_mem_out@CCAMClient@@AAEXPAUBinString@@PAE@Z PROC NEAR ; CCAMClient::copy_mem_out
; _this$ = ecx

; 421  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 	if (!src || !src->data || !dest) return;

	cmp	DWORD PTR _src$[ebp], 0
	je	SHORT $L181904
	mov	eax, DWORD PTR _src$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L181904
	cmp	DWORD PTR _dest$[ebp], 0
	jne	SHORT $L181903
$L181904:
	jmp	SHORT $L181902
$L181903:

; 423  : 
; 424  : 	memcpy (dest, src->data, src->size);

	mov	ecx, DWORD PTR _src$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _src$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _dest$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$L181902:

; 425  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?copy_mem_out@CCAMClient@@AAEXPAUBinString@@PAE@Z ENDP	; CCAMClient::copy_mem_out
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z:NEAR ; ATL::AtlWinModuleInit
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88121

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88121:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
_TEXT	ENDS
EXTRN	_memset:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T182294 DD	0ffffffffH
	DD	FLAT:$L182287
$T182291 DD	019930520H
	DD	01H
	DD	FLAT:$T182294
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L182287:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T182291
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2589 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
EXTRN	__imp__UnregisterClassA@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$91551 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC NEAR ; ATL::AtlWinModuleTerm, COMDAT

; 6215 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6216 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $L91544

; 6217 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L91543
$L91544:

; 6218 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L91546

; 6219 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L91543
$L91546:

; 6220 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [ecx], 44			; 0000002cH
	je	SHORT $L91549

; 6221 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $L91543
$L91549:

; 6222 : 
; 6223 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	mov	DWORD PTR _i$91551[ebp], 0
	jmp	SHORT $L91552
$L91553:
	mov	edx, DWORD PTR _i$91551[ebp]
	add	edx, 1
	mov	DWORD PTR _i$91551[ebp], edx
$L91552:
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
	cmp	DWORD PTR _i$91551[ebp], eax
	jge	SHORT $L91554

; 6224 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	esi, esp
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$91551[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__UnregisterClassA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L91553
$L91554:

; 6225 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 6226 : 	pWinModule->m_csWindowCreate.Term();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 6227 : 	pWinModule->cbSize = 0;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax], 0

; 6228 : 	return S_OK;

	xor	eax, eax
$L91543:

; 6229 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		DeleteCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 149  : 		return S_OK;

	xor	eax, eax

; 150  : 	}	

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$162915 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162914

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$162915[ebp], 0
	jmp	SHORT $L162916
$L162917:
	mov	ecx, DWORD PTR _i$162915[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$162915[ebp], ecx
$L162916:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$162915[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L162918

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L162917
$L162918:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L162914:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ ; `string'
EXTRN	__CrtDbgReport:NEAR
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT
??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ DB 'n'
	DB	'Index >= 0 && nIndex < m_nSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lsimpcoll.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L182317
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L182318
$L182317:
	push	OFFSET FLAT:??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
	push	0
	push	195					; 000000c3H
	push	OFFSET FLAT:??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L182318
	int	3
$L182318:

; 196  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L162924
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L162923
$L162924:

; 197  : 		{
; 198  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);					

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$L162923:

; 199  : 		}
; 200  : 		return m_aT[nIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
$L182316:

; 201  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
EXTRN	__imp__RaiseException@16:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC NEAR		; ATL::_AtlRaiseException, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 27   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _dwExceptionFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwExceptionCode$[ebp]
	push	ecx
	call	DWORD PTR __imp__RaiseException@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 28   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
