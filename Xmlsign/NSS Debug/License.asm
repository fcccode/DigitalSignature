; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\License.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFEEKIIE@mbstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JADEDFCN@wcstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DFFCODPF@m_pData?9?$DOnRefs?5?$DN?$DN?5?91?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFNMPDFA@m_pData?9?$DOnDataLength?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JINHKJCC@pData?9?$DOnRefs?5?$DM?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNGMIMJM@pData?9?$DOnRefs?5?$DM?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@EIPLHBJE@CFixedStringMgr?3?3Allocate?$CI?$CJ?5spil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@PINPFILO@CFixedStringMgr?3?3Reallocate?$CI?$CJ?5sp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDHCGOCC@m_pMemMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@ENACCIMA@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KICONMKH@pData?9?$DOpStringMgr?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPMMCKHL@?$CI?$CIWORD?$CJ?$CI?$CIDWORD_PTR?$CJ?$CIpsz?$CJ?5?$DO?$DO?516?$CJ?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BDLMIBLB@pFormat?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGFACAOB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KCADNOJC@?$CF02ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@FKADHJGH@strFormat?4LoadStringA?$CInFormatID?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJEKGMMD@Warning?3?5implicit?5LoadString?$CI?$CFu?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@GDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@GDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@G@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dowiden@?$ctype@G@std@@IBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Donarrow@?$ctype@G@std@@IBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@G@ATL@@CGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@G@ATL@@KGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@G@ATL@@KGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@G@ATL@@KGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@G@ATL@@SAPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTimeSpan@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatGmt@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCLicense@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Preallocate@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormat@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendChar@?$CSimpleStringT@D$0A@@ATL@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@G@std@@@std@@YAABV?$ctype@G@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlIsValidString@ATL@@YAHPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterWndClassInfoA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PAU_ATL_BASE_MODULE70@1@PAU_ATL_WNDCLASSINFOA@1@PAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamA@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOA@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamA@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DN@BIGELNIF@ERROR?5?3?5Invalid?5Arguments?5to?5Atl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EL@KHCGDDHE@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@EAELIHNL@ERROR?5?3?5Could?5not?5obtain?5Window?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LoadCursorA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAPAUHICON__@@PAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatWindowClassName@AtlModuleRegisterWndClassInfoParamA@ATL@@SAXPADPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09OOFFBKGI@ATL?3?$CF8?48X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetClassInfoExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAHPAUHINSTANCE__@@PBDPAUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterClassExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAGPAU_ATL_WIN_MODULE70@2@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterClassExA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAPAXIPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAXPAXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@ABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOGEFONP@bRet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KAMJMGHJ@pProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIGOECOI@p?9?$DOpWndProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CLicense@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBJEMDLA@nRet?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@MLJMCNFJ@pStringMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWThunk
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWThunk
PUBLIC	?LICENSE@CLicense@@2PBEB			; CLicense::LICENSE
PUBLIC	?VERSION@CLicense@@2PBEB			; CLicense::VERSION
PUBLIC	?EXP_DATE@CLicense@@2PBEB			; CLicense::EXP_DATE
PUBLIC	?MAINT_EXP_DATE@CLicense@@2PBEB			; CLicense::MAINT_EXP_DATE
PUBLIC	?ISSUE_DATE@CLicense@@2PBEB			; CLicense::ISSUE_DATE
PUBLIC	?YEAR@CLicense@@2PBEB				; CLicense::YEAR
PUBLIC	?MON@CLicense@@2PBEB				; CLicense::MON
PUBLIC	?DAY@CLicense@@2PBEB				; CLicense::DAY
PUBLIC	?OPERATIONS@CLicense@@2PBEB			; CLicense::OPERATIONS
PUBLIC	?VERIFY@CLicense@@2PBEB				; CLicense::VERIFY
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?CREATE@CLicense@@2PBEB				; CLicense::CREATE
PUBLIC	?ENCRYPT@CLicense@@2PBEB			; CLicense::ENCRYPT
PUBLIC	?DECRYPT@CLicense@@2PBEB			; CLicense::DECRYPT
PUBLIC	?SECURESIGN@CLicense@@2PBEB			; CLicense::SECURESIGN
PUBLIC	?SECURESIGNPROFESSIONAL@CLicense@@2PBEB		; CLicense::SECURESIGNPROFESSIONAL
PUBLIC	?SECURESIGNENTERPRISE@CLicense@@2PBEB		; CLicense::SECURESIGNENTERPRISE
PUBLIC	?SECURESIGNSERVER@CLicense@@2PBEB		; CLicense::SECURESIGNSERVER
PUBLIC	?TYPE@CLicense@@2PBEB				; CLicense::TYPE
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?SERVER@CLicense@@2PBEB				; CLicense::SERVER
PUBLIC	?CLIENT@CLicense@@2PBEB				; CLicense::CLIENT
PUBLIC	?DEMO@CLicense@@2PBEB				; CLicense::DEMO
PUBLIC	?DEVELOPMENT@CLicense@@2PBEB			; CLicense::DEVELOPMENT
PUBLIC	?LICENSE_KEY@CLicense@@2PBEB			; CLicense::LICENSE_KEY
PUBLIC	?NUM_LICENSE@CLicense@@2PBEB			; CLicense::NUM_LICENSE
PUBLIC	?WINDOWS_CLIENT@CLicense@@2PBEB			; CLicense::WINDOWS_CLIENT
PUBLIC	?CharLowerWThunk@ATL@@YGPAGPAG@Z		; ATL::CharLowerWThunk
PUBLIC	?LINUX_CLIENT@CLicense@@2PBEB			; CLicense::LINUX_CLIENT
PUBLIC	?MAC_CLIENT@CLicense@@2PBEB			; CLicense::MAC_CLIENT
PUBLIC	?SOLARIS_CLIENT@CLicense@@2PBEB			; CLicense::SOLARIS_CLIENT
PUBLIC	?SIGNATURE@CLicense@@2PBEB			; CLicense::SIGNATURE
PUBLIC	?LICENSEE@CLicense@@2PBEB			; CLicense::LICENSEE
PUBLIC	?LICENSER@CLicense@@2PBEB			; CLicense::LICENSER
PUBLIC	?COMPANY@CLicense@@2PBEB			; CLicense::COMPANY
PUBLIC	?CharUpperWThunk@ATL@@YGPAGPAG@Z		; ATL::CharUpperWThunk
PUBLIC	?USER@CLicense@@2PBEB				; CLicense::USER
PUBLIC	?HOSTNAME@CLicense@@2PBEB			; CLicense::HOSTNAME
PUBLIC	?licenseTimeout@CLicense@@0HB			; CLicense::licenseTimeout
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?wCRC16a@@3PAGA					; wCRC16a
PUBLIC	?wCRC16b@@3PAGA					; wCRC16b
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPBG0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
CONST	SEGMENT
$SG192481 DB	'Invalid DateTime', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:$SG192481		; ATL::szInvalidDateTime
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG192483 DB	'Invalid DateTimeSpan', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:$SG192483	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT
?licenseTimeout@CLicense@@0HB DD 01eH			; CLicense::licenseTimeout
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG193162 DB	'SecureXMLLicense', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSE@CLicense@@2PBEB DD FLAT:$SG193162		; CLicense::LICENSE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193164 DB	'Version', 00H
CONST	ENDS
_DATA	SEGMENT
?VERSION@CLicense@@2PBEB DD FLAT:$SG193164		; CLicense::VERSION
_DATA	ENDS
CONST	SEGMENT
$SG193166 DB	'Expiration', 00H
CONST	ENDS
_DATA	SEGMENT
?EXP_DATE@CLicense@@2PBEB DD FLAT:$SG193166		; CLicense::EXP_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193168 DB	'MaintenanceExpiration', 00H
CONST	ENDS
_DATA	SEGMENT
?MAINT_EXP_DATE@CLicense@@2PBEB DD FLAT:$SG193168	; CLicense::MAINT_EXP_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193170 DB	'IssueDate', 00H
CONST	ENDS
_DATA	SEGMENT
?ISSUE_DATE@CLicense@@2PBEB DD FLAT:$SG193170		; CLicense::ISSUE_DATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193172 DB	'Year', 00H
CONST	ENDS
_DATA	SEGMENT
?YEAR@CLicense@@2PBEB DD FLAT:$SG193172			; CLicense::YEAR
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193174 DB	'Month', 00H
CONST	ENDS
_DATA	SEGMENT
?MON@CLicense@@2PBEB DD FLAT:$SG193174			; CLicense::MON
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193176 DB	'Day', 00H
CONST	ENDS
_DATA	SEGMENT
?DAY@CLicense@@2PBEB DD FLAT:$SG193176			; CLicense::DAY
_DATA	ENDS
CONST	SEGMENT
$SG193178 DB	'Operations', 00H
CONST	ENDS
_DATA	SEGMENT
?OPERATIONS@CLicense@@2PBEB DD FLAT:$SG193178		; CLicense::OPERATIONS
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193180 DB	'Verify', 00H
CONST	ENDS
_DATA	SEGMENT
?VERIFY@CLicense@@2PBEB DD FLAT:$SG193180		; CLicense::VERIFY
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193182 DB	'Create', 00H
CONST	ENDS
_DATA	SEGMENT
?CREATE@CLicense@@2PBEB DD FLAT:$SG193182		; CLicense::CREATE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193184 DB	'Encrypt', 00H
CONST	ENDS
_DATA	SEGMENT
?ENCRYPT@CLicense@@2PBEB DD FLAT:$SG193184		; CLicense::ENCRYPT
_DATA	ENDS
CONST	SEGMENT
$SG193186 DB	'Decrypt', 00H
CONST	ENDS
_DATA	SEGMENT
?DECRYPT@CLicense@@2PBEB DD FLAT:$SG193186		; CLicense::DECRYPT
_DATA	ENDS
CONST	SEGMENT
$SG193188 DB	'SecureSign', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGN@CLicense@@2PBEB DD FLAT:$SG193188		; CLicense::SECURESIGN
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193190 DB	'SecureSignProfessional', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNPROFESSIONAL@CLicense@@2PBEB DD FLAT:$SG193190 ; CLicense::SECURESIGNPROFESSIONAL
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193192 DB	'SecureSignEnterprise', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNENTERPRISE@CLicense@@2PBEB DD FLAT:$SG193192	; CLicense::SECURESIGNENTERPRISE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193194 DB	'SecureSignServer', 00H
CONST	ENDS
_DATA	SEGMENT
?SECURESIGNSERVER@CLicense@@2PBEB DD FLAT:$SG193194	; CLicense::SECURESIGNSERVER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193196 DB	'Type', 00H
CONST	ENDS
_DATA	SEGMENT
?TYPE@CLicense@@2PBEB DD FLAT:$SG193196			; CLicense::TYPE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193198 DB	'Server', 00H
CONST	ENDS
_DATA	SEGMENT
?SERVER@CLicense@@2PBEB DD FLAT:$SG193198		; CLicense::SERVER
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193200 DB	'Client', 00H
CONST	ENDS
_DATA	SEGMENT
?CLIENT@CLicense@@2PBEB DD FLAT:$SG193200		; CLicense::CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193202 DB	'Demo', 00H
CONST	ENDS
_DATA	SEGMENT
?DEMO@CLicense@@2PBEB DD FLAT:$SG193202			; CLicense::DEMO
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193204 DB	'Development', 00H
CONST	ENDS
_DATA	SEGMENT
?DEVELOPMENT@CLicense@@2PBEB DD FLAT:$SG193204		; CLicense::DEVELOPMENT
_DATA	ENDS
CONST	SEGMENT
$SG193206 DB	'LicenseKey', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSE_KEY@CLicense@@2PBEB DD FLAT:$SG193206		; CLicense::LICENSE_KEY
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193208 DB	'NumLicense', 00H
CONST	ENDS
_DATA	SEGMENT
?NUM_LICENSE@CLicense@@2PBEB DD FLAT:$SG193208		; CLicense::NUM_LICENSE
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG193210 DB	'WindowsClient', 00H
CONST	ENDS
_DATA	SEGMENT
?WINDOWS_CLIENT@CLicense@@2PBEB DD FLAT:$SG193210	; CLicense::WINDOWS_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193212 DB	'LinuxClient', 00H
CONST	ENDS
_DATA	SEGMENT
?LINUX_CLIENT@CLicense@@2PBEB DD FLAT:$SG193212		; CLicense::LINUX_CLIENT
_DATA	ENDS
CONST	SEGMENT
$SG193214 DB	'MacClient', 00H
CONST	ENDS
_DATA	SEGMENT
?MAC_CLIENT@CLicense@@2PBEB DD FLAT:$SG193214		; CLicense::MAC_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193216 DB	'SolarisClient', 00H
CONST	ENDS
_DATA	SEGMENT
?SOLARIS_CLIENT@CLicense@@2PBEB DD FLAT:$SG193216	; CLicense::SOLARIS_CLIENT
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193218 DB	'Signature', 00H
CONST	ENDS
_DATA	SEGMENT
?SIGNATURE@CLicense@@2PBEB DD FLAT:$SG193218		; CLicense::SIGNATURE
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193220 DB	'Licensee', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSEE@CLicense@@2PBEB DD FLAT:$SG193220		; CLicense::LICENSEE
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193222 DB	'Licensor', 00H
CONST	ENDS
_DATA	SEGMENT
?LICENSER@CLicense@@2PBEB DD FLAT:$SG193222		; CLicense::LICENSER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193224 DB	'Company', 00H
CONST	ENDS
_DATA	SEGMENT
?COMPANY@CLicense@@2PBEB DD FLAT:$SG193224		; CLicense::COMPANY
_DATA	ENDS
CONST	SEGMENT
$SG193226 DB	'User', 00H
CONST	ENDS
_DATA	SEGMENT
?USER@CLicense@@2PBEB DD FLAT:$SG193226			; CLicense::USER
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG193228 DB	'HostName', 00H
CONST	ENDS
_DATA	SEGMENT
?HOSTNAME@CLicense@@2PBEB DD FLAT:$SG193228		; CLicense::HOSTNAME
_DATA	ENDS
CONST	SEGMENT
	ORG $+7
$SG193377 DB	'MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCB'
	DB	'vzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UECh'
	DB	'MWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWw'
	DB	'gU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENv'
	DB	'cnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxI'
	DB	'zAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEw'
	DB	'JVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZ'
	DB	'JbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBT'
	DB	'aWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlb'
	DB	'nNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jA'
	DB	'CKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2'
	DB	'qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdB'
	DB	'n2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA'
	DB	'1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn'
	DB	'2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA'
	DB	'7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A', 00H
	ORG $+7
$SG193380 DB	'cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0lu'
	DB	'Zm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBA'
	DB	'KcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2'
	DB	'dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/s'
	DB	'XMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzr'
	DB	'rTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5'
	DB	'FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKm'
	DB	'bpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=', 00H
	ORG $+3
$SG193383 DB	'aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTER'
	DB	'MA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yY'
	DB	'XRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbW'
	DB	'VudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArbl'
	DB	'Ppz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9D'
	DB	'Tj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyL'
	DB	'ENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcy'
	DB	'xDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZml'
	DB	'jYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmli'
	DB	'dXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvb'
	DB	'W9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi'
	DB	'5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA'
	DB	'6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJs'
	DB	'aWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0a'
	DB	'W9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYm'
	DB	'plY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmx'
	DB	'odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl', 00H
	ORG $+3
$SG193440 DB	'TrialHost', 00H
CONST	ENDS
_DATA	SEGMENT
?wCRC16a@@3PAGA DW 00H					; wCRC16a
	DW	0c0c1H
	DW	0c181H
	DW	0140H
	DW	0c301H
	DW	03c0H
	DW	0280H
	DW	0c241H
	DW	0c601H
	DW	06c0H
	DW	0780H
	DW	0c741H
	DW	0500H
	DW	0c5c1H
	DW	0c481H
	DW	0440H
?wCRC16b@@3PAGA DW 00H					; wCRC16b
	DW	0cc01H
	DW	0d801H
	DW	01400H
	DW	0f001H
	DW	03c00H
	DW	02800H
	DW	0e401H
	DW	0a001H
	DW	06c00H
	DW	07800H
	DW	0b401H
	DW	05000H
	DW	09c01H
	DW	08801H
	DW	04600H
_DATA	ENDS
CONST	SEGMENT
	ORG $+2
$SG193476 DB	'LmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbigx'
	DB	'KS5jcnQwDQYJKoZIhvcNAQEFBQADggEBAFrOd7OXXrIwQB5Fz+AZTt2mgvdXk'
	DB	'JlrneuWoyEF3DSoZfSdGqaORmWEdNcWbcxmN+xl81bWwCmdi99emBvH0sIEvS'
	DB	'9u8y4c93zG/qg3+Icu3/KNYDGAXBWJFdnCyTPfBdhTw1AmXOHepQ9i2C51S4w'
	DB	'A8keQoaH1yCwQjcSA3cRAlweg0BkpBM1NRx+jOlMgLmCETb+8iZ1vDQZ0SBul'
	DB	'O60cX7pdD/cQUE5mbeII/enkaECj8eC9CuPrhmL5D3B0xSgXOGryWNIAl1gcI'
	DB	'M2+wt+D92vN8n0WiZ1LA9DNvZPY17DePeEEwxk1Kd33C+F9Tw9q57b4rsjY/P'
	DB	'aM9Gi8FG0=', 00H
	ORG $+7
$SG193479 DB	'b24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5'
	DB	'MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwg'
	DB	'Z8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALgb0p8Fh0O1DwZyXDONau+SqV'
	DB	'vM3IDvqDDjMLQ8uR4BnGXjiGqgjdrH4obZekYYcjWIWu01vPMAYYHH198gmsF'
	DB	'xHphndAsPllBUl0iX4JEhyBtZAo7koED+J+9aMNkVAjkA4AG17Z/MfglAH+/E'
	DB	'wsvI9nPwwsW1P9lFcQsZivIxAgMBAAGjggIzMIICLzAOBgNVHQ8BAf8EBAMCB'
	DB	'PAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAX3Ts8591e+/KCE4j'
	DB	'gHJqKw5EqzMIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYH'
	DB	'EpIHBMIG+MSIwIAYJKoZIhvcNAQkB', 00H
	ORG $+7
$SG193482 DB	'MIIFvzCCBKegAwIBAgIKFDX9YgABAAAG5DANBgkqhkiG9w0BAQUFADCB'
	DB	'vjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1'
	DB	'UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIER'
	DB	'pZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29y'
	DB	'cG9yYXRpb24wHhcNMDMxMDAzMjIyOTUxWhcNMTMxMDAzMjE1OTUzWjCByjEjM'
	DB	'CEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAl'
	DB	'VTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAo'
	DB	'TFkluZm9tb3NhaWMgQ29ycG9yYXRp', 00H
	ORG $+7
$SG193485 DB	'FhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UE'
	DB	'CBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zY'
	DB	'WljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYX'
	DB	'R1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQKiQ'
	DB	'6i/TBzo1KZki1g15oZzBeBgNVHR8EVzBVMFOgUaBPhk1odHRwOi8vaW5mb21v'
	DB	'c2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvSW5mb21vc2FpY'
	DB	'yUyMENvcnBvcmF0aW9uLmNybDCBiwYIKwYBBQUHAQEEfzB9MHsGCCsGAQUFBz'
	DB	'AChm9odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnR'
	DB	'FbnJvbGwvaW5mb21vc2FpYy1zcnZy', 00H
	ORG $+3
$SG193517 DB	'MaintExpiryYear', 00H
$SG193523 DB	'MaintExpiryMonth', 00H
	ORG $+3
$SG193529 DB	'MaintExpiryDay', 00H
	ORG $+1
$SG193535 DB	'LinuxClient', 00H
$SG193541 DB	'WindowsClient', 00H
	ORG $+2
$SG193547 DB	'SolarisClient', 00H
	ORG $+2
$SG193553 DB	'MacClient', 00H
	ORG $+2
$SG193601 DB	'MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCB'
	DB	'vzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEB'
	DB	'hMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UECh'
	DB	'MWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWw'
	DB	'gU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENv'
	DB	'cnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxI'
	DB	'zAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEw'
	DB	'JVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZ'
	DB	'JbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBT'
	DB	'aWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlb'
	DB	'nNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jA'
	DB	'CKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2'
	DB	'qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdB'
	DB	'n2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA'
	DB	'1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn'
	DB	'2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA'
	DB	'7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A', 00H
	ORG $+7
$SG193604 DB	'cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0lu'
	DB	'Zm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBA'
	DB	'KcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2'
	DB	'dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/s'
	DB	'XMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzr'
	DB	'rTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5'
	DB	'FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKm'
	DB	'bpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=', 00H
	ORG $+3
$SG193607 DB	'aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTER'
	DB	'MA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yY'
	DB	'XRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbW'
	DB	'VudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArbl'
	DB	'Ppz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9D'
	DB	'Tj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyL'
	DB	'ENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcy'
	DB	'xDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZml'
	DB	'jYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmli'
	DB	'dXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvb'
	DB	'W9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi'
	DB	'5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA'
	DB	'6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJs'
	DB	'aWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0a'
	DB	'W9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYm'
	DB	'plY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmx'
	DB	'odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl', 00H
	ORG $+7
$SG193642 DB	'(//. | //@* | //namespace::*)[self::idsig:Signature | se'
	DB	'lf::SignedObject | self::documentID]', 00H
	ORG $+3
$SG193646 DB	'http://www.w3.org/2000/09/xmldsig#', 00H
	ORG $+1
$SG193647 DB	'idsig', 00H
	ORG $+2
$SG193663 DB	'(//. | //@* | //namespace::*)[self::SchemaData]', 00H
$SG193692 DB	'TemplateSource', 00H
	ORG $+5
$SG193693 DB	'(//. | //@* | //namespace::*)[ancestor-or-self::ifmc:Sig'
	DB	'nedObject[@Id=''%s'']]', 00H
	ORG $+3
$SG193698 DB	'http://www.infomosaic.net', 00H
	ORG $+2
$SG193699 DB	'ifmc', 00H
	ORG $+7
$SG193726 DB	'(//. | //@* | //namespace::*)[self::SchemaData | self::X'
	DB	'mlData]', 00H
$SG193732 DB	'XmlData', 00H
$SG194757 DB	'pp != 0', 00H
$SG194758 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
	ORG $+1
$SG164311 DB	'pThis != 0', 00H
	ORG $+5
$SG164312 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164319 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164320 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG164336 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG164337 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164360 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG164361 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164372 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG164373 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164583 DB	'm_begin == 0', 00H
	ORG $+3
$SG164584 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT rtc$IMZ
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -156						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

	mov	DWORD PTR _ver$[ebp], 148		; 00000094H

; 139  : 	::GetVersionEx( &ver );

	mov	esi, esp
	lea	eax, DWORD PTR _ver$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

	cmp	DWORD PTR _ver$[ebp+16], 2
	jne	SHORT $L75781
	cmp	DWORD PTR _ver$[ebp+4], 5
	jb	SHORT $L75781

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

	jmp	SHORT $L75782
$L75781:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L75782:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	mov	ecx, DWORD PTR _pfnGetThreadACP$[ebp]
	push	ecx
	push	OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 152  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195803
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L195803:
	DD	1
	DD	$L195802
$L195802:
	DD	-156					; ffffff64H
	DD	148					; 00000094H
	DD	$L195799
$L195799:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

	mov	esi, esp
	mov	eax, DWORD PTR _pNew$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pp$[ebp]
	push	ecx
	call	DWORD PTR __imp__InterlockedExchange@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 93   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$75769 = -32					; size = 4
_szACP$ = -24						; size = 7
_lcidThread$ = -12					; size = 4
_nACP$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

	mov	DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

	mov	esi, esp
	call	DWORD PTR __imp__GetThreadLocale@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

	mov	esi, esp
	push	7
	lea	eax, DWORD PTR _szACP$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _lcidThread$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetLocaleInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L75768

; 111  : 	{
; 112  : 		char* pch = szACP;

	lea	edx, DWORD PTR _szACP$[ebp]
	mov	DWORD PTR _pch$75769[ebp], edx
$L75771:

; 113  : 		while (*pch != '\0')

	mov	eax, DWORD PTR _pch$75769[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L75768

; 114  : 		{
; 115  : 			nACP *= 10;

	mov	edx, DWORD PTR _nACP$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

	mov	eax, DWORD PTR _pch$75769[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _nACP$[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _nACP$[ebp], eax
	mov	ecx, DWORD PTR _pch$75769[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$75769[ebp], ecx

; 117  : 		}

	jmp	SHORT $L75771
$L75768:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

	cmp	DWORD PTR _nACP$[ebp], 0
	jne	SHORT $L75773

; 121  : 		nACP = ::GetACP();

	mov	esi, esp
	call	DWORD PTR __imp__GetACP@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nACP$[ebp], eax
$L75773:

; 122  : 
; 123  : 	return nACP;

	mov	eax, DWORD PTR _nACP$[ebp]

; 124  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195816
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L195816:
	DD	1
	DD	$L195815
$L195815:
	DD	-24					; ffffffe8H
	DD	7
	DD	$L195813
$L195813:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	67					; 00000043H
	DB	80					; 00000050H
	DB	0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 128  : 	return( CP_THREAD_ACP );

	mov	eax, 3

; 129  : }

	pop	ebp
	ret	0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	mov	eax, DWORD PTR __imp__GetEnvironmentVariableW@12
	push	eax
	push	OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ; ATL::GetEnvironmentVariableWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

	mov	esi, esp
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 188  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	mov	eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	and	eax, 1
	jne	SHORT $L189761
	mov	ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
	mov	esi, esp
	call	DWORD PTR __imp__GetVersion@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483648			; 80000000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L189761:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

	movzx	edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	test	edx, edx
	je	SHORT $L189763

; 125  : 		pfn = pfnWin9x;

	mov	eax, DWORD PTR _pfnWin9x$[ebp]
	mov	DWORD PTR _pfn$[ebp], eax

; 126  : 	else

	jmp	SHORT $L189764
$L189763:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

	mov	ecx, DWORD PTR _pfnNT$[ebp]
	mov	DWORD PTR _pfn$[ebp], ecx
$L189764:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

	mov	edx, DWORD PTR _pfn$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppThunk$[ebp]
	push	eax
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@	; `string'
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
EXTRN	__CrtDbgReport:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T195843 DD	0ffffffffH
	DD	FLAT:$L195830
	DD	00H
	DD	FLAT:$L195831
$T195835 DD	019930520H
	DD	02H
	DD	FLAT:$T195843
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT
??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@ DB 'nSize >= nSizeW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\cs'
	DB	'tringt.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
$T195829 = -316						; size = 4
$T195827 = -312						; size = 4
$T195826 = -308						; size = 4
_pszNameA$ = -300					; size = 132
_pszBufferA$ = -160					; size = 132
_nSizeW$ = -24						; size = 4
_nSizeA$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z	; ATL::CW2AEX<128>::CW2AEX<128>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

	cmp	DWORD PTR _nSizeA$[ebp], 0
	jne	SHORT $L189835

; 167  : 		return 0;

	mov	DWORD PTR $T195826[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195826[ebp]
	jmp	$L189807
$L189835:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

	mov	ecx, DWORD PTR _nSizeA$[ebp]
	shl	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

	mov	esi, esp
	mov	edx, DWORD PTR _nSizeA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

	cmp	DWORD PTR _nSize$[ebp], 0
	jne	SHORT $L189837

; 174  : 		return nSizeW;

	mov	eax, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T195827[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195827[ebp]
	jmp	$L189807
$L189837:

; 175  : 	ATLASSERT(nSize >= nSizeW);

	mov	ecx, DWORD PTR _nSize$[ebp]
	cmp	ecx, DWORD PTR _nSizeW$[ebp]
	jae	SHORT $L195828
	push	OFFSET FLAT:??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
	push	0
	push	175					; 000000afH
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195828
	int	3
$L195828:

; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

	mov	esi, esp
	mov	eax, DWORD PTR _nSizeW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$[ebp]
	push	ecx
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  : 
; 178  : 	return nSizeW;

	mov	edx, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T195829[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195829[ebp]
$L189807:

; 179  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195842
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L195842:
	DD	2
	DD	$L195841
$L195841:
	DD	-160					; ffffff60H
	DD	132					; 00000084H
	DD	$L195836
	DD	-300					; fffffed4H
	DD	132					; 00000084H
	DD	$L195837
$L195837:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	0
$L195836:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L195830:
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L195831:
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	jmp	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z:
	mov	eax, OFFSET FLAT:$T195835
	jmp	___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 158  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 159  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	mov	eax, DWORD PTR __imp__CompareStringW@24
	push	eax
	push	OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ; ATL::CompareStringWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

	mov	esi, esp
	mov	ecx, DWORD PTR _nLength2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszString2$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLength1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszString1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	24					; 00000018H
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPBGHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__alloca_probe:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T195870 DD	0ffffffffH
	DD	FLAT:$L195862
$T195864 DD	019930520H
	DD	01H
	DD	FLAT:$T195870
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
tv147 = -76						; size = 4
tv142 = -72						; size = 4
tv149 = -68						; size = 4
tv89 = -64						; size = 4
tv84 = -60						; size = 4
tv91 = -56						; size = 4
$T195861 = -52						; size = 4
_pszAString2$ = -48					; size = 4
_pszAString1$ = -44					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 193  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

	mov	DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

	cmp	DWORD PTR _pszString1$[ebp], 0
	je	$L189862

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString1$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L195855
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L195856
$L195855:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L195853
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L195853
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv84[ebp], esp
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $L195854
$L195853:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv89[ebp], eax
$L195854:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv91[ebp], eax
$L195856:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

	cmp	DWORD PTR _pszAString1$[ebp], 0
	jne	SHORT $L189862

; 200  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L189862:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

	mov	DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

	cmp	DWORD PTR _pszString2$[ebp], 0
	je	$L189868

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString2$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L195859
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $L195860
$L195859:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L195857
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L195857
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv142[ebp], esp
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv147[ebp], edx
	jmp	SHORT $L195858
$L195857:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv147[ebp], eax
$L195858:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv147[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv149[ebp], eax
$L195860:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

	cmp	DWORD PTR _pszAString2$[ebp], 0
	jne	SHORT $L189868

; 208  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L189868:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

	mov	esi, esp
	mov	eax, DWORD PTR _nLength2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszAString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszAString1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR __imp__CompareStringA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T195861[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195861[ebp]
$L195852:

; 212  : }

	lea	esp, DWORD PTR [ebp-84]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195869
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L195869:
	DD	1
	DD	$L195868
$L195868:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L195866
$L195866:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L195862:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z:
	mov	eax, OFFSET FLAT:$T195864
	jmp	___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__except_handler3:NEAR
EXTRN	__resetstkoflw:NEAR
;	COMDAT CONST
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T195881 DD	0ffffffffH
	DD	FLAT:$L195876
	DD	FLAT:$L195877
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -48						; size = 4
$T195880 = -44						; size = 4
_p$75736 = -36						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET FLAT:$T195881
	push	OFFSET FLAT:__except_handler3
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	add	esp, -32				; ffffffe0H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

	mov	BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 8195				; 00002003H
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv65[ebp], esp
	mov	DWORD PTR __$SEHRec$[ebp], esp
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _p$75736[ebp], eax
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $L195879
$L195876:
$L195888:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T195880[ebp], eax
	mov	eax, DWORD PTR $T195880[ebp]
	sub	eax, -1073741571			; c00000fdH
	neg	eax
	sbb	eax, eax
	inc	eax
$L195878:
$L195887:
	ret	0
$L195877:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

	mov	BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

	call	__resetstkoflw
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
$L195879:

; 345  :     }
; 346  :     return bStackAvailable;

	mov	al, BYTE PTR _bStackAvailable$[ebp]
$L195875:

; 347  : }

	lea	esp, DWORD PTR [ebp-60]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195886
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L195886:
	DD	1
	DD	$L195885
$L195885:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L195883
$L195883:
	DB	112					; 00000070H
	DB	0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
EXTRN	__imp__WideCharToMultiByte@32:NEAR
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
CONST	SEGMENT
??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@ DB 'lpw != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lconv.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@ DB 'lpa != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPBGHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 574  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L195893
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	574					; 0000023eH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195893
	int	3
$L195893:

; 575  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L195894
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	575					; 0000023fH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195894
	int	3
$L195894:

; 576  : 	if (lpa == NULL || lpw == NULL)

	cmp	DWORD PTR _lpa$[ebp], 0
	je	SHORT $L75957
	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L75956
$L75957:

; 577  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75953
$L75956:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

	mov	edx, DWORD PTR _lpa$[ebp]
	mov	BYTE PTR [edx], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpa$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpw$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75959

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L195895
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	585					; 00000249H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195895
	int	3
$L195895:

; 586  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75953
$L75959:

; 587  : 	}
; 588  : 	return lpa;

	mov	eax, DWORD PTR _lpa$[ebp]
$L75953:

; 589  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlW2AHelper@@YGPADPADPBGHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	?atlTraceException@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceException
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
CONST	SEGMENT
??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ DB 'AtlThrow: hr '
	DB	'= 0x%x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lexcept.h', 00H				; `string'
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T195900 = -16						; size = 4
$T195899 = -12						; size = 4
$T195898 = -8						; size = 8
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceException@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceException
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	62					; 0000003eH
	push	OFFSET FLAT:??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T195898[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T195900[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T195899[ebp], edx
	push	OFFSET FLAT:__TI1?AVCAtlException@ATL@@
	lea	eax, DWORD PTR $T195899[ebp]
	push	eax
	call	__CxxThrowException@8
$L195897:

; 74   : #endif
; 75   : };

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
; Function compile flags: /Odt /RTCsu
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 162  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 163  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
	call	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z	; ATL::CTrace::TraceV
	add	esp, 28					; 0000001cH

; 164  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 165  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_AtlTraceVA
	add	esp, 28					; 0000001cH

; 123  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 41   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	mov	eax, DWORD PTR __imp__GetStringTypeExW@20
	push	eax
	push	OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ; ATL::GetStringTypeExWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

	mov	esi, esp
	mov	ecx, DWORD PTR _pwCharType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwInfoType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 244  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T195926 DD	0ffffffffH
	DD	FLAT:$L195918
$T195920 DD	019930520H
	DD	01H
	DD	FLAT:$T195926
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
$T195917 = -164						; size = 4
_pszA$ = -156						; size = 132
_nLengthA$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

	mov	edx, DWORD PTR _nLengthA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszSrc$[ebp]
	push	edx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : 
; 232  : 	if (nLength == -1)

	cmp	DWORD PTR _nLength$[ebp], -1
	jne	SHORT $L189894

; 233  : 		nLengthA = -1;

	mov	DWORD PTR _nLengthA$[ebp], -1
$L189894:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

	mov	esi, esp
	mov	eax, DWORD PTR _pwCharType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLengthA$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	edx, DWORD PTR _dwInfoType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR __imp__GetStringTypeExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T195917[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195917[ebp]

; 236  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195925
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L195925:
	DD	1
	DD	$L195924
$L195924:
	DD	-156					; ffffff64H
	DD	132					; 00000084H
	DD	$L195921
$L195921:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L195918:
	lea	ecx, DWORD PTR _pszA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z:
	mov	eax, OFFSET FLAT:$T195920
	jmp	___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPBG0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	mov	eax, DWORD PTR __imp__lstrcmpiW@8
	push	eax
	push	OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPBG0@Z ; ATL::lstrcmpiWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz1$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 258  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?lstrcmpiWThunk@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPBG0@Z PROC NEAR			; ATL::lstrcmpiWFake, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 248  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

	mov	eax, DWORD PTR _psz2$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L195933
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L195934
$L195933:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv76[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv79[ebp], eax
$L195934:
	mov	ecx, DWORD PTR _psz1$[ebp]
	mov	DWORD PTR __lpw$[ebp], ecx
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L195935
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L195936
$L195935:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv91[ebp], esp
	mov	ecx, DWORD PTR __acp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv91[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv94[ebp], eax
$L195936:
	mov	esi, esp
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 251  : }

	lea	esp, DWORD PTR [ebp-36]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?lstrcmpiWFake@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPAGPAG@Z			; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	mov	eax, DWORD PTR __imp__CharLowerW@4
	push	eax
	push	OFFSET FLAT:?CharLowerWFake@ATL@@YGPAGPAG@Z ; ATL::CharLowerWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 277  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharLowerWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPAGPAGPBDHI@Z			; AtlA2WHelper
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	_wcscpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 262  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L195941
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L195942
$L195941:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L195942:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharLowerA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 267  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L195943
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L195944
$L195943:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L195944:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 268  : 
; 269  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 270  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharLowerWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPAGPAGPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 555  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L195947
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	555					; 0000022bH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195947
	int	3
$L195947:

; 556  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L195948
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	556					; 0000022cH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195948
	int	3
$L195948:

; 557  : 	if (lpw == NULL || lpa == NULL)

	cmp	DWORD PTR _lpw$[ebp], 0
	je	SHORT $L75943
	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L75942
$L75943:

; 558  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75936
$L75942:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

	mov	edx, DWORD PTR _lpw$[ebp]
	mov	WORD PTR [edx], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

	mov	esi, esp
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpw$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpa$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75945

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L195949
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195949
	int	3
$L195949:

; 567  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75936
$L75945:

; 568  : 	}		
; 569  : 	return lpw;

	mov	eax, DWORD PTR _lpw$[ebp]
$L75936:

; 570  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlA2WHelper@@YGPAGPAGPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPAGPAG@Z			; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	mov	eax, DWORD PTR __imp__CharUpperW@4
	push	eax
	push	OFFSET FLAT:?CharUpperWFake@ATL@@YGPAGPAG@Z ; ATL::CharUpperWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 296  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharUpperWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 281  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L195954
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L195955
$L195954:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L195955:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 286  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L195956
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L195957
$L195956:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L195957:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 287  : 
; 288  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 289  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharUpperWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	??0CLicense@@QAE@XZ				; CLicense::CLicense
PUBLIC	?getHostOsType@CLicense@@SAJXZ			; CLicense::getHostOsType
PUBLIC	??_7CLicense@@6B@				; CLicense::`vftable'
PUBLIC	??_GCLicense@@UAEPAXI@Z				; CLicense::`scalar deleting destructor'
EXTRN	??_ECLicense@@UAEPAXI@Z:NEAR			; CLicense::`vector deleting destructor'
EXTRN	??0CTime@ATL@@QAE@XZ:NEAR			; ATL::CTime::CTime
;	COMDAT ??_7CLicense@@6B@
; File c:\activex\xmlsign\license.cpp
CONST	SEGMENT
??_7CLicense@@6B@ DD FLAT:??_ECLicense@@UAEPAXI@Z	; CLicense::`vftable'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
_TEXT	SEGMENT
_osType$ = -8						; size = 4
_this$ = -4						; size = 4
??0CLicense@@QAE@XZ PROC NEAR				; CLicense::CLicense
; _this$ = ecx

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CLicense@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CTime@ATL@@QAE@XZ			; ATL::CTime::CTime
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0CTime@ATL@@QAE@XZ			; ATL::CTime::CTime

; 104  : 
; 105  : 	licenseFile = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 106  : 	isLicenseValid = TRUE; // By default the license is valid

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 1

; 107  : 
; 108  : 	licenseKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 109  : 	expYear = expMon = expDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 110  : 	issYear = issMon = issDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 111  : 	maintExpYear = maintExpMon = maintExpDay = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 112  : 	num_of_lic = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 113  : 
; 114  : 
; 115  : 	long osType;
; 116  : 
; 117  : 	osType = getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	DWORD PTR _osType$[ebp], eax

; 118  : 
; 119  : 	if ((osType != 0) && (osType != VER_NT_WORKSTATION))

	cmp	DWORD PTR _osType$[ebp], 0
	je	SHORT $L193239
	cmp	DWORD PTR _osType$[ebp], 1
	je	SHORT $L193239

; 120  : 		 /* It is not a client machine as it is some sort of windows server product */
; 121  : 	{
; 122  : 		isVerifyAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 123  : 		isDecryptAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+76], 0

; 124  : 	}
; 125  : 	else

	jmp	SHORT $L193240
$L193239:

; 126  : 	{
; 127  : 		isVerifyAllowed = TRUE; // Verification is always allowed for client machines

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+64], 1

; 128  : 		isDecryptAllowed = TRUE; // Decryption is always allowed for client machines

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 1
$L193240:

; 129  : 	}
; 130  : 	
; 131  : 	isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 132  : 	isEncryptAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 133  : 	isSecureSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+80], 0

; 134  : 	isSecureSignProfessionalAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], 0

; 135  : 	isSecureSignEnterpriseAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], 0

; 136  : 
; 137  : 	isSecureSignServerAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 138  : 
; 139  : 	isServerLic = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 140  : 	isClientLic = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0

; 141  : 	isDemoLic	= TRUE; /* by default every license is a demo license */

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 1

; 142  : 	isDevelopmentLic = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 143  : 	isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 144  : 
; 145  : 	sigArr = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+148], 0

; 146  : 	signum = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+152], 0

; 147  : 
; 148  : 	licenser = company = user = hostname = version = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+164], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+160], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], 0

; 149  : 	num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 150  : 	linuxClient = windowsClient = solarisClient = macClient = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+144], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+132], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], 0

; 151  : 
; 152  : }

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CLicense@@QAE@XZ ENDP				; CLicense::CLicense
_TEXT	ENDS
PUBLIC	??1CLicense@@UAE@XZ				; CLicense::~CLicense
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCLicense@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCLicense@@UAEPAXI@Z PROC NEAR			; CLicense::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CLicense@@UAE@XZ			; CLicense::~CLicense
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L193244
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L193244:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCLicense@@UAEPAXI@Z ENDP				; CLicense::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp__SysFreeString@4:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CLicense@@UAE@XZ PROC NEAR				; CLicense::~CLicense
; _this$ = ecx

; 155  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CLicense@@6B@

; 156  : #ifdef WIN32
; 157  : 	SysFreeString(licenseKey);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+116]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 158  : 	SysFreeString(licenser);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+156]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 159  : 	SysFreeString(company);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+160]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 160  : 	SysFreeString(user);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+164]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 161  : 	SysFreeString(hostname);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 162  : 	SysFreeString(version);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+112]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 163  : #else
; 164  : 	SysFreeStringLocal(licenseKey);
; 165  : 	SysFreeStringLocal(licenser);
; 166  : 	SysFreeStringLocal(company);
; 167  : 	SysFreeStringLocal(user);
; 168  : 	SysFreeStringLocal(hostname);
; 169  : 	SysFreeStringLocal(version);
; 170  : #endif
; 171  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CLicense@@UAE@XZ ENDP				; CLicense::~CLicense
_TEXT	ENDS
PUBLIC	?A2WBSTR@@YAPAGPBDH@Z				; A2WBSTR
PUBLIC	?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ; CLicense::getLicenseDetails
EXTRN	_xmlStrcmp:NEAR
EXTRN	_xmlParseFile:NEAR
EXTRN	_atoi:NEAR
EXTRN	__imp__xmlFree:DWORD
EXTRN	_xmlFreeDoc:NEAR
EXTRN	_xmlDocGetRootElement:NEAR
EXTRN	_setError:NEAR
EXTRN	_xmlNodeListGetString:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_tmpInt$193330 = -52					; size = 4
_type$193326 = -48					; size = 4
_tmpInt$193314 = -44					; size = 4
_op$193310 = -40					; size = 4
_date$193299 = -36					; size = 4
_date$193288 = -32					; size = 4
_date$193277 = -28					; size = 4
_licensee$193266 = -24					; size = 4
_curr$ = -20						; size = 4
_root$ = -16						; size = 4
_tmpCharPtr$ = -12					; size = 4
_doc$ = -8						; size = 4
_this$ = -4						; size = 4
_SigHandle$ = 8						; size = 4
?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::getLicenseDetails
; _this$ = ecx

; 183  : BOOL CLicense::getLicenseDetails(PGLOBAL_SIG SigHandle) {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 
; 185  : 	xmlDocPtr doc = NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 186  : 	unsigned char *tmpCharPtr=NULL;

	mov	DWORD PTR _tmpCharPtr$[ebp], 0

; 187  : 
; 188  : 	doc = xmlParseFile((const char *)licenseFile);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_xmlParseFile
	add	esp, 4
	mov	DWORD PTR _doc$[ebp], eax

; 189  : 	if (!doc) {

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L193255

; 190  : 		// cout << "Couldn't parse the license file" << endl;
; 191  : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 192  : 		return FALSE;

	xor	eax, eax
	jmp	$L193251
$L193255:

; 193  : 	}
; 194  : 
; 195  : 	xmlNodePtr root = xmlDocGetRootElement(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlDocGetRootElement
	add	esp, 4
	mov	DWORD PTR _root$[ebp], eax

; 196  : 	xmlNodePtr curr = root->xmlChildrenNode;

	mov	ecx, DWORD PTR _root$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _curr$[ebp], edx

; 197  : 	// cout << "Root element name is " << root->name << endl;
; 198  : 
; 199  : 	for ( ; curr != NULL; curr = curr->next) {

	jmp	SHORT $L193258
$L193259:
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _curr$[ebp], ecx
$L193258:
	cmp	DWORD PTR _curr$[ebp], 0
	je	$L193260

; 200  : 
; 201  : 		if (! xmlStrcmp(curr->name, VERSION)) {

	mov	edx, DWORD PTR ?VERSION@CLicense@@2PBEB	; CLicense::VERSION
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193261

; 202  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 203  : 			version = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+112], eax

; 204  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 205  : 			continue;

	jmp	SHORT $L193259
$L193261:

; 206  : 		}
; 207  : 
; 208  : 		if (! xmlStrcmp(curr->name, LICENSER)) {

	mov	ecx, DWORD PTR ?LICENSER@CLicense@@2PBEB ; CLicense::LICENSER
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193263

; 209  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 210  : 			licenser = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+156], eax

; 211  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 212  : 			continue;

	jmp	$L193259
$L193263:

; 213  : 		}
; 214  : 
; 215  : 		if (! xmlStrcmp(curr->name, LICENSEE)) {

	mov	edx, DWORD PTR ?LICENSEE@CLicense@@2PBEB ; CLicense::LICENSEE
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193265

; 216  : 			xmlNodePtr licensee = curr->xmlChildrenNode;

	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _licensee$193266[ebp], eax
$L193268:

; 217  : 			while (licensee != NULL) {

	cmp	DWORD PTR _licensee$193266[ebp], 0
	je	$L193269

; 218  : 				if (! xmlStrcmp(licensee->name, COMPANY))

	mov	ecx, DWORD PTR ?COMPANY@CLicense@@2PBEB	; CLicense::COMPANY
	push	ecx
	mov	edx, DWORD PTR _licensee$193266[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193270

; 219  : 				{
; 220  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _licensee$193266[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 221  : 					company = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+160], eax

; 222  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193270:

; 223  : 				}
; 224  : 				if (! xmlStrcmp(licensee->name, USER))

	mov	edx, DWORD PTR ?USER@CLicense@@2PBEB	; CLicense::USER
	push	edx
	mov	eax, DWORD PTR _licensee$193266[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193272

; 225  : 				{
; 226  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _licensee$193266[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 227  : 					user = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+164], eax

; 228  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193272:

; 229  : 				}
; 230  : 				if (! xmlStrcmp(licensee->name, HOSTNAME))

	mov	ecx, DWORD PTR ?HOSTNAME@CLicense@@2PBEB ; CLicense::HOSTNAME
	push	ecx
	mov	edx, DWORD PTR _licensee$193266[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193274

; 231  : 				{
; 232  : 					tmpCharPtr = xmlNodeListGetString(doc, licensee->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _licensee$193266[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 233  : 					hostname = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+168], eax

; 234  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193274:

; 235  : 				}
; 236  : 				licensee = licensee->next;

	mov	edx, DWORD PTR _licensee$193266[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _licensee$193266[ebp], eax

; 237  : 			}

	jmp	$L193268
$L193269:

; 238  : 			continue;

	jmp	$L193259
$L193265:

; 239  : 		}
; 240  : 
; 241  : 		if (! xmlStrcmp(curr->name, EXP_DATE)) {

	mov	ecx, DWORD PTR ?EXP_DATE@CLicense@@2PBEB ; CLicense::EXP_DATE
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193276

; 242  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _date$193277[ebp], edx
$L193279:

; 243  : 			while (date != NULL) {

	cmp	DWORD PTR _date$193277[ebp], 0
	je	$L193280

; 244  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	eax, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	eax
	mov	ecx, DWORD PTR _date$193277[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193281

; 245  : 				{
; 246  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _date$193277[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 247  : 					expYear = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 248  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193281:

; 249  : 				}
; 250  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$193277[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193283

; 251  : 				{
; 252  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$193277[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 253  : 					expMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], eax

; 254  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193283:

; 255  : 				}
; 256  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$193277[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193285

; 257  : 				{
; 258  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$193277[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 259  : 					expDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 260  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193285:

; 261  : 				}
; 262  : 				date = date->next;

	mov	ecx, DWORD PTR _date$193277[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$193277[ebp], edx

; 263  : 			}

	jmp	$L193279
$L193280:

; 264  : 			continue;

	jmp	$L193259
$L193276:

; 265  : 		}
; 266  : 
; 267  : 		if (! xmlStrcmp(curr->name, MAINT_EXP_DATE)) {

	mov	eax, DWORD PTR ?MAINT_EXP_DATE@CLicense@@2PBEB ; CLicense::MAINT_EXP_DATE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193287

; 268  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _date$193288[ebp], ecx
$L193290:

; 269  : 			while (date != NULL) {

	cmp	DWORD PTR _date$193288[ebp], 0
	je	$L193291

; 270  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	edx, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	edx
	mov	eax, DWORD PTR _date$193288[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193292

; 271  : 				{
; 272  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$193288[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 273  : 					maintExpYear = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 274  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193292:

; 275  : 				}
; 276  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$193288[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193294

; 277  : 				{
; 278  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$193288[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 279  : 					maintExpMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], eax

; 280  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193294:

; 281  : 				}
; 282  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$193288[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193296

; 283  : 				{
; 284  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$193288[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 285  : 					maintExpDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 286  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193296:

; 287  : 				}
; 288  : 				date = date->next;

	mov	ecx, DWORD PTR _date$193288[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$193288[ebp], edx

; 289  : 			}

	jmp	$L193290
$L193291:

; 290  : 			continue;

	jmp	$L193259
$L193287:

; 291  : 		}
; 292  : 
; 293  : 		if (! xmlStrcmp(curr->name, ISSUE_DATE)) {

	mov	eax, DWORD PTR ?ISSUE_DATE@CLicense@@2PBEB ; CLicense::ISSUE_DATE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193298

; 294  : 			xmlNodePtr date = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _date$193299[ebp], ecx
$L193301:

; 295  : 			while (date != NULL) {

	cmp	DWORD PTR _date$193299[ebp], 0
	je	$L193302

; 296  : 				if (! xmlStrcmp(date->name, YEAR))

	mov	edx, DWORD PTR ?YEAR@CLicense@@2PBEB	; CLicense::YEAR
	push	edx
	mov	eax, DWORD PTR _date$193299[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193303

; 297  : 				{
; 298  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$193299[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 299  : 					issYear = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 300  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193303:

; 301  : 				}
; 302  : 				if (! xmlStrcmp(date->name, MON))

	mov	ecx, DWORD PTR ?MON@CLicense@@2PBEB	; CLicense::MON
	push	ecx
	mov	edx, DWORD PTR _date$193299[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193305

; 303  : 				{
; 304  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _date$193299[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 305  : 					issMon = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], eax

; 306  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193305:

; 307  : 				}
; 308  : 				if (! xmlStrcmp(date->name, DAY))

	mov	edx, DWORD PTR ?DAY@CLicense@@2PBEB	; CLicense::DAY
	push	edx
	mov	eax, DWORD PTR _date$193299[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193307

; 309  : 				{
; 310  : 					tmpCharPtr = xmlNodeListGetString(doc, date->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _date$193299[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 311  : 					issDay = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 312  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L193307:

; 313  : 				}
; 314  : 				date = date->next;

	mov	ecx, DWORD PTR _date$193299[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _date$193299[ebp], edx

; 315  : 			}

	jmp	$L193301
$L193302:

; 316  : 			continue;

	jmp	$L193259
$L193298:

; 317  : 		}
; 318  : 
; 319  : 		if (! xmlStrcmp(curr->name, OPERATIONS)) {

	mov	eax, DWORD PTR ?OPERATIONS@CLicense@@2PBEB ; CLicense::OPERATIONS
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193309

; 320  : 			xmlNodePtr op = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _op$193310[ebp], ecx
$L193312:

; 321  : 			while (op != NULL) {

	cmp	DWORD PTR _op$193310[ebp], 0
	je	$L193313

; 322  : 				int tmpInt;
; 323  : 
; 324  : 				if (op->xmlChildrenNode != NULL)

	mov	edx, DWORD PTR _op$193310[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$L193315

; 325  : 				{
; 326  : 					tmpCharPtr = xmlNodeListGetString(doc, op->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _op$193310[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 327  : 					tmpInt = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _tmpInt$193314[ebp], eax

; 328  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 329  : 					if (! xmlStrcmp(op->name, VERIFY))

	mov	eax, DWORD PTR ?VERIFY@CLicense@@2PBEB	; CLicense::VERIFY
	push	eax
	mov	ecx, DWORD PTR _op$193310[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193317

; 330  : 						isVerifyAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [eax+64], ecx
$L193317:

; 331  : 
; 332  : 					if (! xmlStrcmp(op->name, CREATE))

	mov	edx, DWORD PTR ?CREATE@CLicense@@2PBEB	; CLicense::CREATE
	push	edx
	mov	eax, DWORD PTR _op$193310[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193318

; 333  : 						isSignAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [edx+68], eax
$L193318:

; 334  : 
; 335  : 					if (! xmlStrcmp(op->name, ENCRYPT))

	mov	ecx, DWORD PTR ?ENCRYPT@CLicense@@2PBEB	; CLicense::ENCRYPT
	push	ecx
	mov	edx, DWORD PTR _op$193310[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193319

; 336  : 						isEncryptAllowed = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [ecx+72], edx
$L193319:

; 337  : 
; 338  : 					if (! xmlStrcmp(op->name, DECRYPT))

	mov	eax, DWORD PTR ?DECRYPT@CLicense@@2PBEB	; CLicense::DECRYPT
	push	eax
	mov	ecx, DWORD PTR _op$193310[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193320

; 339  : 						isDecryptAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [eax+76], ecx
$L193320:

; 340  : 
; 341  : 					if (! xmlStrcmp(op->name, SECURESIGN))

	mov	edx, DWORD PTR ?SECURESIGN@CLicense@@2PBEB ; CLicense::SECURESIGN
	push	edx
	mov	eax, DWORD PTR _op$193310[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193321

; 342  : 						isSecureSignAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [edx+80], eax
$L193321:

; 343  : 
; 344  : 					if (! xmlStrcmp(op->name, SECURESIGNPROFESSIONAL))

	mov	ecx, DWORD PTR ?SECURESIGNPROFESSIONAL@CLicense@@2PBEB ; CLicense::SECURESIGNPROFESSIONAL
	push	ecx
	mov	edx, DWORD PTR _op$193310[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193322

; 345  : 						isSecureSignProfessionalAllowed = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [ecx+84], edx
$L193322:

; 346  : 
; 347  : 					if (! xmlStrcmp(op->name, SECURESIGNENTERPRISE))

	mov	eax, DWORD PTR ?SECURESIGNENTERPRISE@CLicense@@2PBEB ; CLicense::SECURESIGNENTERPRISE
	push	eax
	mov	ecx, DWORD PTR _op$193310[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193323

; 348  : 						isSecureSignEnterpriseAllowed = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [eax+88], ecx
$L193323:

; 349  : 
; 350  : 					if (! xmlStrcmp(op->name, SECURESIGNSERVER))

	mov	edx, DWORD PTR ?SECURESIGNSERVER@CLicense@@2PBEB ; CLicense::SECURESIGNSERVER
	push	edx
	mov	eax, DWORD PTR _op$193310[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193315

; 351  : 						isSecureSignServerAllowed = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$193314[ebp]
	mov	DWORD PTR [edx+92], eax
$L193315:

; 352  : 				}
; 353  : 				op = op->next;

	mov	ecx, DWORD PTR _op$193310[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR _op$193310[ebp], edx

; 354  : 			}

	jmp	$L193312
$L193313:

; 355  : 			continue;

	jmp	$L193259
$L193309:

; 356  : 		}
; 357  : 
; 358  : 		if (! xmlStrcmp(curr->name, TYPE)) {

	mov	eax, DWORD PTR ?TYPE@CLicense@@2PBEB	; CLicense::TYPE
	push	eax
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	$L193325

; 359  : 			xmlNodePtr type = curr->xmlChildrenNode;

	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _type$193326[ebp], ecx
$L193328:

; 360  : 			while (type != NULL) {

	cmp	DWORD PTR _type$193326[ebp], 0
	je	$L193329

; 361  : 				int tmpInt;
; 362  : 
; 363  : 				if (type->xmlChildrenNode != NULL)

	mov	edx, DWORD PTR _type$193326[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$L193331

; 364  : 				{
; 365  : 					tmpCharPtr = xmlNodeListGetString(doc, type->xmlChildrenNode, 1);

	push	1
	mov	eax, DWORD PTR _type$193326[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 366  : 					tmpInt = atoi((char *)tmpCharPtr);

	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _tmpInt$193330[ebp], eax

; 367  : 					xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 368  : 
; 369  : 					if (! xmlStrcmp(type->name, SERVER))

	mov	eax, DWORD PTR ?SERVER@CLicense@@2PBEB	; CLicense::SERVER
	push	eax
	mov	ecx, DWORD PTR _type$193326[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193333

; 370  : 						isServerLic = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$193330[ebp]
	mov	DWORD PTR [eax+96], ecx
$L193333:

; 371  : 
; 372  : 					if (! xmlStrcmp(type->name, CLIENT))

	mov	edx, DWORD PTR ?CLIENT@CLicense@@2PBEB	; CLicense::CLIENT
	push	edx
	mov	eax, DWORD PTR _type$193326[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193334

; 373  : 						isClientLic = tmpInt;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpInt$193330[ebp]
	mov	DWORD PTR [edx+100], eax
$L193334:

; 374  : 
; 375  : 					if (! xmlStrcmp(type->name, DEMO))

	mov	ecx, DWORD PTR ?DEMO@CLicense@@2PBEB	; CLicense::DEMO
	push	ecx
	mov	edx, DWORD PTR _type$193326[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193335

; 376  : 						isDemoLic = tmpInt;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpInt$193330[ebp]
	mov	DWORD PTR [ecx+104], edx
$L193335:

; 377  : 
; 378  : 					if (! xmlStrcmp(type->name, DEVELOPMENT))

	mov	eax, DWORD PTR ?DEVELOPMENT@CLicense@@2PBEB ; CLicense::DEVELOPMENT
	push	eax
	mov	ecx, DWORD PTR _type$193326[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193331

; 379  : 						isDevelopmentLic = tmpInt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tmpInt$193330[ebp]
	mov	DWORD PTR [eax+108], ecx
$L193331:

; 380  : 				}
; 381  : 
; 382  : 				type = type->next;

	mov	edx, DWORD PTR _type$193326[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR _type$193326[ebp], eax

; 383  : 			}

	jmp	$L193328
$L193329:

; 384  : 			continue;

	jmp	$L193259
$L193325:

; 385  : 		}
; 386  : 
; 387  : 		if (! xmlStrcmp(curr->name, LICENSE_KEY)) {

	mov	ecx, DWORD PTR ?LICENSE_KEY@CLicense@@2PBEB ; CLicense::LICENSE_KEY
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193337

; 388  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 389  : 			licenseKey = A2WBSTR((const char *)tmpCharPtr);

	push	-1
	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	?A2WBSTR@@YAPAGPBDH@Z			; A2WBSTR
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], eax

; 390  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 391  : 			continue;

	jmp	$L193259
$L193337:

; 392  : 		}
; 393  : 
; 394  : 		if (! xmlStrcmp(curr->name, NUM_LICENSE)) {

	mov	edx, DWORD PTR ?NUM_LICENSE@CLicense@@2PBEB ; CLicense::NUM_LICENSE
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193339

; 395  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 396  : 			num_of_lic = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], eax

; 397  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 398  : 			continue;

	jmp	$L193259
$L193339:

; 399  : 		}
; 400  : 		
; 401  : 		if (! xmlStrcmp(curr->name, WINDOWS_CLIENT)) {

	mov	ecx, DWORD PTR ?WINDOWS_CLIENT@CLicense@@2PBEB ; CLicense::WINDOWS_CLIENT
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193341

; 402  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 403  : 			windowsClient = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], eax

; 404  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 405  : 			continue;

	jmp	$L193259
$L193341:

; 406  : 		}
; 407  : 
; 408  : 		if (! xmlStrcmp(curr->name, SOLARIS_CLIENT)) {

	mov	edx, DWORD PTR ?SOLARIS_CLIENT@CLicense@@2PBEB ; CLicense::SOLARIS_CLIENT
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193343

; 409  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 410  : 			solarisClient = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], eax

; 411  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 412  : 			continue;

	jmp	$L193259
$L193343:

; 413  : 		}
; 414  : 		if (! xmlStrcmp(curr->name, LINUX_CLIENT)) {

	mov	ecx, DWORD PTR ?LINUX_CLIENT@CLicense@@2PBEB ; CLicense::LINUX_CLIENT
	push	ecx
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193345

; 415  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	ecx, DWORD PTR _curr$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 416  : 			linuxClient = atoi((char *)tmpCharPtr);

	mov	ecx, DWORD PTR _tmpCharPtr$[ebp]
	push	ecx
	call	_atoi
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], eax

; 417  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	eax, DWORD PTR _tmpCharPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 418  : 			continue;

	jmp	$L193259
$L193345:

; 419  : 		}
; 420  : 		if (! xmlStrcmp(curr->name, MAC_CLIENT)) {

	mov	edx, DWORD PTR ?MAC_CLIENT@CLicense@@2PBEB ; CLicense::MAC_CLIENT
	push	edx
	mov	eax, DWORD PTR _curr$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_xmlStrcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193347

; 421  : 			tmpCharPtr = xmlNodeListGetString(doc, curr->xmlChildrenNode, 1);

	push	1
	mov	edx, DWORD PTR _curr$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlNodeListGetString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _tmpCharPtr$[ebp], eax

; 422  : 			macClient = atoi((char *)tmpCharPtr);

	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax

; 423  : 			xmlFree(tmpCharPtr);

	mov	esi, esp
	mov	edx, DWORD PTR _tmpCharPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 424  : 			continue;

	jmp	$L193259
$L193347:

; 425  : 		}
; 426  : 	}

	jmp	$L193259
$L193260:

; 427  : 
; 428  : 	xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 429  : 
; 430  : 	return TRUE;

	mov	eax, 1
$L193251:

; 431  : }

	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?getLicenseDetails@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::getLicenseDetails
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ ; `string'
EXTRN	__imp__SysAllocStringLen@8:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
xdata$x	SEGMENT
$T195975 DD	0ffffffffH
	DD	FLAT:$L195968
$T195970 DD	019930520H
	DD	01H
	DD	FLAT:$T195975
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT
??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@ DB 'nResult == nC'
	DB	'onvertedLen', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT
$T195967 = -64						; size = 4
$T195966 = -60						; size = 4
_nResult$76112 = -56					; size = 4
_nAllocLen$ = -52					; size = 4
_nConvertedLen$ = -48					; size = 4
_str$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lp$ = 8						; size = 4
_nLen$ = 12						; size = 4
?A2WBSTR@@YAPAGPBDH@Z PROC NEAR				; A2WBSTR, COMDAT

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?A2WBSTR@@YAPAGPBDH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 776  : 	if (lp == NULL || nLen == 0)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $L76085
	cmp	DWORD PTR _nLen$[ebp], 0
	jne	SHORT $L76084
$L76085:

; 777  : 		return NULL;

	xor	eax, eax
	jmp	$L76083
$L76084:

; 778  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 779  : 	BSTR str = NULL;

	mov	DWORD PTR _str$[ebp], 0

; 780  : 	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp,
; 781  : 		nLen, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nConvertedLen$[ebp], eax

; 782  : 	int nAllocLen = nConvertedLen;

	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	mov	DWORD PTR _nAllocLen$[ebp], eax

; 783  : 	if (nLen == -1)

	cmp	DWORD PTR _nLen$[ebp], -1
	jne	SHORT $L76110

; 784  : 		nAllocLen -= 1;  // Don't allocate terminating '\0'

	mov	ecx, DWORD PTR _nAllocLen$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _nAllocLen$[ebp], ecx
$L76110:

; 785  : 	str = ::SysAllocStringLen(NULL, nAllocLen);

	mov	esi, esp
	mov	edx, DWORD PTR _nAllocLen$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__SysAllocStringLen@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _str$[ebp], eax

; 786  : 
; 787  : 	if (str != NULL)

	cmp	DWORD PTR _str$[ebp], 0
	je	$L76111

; 788  : 	{
; 789  : 		int nResult;
; 790  : 		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);

	mov	esi, esp
	mov	eax, DWORD PTR _nConvertedLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _str$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _lp$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nResult$76112[ebp], eax

; 791  : 		ATLASSERT(nResult == nConvertedLen);

	mov	edx, DWORD PTR _nResult$76112[ebp]
	cmp	edx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L195965
	push	OFFSET FLAT:??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
	push	0
	push	791					; 00000317H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L195965
	int	3
$L195965:

; 792  : 		if(nResult != nConvertedLen)

	mov	ecx, DWORD PTR _nResult$76112[ebp]
	cmp	ecx, DWORD PTR _nConvertedLen$[ebp]
	je	SHORT $L76111

; 793  : 		{
; 794  : 			SysFreeString(str);

	mov	esi, esp
	mov	edx, DWORD PTR _str$[ebp]
	push	edx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 795  : 			return NULL;

	mov	DWORD PTR $T195966[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195966[ebp]
	jmp	SHORT $L76083
$L76111:

; 796  : 		}
; 797  : 
; 798  : 	}
; 799  : 	return str;

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR $T195967[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T195967[ebp]
$L76083:

; 800  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195974
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	add	esp, 64					; 00000040H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L195974:
	DD	1
	DD	$L195973
$L195973:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L195971
$L195971:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L195968:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?A2WBSTR@@YAPAGPBDH@Z:
	mov	eax, OFFSET FLAT:$T195970
	jmp	___CxxFrameHandler
text$x	ENDS
?A2WBSTR@@YAPAGPBDH@Z ENDP				; A2WBSTR
EXTRN	_memset:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\license.cpp
_TEXT	SEGMENT
_osvi$ = -168						; size = 156
_bOsVersionInfoEx$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?getHostOsType@CLicense@@SAJXZ PROC NEAR		; CLicense::getHostOsType

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-172]
	mov	ecx, 43					; 0000002bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 435  :     BOOL bOsVersionInfoEx;
; 436  : 	OSVERSIONINFOEX osvi;
; 437  :    // Try calling GetVersionEx using the OSVERSIONINFOEX structure.
; 438  :    // If that fails, try using the OSVERSIONINFO structure.
; 439  : 
; 440  :    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

	push	156					; 0000009cH
	push	0
	lea	eax, DWORD PTR _osvi$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 441  :    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	mov	DWORD PTR _osvi$[ebp], 156		; 0000009cH

; 442  : 
; 443  : #ifdef WIN32
; 444  :    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )

	mov	esi, esp
	lea	ecx, DWORD PTR _osvi$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _bOsVersionInfoEx$[ebp], eax
	cmp	DWORD PTR _bOsVersionInfoEx$[ebp], 0
	jne	SHORT $L193357

; 445  :    {
; 446  :       // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
; 447  :       osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

	mov	DWORD PTR _osvi$[ebp], 148		; 00000094H

; 448  :       if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 

	mov	esi, esp
	lea	edx, DWORD PTR _osvi$[ebp]
	push	edx
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L193357

; 449  : 	  {
; 450  : 		  return 0;

	xor	eax, eax
	jmp	SHORT $L193351
$L193357:

; 451  : 	  }
; 452  :    }
; 453  : #endif
; 454  : #ifdef LOGGING
; 455  :    char buffer[BUFSIZ];
; 456  :    ZeroMemory(buffer, BUFSIZ);
; 457  :    sprintf((char *)buffer, "dwOSVersionInfoSize = %x", osvi.dwOSVersionInfoSize);
; 458  :    DebugLog((const char *)buffer);
; 459  :    sprintf((char *)buffer, "dwBuildNumber = %x", osvi.dwBuildNumber);
; 460  :    DebugLog((const char *)buffer);
; 461  :    sprintf((char *)buffer, "dwMajorVersion = %x", osvi.dwMajorVersion);
; 462  :    DebugLog((const char *)buffer);
; 463  :    sprintf((char *)buffer, "dwMinorVersion = %x", osvi.dwMinorVersion);
; 464  :    DebugLog((const char *)buffer);
; 465  :    sprintf((char *)buffer, "dwPlatformId = %x", osvi.dwPlatformId);
; 466  :    DebugLog((const char *)buffer);
; 467  :    sprintf((char *)buffer, "wProductType = %x", osvi.wProductType);
; 468  :    DebugLog((const char *)buffer);
; 469  : #endif
; 470  :    return( (long) osvi.wProductType);

	movzx	eax, BYTE PTR _osvi$[ebp+154]
$L193351:

; 471  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L195984
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 172				; 000000acH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L195984:
	DD	1
	DD	$L195983
$L195983:
	DD	-168					; ffffff58H
	DD	156					; 0000009cH
	DD	$L195981
$L195981:
	DB	111					; 0000006fH
	DB	115					; 00000073H
	DB	118					; 00000076H
	DB	105					; 00000069H
	DB	0
?getHostOsType@CLicense@@SAJXZ ENDP			; CLicense::getHostOsType
_TEXT	ENDS
PUBLIC	?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z	; CLicense::verifyLicense
PUBLIC	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z	; CLicense::Get_CRC_CheckSum
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
EXTRN	__imp__GetComputerNameA@8:NEAR
EXTRN	__imp__StrStrIA@8:NEAR
EXTRN	_rFree:NEAR
EXTRN	_axVerifyFile:NEAR
EXTRN	_axGetSignature:NEAR
EXTRN	_strcmp:NEAR
EXTRN	?HeapW2A@@YAPAEPAG@Z:NEAR			; HeapW2A
EXTRN	_xsFree:NEAR
EXTRN	?GetYear@CTime@ATL@@QBEHXZ:NEAR			; ATL::CTime::GetYear
EXTRN	?GetMonth@CTime@ATL@@QBEHXZ:NEAR		; ATL::CTime::GetMonth
EXTRN	?GetDay@CTime@ATL@@QBEHXZ:NEAR			; ATL::CTime::GetDay
EXTRN	__imp__GetSystemTime@4:NEAR
xdata$x	SEGMENT
$T196020 DD	0ffffffffH
	DD	FLAT:$L195997
	DD	00H
	DD	FLAT:$L195998
	DD	01H
	DD	FLAT:$L195999
	DD	02H
	DD	FLAT:$L196000
	DD	03H
	DD	FLAT:$L196001
	DD	04H
	DD	FLAT:$L196002
	DD	03H
	DD	FLAT:$L196002
$T196004 DD	019930520H
	DD	07H
	DD	FLAT:$T196020
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv308 = -688						; size = 4
tv150 = -684						; size = 4
$T195996 = -680						; size = 4
$T195995 = -676						; size = 4
$T195994 = -672						; size = 4
$T195993 = -668						; size = 4
$T195992 = -664						; size = 4
$T195991 = -660						; size = 4
$T195990 = -656						; size = 4
$T195989 = -652						; size = 4
$T195988 = -648						; size = 28
$T195987 = -620						; size = 4
_osType$ = -616						; size = 4
__lpa$ = -612						; size = 4
__lpw$ = -608						; size = 4
__acp$ = -604						; size = 4
__convert$ = -600					; size = 4
_licHostName$ = -596					; size = 4
_lpnSize$ = -588					; size = 4
_lpBuffer$ = -576					; size = 260
_isexp$ = -309						; size = 1
_currDay$ = -308					; size = 4
_currMon$ = -304					; size = 4
_currYear$ = -300					; size = 4
_t$ = -292						; size = 16
_X509Cert$ = -268					; size = 28
_Cert2$ = -232						; size = 28
_junk2$ = -196						; size = 20
_Cert3$ = -168						; size = 28
_junk1$ = -132						; size = 20
_Cert1$ = -104						; size = 28
_cert_in_lic$ = -68					; size = 28
_ret_val$ = -36						; size = 4
_crcValue$ = -28					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_SigHandle$ = 8						; size = 4
?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyLicense
; _this$ = ecx

; 473  : BOOL CLicense::verifyLicense(PGLOBAL_SIG SigHandle) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 676				; 000002a4H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-688]
	mov	ecx, 169				; 000000a9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 474  : 
; 475  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 476  : 	// Here we are verifying the signature of the license file.
; 477  : 	// If license file is modified, the signature verification will fail.
; 478  : 	int ret_val = axVerifyFile((const xmlChar *)licenseFile, NULL, FALSE, -1, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_axVerifyFile
	add	esp, 20					; 00000014H
	mov	DWORD PTR _ret_val$[ebp], eax

; 479  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	SHORT $L193369

; 480  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 481  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 482  : 		return FALSE;

	xor	eax, eax
	jmp	$L193365
$L193369:

; 483  : 	}
; 484  : 	// We also need to verify that the license is signed with our certificate
; 485  : 
; 486  : 	// Sizes of the strings 1024 + 1024 + 460
; 487  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	push	eax
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 488  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	SHORT $L193370

; 489  : 		// There can't be more than one signature in the license file.
; 490  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 491  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 492  : 		xsFree(SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_xsFree
	add	esp, 4

; 493  : 		return FALSE;

	xor	eax, eax
	jmp	$L193365
$L193370:

; 494  : 	}
; 495  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 496  : 	
; 497  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $L193372
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	cmp	DWORD PTR [eax+2048], 0
	je	SHORT $L193372

; 498  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+2048]
	push	edx
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 499  : 	else {

	jmp	SHORT $L193374
$L193372:

; 500  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 501  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 502  : 		xsFree(SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_xsFree
	add	esp, 4

; 503  : 		return FALSE;

	mov	DWORD PTR $T195987[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195987[ebp]
	jmp	$L193365
$L193374:

; 504  : 	}
; 505  : 	xsFree(SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_xsFree
	add	esp, 4

; 506  : 	// This is the certificate that should be used to create XML Licenses for
; 507  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 508  : 	// executable to check against the license used.
; 509  : 
; 510  : 	const string Cert1 = "MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCBvzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWwgU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxIzAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBTaWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlbnNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jACKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdBn2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A";

	push	OFFSET FLAT:$SG193377
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 511  : // Insert some junk data so that search for X509 cert match in the dll fails
; 512  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 513  : 	const string Cert3 = "cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBAKcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/sXMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzrrTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKmbpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=";	

	push	OFFSET FLAT:$SG193380
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 514  : // Insert some junk data so that search for X509 cert match in the dll fails
; 515  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 516  : 	const string Cert2 = "aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTERMA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbWVudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArblPpz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl";

	push	OFFSET FLAT:$SG193383
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 517  : 
; 518  : 	string X509Cert = Cert1 + Cert2 + Cert3;

	lea	ecx, DWORD PTR _Cert2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _Cert1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T195988[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv308[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	edx, DWORD PTR _Cert3$[ebp]
	push	edx
	mov	eax, DWORD PTR tv308[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T195988[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 519  : 
; 520  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	edx, DWORD PTR _crcValue$[ebp]
	push	edx
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 521  : 	if (crcValue != 0xE771) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 59249	; 0000e771H
	je	SHORT $L193396

; 522  : 	{
; 523  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 524  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 525  : 		return FALSE;

	mov	DWORD PTR $T195989[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195989[ebp]
	jmp	$L193365
$L193396:

; 526  : 	}
; 527  : 	if (X509Cert != cert_in_lic) {

	lea	edx, DWORD PTR _cert_in_lic$[ebp]
	push	edx
	lea	eax, DWORD PTR _X509Cert$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L193405

; 528  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 529  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 530  : 		return FALSE;

	mov	DWORD PTR $T195990[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195990[ebp]
	jmp	$L193365
$L193405:

; 531  : 	}
; 532  : 	// Now check the date etc.. of the license.
; 533  : 	SYSTEMTIME t;
; 534  : #ifdef WIN32
; 535  : 	GetSystemTime(&t);

	mov	esi, esp
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 536  : #else
; 537  : 	GetSystemTimeLinux(&t);
; 538  : #endif
; 539  : 	int currYear = t.wYear;

	movzx	edx, WORD PTR _t$[ebp]
	mov	DWORD PTR _currYear$[ebp], edx

; 540  : 	int currMon = t.wMonth;

	movzx	eax, WORD PTR _t$[ebp+2]
	mov	DWORD PTR _currMon$[ebp], eax

; 541  : 	int currDay = t.wDay;

	movzx	ecx, WORD PTR _t$[ebp+6]
	mov	DWORD PTR _currDay$[ebp], ecx

; 542  : 
; 543  : 	bool isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 544  : 	if (currYear < expYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _currYear$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jge	SHORT $L193412

; 545  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 546  : 	else if (currYear == expYear)

	jmp	SHORT $L193413
$L193412:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _currYear$[ebp]
	cmp	edx, DWORD PTR [ecx+28]
	jne	SHORT $L193413

; 547  : 		if (currMon < expMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _currMon$[ebp]
	cmp	ecx, DWORD PTR [eax+32]
	jge	SHORT $L193415

; 548  : 			isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 549  : 		else if (currMon == expMon)

	jmp	SHORT $L193413
$L193415:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _currMon$[ebp]
	cmp	eax, DWORD PTR [edx+32]
	jne	SHORT $L193413

; 550  : 			if (currDay <= expDay)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _currDay$[ebp]
	cmp	edx, DWORD PTR [ecx+36]
	jg	SHORT $L193413

; 551  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L193413:

; 552  : 
; 553  : 	if (isexp) {

	movzx	eax, BYTE PTR _isexp$[ebp]
	test	eax, eax
	je	$L193419

; 554  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 555  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 556  : 		num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 557  : 		return FALSE;

	mov	DWORD PTR $T195991[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195991[ebp]
	jmp	$L193365
$L193419:

; 558  : 	}
; 559  : 
; 560  : #ifdef WIN32
; 561  : 	releaseYear = releaseTime.GetYear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetYear@CTime@ATL@@QBEHXZ		; ATL::CTime::GetYear
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 562  : 	releaseMonth = releaseTime.GetMonth();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetMonth@CTime@ATL@@QBEHXZ		; ATL::CTime::GetMonth
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 563  : 	releaseDay = releaseTime.GetDay();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetDay@CTime@ATL@@QBEHXZ		; ATL::CTime::GetDay
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 564  : #endif
; 565  : 
; 566  : 	isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 567  : 	if (releaseYear < maintExpYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+52]
	jge	SHORT $L193421

; 568  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 569  : 	else

	jmp	SHORT $L193422
$L193421:

; 570  : 	{
; 571  : 		if (releaseYear == maintExpYear)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+52]
	jne	SHORT $L193422

; 572  : 		{
; 573  : 			if (releaseMonth < maintExpMon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $L193424

; 574  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 575  : 			else 

	jmp	SHORT $L193422
$L193424:

; 576  : 			{
; 577  : 				if (releaseMonth == maintExpMon)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	cmp	ecx, DWORD PTR [eax+56]
	jne	SHORT $L193422

; 578  : 				{
; 579  : 					if (releaseDay <= maintExpDay)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	cmp	ecx, DWORD PTR [eax+60]
	jg	SHORT $L193422

; 580  : 					{
; 581  : 						isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L193422:

; 582  : 					}
; 583  : 				}
; 584  : 			}
; 585  : 		}
; 586  : 	}
; 587  : 
; 588  : 	if (isexp) {

	movzx	edx, BYTE PTR _isexp$[ebp]
	test	edx, edx
	je	$L193428

; 589  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 590  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 591  : 		isVerifyAllowed = FALSE; // Maintenance has expired so don't allow either sign or verify

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 592  : 		num_of_lic = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], 0

; 593  : 		return FALSE;

	mov	DWORD PTR $T195992[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195992[ebp]
	jmp	$L193365
$L193428:

; 594  : 	}
; 595  : 
; 596  : 	char lpBuffer[MAX_PATH];
; 597  : 	unsigned long lpnSize=MAX_PATH;

	mov	DWORD PTR _lpnSize$[ebp], 260		; 00000104H

; 598  : 	char *licHostName;
; 599  : 
; 600  : USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 601  : 
; 602  : 	licHostName = (char *)HeapW2A(hostname);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+168]
	push	edx
	call	?HeapW2A@@YAPAEPAG@Z			; HeapW2A
	add	esp, 4
	mov	DWORD PTR _licHostName$[ebp], eax

; 603  : 	if (strcmp((const char *)licHostName,"TrialHost"))

	push	OFFSET FLAT:$SG193440
	mov	eax, DWORD PTR _licHostName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	je	$L193439

; 604  : 	{
; 605  : #ifdef WIN32
; 606  : 		GetComputerName( lpBuffer,  // name buffer
; 607  : 						&lpnSize                // size of name buffer
; 608  : 						);

	mov	esi, esp
	lea	ecx, DWORD PTR _lpnSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpBuffer$[ebp]
	push	edx
	call	DWORD PTR __imp__GetComputerNameA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 609  : #else
; 610  : 		gethostname(lpBuffer, MAX_PATH);
; 611  : #endif
; 612  : 		if (!(StrStrI((const char *)licHostName, (const char *)lpBuffer)))

	mov	esi, esp
	lea	eax, DWORD PTR _lpBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _licHostName$[ebp]
	push	ecx
	call	DWORD PTR __imp__StrStrIA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L193439

; 613  : 		{
; 614  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 615  : 			isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 616  : 			zFree(licHostName);

	mov	ecx, DWORD PTR _licHostName$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 617  : 			return FALSE;

	mov	DWORD PTR $T195993[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195993[ebp]
	jmp	$L193365
$L193439:

; 618  : 		}
; 619  : 	}
; 620  : 	zFree(licHostName);

	mov	edx, DWORD PTR _licHostName$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 621  : 
; 622  : 	long osType;
; 623  : 
; 624  : 	osType = getHostOsType();

	call	?getHostOsType@CLicense@@SAJXZ		; CLicense::getHostOsType
	mov	DWORD PTR _osType$[ebp], eax

; 625  : 	if ((osType != 0) && (osType != VER_NT_WORKSTATION))

	cmp	DWORD PTR _osType$[ebp], 0
	je	$L193446
	cmp	DWORD PTR _osType$[ebp], 1
	je	$L193446

; 626  : 		 /* It is not a client machine as it is some sort of windows server product */
; 627  : 	{
; 628  : 		if (isServerLic == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+96], 0
	jne	SHORT $L193447

; 629  : 		{
; 630  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 631  : 			isLicenseValid = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 0

; 632  : 			return FALSE;

	mov	DWORD PTR $T195994[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195994[ebp]
	jmp	$L193365
$L193447:

; 633  : 		}
; 634  : 	}
; 635  : 	else

	jmp	SHORT $L193449
$L193446:

; 636  : 	{
; 637  : 		if (isClientLic == FALSE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	jne	SHORT $L193449

; 638  : 		{
; 639  : 			setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 640  : 			isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 641  : 			return FALSE;

	mov	DWORD PTR $T195995[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195995[ebp]
	jmp	SHORT $L193365
$L193449:

; 642  : 		}
; 643  : 	}
; 644  : 
; 645  : 	// We verified the values in the license file.
; 646  : 
; 647  : 	isLicenseValid = TRUE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 1

; 648  : 	return TRUE;

	mov	DWORD PTR $T195996[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T195996[ebp]
$L193365:

; 649  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L196019
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 688				; 000002b0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L196019:
	DD	11					; 0000000bH
	DD	$L196018
$L196018:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L196005
	DD	-68					; ffffffbcH
	DD	28					; 0000001cH
	DD	$L196006
	DD	-104					; ffffff98H
	DD	28					; 0000001cH
	DD	$L196007
	DD	-132					; ffffff7cH
	DD	20					; 00000014H
	DD	$L196008
	DD	-168					; ffffff58H
	DD	28					; 0000001cH
	DD	$L196009
	DD	-196					; ffffff3cH
	DD	20					; 00000014H
	DD	$L196010
	DD	-232					; ffffff18H
	DD	28					; 0000001cH
	DD	$L196011
	DD	-268					; fffffef4H
	DD	28					; 0000001cH
	DD	$L196012
	DD	-292					; fffffedcH
	DD	16					; 00000010H
	DD	$L196013
	DD	-576					; fffffdc0H
	DD	260					; 00000104H
	DD	$L196014
	DD	-588					; fffffdb4H
	DD	4
	DD	$L196015
$L196015:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	110					; 0000006eH
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L196014:
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L196013:
	DB	116					; 00000074H
	DB	0
$L196012:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L196011:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L196010:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L196009:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L196008:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L196007:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L196006:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L196005:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L195997:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L195998:
	lea	ecx, DWORD PTR _Cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L195999:
	lea	ecx, DWORD PTR _Cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196000:
	lea	ecx, DWORD PTR _Cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196001:
	lea	ecx, DWORD PTR $T195988[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196002:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T196004
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyLicense@CLicense@@QAEHPAU_GLOBAL_SIG@@@Z ENDP	; CLicense::verifyLicense
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_bTmp$ = -5						; size = 1
_pb$ = -4						; size = 4
_pBuffer$ = 8						; size = 4
_ulSize$ = 12						; size = 4
_pulSeed$ = 16						; size = 4
?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z PROC NEAR	; CLicense::Get_CRC_CheckSum

; 665  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 666  :   PBYTE    pb;
; 667  :   BYTE    bTmp;
; 668  : 
; 669  :   for (pb=(BYTE *)pBuffer; ulSize; ulSize--, pb++)

	mov	eax, DWORD PTR _pBuffer$[ebp]
	mov	DWORD PTR _pb$[ebp], eax
	jmp	SHORT $L193463
$L193464:
	mov	ecx, DWORD PTR _ulSize$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulSize$[ebp], ecx
	mov	edx, DWORD PTR _pb$[ebp]
	add	edx, 1
	mov	DWORD PTR _pb$[ebp], edx
$L193463:
	cmp	DWORD PTR _ulSize$[ebp], 0
	je	SHORT $L193459

; 670  :   {
; 671  :     bTmp=(BYTE)(((WORD)*pb)^((WORD)*pulSeed));    // Xor CRC with new char

	mov	eax, DWORD PTR _pb$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pulSeed$[ebp]
	movzx	eax, WORD PTR [edx]
	xor	ecx, eax
	mov	BYTE PTR _bTmp$[ebp], cl

; 672  :     *pulSeed=((*pulSeed)>>8) ^ wCRC16a[bTmp&0x0F] ^ wCRC16b[bTmp>>4];

	mov	ecx, DWORD PTR _pulSeed$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 8
	movzx	eax, BYTE PTR _bTmp$[ebp]
	and	eax, 15					; 0000000fH
	movzx	ecx, WORD PTR ?wCRC16a@@3PAGA[eax*2]
	xor	edx, ecx
	movzx	eax, BYTE PTR _bTmp$[ebp]
	sar	eax, 4
	movzx	ecx, WORD PTR ?wCRC16b@@3PAGA[eax*2]
	xor	edx, ecx
	mov	eax, DWORD PTR _pulSeed$[ebp]
	mov	DWORD PTR [eax], edx

; 673  :   }

	jmp	SHORT $L193464
$L193459:

; 674  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ENDP		; CLicense::Get_CRC_CheckSum
_TEXT	ENDS
PUBLIC	?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z ; CLicense::verifyFloatingLicense
EXTRN	_base64decodeSize:NEAR
EXTRN	_base64decode:NEAR
EXTRN	_axVerify:NEAR
EXTRN	_malloc:NEAR
EXTRN	_strlen:NEAR
EXTRN	_strchr:NEAR
EXTRN	_strstr:NEAR
EXTRN	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z:NEAR	; ATL::CTime::CTime
EXTRN	_vbNowTimeToSystem:NEAR
xdata$x	SEGMENT
$T196051 DD	0ffffffffH
	DD	FLAT:$L196026
	DD	00H
	DD	FLAT:$L196027
	DD	01H
	DD	FLAT:$L196028
	DD	02H
	DD	FLAT:$L196029
	DD	03H
	DD	FLAT:$L196030
	DD	04H
	DD	FLAT:$L196031
	DD	05H
	DD	FLAT:$L196032
	DD	03H
	DD	FLAT:$L196032
	DD	07H
	DD	FLAT:$L196031
	DD	07H
	DD	FLAT:$L196033
$T196035 DD	019930520H
	DD	0aH
	DD	FLAT:$T196051
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv462 = -452						; size = 4
tv73 = -448						; size = 4
tv460 = -444						; size = 4
tv77 = -440						; size = 4
$T196025 = -436						; size = 28
$T196024 = -408						; size = 28
_licTime$ = -376					; size = 8
_floatLicTimeStamp$ = -364				; size = 4
_isexp$ = -357						; size = 1
_i$193510 = -356					; size = 4
_equalPtr$ = -352					; size = 4
_propNumber$ = -348					; size = 4
_timeStr$ = -344					; size = 4
_length$ = -340						; size = 4
_cert_in_lic$ = -332					; size = 28
_ret_val$ = -300					; size = 4
_X509Cert$ = -292					; size = 28
_crcValue$ = -256					; size = 4
_cert3$ = -244						; size = 28
_junk3$ = -208						; size = 20
_cert1$ = -180						; size = 28
_junk2$ = -144						; size = 20
_cert2$ = -116						; size = 28
_junk1$ = -80						; size = 20
_cert4$ = -52						; size = 28
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_inputXMLStr$ = 8					; size = 4
_size$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyFloatingLicense
; _this$ = ecx

; 677  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 440				; 000001b8H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-452]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 678  : 	const string cert4 = "LmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbigxKS5jcnQwDQYJKoZIhvcNAQEFBQADggEBAFrOd7OXXrIwQB5Fz+AZTt2mgvdXkJlrneuWoyEF3DSoZfSdGqaORmWEdNcWbcxmN+xl81bWwCmdi99emBvH0sIEvS9u8y4c93zG/qg3+Icu3/KNYDGAXBWJFdnCyTPfBdhTw1AmXOHepQ9i2C51S4wA8keQoaH1yCwQjcSA3cRAlweg0BkpBM1NRx+jOlMgLmCETb+8iZ1vDQZ0SBulO60cX7pdD/cQUE5mbeII/enkaECj8eC9CuPrhmL5D3B0xSgXOGryWNIAl1gcIM2+wt+D92vN8n0WiZ1LA9DNvZPY17DePeEEwxk1Kd33C+F9Tw9q57b4rsjY/PaM9Gi8FG0=";

	push	OFFSET FLAT:$SG193476
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 679  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 680  : 	const string cert2 = "b24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALgb0p8Fh0O1DwZyXDONau+SqVvM3IDvqDDjMLQ8uR4BnGXjiGqgjdrH4obZekYYcjWIWu01vPMAYYHH198gmsFxHphndAsPllBUl0iX4JEhyBtZAo7koED+J+9aMNkVAjkA4AG17Z/MfglAH+/EwsvI9nPwwsW1P9lFcQsZivIxAgMBAAGjggIzMIICLzAOBgNVHQ8BAf8EBAMCBPAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAX3Ts8591e+/KCE4jgHJqKw5EqzMIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYHEpIHBMIG+MSIwIAYJKoZIhvcNAQkB";

	push	OFFSET FLAT:$SG193479
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 681  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 682  : 	const string cert1 = "MIIFvzCCBKegAwIBAgIKFDX9YgABAAAG5DANBgkqhkiG9w0BAQUFADCBvjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIERpZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24wHhcNMDMxMDAzMjIyOTUxWhcNMTMxMDAzMjE1OTUzWjCByjEjMCEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRp";

	push	OFFSET FLAT:$SG193482
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 683  : 	const int	 junk3[5] = { 0x0112a123, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk3$[ebp], 17998115	; 0112a123H
	mov	DWORD PTR _junk3$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk3$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk3$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk3$[ebp+16], 17497089	; 010afc01H

; 684  : 	const string cert3 = "FhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYXR1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQKiQ6i/TBzo1KZki1g15oZzBeBgNVHR8EVzBVMFOgUaBPhk1odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvSW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLmNybDCBiwYIKwYBBQUHAQEEfzB9MHsGCCsGAQUFBzAChm9odHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvaW5mb21vc2FpYy1zcnZy";

	push	OFFSET FLAT:$SG193485
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 685  : 
; 686  : //	const string cert3 = "YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0NlcnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBADkFy7R4bgPZoWi1v0Nro7J0ZSNpa8xAuzgwa9ff5dJDuiB3ER4EAiws5O3DFUv8W0dfsFX262PJKk1jkcIRwox7e5ZzKU+1XUVc6vM9vXk1lvYiNsy5n4h9fUskMJNnotky2Z8SZ/7vL+iGeOP9Wti5U779Ues2BxZMHaFYR+dzWpz6xC64rqwSBDeZq3VIXFfXnS3q7yqEGS287Q4P8jAntM7ImN2brFieSL597nNSW7pEOlFRV462A3IPzTTjQSoS5M99XqIyCfw+NL8oyfOoV8mhVm0JmqlodYAelJpwDswGUuzdSjJl91iBluMJR0uMx4mE+KkeV1+r7HF7A4U=";
; 687  : // Insert some junk data so that search for X509 cert match in the dll fails
; 688  : //	const string cert2 = "/7Ufng45apgE7V1MIH6BgNVHSMEgfIwge+AFMg6HvPyz5/mwAhQO2rq5Yz+TbXuoYHEpIHBMIG+MSIwIAYJKoZIhvcNAQkBFhNpbmZvQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExFDASBgNVBAcTC1NhbnRhIENsYXJhMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSYwJAYDVQQLEx1NYWtpbmcgRGlnaXRhbCBTaWduYXR1cmUgRWFzeTEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQdOykPAAmzJZAPfFU7pEKWDCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/";
; 689  : // Insert some junk data so that search for X509 cert match in the dll fails
; 690  : //	const string cert1 = "MIIHWjCCBkKgAwIBAgIKGg1iMAAAAAAGsjANBgkqhkiG9w0BAQUFADCBvjEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRQwEgYDVQQHEwtTYW50YSBDbGFyYTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEmMCQGA1UECxMdTWFraW5nIERpZ2l0YWwgU2lnbmF0dXJlIEVhc3kxHzAdBgNVBAMTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24wHhcNMDMwOTEyMDAyMTM5WhcNMDQwOTEyMDAzMTM5WjCByjEjMCEGCSqGSIb3DQEJARYUc2FsZXNAaW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTEUMBIGA1UEBxMLU2FudGEgQ2xhcmExHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xJjAkBgNVBAsTHU1ha2luZyBEaWdpdGFsIFNpZ25hdHVyZSBFYXN5MSowKAYDVQQDEyFTZWN1cmVYTUwgRmxvYXRpbmcgTGljZW5zZSBJc3N1ZXIwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAOjh54QWn49CV32AgiWGReEAN4VkufrByl0QW8LblTfJu8C5Uge66I31M6puAz9HtXI+EFSIKbahbQpR4uM/wroeD5oEnL3kHiWyRRBipFqF5JkvMShg6x0Y+OTec1ooSEWkBkujsk4vW8wKsQGaxbjlxCfPvIsN7bzX1dpgWvBHAgMBAAGjggPOMIIDyjAOBgNVHQ8BAf8EBAMCBPAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwHQYDVR0OBBYEFAByQ3GdrZYaO";
; 691  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 692  : 	
; 693  : 	string X509Cert = cert1 + cert2 + cert3 + cert4;

	lea	eax, DWORD PTR _cert2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cert1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T196024[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv77[ebp], eax
	mov	eax, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv460[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _cert3$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv460[ebp]
	push	edx
	lea	eax, DWORD PTR $T196025[ebp]
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv73[ebp], eax
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv462[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	edx, DWORD PTR _cert4$[ebp]
	push	edx
	mov	eax, DWORD PTR tv462[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T196025[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T196024[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 694  : 
; 695  : 	EnterLog;
; 696  : //	DebugBreak();
; 697  : 
; 698  : 	// Here we are verifying the signature of the license file.
; 699  : 	// If license file is modified, the signature verification will fail.
; 700  : 	int ret_val = axVerify((const xmlChar *)inputXMLStr, size, NULL, FALSE, -1, 1, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	push	1
	push	-1
	push	0
	push	0
	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputXMLStr$[ebp]
	push	ecx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$[ebp], eax

; 701  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	SHORT $L193493

; 702  : 		DebugLog("axVerify() for floating license xml failed");
; 703  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 704  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 705  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193493:

; 706  : 	}
; 707  : 
; 708  : 	// We also need to verify that the license is signed with our certificate
; 709  : 
; 710  : 	// Sizes of the strings 1024 + 1024 + 460
; 711  : 
; 712  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 152				; 00000098H
	push	edx
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 713  : 
; 714  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	SHORT $L193494

; 715  : 		// There can't be more than one signature in the license file.
; 716  : 		DebugLog("signum != 1 from axGetSignature() after axVerify() for floating license xml");
; 717  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 718  : 		isSignAllowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+68], 0

; 719  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193494:

; 720  : 	}
; 721  : 
; 722  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 723  : 	
; 724  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $L193496
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	cmp	DWORD PTR [edx+2048], 0
	je	SHORT $L193496

; 725  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR [eax+2048]
	push	ecx
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 726  : 	else {

	jmp	SHORT $L193498
$L193496:

; 727  : 		DebugLog("Certificate not present in the output from axGetSignature()");
; 728  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 729  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 730  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193498:

; 731  : 	}
; 732  : 
; 733  : 	// This is the certificate that should be used to create floating Licenses for
; 734  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 735  : 	// executable to check against the license used.
; 736  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	ecx, DWORD PTR _crcValue$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 737  : 	if (crcValue != 0xF3E9) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 62441	; 0000f3e9H
	je	SHORT $L193501

; 738  : //	if (crcValue != 0x5C68) // Someone patched the dll with a different X509 cert
; 739  : 	{
; 740  : 		DebugLog("Checksum validation failed");
; 741  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 742  : 		isSignAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 0

; 743  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193501:

; 744  : 	}
; 745  : 	if (X509Cert != cert_in_lic) {

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	push	ecx
	lea	edx, DWORD PTR _X509Cert$[ebp]
	push	edx
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $L193502

; 746  : 		DebugLog("X509 Data not the same as expected in floating license");
; 747  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 748  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 749  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193502:

; 750  : 	}
; 751  : 
; 752  : 	// Now check the date etc.. of the license.
; 753  : 
; 754  : 	unsigned int length = strlen((const char *)(sigArr[0]->refArray[0]->refObject->encodedData));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+256]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _length$[ebp], eax

; 755  : 	size = base64decodeSize(length);

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _size$[ebp], eax

; 756  : 	unsigned char *timeStr = (unsigned char *)zMalloc(size+1);

	mov	edx, DWORD PTR _size$[ebp]
	add	edx, 1
	push	edx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _timeStr$[ebp], eax

; 757  : 	if ((size = base64decode(sigArr[0]->refArray[0]->refObject->encodedData, timeStr, size+1)) == -1)

	mov	eax, DWORD PTR _size$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _timeStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+256]
	push	edx
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _size$[ebp], eax
	cmp	DWORD PTR _size$[ebp], -1
	jne	SHORT $L193507

; 758  : 	{
; 759  : 		DebugLog("Base64 decode failed");
; 760  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 761  : 		isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 762  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193507:

; 763  : 	}
; 764  : 	int propNumber = sigArr[0]->propNumber;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _propNumber$[ebp], edx

; 765  : 	char *equalPtr=NULL;

	mov	DWORD PTR _equalPtr$[ebp], 0

; 766  : 	for (int i=0; i<propNumber; i++)

	mov	DWORD PTR _i$193510[ebp], 0
	jmp	SHORT $L193511
$L193512:
	mov	eax, DWORD PTR _i$193510[ebp]
	add	eax, 1
	mov	DWORD PTR _i$193510[ebp], eax
$L193511:
	mov	ecx, DWORD PTR _i$193510[ebp]
	cmp	ecx, DWORD PTR _propNumber$[ebp]
	jge	$L193513

; 767  : 	{
; 768  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryYear") != NULL)

	push	OFFSET FLAT:$SG193517
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193516

; 769  : 		{
; 770  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 771  : 			maintExpYear = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+52], eax
$L193516:

; 772  : 		}
; 773  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryMonth") != NULL)

	push	OFFSET FLAT:$SG193523
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193522

; 774  : 		{
; 775  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 776  : 			maintExpMon = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], eax
$L193522:

; 777  : 		}
; 778  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MaintExpiryDay") != NULL)

	push	OFFSET FLAT:$SG193529
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193528

; 779  : 		{
; 780  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 781  : 			maintExpDay = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], eax
$L193528:

; 782  : 		}
; 783  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"LinuxClient") != NULL)

	push	OFFSET FLAT:$SG193535
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193534

; 784  : 		{
; 785  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 786  : 			linuxClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+136], eax
$L193534:

; 787  : 		}
; 788  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"WindowsClient") != NULL)

	push	OFFSET FLAT:$SG193541
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193540

; 789  : 		{
; 790  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 791  : 			windowsClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+132], eax
$L193540:

; 792  : 		}
; 793  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"SolarisClient") != NULL)

	push	OFFSET FLAT:$SG193547
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193546

; 794  : 		{
; 795  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 796  : 			solarisClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+144], eax
$L193546:

; 797  : 		}
; 798  : 		if (strstr((const char *)sigArr[0]->propArray[i], (const char *)"MacClient") != NULL)

	push	OFFSET FLAT:$SG193553
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $L193552

; 799  : 		{
; 800  : 			equalPtr = strchr((const char *)sigArr[0]->propArray[i], '=');

	push	61					; 0000003dH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _i$193510[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _equalPtr$[ebp], eax

; 801  : 			macClient = atoi((const char *)++equalPtr);

	mov	edx, DWORD PTR _equalPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _equalPtr$[ebp], edx
	mov	eax, DWORD PTR _equalPtr$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+140], eax
$L193552:

; 802  : 		}
; 803  : 	}

	jmp	$L193512
$L193513:

; 804  : 
; 805  : #ifdef WIN32
; 806  : 	releaseYear = releaseTime.GetYear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetYear@CTime@ATL@@QBEHXZ		; ATL::CTime::GetYear
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 807  : 	releaseMonth = releaseTime.GetMonth();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetMonth@CTime@ATL@@QBEHXZ		; ATL::CTime::GetMonth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 808  : 	releaseDay = releaseTime.GetDay();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?GetDay@CTime@ATL@@QBEHXZ		; ATL::CTime::GetDay
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], eax

; 809  : #endif
; 810  : 	
; 811  : 	bool isexp = true;

	mov	BYTE PTR _isexp$[ebp], 1

; 812  : 	if (releaseYear < maintExpYear)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+52]
	jge	SHORT $L193557

; 813  : 		isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 814  : 	else

	jmp	SHORT $L193558
$L193557:

; 815  : 	{
; 816  : 		if (releaseYear == maintExpYear)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+52]
	jne	SHORT $L193558

; 817  : 		{
; 818  : 			if (releaseMonth < maintExpMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+56]
	jge	SHORT $L193560

; 819  : 				isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0

; 820  : 			else 

	jmp	SHORT $L193558
$L193560:

; 821  : 			{
; 822  : 				if (releaseMonth == maintExpMon)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+56]
	jne	SHORT $L193558

; 823  : 				{
; 824  : 					if (releaseDay <= maintExpDay)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+60]
	jg	SHORT $L193558

; 825  : 					{
; 826  : 						isexp = false;

	mov	BYTE PTR _isexp$[ebp], 0
$L193558:

; 827  : 					}
; 828  : 				}
; 829  : 			}
; 830  : 		}
; 831  : 	}
; 832  : 
; 833  : 	if (isexp) {

	movzx	eax, BYTE PTR _isexp$[ebp]
	test	eax, eax
	je	$L193564

; 834  : 		setError(SigHandle, LICENSE_EXPIRED);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 835  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 836  : 		isVerifyAllowed = FALSE; // Maintenance has expired so don't allow either sign or verify

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 837  : 		num_of_lic = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 838  : 		isLicenseFloating = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 0

; 839  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193564:

; 840  : 	}
; 841  : 
; 842  : #ifdef WIN32
; 843  : 	if (windowsClient == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+132], 0
	jne	$L193565

; 844  : 	{
; 845  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 846  : 		isSignAllowed = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+68], 0

; 847  : 		isVerifyAllowed = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+64], 0

; 848  : 		isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 849  : 		num_of_lic = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+128], 0

; 850  : 		DebugLog("WindowsClient is not allowed");
; 851  : 		return;

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$L193474
$L193565:

; 852  : 	}
; 853  : #endif
; 854  : 
; 855  : 	//DebugBreak();
; 856  : 	LPSYSTEMTIME floatLicTimeStamp = vbNowTimeToSystem((BYTE *)(char *)timeStr);

	mov	eax, DWORD PTR _timeStr$[ebp]
	push	eax
	call	_vbNowTimeToSystem
	add	esp, 4
	mov	DWORD PTR _floatLicTimeStamp$[ebp], eax

; 857  : 	DebugLog("Time in floating license data = ");
; 858  : 	DebugLog((const char *)timeStr);
; 859  : 	CTime licTime(*floatLicTimeStamp, -1);

	push	-1
	mov	ecx, DWORD PTR _floatLicTimeStamp$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _licTime$[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 860  : 
; 861  : 	floatingLicenseTime = licTime;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _licTime$[ebp]
	mov	DWORD PTR [edx+172], eax
	mov	ecx, DWORD PTR _licTime$[ebp+4]
	mov	DWORD PTR [edx+176], ecx

; 862  : 	isLicenseFloating = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], 1

; 863  : 	zFree(timeStr);

	mov	eax, DWORD PTR _timeStr$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 864  : 	zFree(floatLicTimeStamp);

	mov	ecx, DWORD PTR _floatLicTimeStamp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 865  : 	ExitLog;
; 866  : }

	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert4$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L193474:
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L196050
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 452				; 000001c4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L196050:
	DD	11					; 0000000bH
	DD	$L196049
$L196049:
	DD	-52					; ffffffccH
	DD	28					; 0000001cH
	DD	$L196036
	DD	-80					; ffffffb0H
	DD	20					; 00000014H
	DD	$L196037
	DD	-116					; ffffff8cH
	DD	28					; 0000001cH
	DD	$L196038
	DD	-144					; ffffff70H
	DD	20					; 00000014H
	DD	$L196039
	DD	-180					; ffffff4cH
	DD	28					; 0000001cH
	DD	$L196040
	DD	-208					; ffffff30H
	DD	20					; 00000014H
	DD	$L196041
	DD	-244					; ffffff0cH
	DD	28					; 0000001cH
	DD	$L196042
	DD	-256					; ffffff00H
	DD	4
	DD	$L196043
	DD	-292					; fffffedcH
	DD	28					; 0000001cH
	DD	$L196044
	DD	-332					; fffffeb4H
	DD	28					; 0000001cH
	DD	$L196045
	DD	-376					; fffffe88H
	DD	8
	DD	$L196046
$L196046:
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L196045:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L196044:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L196043:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$L196042:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L196041:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	51					; 00000033H
	DB	0
$L196040:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L196039:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L196038:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L196037:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L196036:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	52					; 00000034H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L196026:
	lea	ecx, DWORD PTR _cert4$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196027:
	lea	ecx, DWORD PTR _cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196028:
	lea	ecx, DWORD PTR _cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196029:
	lea	ecx, DWORD PTR _cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196030:
	lea	ecx, DWORD PTR $T196024[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196031:
	lea	ecx, DWORD PTR $T196025[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196032:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196033:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T196035
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyFloatingLicense@CLicense@@QAEXPAEKPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyFloatingLicense
PUBLIC	?floatingLicenseStatus@CLicense@@QAEHXZ		; CLicense::floatingLicenseStatus
EXTRN	?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ:NEAR	; ATL::CTimeSpan::GetTotalMinutes
EXTRN	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z:NEAR	; ATL::CTime::operator-
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
tv137 = -80						; size = 8
tv134 = -72						; size = 8
_timeDiff$193577 = -60					; size = 8
_curTime$193576 = -44					; size = 8
_allowedTimeOut$ = -32					; size = 4
_t$ = -24						; size = 16
_this$ = -4						; size = 4
?floatingLicenseStatus@CLicense@@QAEHXZ PROC NEAR	; CLicense::floatingLicenseStatus
; _this$ = ecx

; 869  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 870  : 	SYSTEMTIME t;
; 871  : 	int allowedTimeOut=licenseTimeout;

	mov	DWORD PTR _allowedTimeOut$[ebp], 30	; 0000001eH

; 872  : //DebugBreak();
; 873  : 	if (isLicenseFloating == TRUE)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+124], 1
	jne	$L193575

; 874  : 	{
; 875  : #ifdef LOGGING
; 876  : 		unsigned char buffer[BUFSIZ];
; 877  : #endif
; 878  : #ifdef WIN32
; 879  : 		GetSystemTime(&t);

	mov	esi, esp
	lea	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSystemTime@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 880  : #else
; 881  : 		GetSystemTimeLinux(&t);
; 882  : #endif
; 883  : 		CTime curTime(t, -1);

	push	-1
	lea	edx, DWORD PTR _t$[ebp]
	push	edx
	lea	ecx, DWORD PTR _curTime$193576[ebp]
	call	??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z	; ATL::CTime::CTime

; 884  : 		CTimeSpan timeDiff = curTime - floatingLicenseTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	push	ecx
	mov	edx, DWORD PTR [eax+172]
	push	edx
	lea	eax, DWORD PTR _timeDiff$193577[ebp]
	push	eax
	lea	ecx, DWORD PTR _curTime$193576[ebp]
	call	??GCTime@ATL@@QBE?AVCTimeSpan@1@V01@@Z	; ATL::CTime::operator-

; 885  : #ifdef LOGGING
; 886  : 		sprintf((char *)buffer, "Time difference = %d", timeDiff.GetTotalMinutes());
; 887  : 		DebugLog((const char *)buffer);
; 888  : #endif
; 889  : 		//if (::dwMinorVersion == 0)
; 890  : 		//	allowedTimeOut += 60;
; 891  : 
; 892  : 		if (timeDiff.GetTotalMinutes() >= allowedTimeOut)

	lea	ecx, DWORD PTR _timeDiff$193577[ebp]
	call	?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ	; ATL::CTimeSpan::GetTotalMinutes
	mov	ecx, eax
	mov	esi, edx
	mov	eax, DWORD PTR _allowedTimeOut$[ebp]
	cdq
	mov	DWORD PTR tv134[ebp], ecx
	mov	DWORD PTR tv134[ebp+4], esi
	mov	DWORD PTR tv137[ebp], eax
	mov	DWORD PTR tv137[ebp+4], edx
	mov	edx, DWORD PTR tv134[ebp+4]
	cmp	edx, DWORD PTR tv137[ebp+4]
	jl	SHORT $L193579
	jg	SHORT $L196053
	mov	eax, DWORD PTR tv134[ebp]
	cmp	eax, DWORD PTR tv137[ebp]
	jb	SHORT $L193579
$L196053:

; 893  : 		{
; 894  : 			isLicenseFloating = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 0

; 895  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L193572
$L193579:

; 896  : 		}
; 897  : 		else
; 898  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L193572
$L193575:

; 899  : 	}
; 900  : 	else
; 901  : 		return FALSE;

	xor	eax, eax
$L193572:

; 902  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L196058
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L196058:
	DD	3
	DD	$L196057
$L196057:
	DD	-24					; ffffffe8H
	DD	16					; 00000010H
	DD	$L196054
	DD	-44					; ffffffd4H
	DD	8
	DD	$L196055
	DD	-60					; ffffffc4H
	DD	8
	DD	$L196056
$L196056:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	0
$L196055:
	DB	99					; 00000063H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L196054:
	DB	116					; 00000074H
	DB	0
?floatingLicenseStatus@CLicense@@QAEHXZ ENDP		; CLicense::floatingLicenseStatus
_TEXT	ENDS
PUBLIC	?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSignature
xdata$x	SEGMENT
$T196086 DD	0ffffffffH
	DD	FLAT:$L196066
	DD	00H
	DD	FLAT:$L196067
	DD	01H
	DD	FLAT:$L196068
	DD	02H
	DD	FLAT:$L196069
	DD	03H
	DD	FLAT:$L196070
	DD	04H
	DD	FLAT:$L196071
	DD	03H
	DD	FLAT:$L196071
$T196073 DD	019930520H
	DD	07H
	DD	FLAT:$T196086
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
_TEXT	SEGMENT
tv214 = -332						; size = 4
tv145 = -328						; size = 4
$T196065 = -324						; size = 4
$T196064 = -320						; size = 4
$T196063 = -316						; size = 4
$T196062 = -312						; size = 28
$T196061 = -284						; size = 4
_X509Cert$ = -276					; size = 28
_Cert2$ = -240						; size = 28
_junk2$ = -204						; size = 20
_Cert3$ = -176						; size = 28
_junk1$ = -140						; size = 20
_Cert1$ = -112						; size = 28
_cert_in_lic$ = -76					; size = 28
_ret_val$ = -44						; size = 4
_xpathResultPtr$ = -40					; size = 4
_xpathPtr$ = -36					; size = 4
_crcValue$ = -28					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_templateSource$ = 8					; size = 4
_sizeM$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyTemplateSignature
; _this$ = ecx

; 905  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 320				; 00000140H
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-332]
	mov	ecx, 80					; 00000050H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 906  : 	ULONG crcValue=0xff01ff01;

	mov	DWORD PTR _crcValue$[ebp], -16646399	; ff01ff01H

; 907  : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 908  : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 909  : 
; 910  : 	int ret_val = axVerify((const xmlChar *)templateSource, sizeM, NULL, FALSE, -1, 1, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	push	1
	push	-1
	push	0
	push	0
	mov	ecx, DWORD PTR _sizeM$[ebp]
	push	ecx
	mov	edx, DWORD PTR _templateSource$[ebp]
	push	edx
	call	_axVerify
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _ret_val$[ebp], eax

; 911  : 
; 912  : 	if (!ret_val) {

	cmp	DWORD PTR _ret_val$[ebp], 0
	jne	SHORT $L193593

; 913  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 914  : 		return FALSE;

	xor	eax, eax
	jmp	$L193587
$L193593:

; 915  : 	}
; 916  : 
; 917  : 	// We also need to verify that the license is signed with our certificate
; 918  : 
; 919  : 	// Sizes of the strings 1024 + 1024 + 460
; 920  : 
; 921  : 	sigArr = axGetSignature(&signum, SigHandle);

	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 152				; 00000098H
	push	edx
	call	_axGetSignature
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+148], eax

; 922  : 
; 923  : 	if (signum != 1) {

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+152], 1
	je	SHORT $L193594

; 924  : 		// There can't be more than one signature in the license file.
; 925  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 926  : 		return FALSE;

	xor	eax, eax
	jmp	$L193587
$L193594:

; 927  : 	}
; 928  : 
; 929  : 	string cert_in_lic;

	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 930  : 	
; 931  : 	if (sigArr[0]->signerCert && sigArr[0]->signerCert->certificate)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $L193596
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+148]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+24]
	cmp	DWORD PTR [ecx+2048], 0
	je	SHORT $L193596

; 932  : 		cert_in_lic = (char *)(sigArr[0]->signerCert->certificate);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+148]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR [edx+2048]
	push	eax
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 933  : 	else {

	jmp	SHORT $L193598
$L193596:

; 934  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 935  : 		return FALSE;

	mov	DWORD PTR $T196061[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T196061[ebp]
	jmp	$L193587
$L193598:

; 936  : 	}
; 937  : 
; 938  : 	// This is the certificate that should be used to create XML Licenses for
; 939  : 	// Infomosaic Corporation. This is being incorporated into the birary
; 940  : 	// executable to check against the license used.
; 941  : 
; 942  : 	const string Cert1 = "MIIHVDCCBjygAwIBAgIKJbmN0QAAAAABVDANBgkqhkiG9w0BAQUFADCBvzEiMCAGCSqGSIb3DQEJARYTaW5mb0BpbmZvbW9zYWljLmNvbTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMREwDwYDVQQHEwhTYW4gSm9zZTEfMB0GA1UEChMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvbjEqMCgGA1UECxMhWE1MIERpZ2l0YWwgU2lnbmF0dXJlIERldmVsb3BtZW50MR8wHQYDVQQDExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMB4XDTAyMDUyMzIzMjYxN1oXDTAzMDUyMzIzMzYxN1owgcIxIzAhBgkqhkiG9w0BCQEWFHNhbGVzQGluZm9tb3NhaWMuY29tMQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExETAPBgNVBAcTCFNhbiBKb3NlMR8wHQYDVQQKExZJbmZvbW9zYWljIENvcnBvcmF0aW9uMSowKAYDVQQLEyFYTUwgRGlnaXRhbCBTaWduYXR1cmUgRGV2ZWxvcG1lbnQxITAfBgNVBAMTGFNlY3VyZVhNTCBMaWNlbnNlIFNpZ25lcjCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvpEsRpF1jACKaOFENwvBnk47MnBywKvwZ3asWNLr+L3ibjrsxpA+yBMRbRXoYaEK4goGyH2qdANCfBPc0SMwiAWSY/moSSRBxcqL5kmgMeJB37Lw6cKy0HU2UC9kwg5bXgdBn2JeM4sN+/n4No7iteft75zuqGI8Z0BqNOQ2m+cCAwEAAaOCA88wggPLMA4GA1UdDwEB/wQEAwIE8DATBgNVHSUEDDAKBggrBgEFBQcDAjAdBgNVHQ4EFgQUBn2JDstuotvk/TRfp7CvueNy/oowgfsGA1UdIwSB8zCB8IAUyDoe8/LPn+bACFA7aurljP5Nte6hgcWkgcIwgb8xIjAgBgkqhkiG9w0BCQEWE2luZm9A";

	push	OFFSET FLAT:$SG193601
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 943  : // Insert some junk data so that search for X509 cert match in the dll fails
; 944  : 	const int	 junk1[5] = {0xff01ff01, 0x0112abcd, 0x45fa23cd, 0x010afc01, 0x4578fbd1};

	mov	DWORD PTR _junk1$[ebp], -16646399	; ff01ff01H
	mov	DWORD PTR _junk1$[ebp+4], 18000845	; 0112abcdH
	mov	DWORD PTR _junk1$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk1$[ebp+12], 17497089	; 010afc01H
	mov	DWORD PTR _junk1$[ebp+16], 1165556689	; 4578fbd1H

; 945  : 	const string Cert3 = "cnRFbnJvbGwvaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0X0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcnQwDQYJKoZIhvcNAQEFBQADggEBAKcMX8EMUUnaLgv+d31IpemMMlDDmvUlPLu6T/sFsh3j7eQrjUhsVKTZ303Q+2dh0Qv7REfPLCb1T1Uxbj9bCaEh2UVZSwDdDXETO5QztkLyQZXWPfaUMbHQU/sXMZ7PZBfVo6pMRSTKKY7Lc7wWuDI4HsKDt1Ny2LTyZZdei3LNwLA3WhxuYDzrrTYL0IDOU4HxYhSsQqRUPWhZzBL0QKH/KBspukXK8X5ZdSNJKHDcdyqftaln5FSrh/uth+9fdJIRiJhXKSvnotetBsTRRz4DAR6yLyLou8LTYhfFKHRi7ZOAKmbpkQhtdqXXMkzSoUqvnCIJ5w9WkQGP/9WBKT4=";	

	push	OFFSET FLAT:$SG193604
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 946  : // Insert some junk data so that search for X509 cert match in the dll fails
; 947  : 	const int	 junk2[5] = { 0x0112abcd, 0xff01ff01, 0x45fa23cd, 0x4578fbd1, 0x010afc01};

	mov	DWORD PTR _junk2$[ebp], 18000845	; 0112abcdH
	mov	DWORD PTR _junk2$[ebp+4], -16646399	; ff01ff01H
	mov	DWORD PTR _junk2$[ebp+8], 1174021069	; 45fa23cdH
	mov	DWORD PTR _junk2$[ebp+12], 1165556689	; 4578fbd1H
	mov	DWORD PTR _junk2$[ebp+16], 17497089	; 010afc01H

; 948  : 	const string Cert2 = "aW5mb21vc2FpYy5jb20xCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJDQTERMA8GA1UEBxMIU2FuIEpvc2UxHzAdBgNVBAoTFkluZm9tb3NhaWMgQ29ycG9yYXRpb24xKjAoBgNVBAsTIVhNTCBEaWdpdGFsIFNpZ25hdHVyZSBEZXZlbG9wbWVudDEfMB0GA1UEAxMWSW5mb21vc2FpYyBDb3Jwb3JhdGlvboIQN2ikHVFArblPpz2OZYaSNjCCATgGA1UdHwSCAS8wggErMIHToIHQoIHNhoHKbGRhcDovLy9DTj1JbmZvbW9zYWljJTIwQ29ycG9yYXRpb24sQ049aW5mb21vc2FpYy1zcnZyLENOPUNEUCxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NlcnRpZmljYXRlUmV2b2NhdGlvbkxpc3Q/YmFzZT9vYmplY3RjbGFzcz1jUkxEaXN0cmlidXRpb25Qb2ludDBToFGgT4ZNaHR0cDovL2luZm9tb3NhaWMtc3J2ci5pbmZvbW9zYWljLm5ldC9DZXJ0RW5yb2xsL0luZm9tb3NhaWMlMjBDb3Jwb3JhdGlvbi5jcmwwggFJBggrBgEFBQcBAQSCATswggE3MIG6BggrBgEFBQcwAoaBrWxkYXA6Ly8vQ049SW5mb21vc2FpYyUyMENvcnBvcmF0aW9uLENOPUFJQSxDTj1QdWJsaWMlMjBLZXklMjBTZXJ2aWNlcyxDTj1TZXJ2aWNlcyxDTj1Db25maWd1cmF0aW9uLERDPWluZm9tb3NhaWMsREM9bmV0P2NBQ2VydGlmaWNhdGU/YmFzZT9vYmplY3RjbGFzcz1jZXJ0aWZpY2F0aW9uQXV0aG9yaXR5MHgGCCsGAQUFBzAChmxodHRwOi8vaW5mb21vc2FpYy1zcnZyLmluZm9tb3NhaWMubmV0L0Nl";

	push	OFFSET FLAT:$SG193607
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 949  : 
; 950  : 	string X509Cert = Cert1 + Cert2 + Cert3;

	lea	edx, DWORD PTR _Cert2$[ebp]
	push	edx
	lea	eax, DWORD PTR _Cert1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T196062[ebp]
	push	ecx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv214[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	eax, DWORD PTR _Cert3$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv214[ebp]
	push	ecx
	lea	edx, DWORD PTR _X509Cert$[ebp]
	push	edx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T196062[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 951  : 
; 952  : 	Get_CRC_CheckSum((PVOID) X509Cert.c_str(), (ULONG) X509Cert.length(), &crcValue);

	lea	eax, DWORD PTR _crcValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
	push	eax
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
	push	eax
	call	?Get_CRC_CheckSum@CLicense@@SAXPAXKPAK@Z ; CLicense::Get_CRC_CheckSum
	add	esp, 12					; 0000000cH

; 953  : 	if (crcValue != 0xE771) // Someone patched the dll with a different X509 cert

	cmp	DWORD PTR _crcValue$[ebp], 59249	; 0000e771H
	je	SHORT $L193613

; 954  : 	{
; 955  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 956  : 		return FALSE;

	mov	DWORD PTR $T196063[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T196063[ebp]
	jmp	$L193587
$L193613:

; 957  : 	}
; 958  : 	if (X509Cert != cert_in_lic) {

	lea	edx, DWORD PTR _cert_in_lic$[ebp]
	push	edx
	lea	eax, DWORD PTR _X509Cert$[ebp]
	push	eax
	call	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L193615

; 959  : 		setError(SigHandle, INVALID_SECUREXML_LIC);

	push	47					; 0000002fH
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 960  : 		return FALSE;

	mov	DWORD PTR $T196064[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T196064[ebp]
	jmp	SHORT $L193587
$L193615:

; 961  : 	}
; 962  : 	return TRUE;

	mov	DWORD PTR $T196065[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _Cert2$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _Cert3$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _Cert1$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T196065[ebp]
$L193587:

; 963  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L196085
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 332				; 0000014cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L196085:
	DD	8
	DD	$L196084
$L196084:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L196074
	DD	-76					; ffffffb4H
	DD	28					; 0000001cH
	DD	$L196075
	DD	-112					; ffffff90H
	DD	28					; 0000001cH
	DD	$L196076
	DD	-140					; ffffff74H
	DD	20					; 00000014H
	DD	$L196077
	DD	-176					; ffffff50H
	DD	28					; 0000001cH
	DD	$L196078
	DD	-204					; ffffff34H
	DD	20					; 00000014H
	DD	$L196079
	DD	-240					; ffffff10H
	DD	28					; 0000001cH
	DD	$L196080
	DD	-276					; fffffeecH
	DD	28					; 0000001cH
	DD	$L196081
$L196081:
	DB	88					; 00000058H
	DB	53					; 00000035H
	DB	48					; 00000030H
	DB	57					; 00000039H
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	0
$L196080:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	50					; 00000032H
	DB	0
$L196079:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	50					; 00000032H
	DB	0
$L196078:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	51					; 00000033H
	DB	0
$L196077:
	DB	106					; 0000006aH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	107					; 0000006bH
	DB	49					; 00000031H
	DB	0
$L196076:
	DB	67					; 00000043H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	49					; 00000031H
	DB	0
$L196075:
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	116					; 00000074H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	108					; 0000006cH
	DB	105					; 00000069H
	DB	99					; 00000063H
	DB	0
$L196074:
	DB	99					; 00000063H
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
text$x	SEGMENT
$L196066:
	lea	ecx, DWORD PTR _cert_in_lic$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196067:
	lea	ecx, DWORD PTR _Cert1$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196068:
	lea	ecx, DWORD PTR _Cert3$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196069:
	lea	ecx, DWORD PTR _Cert2$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196070:
	lea	ecx, DWORD PTR $T196062[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196071:
	lea	ecx, DWORD PTR _X509Cert$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z:
	mov	eax, OFFSET FLAT:$T196073
	jmp	___CxxFrameHandler
text$x	ENDS
?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyTemplateSignature
PUBLIC	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
EXTRN	_xmlSchemaNewValidCtxt:NEAR
EXTRN	_xmlSchemaFreeValidCtxt:NEAR
EXTRN	_xmlSchemaValidateDoc:NEAR
EXTRN	_xmlSchemaNewMemParserCtxt:NEAR
EXTRN	_xmlSchemaFreeParserCtxt:NEAR
EXTRN	_xmlSchemaParse:NEAR
EXTRN	_xmlSchemaFree:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_validationResult$ = -20				; size = 4
_schemaValidCtxtPtr$ = -16				; size = 4
_schemaPtr$ = -12					; size = 4
_schemaParserCtxtPtr$ = -8				; size = 4
_this$ = -4						; size = 4
_schemaDataStr$ = 8					; size = 4
_doc$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::validateXmlWithSchema
; _this$ = ecx

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 967  : 	xmlSchemaParserCtxtPtr schemaParserCtxtPtr = xmlSchemaNewMemParserCtxt((const char *)schemaDataStr, strlen((const char *)schemaDataStr));

	mov	eax, DWORD PTR _schemaDataStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _schemaDataStr$[ebp]
	push	ecx
	call	_xmlSchemaNewMemParserCtxt
	add	esp, 8
	mov	DWORD PTR _schemaParserCtxtPtr$[ebp], eax

; 968  : 	xmlSchemaPtr		   schemaPtr		   = xmlSchemaParse(schemaParserCtxtPtr);

	mov	edx, DWORD PTR _schemaParserCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaParse
	add	esp, 4
	mov	DWORD PTR _schemaPtr$[ebp], eax

; 969  : 	xmlSchemaValidCtxtPtr  schemaValidCtxtPtr = xmlSchemaNewValidCtxt (schemaPtr);

	mov	eax, DWORD PTR _schemaPtr$[ebp]
	push	eax
	call	_xmlSchemaNewValidCtxt
	add	esp, 4
	mov	DWORD PTR _schemaValidCtxtPtr$[ebp], eax

; 970  : 	int validationResult = xmlSchemaValidateDoc(schemaValidCtxtPtr, doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _schemaValidCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaValidateDoc
	add	esp, 8
	mov	DWORD PTR _validationResult$[ebp], eax

; 971  : 	xmlSchemaFreeValidCtxt(schemaValidCtxtPtr);

	mov	eax, DWORD PTR _schemaValidCtxtPtr$[ebp]
	push	eax
	call	_xmlSchemaFreeValidCtxt
	add	esp, 4

; 972  : 	xmlSchemaFree(schemaPtr);

	mov	ecx, DWORD PTR _schemaPtr$[ebp]
	push	ecx
	call	_xmlSchemaFree
	add	esp, 4

; 973  : 	xmlSchemaFreeParserCtxt(schemaParserCtxtPtr);

	mov	edx, DWORD PTR _schemaParserCtxtPtr$[ebp]
	push	edx
	call	_xmlSchemaFreeParserCtxt
	add	esp, 4

; 974  : 
; 975  : //#endif
; 976  : 	// We verified the values in the license file.
; 977  : 	if (validationResult == 0)

	cmp	DWORD PTR _validationResult$[ebp], 0
	jne	SHORT $L193630

; 978  : 		return TRUE;

	mov	eax, 1
	jmp	SHORT $L193623
$L193630:

; 979  : 	else
; 980  : 		return FALSE;

	xor	eax, eax
$L193623:

; 981  : }

	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ENDP ; CLicense::validateXmlWithSchema
_TEXT	ENDS
PUBLIC	?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::verifyFormSchema
EXTRN	_xmlXPathFreeObject:NEAR
EXTRN	_xmlXPathNewContext:NEAR
EXTRN	_xmlXPathFreeContext:NEAR
EXTRN	_xmlXPathEvalExpression:NEAR
EXTRN	_xmlParseMemory:NEAR
EXTRN	_xmlXPathRegisterNs:NEAR
EXTRN	_sprintf:NEAR
EXTRN	_xmlUnlinkNode:NEAR
EXTRN	_xmlFreeNode:NEAR
EXTRN	_xmlNodeGetContent:NEAR
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_result$ = -40						; size = 4
_schemaDataNode$ = -36					; size = 4
_schemaData$ = -32					; size = 4
_templateXMLDoc$ = -28					; size = 4
_secureSignNode$193655 = -24				; size = 4
_i$193651 = -20						; size = 4
_ptemp$ = -16						; size = 4
_xpathResultPtr$ = -12					; size = 4
_xpathPtr$ = -8						; size = 4
_this$ = -4						; size = 4
_templateSource$ = 8					; size = 4
_doc$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyFormSchema
; _this$ = ecx

; 985  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 986  : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 987  : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 988  : 
; 989  : // Now lets verify that the form being signed conforms to the schema in the licensed form template
; 990  : // In order to do this, we must first remove all SecureSign addded XML elements and signatures
; 991  : // from the form document.
; 992  : 	char *ptemp = (char *)zMalloc(4096);

	push	4096					; 00001000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptemp$[ebp], eax

; 993  : 
; 994  : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::idsig:Signature | self::SignedObject | self::documentID]");

	push	OFFSET FLAT:$SG193642
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 995  : 
; 996  : 	xpathPtr = xmlXPathNewContext(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 997  : 
; 998  : 	// register additional namespace for the signature
; 999  : 	if (xmlXPathRegisterNs(xpathPtr,(const unsigned char *)NS_PREFIX,(const unsigned char *)SIGNATURE_URI)!=0)

	push	OFFSET FLAT:$SG193646
	push	OFFSET FLAT:$SG193647
	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L193645

; 1000 : 	{
; 1001 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1002 : 		zFree(ptemp);

	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1003 : 		return FALSE;

	xor	eax, eax
	jmp	$L193637
$L193645:

; 1004 : 	}
; 1005 : 
; 1006 : 
; 1007 : 	// apply XPath
; 1008 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1009 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L193649

; 1010 : 	{
; 1011 : 		// not found
; 1012 : 		setError(SigHandle, SIG_NOT_FOUND);

	push	56					; 00000038H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1013 : 		zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1014 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1015 : 		return FALSE;

	xor	eax, eax
	jmp	$L193637
$L193649:

; 1016 : 	}
; 1017 : 
; 1018 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L193650
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L193650

; 1019 : 	{
; 1020 : 		// we found something, try to parse it
; 1021 : 		// start traversing the document, looking for Signature's children elements
; 1022 : 		for (int i = 0; i < xpathResultPtr->nodesetval->nodeNr; i++)

	mov	DWORD PTR _i$193651[ebp], 0
	jmp	SHORT $L193652
$L193653:
	mov	ecx, DWORD PTR _i$193651[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$193651[ebp], ecx
$L193652:
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _i$193651[ebp]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $L193650

; 1023 : 		{
; 1024 : 			xmlNodePtr secureSignNode = xpathResultPtr->nodesetval->nodeTab[i];

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _i$193651[ebp]
	mov	eax, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _secureSignNode$193655[ebp], eax

; 1025 : 			xmlUnlinkNode(secureSignNode);

	mov	ecx, DWORD PTR _secureSignNode$193655[ebp]
	push	ecx
	call	_xmlUnlinkNode
	add	esp, 4

; 1026 : 			xmlFreeNode(secureSignNode);

	mov	edx, DWORD PTR _secureSignNode$193655[ebp]
	push	edx
	call	_xmlFreeNode
	add	esp, 4

; 1027 : 		}

	jmp	SHORT $L193653
$L193650:

; 1028 : 	}
; 1029 :     xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1030 : 	xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1031 : 
; 1032 : 	// Now doc is ready to be processed against the SchemaData present in the licensed form template
; 1033 : //DebugBreak();
; 1034 : 
; 1035 : //#if _DEBUG_
; 1036 : //	xmlChar *mem=NULL;
; 1037 : //	int iSize=0;
; 1038 : //	FILE *hOutFile;
; 1039 : //	xmlDocDumpMemory(doc,&mem,&iSize);
; 1040 : //	// open file in write mode 
; 1041 : //	hOutFile = fopen("C:\\temp\\ObjectsRemoved.xml","wb");
; 1042 : //	fwrite(mem, 1, iSize, hOutFile);
; 1043 : //	fclose(hOutFile);
; 1044 : //	xmlFree(mem);
; 1045 : //#endif
; 1046 : // Now lets verify that the form being signed conforms to the schema in the licensed form template
; 1047 : // In order to do this, we must first remove all SecureSign addded XML elements and signatures
; 1048 : // from the form document.
; 1049 : 
; 1050 : 	xmlDocPtr templateXMLDoc = xmlParseMemory((const char *)templateSource, strlen((const char *)templateSource));

	mov	edx, DWORD PTR _templateSource$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR _templateSource$[ebp]
	push	eax
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _templateXMLDoc$[ebp], eax

; 1051 : //#if _DEBUG_
; 1052 : //	// open file in write mode 
; 1053 : //	hOutFile = fopen("C:\\temp\\TemplateSource.xml","wb");
; 1054 : //	fwrite(templateSource, 1, strlen((const char *)templateSource), hOutFile);
; 1055 : //	fclose(hOutFile);
; 1056 : //#endif
; 1057 : 
; 1058 : 	xmlChar *schemaData=NULL;

	mov	DWORD PTR _schemaData$[ebp], 0

; 1059 : 	xmlNodePtr schemaDataNode=NULL;

	mov	DWORD PTR _schemaDataNode$[ebp], 0

; 1060 : 
; 1061 : 	if (!templateXMLDoc) 

	cmp	DWORD PTR _templateXMLDoc$[ebp], 0
	jne	SHORT $L193661

; 1062 : 	{
; 1063 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1064 : 		return FALSE;

	xor	eax, eax
	jmp	$L193637
$L193661:

; 1065 : 	}
; 1066 : 	ptemp = (char *)zMalloc(4096);

	push	4096					; 00001000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptemp$[ebp], eax

; 1067 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::SchemaData]");

	push	OFFSET FLAT:$SG193663
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 1068 : 	xpathPtr = xmlXPathNewContext(templateXMLDoc);

	mov	eax, DWORD PTR _templateXMLDoc$[ebp]
	push	eax
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1069 : 
; 1070 : 	// apply XPath
; 1071 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1072 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L193665

; 1073 : 	{
; 1074 : 		// not found
; 1075 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1076 : 		zFree(ptemp);

	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1077 : 		xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1078 : 		xmlFreeDoc(templateXMLDoc);

	mov	eax, DWORD PTR _templateXMLDoc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1079 : 		return FALSE;

	xor	eax, eax
	jmp	$L193637
$L193665:

; 1080 : 	}
; 1081 : 
; 1082 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L193666
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L193666

; 1083 : 	{
; 1084 : 		// we found something, must be the schema data node
; 1085 : 		schemaDataNode = xpathResultPtr->nodesetval->nodeTab[0];

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _schemaDataNode$[ebp], ecx

; 1086 : 		schemaDataNode = schemaDataNode->children;

	mov	edx, DWORD PTR _schemaDataNode$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], eax

; 1087 : 		schemaData = xmlNodeGetContent(schemaDataNode);

	mov	ecx, DWORD PTR _schemaDataNode$[ebp]
	push	ecx
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax

; 1088 : 	}
; 1089 : 	else

	jmp	SHORT $L193667
$L193666:

; 1090 : 	{
; 1091 :         xmlXPathFreeObject(xpathResultPtr);

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1092 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1093 : 		zFree(ptemp);

	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1094 : 		xmlFreeDoc(templateXMLDoc);

	mov	edx, DWORD PTR _templateXMLDoc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1095 : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L193637
$L193667:

; 1096 : 	}
; 1097 : 
; 1098 :     xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1099 : 	xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1100 : 	zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1101 : 
; 1102 : 	BOOL result = validateXmlWithSchema(schemaData, doc, SigHandle);

	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _schemaData$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
	mov	DWORD PTR _result$[ebp], eax

; 1103 : 	xmlFree(schemaData);

	mov	esi, esp
	mov	eax, DWORD PTR _schemaData$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1104 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L193637:

; 1105 : }

	pop	edi
	pop	esi
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?verifyFormSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyFormSchema
_TEXT	ENDS
PUBLIC	?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::getFormSignAllowed
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_result$ = -60						; size = 4
_sizeM$ = -56						; size = 4
_base64DecodedTemplateSource$ = -52			; size = 4
_base64EncodedTemplateSource$ = -48			; size = 4
_templateFound$ = -44					; size = 4
_ptemp$ = -40						; size = 4
_xpathResultPtr$ = -36					; size = 4
_xpathPtr$ = -32					; size = 4
_signedInfoNode$ = -28					; size = 4
_sigNode$ = -24						; size = 4
_parent$ = -20						; size = 4
_cur$ = -16						; size = 4
_root$ = -12						; size = 4
_doc$ = -8						; size = 4
_this$ = -4						; size = 4
_inputXML$ = 8						; size = 4
_size$ = 12						; size = 4
_SigHandle$ = 16					; size = 4
?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::getFormSignAllowed
; _this$ = ecx

; 1108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-60]
	mov	ecx, 15					; 0000000fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 	xmlDocPtr doc =NULL;

	mov	DWORD PTR _doc$[ebp], 0

; 1110 : 	xmlNodePtr root=NULL, cur=NULL, parent=NULL, sigNode=NULL, signedInfoNode=NULL;

	mov	DWORD PTR _root$[ebp], 0
	mov	DWORD PTR _cur$[ebp], 0
	mov	DWORD PTR _parent$[ebp], 0
	mov	DWORD PTR _sigNode$[ebp], 0
	mov	DWORD PTR _signedInfoNode$[ebp], 0

; 1111 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 1112 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 1113 : 	char *ptemp=NULL;

	mov	DWORD PTR _ptemp$[ebp], 0

; 1114 : 	BOOL templateFound=FALSE;

	mov	DWORD PTR _templateFound$[ebp], 0

; 1115 : 	xmlChar *base64EncodedTemplateSource;
; 1116 : 	xmlChar *base64DecodedTemplateSource;
; 1117 : 	unsigned int sizeM;
; 1118 : 	BOOL result = FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 1119 : 
; 1120 : 	// original document
; 1121 : 	doc = xmlParseMemory((const char *)inputXML,size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _inputXML$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1122 : 	if (!doc) 

	cmp	DWORD PTR _doc$[ebp], 0
	jne	SHORT $L193690

; 1123 : 	{
; 1124 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1125 : 		return FALSE;

	xor	eax, eax
	jmp	$L193674
$L193690:

; 1126 : 	}
; 1127 : 
; 1128 : 	ptemp = (char *)zMalloc(4096);

	push	4096					; 00001000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptemp$[ebp], eax

; 1129 : 
; 1130 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[ancestor-or-self::ifmc:SignedObject[@Id='%s']]","TemplateSource");

	push	OFFSET FLAT:$SG193692
	push	OFFSET FLAT:$SG193693
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1131 : 
; 1132 : 	xpathPtr = xmlXPathNewContext(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1133 : 
; 1134 : 	if (xpathPtr == NULL)

	cmp	DWORD PTR _xpathPtr$[ebp], 0
	jne	SHORT $L193694

; 1135 : 	{
; 1136 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1137 : 		zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1138 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1139 : 		return FALSE;

	xor	eax, eax
	jmp	$L193674
$L193694:

; 1140 : 	}
; 1141 : 
; 1142 : 	// register additional namespace for the signature
; 1143 : 	if (xmlXPathRegisterNs(xpathPtr,(const unsigned char *)"ifmc",(const unsigned char *)"http://www.infomosaic.net")!=0)

	push	OFFSET FLAT:$SG193698
	push	OFFSET FLAT:$SG193699
	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathRegisterNs
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $L193697

; 1144 : 	{
; 1145 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	eax, DWORD PTR _SigHandle$[ebp]
	push	eax
	call	_setError
	add	esp, 8

; 1146 : 		xmlFreeDoc(doc);

	mov	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1147 : 		zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1148 : 		return S_FALSE;

	mov	eax, 1
	jmp	$L193674
$L193697:

; 1149 : 	}
; 1150 : 
; 1151 : 	// apply XPath
; 1152 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1153 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L193702

; 1154 : 	{
; 1155 : 		// not found
; 1156 : 		setError(SigHandle, INVALID_XML);

	push	32					; 00000020H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1157 : 		zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1158 : 		xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1159 : 		xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1160 : 		return FALSE;

	xor	eax, eax
	jmp	$L193674
$L193702:

; 1161 : 	}
; 1162 : 
; 1163 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$L193703
	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	DWORD PTR [edx+8], 0
	je	$L193703

; 1164 : 	{
; 1165 : 		// we found something, try to parse it
; 1166 : 		sigNode = xpathResultPtr->nodesetval->nodeTab[0];

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _sigNode$[ebp], eax

; 1167 : 		base64EncodedTemplateSource = xmlNodeGetContent(sigNode);

	mov	ecx, DWORD PTR _sigNode$[ebp]
	push	ecx
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _base64EncodedTemplateSource$[ebp], eax

; 1168 : 
; 1169 : 		if (base64EncodedTemplateSource == NULL)

	cmp	DWORD PTR _base64EncodedTemplateSource$[ebp], 0
	jne	SHORT $L193704

; 1170 : 		{
; 1171 : 			setError(SigHandle, INVALID_XML);

	push	32					; 00000020H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1172 : 			zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1173 : 			xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1174 : 			xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1175 : 			xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1176 : 			return FALSE;

	xor	eax, eax
	jmp	$L193674
$L193704:

; 1177 : 		}
; 1178 : 
; 1179 : 		sizeM = strlen((const char *)base64EncodedTemplateSource);

	mov	ecx, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 1180 : 		sizeM = base64decodeSize(sizeM);

	mov	edx, DWORD PTR _sizeM$[ebp]
	push	edx
	call	_base64decodeSize
	add	esp, 4
	mov	DWORD PTR _sizeM$[ebp], eax

; 1181 : 		base64DecodedTemplateSource = (unsigned char *)zMalloc(sizeM+1);

	mov	eax, DWORD PTR _sizeM$[ebp]
	add	eax, 1
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _base64DecodedTemplateSource$[ebp], eax

; 1182 : 		if ((sizeM = base64decode(base64EncodedTemplateSource,base64DecodedTemplateSource,sizeM+1))==-1)

	mov	ecx, DWORD PTR _sizeM$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	edx
	mov	eax, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	eax
	call	_base64decode
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _sizeM$[ebp], eax
	cmp	DWORD PTR _sizeM$[ebp], -1
	jne	SHORT $L193707

; 1183 : 		{
; 1184 : 			xmlFree(base64EncodedTemplateSource);

	mov	esi, esp
	mov	ecx, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1185 : 			zFree(base64DecodedTemplateSource);

	mov	eax, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1186 : 			setError(SigHandle, BASE64_ERROR);

	push	2
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1187 : 			zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1188 : 			xmlXPathFreeObject(xpathResultPtr);

	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	push	eax
	call	_xmlXPathFreeObject
	add	esp, 4

; 1189 : 			xmlXPathFreeContext(xpathPtr);

	mov	ecx, DWORD PTR _xpathPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1190 : 			xmlFreeDoc(doc);

	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	call	_xmlFreeDoc
	add	esp, 4

; 1191 : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L193674
$L193707:

; 1192 : 		}
; 1193 : 		xmlFree(base64EncodedTemplateSource);

	mov	esi, esp
	mov	eax, DWORD PTR _base64EncodedTemplateSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [ecx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1194 : 		result = verifyTemplateSignature(base64DecodedTemplateSource, sizeM, SigHandle);

	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _sizeM$[ebp]
	push	eax
	mov	ecx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?verifyTemplateSignature@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSignature
	mov	DWORD PTR _result$[ebp], eax

; 1195 : 		//if (result != 0)
; 1196 : 		//{
; 1197 : 		//	result = verifyFormSchema(base64DecodedTemplateSource, doc, SigHandle);
; 1198 : 		//}
; 1199 : 		zFree(base64DecodedTemplateSource);

	mov	edx, DWORD PTR _base64DecodedTemplateSource$[ebp]
	push	edx
	call	_rFree
	add	esp, 4
$L193703:

; 1200 : 	}
; 1201 : 
; 1202 : 	zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1203 : 	xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1204 : 	xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1205 : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1206 : 
; 1207 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L193674:

; 1208 : }

	pop	edi
	pop	esi
	add	esp, 60					; 0000003cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getFormSignAllowed@CLicense@@QAEHPAEIPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::getFormSignAllowed
_TEXT	ENDS
PUBLIC	?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z ; CLicense::verifyTemplateSchema
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_instanceXmlStrSize$ = -48				; size = 4
_doc$ = -44						; size = 4
_result$ = -40						; size = 4
_xpathResultPtr$ = -36					; size = 4
_xpathPtr$ = -32					; size = 4
_xmlData$ = -28						; size = 4
_xmlDataNode$ = -24					; size = 4
_schemaDataNode$ = -20					; size = 4
_schemaData$ = -16					; size = 4
_templateXMLDoc$ = -12					; size = 4
_ptemp$ = -8						; size = 4
_this$ = -4						; size = 4
_templateSource$ = 8					; size = 4
_SigHandle$ = 12					; size = 4
?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z PROC NEAR ; CLicense::verifyTemplateSchema
; _this$ = ecx

; 1210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-48]
	mov	ecx, 12					; 0000000cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1211 : 	char *ptemp;
; 1212 : 	xmlDocPtr templateXMLDoc = xmlParseMemory((const char *)templateSource, strlen((const char *)templateSource));

	mov	eax, DWORD PTR _templateSource$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _templateSource$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _templateXMLDoc$[ebp], eax

; 1213 : 	xmlChar *schemaData=NULL;

	mov	DWORD PTR _schemaData$[ebp], 0

; 1214 : 	xmlNodePtr schemaDataNode=NULL;

	mov	DWORD PTR _schemaDataNode$[ebp], 0

; 1215 : 	xmlNodePtr xmlDataNode=NULL;

	mov	DWORD PTR _xmlDataNode$[ebp], 0

; 1216 : 	xmlChar *xmlData;
; 1217 : 	xmlXPathContextPtr xpathPtr=NULL;

	mov	DWORD PTR _xpathPtr$[ebp], 0

; 1218 : 	xmlXPathObjectPtr xpathResultPtr=NULL;

	mov	DWORD PTR _xpathResultPtr$[ebp], 0

; 1219 : 	BOOL result=FALSE;

	mov	DWORD PTR _result$[ebp], 0

; 1220 : 
; 1221 : 	if (!templateXMLDoc) 

	cmp	DWORD PTR _templateXMLDoc$[ebp], 0
	jne	SHORT $L193724

; 1222 : 	{
; 1223 : 		setError(SigHandle, XML_PARSER_ERROR);

	push	16					; 00000010H
	mov	edx, DWORD PTR _SigHandle$[ebp]
	push	edx
	call	_setError
	add	esp, 8

; 1224 : 		return FALSE;

	xor	eax, eax
	jmp	$L193712
$L193724:

; 1225 : 	}
; 1226 : 	ptemp = (char *)zMalloc(4096);

	push	4096					; 00001000H
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptemp$[ebp], eax

; 1227 : 	sprintf (ptemp,"(//. | //@* | //namespace::*)[self::SchemaData | self::XmlData]");

	push	OFFSET FLAT:$SG193726
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 1228 : 	xpathPtr = xmlXPathNewContext(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlXPathNewContext
	add	esp, 4
	mov	DWORD PTR _xpathPtr$[ebp], eax

; 1229 : 
; 1230 : 	// apply XPath
; 1231 : 	xpathResultPtr = xmlXPathEvalExpression((const unsigned char *)ptemp, xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_xmlXPathEvalExpression
	add	esp, 8
	mov	DWORD PTR _xpathResultPtr$[ebp], eax

; 1232 : 	if (xpathResultPtr == NULL) 

	cmp	DWORD PTR _xpathResultPtr$[ebp], 0
	jne	SHORT $L193728

; 1233 : 	{
; 1234 : 		// not found
; 1235 : 		setError(SigHandle, XPATH_ERROR);

	push	37					; 00000025H
	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	call	_setError
	add	esp, 8

; 1236 : 		zFree(ptemp);

	mov	edx, DWORD PTR _ptemp$[ebp]
	push	edx
	call	_rFree
	add	esp, 4

; 1237 : 		xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1238 : 		xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1239 : 		return FALSE;

	xor	eax, eax
	jmp	$L193712
$L193728:

; 1240 : 	}
; 1241 : 
; 1242 : 	if ((xpathResultPtr->nodesetval!=NULL) && (xpathResultPtr->nodesetval->nodeTab!=NULL)) 

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$L193729
	mov	eax, DWORD PTR _xpathResultPtr$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR [ecx+8], 0
	je	$L193729

; 1243 : 	{
; 1244 : 		// we found something, must be schema data  and Xml data nodes
; 1245 : 		if (!strcmp((const char *)xpathResultPtr->nodesetval->nodeTab[0]->name, "XmlData"))

	push	OFFSET FLAT:$SG193732
	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_strcmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L193731

; 1246 : 		{
; 1247 : 			xmlDataNode = xpathResultPtr->nodesetval->nodeTab[0]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _xmlDataNode$[ebp], edx

; 1248 : 			xmlData = xmlNodeGetContent(xmlDataNode);

	mov	eax, DWORD PTR _xmlDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _xmlData$[ebp], eax

; 1249 : 			schemaDataNode = xpathResultPtr->nodesetval->nodeTab[1]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], edx

; 1250 : 			schemaData = xmlNodeGetContent(schemaDataNode);

	mov	eax, DWORD PTR _schemaDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax

; 1251 : 		}
; 1252 : 		else

	jmp	SHORT $L193733
$L193731:

; 1253 : 		{
; 1254 : 			xmlDataNode = xpathResultPtr->nodesetval->nodeTab[1]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _xmlDataNode$[ebp], edx

; 1255 : 			xmlData = xmlNodeGetContent(xmlDataNode);

	mov	eax, DWORD PTR _xmlDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _xmlData$[ebp], eax

; 1256 : 			schemaDataNode = xpathResultPtr->nodesetval->nodeTab[0]->children;

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _schemaDataNode$[ebp], edx

; 1257 : 			schemaData = xmlNodeGetContent(schemaDataNode);

	mov	eax, DWORD PTR _schemaDataNode$[ebp]
	push	eax
	call	_xmlNodeGetContent
	add	esp, 4
	mov	DWORD PTR _schemaData$[ebp], eax
$L193733:

; 1258 : 		}
; 1259 : 	}
; 1260 : 	else

	jmp	SHORT $L193734
$L193729:

; 1261 : 	{
; 1262 : 		xmlXPathFreeObject(xpathResultPtr);

	mov	ecx, DWORD PTR _xpathResultPtr$[ebp]
	push	ecx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1263 : 		xmlXPathFreeContext(xpathPtr);

	mov	edx, DWORD PTR _xpathPtr$[ebp]
	push	edx
	call	_xmlXPathFreeContext
	add	esp, 4

; 1264 : 		zFree(ptemp);

	mov	eax, DWORD PTR _ptemp$[ebp]
	push	eax
	call	_rFree
	add	esp, 4

; 1265 : 		xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1266 : 		return FALSE;

	xor	eax, eax
	jmp	$L193712
$L193734:

; 1267 : 	}
; 1268 : 
; 1269 : 	xmlXPathFreeObject(xpathResultPtr);

	mov	edx, DWORD PTR _xpathResultPtr$[ebp]
	push	edx
	call	_xmlXPathFreeObject
	add	esp, 4

; 1270 : 	xmlXPathFreeContext(xpathPtr);

	mov	eax, DWORD PTR _xpathPtr$[ebp]
	push	eax
	call	_xmlXPathFreeContext
	add	esp, 4

; 1271 : 	zFree(ptemp);

	mov	ecx, DWORD PTR _ptemp$[ebp]
	push	ecx
	call	_rFree
	add	esp, 4

; 1272 : 
; 1273 : 	xmlDocPtr doc;
; 1274 : 	size_t instanceXmlStrSize = strlen((const char *)xmlData);

	mov	edx, DWORD PTR _xmlData$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _instanceXmlStrSize$[ebp], eax

; 1275 : 	doc = xmlParseMemory((const char *)xmlData, instanceXmlStrSize);

	mov	eax, DWORD PTR _instanceXmlStrSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _xmlData$[ebp]
	push	ecx
	call	_xmlParseMemory
	add	esp, 8
	mov	DWORD PTR _doc$[ebp], eax

; 1276 : 	xmlFree(xmlData);

	mov	esi, esp
	mov	edx, DWORD PTR _xmlData$[ebp]
	push	edx
	mov	eax, DWORD PTR __imp__xmlFree
	call	DWORD PTR [eax]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1277 : 
; 1278 : 	result = validateXmlWithSchema(schemaData, doc, SigHandle);

	mov	ecx, DWORD PTR _SigHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _doc$[ebp]
	push	edx
	mov	eax, DWORD PTR _schemaData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?validateXmlWithSchema@CLicense@@QAEHPAEPAU_xmlDoc@@PAU_GLOBAL_SIG@@@Z ; CLicense::validateXmlWithSchema
	mov	DWORD PTR _result$[ebp], eax

; 1279 : 	xmlFree(schemaData);

	mov	esi, esp
	mov	ecx, DWORD PTR _schemaData$[ebp]
	push	ecx
	mov	edx, DWORD PTR __imp__xmlFree
	call	DWORD PTR [edx]
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1280 : 	xmlFreeDoc(doc);

	mov	eax, DWORD PTR _doc$[ebp]
	push	eax
	call	_xmlFreeDoc
	add	esp, 4

; 1281 : 	xmlFreeDoc(templateXMLDoc);

	mov	ecx, DWORD PTR _templateXMLDoc$[ebp]
	push	ecx
	call	_xmlFreeDoc
	add	esp, 4

; 1282 : 	return result;

	mov	eax, DWORD PTR _result$[ebp]
$L193712:

; 1283 : }

	pop	edi
	pop	esi
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?verifyTemplateSchema@CLicense@@QAEHPAEPAU_GLOBAL_SIG@@@Z ENDP ; CLicense::verifyTemplateSchema
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 311  : 		{	// construct empty string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 312  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 313  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 360  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@D@std@@QAE@XZ		; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 361  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 362  : 		assign(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 363  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 457  : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 458  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 471  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 472  : 		return (assign(_Ptr));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 473  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 1093 : 		{	// return pointer to null-terminated nonmutable array

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		return (_Myptr());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr

; 1095 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1103 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1104 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1105 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z	; ATL::CW2AEX<128>::Init

; 421  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L194081

; 430  : 		{
; 431  : 			free( m_psz );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4
$L194081:

; 432  : 		}
; 433  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 438  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	?length@?$char_traits@D@std@@SAIPBD@Z	; std::char_traits<char>::length
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 623  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 351  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	_strlen
	add	esp, 4

; 353  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Ptr$194301 = -8					; size = 4
_this$ = -4						; size = 4
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1509 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1510 : 		if (!_Built)

	movzx	eax, BYTE PTR __Built$[ebp]
	test	eax, eax
	jne	SHORT $L194298

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	jmp	SHORT $L194299
$L194298:
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L194299

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR __Ptr$194301[ebp], eax

; 1515 : 			if (0 < _Newsize)

	cmp	DWORD PTR __Newsize$[ebp], 0
	jbe	SHORT $L194302

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$194301[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L194302:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR __Ptr$194301[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$L194299:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 1520 : 		_Eos(_Newsize);

	mov	edx, DWORD PTR __Newsize$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1521 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 357  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 359  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1536 : 		{	// determine current pointer to buffer for nonmutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L196120
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L196121
$L196120:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L196121:
	mov	eax, DWORD PTR tv70[ebp]

; 1538 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>

; 35   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT
_nLengthA$ = -12					; size = 4
_nLengthW$ = -8						; size = 4
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L194529

; 444  : 		{
; 445  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 446  : 			return;

	jmp	$L196129
$L194529:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

	mov	edx, DWORD PTR _nLengthW$[ebp]
	shl	edx, 1
	mov	DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

	cmp	DWORD PTR _nLengthA$[ebp], 128		; 00000080H
	jle	SHORT $L194532

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L194532

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L194532:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L196129

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$L196129:

; 463  : 		}
; 464  : 	}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 81   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	cmp	DWORD PTR _dwError$[ebp], 0
	jg	SHORT $L196132
	mov	eax, DWORD PTR _dwError$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L196133
$L196132:
	mov	ecx, DWORD PTR _dwError$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv69[ebp], ecx
$L196133:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L196131:

; 83   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 609  : 		if (_Inside(_Ptr))

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L194598

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR __Ptr$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $L194597
$L194598:

; 611  : 
; 612  : 		if (_Grow(_Num))

	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L194599

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 615  : 			_Eos(_Num);

	mov	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L194599:

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]
$L194597:

; 618  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 591  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L194171

; 592  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L194171:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[ebp]
	cmp	eax, DWORD PTR __Num$[ebp]
	jae	SHORT $L194173

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
$L194173:

; 596  : 
; 597  : 		if (this == &_Right)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR __Right$[ebp]
	jne	SHORT $L194174

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	mov	eax, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	eax
	mov	ecx, DWORD PTR __Roff$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	mov	edx, DWORD PTR __Roff$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 599  : 		else if (_Grow(_Num))

	jmp	SHORT $L194292
$L194174:
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L194292

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 602  : 			_Eos(_Num);

	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L194292:

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 605  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1108 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 1110 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
; Function compile flags: /Odt /RTCsu
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Newsize$194605 = -8					; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 793  : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L194602

; 794  : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L194602:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L194603

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Count$[ebp], edx
$L194603:

; 797  : 		if (0 < _Count)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L194604

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, DWORD PTR __Off$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 12					; 0000000cH

; 801  : 			size_type _Newsize = _Mysize - _Count;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Newsize$194605[ebp], eax

; 802  : 			_Eos(_Newsize);

	mov	ecx, DWORD PTR __Newsize$194605[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L194604:

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 805  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
EXTRN	_memmove:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 369  : 		{	// copy [_First1, _First1 + _Count) to [_First2, ...)

	push	ebp
	mov	ebp, esp

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH

; 371  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
$T196146 = -5						; size = 1
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1474 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	mov	BYTE PTR $T196146[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [eax+20], ecx
	lea	edx, DWORD PTR $T196146[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	call	?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign
	add	esp, 8

; 1476 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 330  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 332  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1481 : 		if (max_size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L194611

; 1482 : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L194611:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $L194612

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	jmp	SHORT $L194613
$L194612:
	movzx	edx, BYTE PTR __Trim$[ebp]
	test	edx, edx
	je	SHORT $L194614
	cmp	DWORD PTR __Newsize$[ebp], 16		; 00000010H
	jae	SHORT $L194614

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newsize$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jae	SHORT $L196151
	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR tv81[ebp], edx
	jmp	SHORT $L196152
$L196151:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR tv81[ebp], ecx
$L196152:
	mov	edx, DWORD PTR tv81[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1488 : 		else if (_Newsize == 0)

	jmp	SHORT $L194613
$L194614:
	cmp	DWORD PTR __Newsize$[ebp], 0
	jne	SHORT $L194613

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L194613:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, DWORD PTR __Newsize$[ebp]
	sbb	eax, eax
	neg	eax

; 1491 : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1531 : 		{	// determine current pointer to buffer for mutable string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L196155
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L196156
$L196155:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$L196156:
	mov	eax, DWORD PTR tv70[ebp]

; 1533 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 131  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv68 = -12						; size = 4
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1113 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@D@std@@QBEIXZ	; std::allocator<char>::max_size
	mov	DWORD PTR __Num$[ebp], eax

; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	cmp	DWORD PTR __Num$[ebp], 1
	ja	SHORT $L196161
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $L196162
$L196161:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
$L196162:
	mov	eax, DWORD PTR tv68[ebp]

; 1116 : 		}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
$T196172 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T196174 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L196168
$T196175 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L196166
$T196173 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T196174
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T196175
$T196170 DD	019930520H
	DD	04H
	DD	FLAT:$T196172
	DD	02H
	DD	FLAT:$T196173
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
tv145 = -36						; size = 4
tv144 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	or	eax, 15					; 0000000fH
	mov	DWORD PTR __Newres$[ebp], eax

; 1446 : 		if (max_size() < _Newres)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Newres$[ebp]
	jae	SHORT $L194682

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L194683
$L194682:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+24]
	shr	ecx, 1
	mov	eax, DWORD PTR __Newres$[ebp]
	xor	edx, edx
	mov	esi, 3
	div	esi
	cmp	eax, ecx
	jae	SHORT $L194683
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+24]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
	sub	eax, esi
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+24], eax
	ja	SHORT $L194683

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+24]
	mov	DWORD PTR __Newres$[ebp], eax
$L194683:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L196165
$L196166:

; 1455 : 		_CATCH_ALL

	mov	DWORD PTR __$EHRec$[ebp], esp

; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	ecx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], ecx

; 1457 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2

; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	mov	edx, DWORD PTR __Newres$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $L196167
$L196168:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1461 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L196167:

; 1462 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 1463 : 		_CATCH_END

	mov	eax, $L196165
	ret	0
$L196165:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	cmp	DWORD PTR __Oldlen$[ebp], 0
	jbe	SHORT $L194688

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	edx, DWORD PTR __Ptr$[ebp]
	push	edx
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH
$L194688:

; 1467 : 		_Tidy(true);

	push	0
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 1468 : 		_Bx._Ptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1469 : 		_Myres = _Newres;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newres$[ebp]
	mov	DWORD PTR [edx+24], eax

; 1470 : 		_Eos(_Oldlen);

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L196164:

; 1471 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T196170
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	cmp	DWORD PTR __Ptr$[ebp], eax
	jb	SHORT $L194692
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $L194691
$L194692:

; 1496 : 			return (false);	// don't ask

	xor	al, al
	jmp	SHORT $L194690
$L194691:

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
$L194690:

; 1499 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 136  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@D@std@@YAPADIPAD@Z		; std::_Allocate<char>
	add	esp, 8

; 138  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
__Count$ = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 156  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 158  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L196184
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $L196185
$L196184:
	mov	DWORD PTR tv65[ebp], 1
$L196185:
	mov	eax, DWORD PTR tv65[ebp]

; 159  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T196196 DD	0ffffffffH
	DD	FLAT:$L196190
	DD	00H
	DD	FLAT:$L196189
$T196194 DD	019930520H
	DD	02H
	DD	FLAT:$T196196
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
tv77 = -52						; size = 4
tv82 = -48						; size = 4
$T196191 = -44						; size = 4
$T196188 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR $T196191[ebp], 0

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T196188[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR tv77[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR tv77[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR $T196191[ebp]
	or	eax, 1
	mov	DWORD PTR $T196191[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T196188[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 23   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L196189:
	lea	ecx, DWORD PTR $T196188[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196190:
	mov	eax, DWORD PTR $T196191[ebp]
	and	eax, 1
	je	$L196192
	and	DWORD PTR $T196191[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L196192:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
	mov	eax, OFFSET FLAT:$T196194
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@D@std@@QAE@ABV01@@Z	; std::allocator<char>::allocator<char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >

; 324  : 		_Tidy();

	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 325  : 		assign(_Right, 0, npos);

	mov	ecx, DWORD PTR ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
	push	ecx
	push	0
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 101  : 	{	// test for string inequality

	push	ebp
	mov	ebp, esp

; 102  : 	return (!(_Left == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	inc	eax

; 103  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 33   : 	{	// allocate storage for _Count elements of type _Ty

	push	ebp
	mov	ebp, esp

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 481  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 		return (append(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 483  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 496  : 		{	// append _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 497  : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 498  : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Num$ = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 502  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 503  : 		if (_Right.size() < _Roff)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	cmp	eax, DWORD PTR __Roff$[ebp]
	jae	SHORT $L194877

; 504  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L194877:

; 505  : 		size_type _Num = _Right.size() - _Roff;

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	sub	eax, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Num$[ebp], eax

; 506  : 		if (_Num < _Count)

	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L194879

; 507  : 			_Count = _Num;	// trim _Count to size

	mov	ecx, DWORD PTR __Num$[ebp]
	mov	DWORD PTR __Count$[ebp], ecx
$L194879:

; 508  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR _this$[ebp]
	or	eax, -1
	sub	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	ja	SHORT $L194880

; 509  : 			_String_base::_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L194880:

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $L194881
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	add	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	push	0
	mov	eax, DWORD PTR __Num$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L194881

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Roff$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+20]
	push	eax
	call	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy
	add	esp, 12					; 0000000cH

; 515  : 			_Eos(_Num);

	mov	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
$L194881:

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 518  : 		}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 71   : 	{	// test for string equality

	push	ebp
	mov	ebp, esp

; 72   : 	return (_Left.compare(_Right) == 0);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
	neg	eax
	sbb	eax, eax
	inc	eax

; 73   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1379 : 		{	// compare [0, _Mysize) with _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 1380 : 		return (compare(0, _Mysize, _Right._Myptr(), _Right.size()));

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare

; 1381 : 		}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT
tv87 = -24						; size = 4
tv88 = -20						; size = 4
tv75 = -16						; size = 4
tv82 = -12						; size = 4
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 1412 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1413 : 		if (_Mysize < _Off)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jae	SHORT $L194889

; 1414 : 			_String_base::_Xran();	// _Off off end

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L194889:

; 1415 : 		if (_Mysize - _Off < _N0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	sub	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __N0$[ebp]
	jae	SHORT $L194890

; 1416 : 			_N0 = _Mysize - _Off;	// trim _N0 to size

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __N0$[ebp], edx
$L194890:

; 1417 : 
; 1418 : 		size_type _Ans = _N0 == 0 ? 0
; 1419 : 			: _Traits::compare(_Myptr() + _Off, _Ptr,
; 1420 : 				_N0 < _Count ? _N0 : _Count);

	cmp	DWORD PTR __N0$[ebp], 0
	jne	SHORT $L196220
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $L196221
$L196220:
	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $L196218
	mov	ecx, DWORD PTR __N0$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	jmp	SHORT $L196219
$L196218:
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv75[ebp], edx
$L196219:
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv82[ebp], eax
$L196221:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR __Ans$[ebp], edx

; 1421 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 1422 : 			: _N0 == _Count ? 0 : +1);

	cmp	DWORD PTR __Ans$[ebp], 0
	je	SHORT $L196224
	mov	eax, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $L196225
$L196224:
	mov	ecx, DWORD PTR __N0$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	jae	SHORT $L196222
	mov	DWORD PTR tv87[ebp], -1
	jmp	SHORT $L196223
$L196222:
	mov	edx, DWORD PTR __N0$[ebp]
	xor	eax, eax
	cmp	edx, DWORD PTR __Count$[ebp]
	setne	al
	mov	DWORD PTR tv87[ebp], eax
$L196223:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$L196225:
	mov	eax, DWORD PTR tv88[ebp]

; 1423 : 		}

	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC NEAR	; std::char_traits<char>::compare, COMDAT

; 346  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	push	ebp
	mov	ebp, esp

; 347  : 		return (::memcmp(_First1, _First2, _Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH

; 348  : 		}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

	mov	eax, DWORD PTR _nRequestedSize$[ebp]
	add	eax, 8
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L162795

; 378  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L162782
$L162795:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L162782:

; 385  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 32   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_p$162801 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L162799:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162797

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$162801[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

	mov	ecx, DWORD PTR _p$162801[ebp]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 394  : 		}

	jmp	SHORT $L162799
$L162797:

; 395  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp

; 36   : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 37   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L162865

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L162865:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@ DB 'm_p == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lalloc.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L196248
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L196248
	int	3
$L196248:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 128		; 00000080H
	jbe	SHORT $L163783

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L163784
$L163783:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L163784:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 367  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L164148

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164148:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L196254:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z:NEAR ; ATL::AtlWinModuleInit
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88121

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88121:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
xdata$x	SEGMENT
$T196275 DD	0ffffffffH
	DD	FLAT:$L196271
$T196273 DD	019930520H
	DD	01H
	DD	FLAT:$T196275
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L196271:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T196273
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2589 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
_TEXT	ENDS
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
EXTRN	__imp__UnregisterClassA@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$91551 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC NEAR ; ATL::AtlWinModuleTerm, COMDAT

; 6215 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6216 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $L91544

; 6217 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L91543
$L91544:

; 6218 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L91546

; 6219 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L91543
$L91546:

; 6220 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [ecx], 44			; 0000002cH
	je	SHORT $L91549

; 6221 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $L91543
$L91549:

; 6222 : 
; 6223 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	mov	DWORD PTR _i$91551[ebp], 0
	jmp	SHORT $L91552
$L91553:
	mov	edx, DWORD PTR _i$91551[ebp]
	add	edx, 1
	mov	DWORD PTR _i$91551[ebp], edx
$L91552:
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
	cmp	DWORD PTR _i$91551[ebp], eax
	jge	SHORT $L91554

; 6224 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	esi, esp
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$91551[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__UnregisterClassA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L91553
$L91554:

; 6225 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 6226 : 	pWinModule->m_csWindowCreate.Term();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 6227 : 	pWinModule->cbSize = 0;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax], 0

; 6228 : 	return S_OK;

	xor	eax, eax
$L91543:

; 6229 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		DeleteCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 149  : 		return S_OK;

	xor	eax, eax

; 150  : 	}	

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$162915 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162914

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$162915[ebp], 0
	jmp	SHORT $L162916
$L162917:
	mov	ecx, DWORD PTR _i$162915[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$162915[ebp], ecx
$L162916:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$162915[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L162918

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L162917
$L162918:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L162914:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ ; `string'
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT
??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ DB 'n'
	DB	'Index >= 0 && nIndex < m_nSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lsimpcoll.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L196297
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L196298
$L196297:
	push	OFFSET FLAT:??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
	push	0
	push	195					; 000000c3H
	push	OFFSET FLAT:??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L196298
	int	3
$L196298:

; 196  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L162924
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L162923
$L162924:

; 197  : 		{
; 198  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);					

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$L162923:

; 199  : 		}
; 200  : 		return m_aT[nIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
$L196296:

; 201  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
EXTRN	__imp__RaiseException@16:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC NEAR		; ATL::_AtlRaiseException, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 27   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _dwExceptionFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwExceptionCode$[ebp]
	push	ecx
	call	DWORD PTR __imp__RaiseException@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 28   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
END
