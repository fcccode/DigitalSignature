; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\XMLSign.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@NBFKEDIC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@HFEEKIIE@mbstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@JADEDFCN@wcstr?5?$DN?$DN?50?5?$HM?$HM?5result?5?$DM?$DN?5?$CIint?$CJcou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DFFCODPF@m_pData?9?$DOnRefs?5?$DN?$DN?5?91?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KFNMPDFA@m_pData?9?$DOnDataLength?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JINHKJCC@pData?9?$DOnRefs?5?$DM?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNGMIMJM@pData?9?$DOnRefs?5?$DM?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@EIPLHBJE@CFixedStringMgr?3?3Allocate?$CI?$CJ?5spil@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FD@PINPFILO@CFixedStringMgr?3?3Reallocate?$CI?$CJ?5sp@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0P@MDHCGOCC@m_pMemMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EP@ENACCIMA@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@KICONMKH@pData?9?$DOpStringMgr?5?$DN?$DN?5this?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@HPMMCKHL@?$CI?$CIWORD?$CJ?$CI?$CIDWORD_PTR?$CJ?$CIpsz?$CJ?5?$DO?$DO?516?$CJ?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@BDLMIBLB@pFormat?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGFACAOB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KCADNOJC@?$CF02ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CB@FKADHJGH@strFormat?4LoadStringA?$CInFormatID?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@BJCBICOJ@c?3?2activex?2xmlsign?2ShowSelectCer@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EJ@DPIMAKHN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@DIDNGAPJ@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5char?$CK?$CJ?5?$CKthis?5?$CB?$DN@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CG@PAOIECBF@s?5?$DN?$DN?50?5?$HM?$HM?5?$CIconst?5wchar_t?$CK?$CJ?5?$CKthis@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DD@NCNHACCB@s?5?$DN?$DN?50?5?$HM?$HM?5m_Data?5?$DN?$DN?50?5?$HM?$HM?5m_Data?9@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@LJMJHPFK@m_Data?5?$CB?$DN?50?5?$CG?$CG?5m_Data?9?$DORefCount?$CI@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@GKIPNLEE@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5?$CIBSTR@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDNDDDBI@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_BSTR?5?$HM?$HM?5pSrc?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EL@EEEMIENH@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5?$CIVT_I1?5?$HM?5VT_BYRE@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EH@IHHPLLAD@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_DISPATCH?5?$HM?$HM?5p@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EF@LJOMBHMP@?$CI?$CIthis?$CJ?9?$DOvt?$CJ?5?$CB?$DN?5VT_UNKNOWN?5?$HM?$HM?5pS@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NNIJINN@IDispatch?5error?5?$CD?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IPPGFENJ@Unknown?5error?50x?$CF0lX?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BP@BJHHJGLF@c?3?2activex?2xmlsign?2Signature?4h?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KEHCEMNB@CSignature?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@OBIGOAOM@AtlIsValidString?$CI?5pszFormat?5?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08LIEICNMC@m_bModal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GOIMFHNK@pStringMgr?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FJEKGMMD@Warning?3?5implicit?5LoadString?$CI?$CFu?$CJ@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNIEOBOF@nNewLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EE@PNDBCBIA@CAxDialogImpl?3?3AdviseSinkMap?5cal@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@DKHIMJLN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BNFEDJPE@?$CBm_bModal?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
ATL$__m	SEGMENT DWORD USE32 PUBLIC ''
ATL$__m	ENDS
ATL$__z	SEGMENT DWORD USE32 PUBLIC ''
ATL$__z	ENDS
ATL$__a	SEGMENT DWORD USE32 PUBLIC ''
ATL$__a	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_GCConfig@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceill
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10l
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modfl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhl
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _frexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ldexpf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _acosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _asinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _atan2f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ceilf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _cosf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _coshf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _expf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fabsf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _floorf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _fmodf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _logf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _log10f
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _modff
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _powf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sinhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _sqrtf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _tanhf
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferVariant@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferVariant@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferVariant@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCBufferVariant@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@CBufferVariant@@QAEXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MyVariantCopy@CBufferVariant@@QAEXPAUtagVARIANT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@CBufferVariant@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BuildByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendByteArrayFromVariant@CBufferVariant@@AAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendByteArrayFromData@CBufferVariant@@AAEXPBXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_DebugHeapString@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfacet@locale@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$codecvt@GDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$codecvt@GDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_in@?$codecvt@GDH@std@@MBEHAAHPBD1AAPBDPAG3AAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_out@?$codecvt@GDH@std@@MBEHAAHPBG1AAPBGPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_unshift@?$codecvt@GDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_length@?$codecvt@GDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_always_noconv@?$codecvt@GDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_max_length@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_encoding@?$codecvt@GDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@GDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getcat@?$ctype@G@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$ctype@G@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dowiden@?$ctype@G@std@@IBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Donarrow@?$ctype@G@std@@IBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@G@ATL@@CGKPBGPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CAtlStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CAtlStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CAtlStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CAtlStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCAtlStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringW@?$ChTraitsOS@G@ATL@@KGHKKPBGH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExW@?$ChTraitsOS@G@ATL@@KGHKKPBGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiW@?$ChTraitsOS@G@ATL@@KGHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperW@?$ChTraitsOS@G@ATL@@KGPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strrchr@?$ChTraitsOS@G@ATL@@SAPBGPBGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strrev@?$ChTraitsOS@G@ATL@@SAPAGPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strstr@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strcspn@?$ChTraitsOS@G@ATL@@SAHPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?strpbrk@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsOS@G@ATL@@SAPBGPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTimeSpan@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatGmt@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessWindowMessage@CShowSelectCert@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnInitDialog@CShowSelectCert@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnOK@CShowSelectCert@@QAEJGGPAUHWND__@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCancel@CShowSelectCert@@QAEJGGPAUHWND__@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateHeader@CShowSelectCert@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCell@CShowSelectCert@@QAEXPAGHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClickList@CShowSelectCert@@QAEJHPAUtagNMHDR@@AAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setSelection@CShowSelectCert@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCShowSelectCert@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckError@_com_util@@YAXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_bstr_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_bstr_t@@QAEAAV0@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y_bstr_t@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7_bstr_t@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@_bstr_t@@QAEXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AddRef@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Compare@_bstr_t@@ABEHABV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@PAG_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Data_t@_bstr_t@@QAE@ABV1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@Data_t@_bstr_t@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RefCount@Data_t@_bstr_t@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWString@Data_t@_bstr_t@@QAEAAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@Data_t@_bstr_t@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@Data_t@_bstr_t@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@Data_t@_bstr_t@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Compare@Data_t@_bstr_t@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2Data_t@_bstr_t@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Data_t@_bstr_t@@AAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Free@Data_t@_bstr_t@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_variant_t@@QAEAAV0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8_variant_t@@QBE_NPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@_variant_t@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChangeType@_variant_t@@QAEXGPBV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_variant_t@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_com_error@@QAE@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_com_error@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WCode@_com_error@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HRESULTToWCode@_com_error@@SAGJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GData_t@_bstr_t@@AAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_com_error@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CSignature@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CSignature@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetRawUnknown@CSignature@@QAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistry@CSignature@@SGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ANSIToUnicode@CSignature@@QAEPAGPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@SigException@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GSigException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1SigException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E6
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Preallocate@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxFrameWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCAxUIWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$_CopyInterface@UIUnknown@@@ATL@@SAJPAPAUIUnknown@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?init@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$_CopyInterface@UIUnknown@@@ATL@@SAXPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEPAV12@PAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@GU?$char_traits@G@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?overflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbackfail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?underflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekoff@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@JHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?seekpos@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE?AV?$fpos@H@2@V32@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormat@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDialogProc@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEP6GHPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoModal@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHPAUHWND__@@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndDialog@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessWindowMessage@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateActiveXControls@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_DebugHeapAllocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ostream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_ios@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@GU?$char_traits@G@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_istream@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleStringT@D$0A@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleStringT@D$0A@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MapDialogRect@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAEHPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLic@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEJPBGPAUIStream@@PAPAUIUnknown@@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$_DebugHeapAllocator@D@std@@@std@@IAE@V?$_DebugHeapAllocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendFormatV@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckImplicitLoad@?$CStringT@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@SAPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnInitDialog@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDestroy@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComClassFactory@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IClassFactory@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CSimpleStringT@D$0A@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AppendChar@?$CSimpleStringT@D$0A@@ATL@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLength@?$CSimpleStringT@D$0A@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseBufferSetLength@?$CSimpleStringT@D$0A@@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloneData@?$CSimpleStringT@D$0A@@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExecuteDlgInit@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAxWindowT@VCWindow@ATL@@@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLicEx@?$CAxWindow2T@VCWindow@ATL@@@ATL@@QAEJPBGPAUIStream@@PAPAUIUnknown@@2ABU_GUID@@PAU4@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$_DebugHeapAllocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPBGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdviseSinkMap@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEJ_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCSignature@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetString@?$CSimpleStringT@D$0A@@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$_DebugHeapAllocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetString@?$CSimpleStringT@D$0A@@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyCharsOverlapped@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartDialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@N@@YANNH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@H@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@M@@YAMMH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Pow_int@O@@YAOOH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vfacet@locale@std@@@std@@YAXPAVfacet@locale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@G@std@@@std@@YAABV?$ctype@G@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAlignUp@H@ATL@@YGHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DialogProc@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@Vlocale@std@@@std@@YAXPAVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryHost@UIAxWinHostWindowLic@@@?$CAxWindowT@VCWindow@ATL@@@ATL@@QAEJPAPAUIAxWinHostWindowLic@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryInterface@UIUnknown@@@?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QBEJPAPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_DebugHeapDelete@X@std@@YAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryHost@?$CAxWindowT@VCWindow@ATL@@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDD@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CAxDialogImpl@VCShowSelectCert@@VCWindow@ATL@@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LockServer@CComClassFactory@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@HNHMIKBN@m_pfnCreateInstance?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FH@OCMNPHBO@CComClassFactory?3?5asked?5for?5non?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UIUnknown@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIUnknown@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _AtlAxGetHost@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@CFOEICJD@WM_ATLGETHOST?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NHACCMFP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?WM_ATLGETHOST@ATL@@3IA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PGEBGEDK@ppUnk?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07MEKCDCMA@pp?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_3935bda8_4ed9_495c_8650_e01fc1e38a4b
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DialogProc@?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@SGHPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IEnumUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09BEHAHIFA@_CComEnum?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000100_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Next@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJKPAPAUIUnknown@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@UAGJPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CComEnumImpl@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@@ATL@@QAEJPAPAUIUnknown@@0PAU3@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIUnknown@@@ATL@@QBEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumUnknown@@$1?_GUID_00000100_0000_0000_c000_000000000046@@3U__s_GUID@@BPAUIUnknown@@V?$_CopyInterface@UIUnknown@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongPtrA@@YAJPAUHWND__@@HJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWNDPROC@CWndProcThunk@ATL@@QAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCodeAddress@CDynamicStdCallThunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06CIAHICCP@pThunk?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetCodeAddress@_stdcallthunk@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CWndProcThunk@ATL@@QAEXP6GJPAUHWND__@@IIJ@ZPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CDynamicStdCallThunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@_stdcallthunk@ATL@@QAEXKPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ExtractCreateWndData@CAtlWinModule@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Empty@?$CSimpleStringT@D$0A@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6BIObjectWithSite@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?StringLength@?$CSimpleStringT@D$0A@@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComAggObject@VCSignature@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@CCFFBNDL@?$CI?$CIHRESULT?$CJ?$CIhr?$CJ?5?$DO?$DN?50?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Detach@?$CComPtrBase@UIUnknown@@@ATL@@QAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIUnknown@@@ATL@@QAEPAPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIAxWinHostWindowLic@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIUnknown@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIUnknown@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AtlAxCreateControlLicEx@32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxHostWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxHostWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@IEKIGPOE@CAxHostWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000118_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_922eada0_3424_11cf_b670_00aa004cd6d8
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_9c2cad80_3424_11cf_b670_00aa004cd6d8
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000119_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b196b289_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000011b_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_6d5140c1_7436_11ce_8034_00aa006009fa
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b6ea2051_048a_11d1_82b9_00c04fb9942e
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_bd3f23c0_d43e_11cf_893b_00aa00bdce1a
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000010f_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxHostWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxHostWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseAll@CAxHostWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIViewObjectEx@@@ATL@@QBEPAUIViewObjectEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIViewObjectEx@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIViewObjectEx@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleObject@@@ATL@@QBEPAUIOleObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIOleObject@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIOleObject@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIObjectWithSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIObjectWithSite@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIObjectWithSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIObjectWithSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIObjectWithSite@@@ATL@@QAEPAPAUIObjectWithSite@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIObjectWithSite@@@ATL@@QBEPAUIObjectWithSite@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIObjectWithSite@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIObjectWithSite@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIViewObjectEx@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIUnknown@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxHostWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxHostWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxHostWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAxWinHostWindowLic@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAxWinHostWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleClientSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceSiteWindowless@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceSiteEx@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleControlSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleContainer@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IParseDisplayName@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$IObjectWithSiteImpl@VCAxHostWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IObjectWithSite@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$IObjectWithSiteImpl@VCAxHostWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IServiceProvider@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAdviseSink@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDocHostUIHandler@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAxWinAmbientDispatchEx@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IAxWinAmbientDispatch@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IDispatch@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceFrame@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceFrame@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceUIWindow@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceUIWindow@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIViewObjectEx@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIViewObjectEx@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIViewObjectEx@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIViewObjectEx@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceObjectWindowless@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceObjectWindowless@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIDispatch@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIDocHostUIHandlerDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIDocHostUIHandlerDispatch@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIDocHostUIHandlerDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIDocHostUIHandlerDispatch@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIFontDisp@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIFontDisp@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIFontDisp@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIFontDisp@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIServiceProvider@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIServiceProvider@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIServiceProvider@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIServiceProvider@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxHostWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxHostWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxHostWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnEraseBackground@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8?$CComPtrBase@UIViewObjectEx@@@ATL@@QBE_NPAUIViewObjectEx@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnPaint@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetClientRect@CWindow@ATL@@QBEHPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSize@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlPixelToHiMetric@ATL@@YGXPBUtagSIZE@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MGJHNDPC@hDCScreen?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QBEPAUIOleInPlaceObjectWindowless@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIOleInPlaceObjectWindowless@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnMouseActivate@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleClientSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleClientSite@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleClientSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleClientSite@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIOleClientSite@@@ATL@@QAEPAPAUIOleClientSite@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleClientSite@@@ATL@@QBEPAUIOleClientSite@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSetFocus@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsChild@CWindow@ATL@@QBEHPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnKillFocus@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnWindowlessMouseMessage@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnWindowMessage@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDestroy@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReflectNotifications@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DefWindowProcA@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BG@FBJLDDEB@?3?3IsWindow?$CIhWndChild?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnGetUnknown@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WM_ATLGETCONTROL@ATL@@3IA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?OnGetControl@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnForwardMsg@CAxHostWindow@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@NJNLJPMN@lParam?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComQIPtr@UIOleInPlaceActiveObject@@$1?_GUID_00000117_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000117_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComQIPtr@UIOleInPlaceActiveObject@@$1?_GUID_00000117_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QBEPAUIOleInPlaceActiveObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIOleInPlaceActiveObject@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindowLongPtrA@@YAJPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@CAxHostWindow@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetControllingUnknown@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAEPAUIUnknown@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIAxWinHostWindowLic@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControl@CAxHostWindow@ATL@@UAGJPBGPAUHWND__@@PAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlEx@CAxHostWindow@ATL@@UAGJPBGPAUHWND__@@PAUIStream@@PAPAUIUnknown@@ABU_GUID@@PAU5@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AttachControl@CAxHostWindow@ATL@@UAGJPAUIUnknown@@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubclassWindow@CAxHostWindow@ATL@@QAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SubclassWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ActivateAx@CAxHostWindow@ATL@@QAEJPAUIUnknown@@_NPAUIStream@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIOleObject@@@ATL@@QAEPAPAUIOleObject@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000112_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComQIPtr@UIPersistStreamInit@@$1?_GUID_7fd52380_4e07_101b_ae2d_08002b2ec713@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIPersistStreamInit@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIPersistStreamInit@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIPersistStreamInit@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIPersistStreamInit@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComQIPtr@UIPersistStreamInit@@$1?_GUID_7fd52380_4e07_101b_ae2d_08002b2ec713@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIPersistStreamInit@@@ATL@@QBEPAUIPersistStreamInit@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIPersistStreamInit@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIPersistStreamInit@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComQIPtr@UIPersistStream@@$1?_GUID_00000109_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIPersistStream@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIPersistStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComQIPtr@UIPersistStream@@$1?_GUID_00000109_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIPersistStream@@@ATL@@QBEPAUIPersistStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIPersistStream@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIPersistStream@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000127_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UIViewObjectEx@@@ATL@@QAEPAPAUIViewObjectEx@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_0000010d_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComQIPtr@UIAdviseSink@@$1?_GUID_0000010f_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIAdviseSink@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIAdviseSink@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIAdviseSink@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIAdviseSink@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComQIPtr@UIAdviseSink@@$1?_GUID_0000010f_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIAdviseSink@@@ATL@@QBEPAUIAdviseSink@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_1M@IJFAIKMG@?$AAA?$AAX?$AAW?$AAI?$AAN?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComQIPtr@UIOleClientSite@@$1?_GUID_00000118_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComQIPtr@UIOleClientSite@@$1?_GUID_00000118_0000_0000_c000_000000000046@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RedrawWindow@CWindow@ATL@@QAEHPBUtagRECT@@PAUHRGN__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseWindow@CAxHostWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UnsubclassWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DestroyWindow@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryControl@CAxHostWindow@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExternalDispatch@CAxHostWindow@ATL@@UAGJPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIDispatch@@@ATL@@QAEPAUIDispatch@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetExternalUIHandler@CAxHostWindow@ATL@@UAGJPAUIDocHostUIHandlerDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIDocHostUIHandlerDispatch@@@ATL@@QAEPAUIDocHostUIHandlerDispatch@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLic@CAxHostWindow@ATL@@UAGJPBGPAUHWND__@@PAUIStream@@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateControlLicEx@CAxHostWindow@ATL@@UAGJPBGPAUHWND__@@PAUIStream@@PAPAUIUnknown@@ABU_GUID@@PAU5@PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsParentDialog@CWindow@ATL@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@CWindow@ATL@@QBE?AV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06FGFHJIJL@?$CD32770?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_25336920_03f9_11cf_8fd0_00aa00686f13
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FindOneOf@CAtlModule@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_8856f961_340a_11d0_a96b_00c04fd705a2
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComPtr@UIClassFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIClassFactory2@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIClassFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIClassFactory2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIClassFactory2@@@ATL@@QAEPAPAUIClassFactory2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_b196b28f_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UIClassFactory2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIClassFactory2@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStyle@CWindow@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowLongA@CWindow@ATL@@QAEJHJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocslen@@YAHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIPersistStreamInit@@@ATL@@QAEPAPAUIPersistStreamInit@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIWebBrowser2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIWebBrowser2@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIWebBrowser2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIWebBrowser2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIWebBrowser2@@@ATL@@QAEPAPAUIWebBrowser2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_d30c1661_cdaf_11d0_8a3e_00c04fc9e26e
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CComPtrBase@UIWebBrowser2@@@ATL@@QBEPAUIWebBrowser2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CComVariant@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIWebBrowser2@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIWebBrowser2@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8?$CComPtrBase@UIUnknown@@@ATL@@QBE_NPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIOleClientSite@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W3AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SaveObject@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BL@CNPLMFBE@IOleClientSite?3?3SaveObject?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@HFBNDALM@ATL?3?5?$CFs?5not?5implemented?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetMoniker@CAxHostWindow@ATL@@UAGJKKPAPAUIMoniker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BL@HDINKMHC@IOleClientSite?3?3GetMoniker?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetContainer@CAxHostWindow@ATL@@UAGJPAPAUIOleContainer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@KEMGAJPK@IOleClientSite?3?3GetContainer?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@IKOGDFNC@ppContainer?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ShowObject@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@FMNOCGEC@IOleClientSite?3?3ShowObject?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetDC@CWindow@ATL@@QAEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseDC@CWindow@ATL@@QAEHPAUHDC__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnShowWindow@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@BIBMKNOD@IOleClientSite?3?3OnShowWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RequestNewObjectLayout@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CH@INFDHCMD@IOleClientSite?3?3RequestNewObject@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIOleInPlaceSiteWindowless@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@W7AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxHostWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CG@NBALHJKL@IOleInPlaceSite?3?3ContextSensitiv@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CanInPlaceActivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnInPlaceActivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BG@DFBPOHKH@m_bInPlaceActive?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??8?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QBE_NPAUIOleInPlaceObjectWindowless@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@FKHKLPMP@m_spInPlaceObjectWindowless?5?$DN?$DN?50@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UIOleInPlaceObjectWindowless@@@ATL@@QAEPAPAUIOleInPlaceObjectWindowless@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000113_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnUIActivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BP@BDGDJPEF@IOleInPlaceSite?3?3OnUIActivate?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWindowContext@CAxHostWindow@ATL@@UAGJPAPAUIOleInPlaceFrame@@PAPAUIOleInPlaceUIWindow@@PAUtagRECT@@2PAUtagOIFI@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??7?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QAEPAPAUIOleInPlaceFrame@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000116_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QBEPAUIOleInPlaceFrame@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@OJFGBHML@m_spInPlaceFrame?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??7?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateInstance@?$CComObject@VCAxUIWindow@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QAEPAPAUIOleInPlaceUIWindow@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00000115_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QBEPAUIOleInPlaceUIWindow@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@OHNINIJH@m_spInPlaceUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CopyTo@?$CComPtrBase@UIOleInPlaceFrame@@@ATL@@QAEJPAPAUIOleInPlaceFrame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08IMNICHFN@ppT?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CopyTo@?$CComPtrBase@UIOleInPlaceUIWindow@@@ATL@@QAEJPAPAUIOleInPlaceUIWindow@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Scroll@CAxHostWindow@ATL@@UAGJUtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@LMFIJFLF@IOleInPlaceSite?3?3Scroll?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnUIDeactivate@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@DPJACDKI@IOleInPlaceSite?3?3OnUIDeactivate?6@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnInPlaceDeactivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DiscardUndoState@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CC@DHNOFCHL@IOleInPlaceSite?3?3DiscardUndoStat@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DeactivateAndUndo@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CD@HDPLACCC@IOleInPlaceSite?3?3DeactivateAndUn@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnPosRectChange@CAxHostWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@EMPHOJEH@IOleInPlaceSite?3?3OnPosRectChange@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnInPlaceActivateEx@CAxHostWindow@ATL@@UAGJPAHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_1c2056cc_5ef4_101b_8bc8_00aa003e3b29
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?OnInPlaceDeactivateEx@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestUIActivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CanWindowlessActivate@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCapture@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCapture@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetCapture@CWindow@ATL@@QAEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFocus@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetFocus@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDC@CAxHostWindow@ATL@@UAGJPBUtagRECT@@KPAPAUHDC__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReleaseDC@CAxHostWindow@ATL@@UAGJPAUHDC__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidateRect@CAxHostWindow@ATL@@UAGJPBUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidateRect@CWindow@ATL@@QAEHPBUtagRECT@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidateRgn@CAxHostWindow@ATL@@UAGJPAUHRGN__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InvalidateRgn@CWindow@ATL@@QAEXPAUHRGN__@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ScrollRect@CAxHostWindow@ATL@@UAGJHHPBUtagRECT@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AdjustRect@CAxHostWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDefWindowMessage@CAxHostWindow@ATL@@UAGJIIJPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIOleControlSite@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnControlInfoChanged@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LockInPlaceActive@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetExtendedControl@CAxHostWindow@ATL@@UAGJPAPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryInterface@UIDispatch@@@?$CComPtrBase@UIOleObject@@@ATL@@QBEJPAPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TransformCoords@CAxHostWindow@ATL@@UAGJPAU_POINTL@@PAUtagPOINTF@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BP@OACOCMEL@CAxHostWindow?3?3TransformCoords?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxHostWindow@ATL@@UAGJPAUtagMSG@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFocus@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowPropertyFrame@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@LHNPGPLG@CAxHostWindow?3?3ShowPropertyFrame@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIOleContainer@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBA@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBA@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseDisplayName@CAxHostWindow@ATL@@UAGJPAUIBindCtx@@PAGPAKPAPAUIMoniker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@JLJFMEKB@CAxHostWindow?3?3ParseDisplayName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EnumObjects@CAxHostWindow@ATL@@UAGJKPAPAUIEnumUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LockContainer@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6B?$IObjectWithSiteImpl@VCAxHostWindow@ATL@@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBE@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBE@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSite@CAxHostWindow@ATL@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetSite@?$IObjectWithSiteImpl@VCAxHostWindow@ATL@@@ATL@@UAGJPAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@GGAAJPMM@IObjectWithSiteImpl?3?3SetSite?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UIServiceProvider@@@ATL@@QAEPAPAUIServiceProvider@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@MNNNBAEJ@No?5ServiceProvider?$CB?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@CCGAKCJM@?$CBhr?5?$CG?$CG?5?$CCNo?5ServiceProvider?$CB?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIServiceProvider@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSite@?$IObjectWithSiteImpl@VCAxHostWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@JHCMIMLB@IObjectWithSiteImpl?3?3GetSite?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07HFHBNNAN@ppvSite?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_E?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WDI@AEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIServiceProvider@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WBM@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?QueryService@CAxHostWindow@ATL@@UAGJABU_GUID@@0PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@HHBDEBO@ppvObj?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CComPtrBase@UIServiceProvider@@@ATL@@QBEPAUIServiceProvider@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIServiceProvider@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIServiceProvider@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIAdviseSink@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCA@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCA@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDataChange@CAxHostWindow@ATL@@UAGXPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnViewChange@CAxHostWindow@ATL@@UAGXKJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnRename@CAxHostWindow@ATL@@UAGXPAUIMoniker@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnSave@CAxHostWindow@ATL@@UAGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnClose@CAxHostWindow@ATL@@UAGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6BIDocHostUIHandler@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCE@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCE@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowContextMenu@CAxHostWindow@ATL@@UAGJKPAUtagPOINT@@PAUIUnknown@@PAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIDocHostUIHandlerDispatch@@@ATL@@QBEPAUIDocHostUIHandlerDispatch@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIDocHostUIHandlerDispatch@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDocHostUIHandlerDispatch@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHostInfo@CAxHostWindow@ATL@@UAGJPAU_DOCHOSTUIINFO@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ShowUI@CAxHostWindow@ATL@@UAGJKPAUIOleInPlaceActiveObject@@PAUIOleCommandTarget@@PAUIOleInPlaceFrame@@PAUIOleInPlaceUIWindow@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?HideUI@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateUI@CAxHostWindow@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnDocWindowActivate@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFrameWindowActivate@CAxHostWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResizeBorder@CAxHostWindow@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxHostWindow@ATL@@UAGJPAUtagMSG@@PBU_GUID@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOptionKeyPath@CAxHostWindow@ATL@@UAGJPAPAGK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ByteLength@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocscpy@@YAPAGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDropTarget@CAxHostWindow@ATL@@UAGJPAUIDropTarget@@PAPAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BC@PLOCGENL@ppDropTarget?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000122_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetExternal@CAxHostWindow@ATL@@UAGJPAPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@NNOLHPBE@ppDispatch?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CopyTo@?$CComPtrBase@UIDispatch@@@ATL@@QAEJPAPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateUrl@CAxHostWindow@ATL@@UAGJKPAGPAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@INEFCEPO@ppchURLOut?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??ICComBSTR@ATL@@QAEPAPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Length@CComBSTR@ATL@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FilterDataObject@CAxHostWindow@ATL@@UAGJPAUIDataObject@@PAPAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@KFNKBCLH@ppDORet?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0000010e_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@6B?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCI@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCI@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@WCI@AGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfoCount@?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTypeInfo@?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_tih@?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetIDsOfNames@?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke@CAxHostWindow@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Invoke@?$IDispatchImpl@UIAxWinAmbientDispatchEx@@$1?_GUID_b2d0778b_ac99_4c58_a5c8_e7724e5316b5@@3U__s_GUID@@B$1?m_libid@CAtlModule@ATL@@2U_GUID@@A$0PPPP@$0PPPP@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIDispatch@@@ATL@@QBEPAUIDispatch@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIDispatch@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIDispatch@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FireAmbientPropertyChange@CAxHostWindow@ATL@@QAEJJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComQIPtr@UIOleControl@@$1?_GUID_b196b288_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIOleControl@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIOleControl@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIOleControl@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIOleControl@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_b196b288_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CComQIPtr@UIOleControl@@$1?_GUID_b196b288_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIOleControl@@@ATL@@QBEPAUIOleControl@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UIOleControl@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UIOleControl@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put_AllowWindowlessActivation@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_AllowWindowlessActivation@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BH@JHFFPENB@pbAllowWindowless?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_BackColor@CAxHostWindow@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_BackColor@CAxHostWindow@ATL@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@DDJGHAOM@pclrBackground?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_ForeColor@CAxHostWindow@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_ForeColor@CAxHostWindow@ATL@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@LIPPFLE@pclrForeground?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_LocaleID@CAxHostWindow@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_LocaleID@CAxHostWindow@ATL@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@GDKLOMEM@plcidLocaleID?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_UserMode@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_UserMode@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@OPEFOKNK@pbUserMode?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_DisplayAsDefault@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_DisplayAsDefault@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@NOFOIMNO@pbDisplayAsDefault?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_Font@CAxHostWindow@ATL@@UAGJPAUIFontDisp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIFontDisp@@@ATL@@QAEPAUIFontDisp@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_Font@CAxHostWindow@ATL@@UAGJPAPAUIFontDisp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@LJCFDACO@pFont?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??8?$CComPtrBase@UIFontDisp@@@ATL@@QBE_NPAUIFontDisp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIFontDisp@@@ATL@@QAEPAPAUIFontDisp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_bef6e003_a874_101a_8bba_00aa00300cab
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CopyTo@?$CComPtrBase@UIFontDisp@@@ATL@@QAEJPAPAUIFontDisp@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?put_MessageReflect@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_MessageReflect@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BG@FLHHODIE@pbMessageReflect?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?get_ShowGrabHandles@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_ShowHatching@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BE@JEDDFNM@pbShowHatching?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_DocHostFlags@CAxHostWindow@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_DocHostFlags@CAxHostWindow@ATL@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BF@IJHKDPOI@pdwDocHostFlags?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_DocHostDoubleClickFlags@CAxHostWindow@ATL@@UAGJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_DocHostDoubleClickFlags@CAxHostWindow@ATL@@UAGJPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@LFBHCFDK@pdwDocHostDoubleClickFlags?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_AllowContextMenu@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_AllowContextMenu@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@OGJLKJIH@pbAllowContextMenu?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_AllowShowUI@CAxHostWindow@ATL@@UAGJF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_AllowShowUI@CAxHostWindow@ATL@@UAGJPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@CGGOPJAM@pbAllowShowUI?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?put_OptionKeyPath@CAxHostWindow@ATL@@UAGJPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CComBSTR@ATL@@QAEAAV01@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_OptionKeyPath@CAxHostWindow@ATL@@UAGJPAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BI@IKNLNBPD@pbstrOptionKeyPath?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetAmbientDispatch@CAxHostWindow@ATL@@UAGJPAUIDispatch@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComContainedObject@VCAxHostWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@?$CComPolyObject@VCAxHostWindow@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_b6ea2050_048a_11d1_82b9_00c04fb9942e
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QAEPAPAUIAxWinHostWindowLic@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIAxWinHostWindowLic@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIAxWinHostWindowLic@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AtlAxWinInit@0
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HGBKDMEN@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@POPOELFC@WM_ATLGETHOST?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@ICJMLDDL@WM_ATLGETCONTROL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _AtlAxCreateControlLic@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@?$CAxWindowT@VCWindow@ATL@@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@EFNCNKLF@AtlAxWin71?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWindow@ATL@@QAE@PAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?A2T@@YAPADPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendDlgItemMessageA@CWindow@ATL@@QAEJHIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CopyChars@?$CSimpleStringT@D$0A@@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ThrowMemoryException@?$CSimpleStringT@D$0A@@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetLength@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@ILOMLJGA@nLength?5?$DO?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CD@EEFFJEGJ@nLength?5?$DM?$DN?5GetData?$CI?$CJ?9?$DOnAllocLeng@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CComClassFactory@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCComClassFactory@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@PADCHBLN@CComClassFactory?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000001_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CComClassFactory@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?AtlFindStringResourceInstance@ATL@@YAPAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuffer@?$CSimpleStringT@D$0A@@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@?$CAxWindow2T@VCWindow@ATL@@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@HHPDHHJB@AtlAxWinLic71?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@CWindow@ATL@@QAEPAUHWND__@@PBDPAU3@V_U_RECT@2@0KKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@OIIMFBNE@nRefs?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetData@?$CSimpleStringT@D$0A@@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@?$CSimpleStringT@D$0A@@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FD@MKDEOELP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CWindowImplRoot@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DE@JJEOCICO@ERROR?5?9?5Object?5deleted?5before?5wi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CWindowImplRoot@VCWindow@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMessageMap@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CWndProcThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CDynamicStdCallThunk@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InlineIsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_00020401_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CComBSTR@ATL@@QAEXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CComBSTR@ATL@@QAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?FindNextDlgItem@_DialogSplitHelper@ATL@@SAPAUDLGITEMTEMPLATE@@PAU3@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowPos@CWindow@ATL@@QAEHPAUHWND__@@HHHHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetWindowContextHelpId@CWindow@ATL@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_U_RECT@ATL@@QAE@PAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_U_MENUorID@ATL@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UIStream@@@ATL@@QBEPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ParseInitData@_DialogSplitHelper@ATL@@SAJPAUIStream@@PAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UIStream@@@ATL@@QAEPAPAUIStream@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UIStream@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UIStream@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindCreateData@_DialogSplitHelper@ATL@@SAKKPAEPAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@KAJDHFFC@dwLen?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsActiveXControl@_DialogSplitHelper@ATL@@SA_NPAUDLGITEMTEMPLATE@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CWindow@ATL@@QBE?AV12@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindFirstDlgItem@_DialogSplitHelper@ATL@@SAPAUDLGITEMTEMPLATE@@PBUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DlgTemplateItemCount@_DialogSplitHelper@ATL@@SAAAGPAUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsDialogEx@_DialogSplitHelper@ATL@@SAHPBUDLGTEMPLATE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OAFOKPBM@?3?3IsWindow?$CIm_hWnd?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetResourceInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AtlAxDialogBoxA@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlAxDialogCreateT@PBDV_AtlDialogBoxIndirectParamHelper@ATL@@$1?DialogBoxIndirectParamA@@YGHPAUHINSTANCE__@@PBUDLGTEMPLATE@@PAUHWND__@@P6GH2IIJ@ZJ@Z@ATL@@YAHPAUHINSTANCE__@@PBDPAUHWND__@@P6GH2IIJ@ZJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInvalidValue@_AtlDialogBoxIndirectParamHelper@ATL@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlFindResource@ATL@@YAPAUHRSRC__@@PAUHINSTANCE__@@PBD1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SplitDialogTemplate@_DialogSplitHelper@ATL@@SAPAUDLGTEMPLATE@@PAU3@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EM@CKDPENDE@cbItem?5?$DO?$DN?5?$CIbDialogEx?5?$DP?5sizeof?$CIDL@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsValidReturnVal@_AtlDialogBoxIndirectParamHelper@ATL@@SA_NH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
;	COMDAT ?AddCreateWndData@CAtlWinModule@ATL@@QAEXPAU_AtlCreateWndData@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EP@FECMNBMC@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@MFNOGLO@m_hWnd?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlIsValidString@ATL@@YAHPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$basic_streambuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_istream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$basic_ostream@GU?$char_traits@G@std@@@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$_DebugHeapAllocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6BIOleInPlaceUIWindow@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxUIWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@EHKCMBND@CAxUIWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxUIWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxUIWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassName@CWindow@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Register@_ATL_WNDCLASSINFOA@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterWndClassInfoA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PAU_ATL_BASE_MODULE70@1@PAU_ATL_WNDCLASSINFOA@1@PAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamA@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOA@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamA@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DN@BIGELNIF@ERROR?5?3?5Invalid?5Arguments?5to?5Atl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0EL@KHCGDDHE@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DK@EAELIHNL@ERROR?5?3?5Could?5not?5obtain?5Window?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?LoadCursorA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAPAUHICON__@@PAUHINSTANCE__@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatWindowClassName@AtlModuleRegisterWndClassInfoParamA@ATL@@SAXPADPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09OOFFBKGI@ATL?3?$CF8?48X?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetClassInfoExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAHPAUHINSTANCE__@@PBDPAUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterClassExA@AtlModuleRegisterWndClassInfoParamA@ATL@@SAGPAU_ATL_WIN_MODULE70@2@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlWinModuleRegisterClassExA@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXA@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXHABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAPAXIPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3G@Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@SAXPAXPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Wrapper@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@ABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04LOGEFONP@bRet?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@KAMJMGHJ@pProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIGOECOI@p?9?$DOpWndProc?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndExStyle@?$CWinTraits@$0FGAAAAAA@$0A@@ATL@@SAKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@FJBCDDKK@AXWIN?5UI?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxUIWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxUIWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxUIWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxUIWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$CComPtr@UIOleInPlaceActiveObject@@@ATL@@QAEPAUIOleInPlaceActiveObject@@PAU2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxUIWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxUIWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxUIWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxUIWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComPtrBase@UIOleInPlaceActiveObject@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxUIWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxUIWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxUIWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceUIWindow@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6BIOleInPlaceFrame@@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_InternalQueryInterface@CAxFrameWindow@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@MFMDEJMN@CAxFrameWindow?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CAxFrameWindow@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWindow@CAxFrameWindow@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@JIHHHPOK@phwnd?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PBDKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAAAU_ATL_WNDCLASSINFOA@3@XZ@4U43@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetWndCaption@?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@LIOMMJMF@AXWIN?5Frame?5Window?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ContextSensitiveHelp@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBorder@CAxFrameWindow@ATL@@UAGJPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RequestBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetBorderSpace@CAxFrameWindow@ATL@@UAGJPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetActiveObject@CAxFrameWindow@ATL@@UAGJPAUIOleInPlaceActiveObject@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAUtagOleMenuGroupWidths@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMenu@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@PAXPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveMenus@CAxFrameWindow@ATL@@UAGJPAUHMENU__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetStatusText@CAxFrameWindow@ATL@@UAGJPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableModeless@CAxFrameWindow@ATL@@UAGJH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TranslateAcceleratorA@CAxFrameWindow@ATL@@UAGJPAUtagMSG@@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7?$CComObject@VCAxFrameWindow@ATL@@@ATL@@6B?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@1@@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ProcessWindowMessage@CAxFrameWindow@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComObject@VCAxFrameWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FinalRelease@CAxFrameWindow@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAxFrameWindow@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAxFrameWindow@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CWindowImpl@VCAxFrameWindow@ATL@@VCWindow@2@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IOleInPlaceFrame@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite@?$CSimpleStringT@D$0A@@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrepareWrite2@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fork@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@?$CSimpleStringT@D$0A@@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@GFHAPKDK@pOldData?9?$DOnAllocLength?5?$DM?5nLength@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0HE@GOKGCPDA@0?5?$CG?$CG?5?$CCUse?5OBJECT_ENTRY_NON_CREAT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06JHNIBAJK@CLSID?2?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@LBABFFHO@lRes?5?$DN?$DN?50L?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCRegKey@ATL@@QBEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CB@IHBDCFNI@pbstrPath?5?$CB?$DN?50?5?$CG?$CG?5ppTypeLib?5?$CB?$DN?50@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFPPHOIH@hInstTypeLib?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LFHHJFCN@?4tlb?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CA@JANIBNGM@pComModule?9?$DOm_hInstTypeLib?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharNextO@@YAPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EH@BABLPHCB@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetLockCount@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CAtlModule@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComModule@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CAtlModule@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CAtlModule@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_ATL_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@JLCMIEMB@_pAtlModule?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@JALIHHGH@ERROR?5?3?5Unable?5to?5initialize?5cri@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CComModule@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCComModule@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@NJOPLADJ@ppGIT?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _CLSID_StdGlobalInterfaceTable
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@GKCENBEN@m_pGIT?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegObject@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IRegistrarBase@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@CComFakeCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BP@DILLEFPO@lpszKey?5?$CB?$DN?50?5?$CG?$CG?5lpszValue?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@HGJLNPOD@Failed?5to?5LoadLibrary?5on?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KJDBLEOI@Failed?5to?5FindResource?5on?5ID?3?$CFd?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@COPMGFKA@Failed?5to?5FindResource?5on?5ID?3?$CFs?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@LNHJMEOP@Failed?5to?5LoadResource?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0N@FCNKJMCG@lpszReg?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@HMGHIDAH@ppszReg?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CParseBuffer@CRegParser@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StrChrA@CRegParser@ATL@@KAPADPADD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BK@LLGNALDE@Error?5no?5closing?5?$CF?5found?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BF@KHDDAOIJ@Map?5Entry?5not?5found?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_06JALMKDEH@p?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_04OHBKMIBJ@HKCR?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KIFLFONO@HKCU?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04CBBMIBLK@HKLM?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DLBIJLAB@HKU?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04OFOCGAOH@HKPD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04POMNGLEL@HKDD?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LEMDOLAJ@HKCC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BN@HJIJAHEL@HKeyFromString?5failed?5on?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CE@HPLFHOFC@NextToken?5?3?5Unexpected?5End?5of?5Fi@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CJ@JJEGIHLG@Syntax?5error?0?5expecting?5a?5?$HL?0?5fou@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GenerateError@CRegParser@ATL@@IAEJI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CC@MOJNOPNN@Failed?5to?5register?0?5cleaning?5up?$CB@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@EHICPHFJ@Num?5Els?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0N@GKIPNAL@Deleting?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?DeleteValue@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BB@POOIJOEN@Creating?5key?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_C@_0BH@IHOFLOMJ@?$CFs?5Type?5not?5supported?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@EEDIHPHE@?$CIdwType?5?$DN?$DN?5?$CI?51?5?$CJ?$CJ?5?$HM?$HM?5?$CIdwType?5?$DN?$DN?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDCHGJG@Setting?5Value?5?$CFd?5at?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CN@BAKOHBFP@Binary?5Data?5does?5not?5fall?5on?5BYT@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ChToByte@CRegParser@ATL@@KAED@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0CL@PILPOMLI@Bogus?5value?5?$CFc?5passed?5as?5binary?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0P@IONAJCEO@Opened?5Key?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CM@LEFFDKCG@Ignoring?5Open?5key?5on?5?$CFs?5?3?5In?5Rec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BG@OEFMOOAA@Ending?5Recovery?5Mode?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BG@OFKLEKA@Should?5not?5be?5here?$CB?$CB?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CH@OEJDLABI@Deleting?5non?9empty?5subkey?5?$CFs?5by?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0DP@JOHDIOJH@CRegKey?3?3RecurseDeleteKey?5?3?5Fail@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@FDAMNOMP@Deleting?5Key?5?$CFs?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0M@BNMKLGID@m_hKey?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@PGKIMHP@_pModule?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7SigException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??4CComVariant@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalCopy@CComVariant@ATL@@QAEXPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Copy@CComVariant@ATL@@QAEJPBUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComVariant@ATL@@QAE@ABUtagVARIANT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_b722bccb_4e68_101b_a2bc_00aa00404770
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DJ@HNJMKNAP@_GetEntries?$CI?$CJ?$FL0?$FN?4pFunc?5?$DN?$DN?5?$CI?$CIATL?3@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Unlock@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Cache@CComObjectRootBase@ATL@@SGJPAXABU_GUID@@PAPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Lock@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __GUID_c8be4864_227a_4a1b_84ee_473681bd4872
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_0d61aa35_48d5_47f5_8249_f685f75250fd
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_0000_000000000000
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7_com_error@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$CDialogImplBaseT@VCWindow@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCWindow@ATL@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MessageBoxA@CWindow@ATL@@QAEHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendMessageA@CWindow@ATL@@QAEJIIJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDlgItem@CWindow@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CenterWindow@CWindow@ATL@@QAEHPAUHWND__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BH@ENLIMLGL@?3?3IsWindow?$CIhWndParent?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@LBNLFONB@?3?3IsWindow?$CIhWndCenter?$CJ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?A2WBSTR@@YAPAGPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BJ@OGJFCAD@nResult?5?$DN?$DN?5nConvertedLen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringA@CComBSTR@ATL@@QAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?LoadStringResource@CComBSTR@ATL@@SA_NIAAPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0O@LPAFDJOF@bstrText?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BN@BNLFFEBD@Invalid?5message?5map?5ID?5?$CI?$CFi?$CJ?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?EnableWindow@CWindow@ATL@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CShowSelectCert@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BBJEMDLA@nRet?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_09EEBKLCFA@nRefs?5?$DO?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?SetManager@CNilStringData@ATL@@QAEXPAUIAtlStringMgr@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BA@MLJMCNFJ@pStringMgr?5?$DN?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CNilStringData@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CAtlStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7?$codecvt@GDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBufferVariant@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CConfig@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT _IID_IObjectSafety
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCU
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	_IID_ISignature
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?UpdateRegistry@CSignature@@SGJH@Z		; CSignature::UpdateRegistry
PUBLIC	?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ ; CSignature::GetCategoryMap
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	_CLSID_StdGlobalInterfaceTable
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	_LIBID_XMLSIGNLib
PUBLIC	_CLSID_Signature
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
PUBLIC	_IID_IObjectSafety
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQBDB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
PUBLIC	?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ ; ATL::CComCoClass<CSignature,&CLSID_Signature>::GetObjectDescription
PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWThunk
PUBLIC	?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z	; ATL::CComObjectRootBase::ObjectMain
PUBLIC	?licenseTimeout@CLicense@@0HB			; CLicense::licenseTimeout
PUBLIC	?szModulePath@@3PAGA				; szModulePath
PUBLIC	_hInst
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWThunk
PUBLIC	?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance
PUBLIC	?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CSignature> >,ATL::CComCreator<ATL::CComAggObject<CSignature> > >::CreateInstance
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPAGPAG@Z		; ATL::CharLowerWThunk
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?CharUpperWThunk@ATL@@YGPAGPAG@Z		; ATL::CharUpperWThunk
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?WM_ATLGETHOST@ATL@@3IA				; ATL::WM_ATLGETHOST
PUBLIC	?WM_ATLGETCONTROL@ATL@@3IA			; ATL::WM_ATLGETCONTROL
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
_BSS	SEGMENT
?szModulePath@@3PAGA DW 0104H DUP (?)			; szModulePath
_hInst	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ?WM_ATLGETHOST@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETHOST@ATL@@3IA DD 01H DUP (?)			; ATL::WM_ATLGETHOST
_BSS	ENDS
;	COMDAT ?WM_ATLGETCONTROL@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETCONTROL@ATL@@3IA DD 01H DUP (?)		; ATL::WM_ATLGETCONTROL
_BSS	ENDS
CONST	SEGMENT
_IID_ISignature DD 062ec64dcH
	DW	0b26dH
	DW	046ceH
	DB	09eH
	DB	033H
	DB	024H
	DB	028H
	DB	09bH
	DB	0cfH
	DB	05fH
	DB	063H
_LIBID_XMLSIGNLib DD 07cad46b3H
	DW	047cbH
	DW	045b6H
	DB	0bbH
	DB	083H
	DB	01bH
	DB	022H
	DB	0aeH
	DB	0cH
	DB	0b3H
	DB	0bcH
_CLSID_Signature DD 0d300c133H
	DW	0a6f6H
	DW	04fb4H
	DB	0a7H
	DB	034H
	DB	048H
	DB	065H
	DB	0fbH
	DB	0f5H
	DB	0a3H
	DB	0b1H
CONST	ENDS
;	COMDAT _IID_IObjectSafety
CONST	SEGMENT
_IID_IObjectSafety DD 0cb5bdc81H
	DW	093c1H
	DW	011cfH
	DB	08fH
	DB	020H
	DB	00H
	DB	080H
	DB	05fH
	DB	02cH
	DB	0d0H
	DB	064H
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPBG0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPAGPAG@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitATL@DV?$ChTraitsCRT@D@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,ATL::StrTraitATL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@GV?$StrTraitATL@GV?$ChTraitsCRT@G@ATL@@@ATL@@@_CSTRING_IMPL_@ATL@@2_NB DB 00H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
CONST	SEGMENT
$SG201166 DB	'Invalid DateTime', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:$SG201166		; ATL::szInvalidDateTime
CONST	ENDS
CONST	SEGMENT
	ORG $+3
$SG201168 DB	'Invalid DateTimeSpan', 00H
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:$SG201168	; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ?licenseTimeout@CLicense@@0HB
CONST	SEGMENT
?licenseTimeout@CLicense@@0HB DD 01eH			; CLicense::licenseTimeout
CONST	ENDS
_DATA	SEGMENT
_ObjectMap DD	FLAT:_CLSID_Signature
	DD	FLAT:?UpdateRegistry@CSignature@@SGJH@Z
	DD	FLAT:?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	DD	FLAT:?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	DD	00H
	DD	00H
	DD	FLAT:?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ
	DD	FLAT:?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ
	DD	FLAT:?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
CONST	SEGMENT
	ORG $+3
$SG209375 DB	'pThis != 0', 00H
	ORG $+1
$SG209376 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG209386 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG209387 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG209393 DB	'pp != 0', 00H
$SG209394 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT _CLSID_StdGlobalInterfaceTable
CONST	SEGMENT
_CLSID_StdGlobalInterfaceTable DD 0323H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
CONST	SEGMENT
	ORG $+1
$SG89605 DB	'S', 00H
	ORG $+2
_szStringVal DD	FLAT:$SG89605
$SG89607 DB	'M', 00H
	ORG $+2
_multiszStringVal DD FLAT:$SG89607
$SG89609 DB	'D', 00H
	ORG $+2
_szDwordVal DD	FLAT:$SG89609
$SG89611 DB	'B', 00H
	ORG $+2
_szBinaryVal DD	FLAT:$SG89611
$SG89613 DB	'Val', 00H
_szValToken DD	FLAT:$SG89613
$SG89615 DB	'ForceRemove', 00H
_szForceRemove DD FLAT:$SG89615
$SG89617 DB	'NoRemove', 00H
	ORG $+3
_szNoRemove DD	FLAT:$SG89617
$SG89619 DB	'Delete', 00H
	ORG $+1
_szDelete DD	FLAT:$SG89619
$SG90266 DB	'AppID', 00H
	ORG $+2
$SG90267 DB	'CLSID', 00H
	ORG $+2
$SG90268 DB	'Component Categories', 00H
	ORG $+3
$SG90269 DB	'FileType', 00H
	ORG $+3
$SG90270 DB	'Interface', 00H
	ORG $+2
$SG90271 DB	'Hardware', 00H
	ORG $+3
$SG90272 DB	'Mime', 00H
	ORG $+3
$SG90273 DB	'SAM', 00H
$SG90274 DB	'SECURITY', 00H
	ORG $+3
$SG90275 DB	'SYSTEM', 00H
	ORG $+1
$SG90276 DB	'Software', 00H
	ORG $+3
$SG90277 DB	'TypeLib', 00H
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQBDB DD FLAT:$SG90266 ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:$SG90267
	DD	FLAT:$SG90268
	DD	FLAT:$SG90269
	DD	FLAT:$SG90270
	DD	FLAT:$SG90271
	DD	FLAT:$SG90272
	DD	FLAT:$SG90273
	DD	FLAT:$SG90274
	DD	FLAT:$SG90275
	DD	FLAT:$SG90276
	DD	FLAT:$SG90277
CONST	ENDS
CONST	SEGMENT
$SG91136 DB	'lpszPathName != 0', 00H
	ORG $+2
$SG91137 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlbase.h', 00H
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
CONST	SEGMENT
$SG147460 DB	'ppvObj', 00H
	ORG $+1
$SG147461 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG147486 DB	':', 00H
$SG151553 DB	00H
	ORG $+5
$SG151579 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG151580 DB	'Control creation failed for ''%s''', 0aH, 00H
	ORG $+6
$SG151582 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG151583 DB	'Error code: 0x%x - %s', 00H
	ORG $+2
$SG151598 DB	'lParam', 00H
	ORG $+1
$SG151599 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG151621 DB	00H
	ORG $+7
$SG151651 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG151652 DB	'Control creation failed for ''%s''', 0aH, 00H
	ORG $+6
$SG151654 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG151655 DB	'Error code: 0x%x - %s', 00H
	ORG $+2
$SG151670 DB	'lParam', 00H
	ORG $+1
$SG151671 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlhost.h', 00H
$SG164286 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG164287 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164311 DB	'pThis != 0', 00H
	ORG $+5
$SG164312 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164319 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164320 DB	'Subclassing through a hook discarded.', 0aH, 00H
	ORG $+1
$SG164336 DB	'pThis->m_pCurrentMsg == &msg', 00H
	ORG $+3
$SG164337 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164360 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG164361 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164372 DB	'm_hWnd == hWnd', 00H
	ORG $+1
$SG164373 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164381 DB	'm_hWnd == 0', 00H
	ORG $+4
$SG164382 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164384 DB	'::IsWindow(hWnd)', 00H
	ORG $+7
$SG164385 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164398 DB	'm_hWnd != 0', 00H
	ORG $+4
$SG164399 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlwin.h', 00H
	ORG $+1
$SG164419 DB	'pp != 0', 00H
$SG164420 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
	ORG $+1
$SG164441 DB	'pp != 0', 00H
$SG164442 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
	ORG $+1
$SG164583 DB	'm_begin == 0', 00H
	ORG $+3
$SG164584 DB	'C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\a'
	DB	'tlmfc\include\atlcom.h', 00H
CONST	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
EXTRN	__imp__GetVersionExA@4:NEAR
EXTRN	__RTC_InitBase:NEAR
EXTRN	__RTC_Shutdown:NEAR
EXTRN	__RTC_CheckEsp:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@_RTC_CheckStackVars@8:NEAR
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT rtc$IMZ
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
; Function compile flags: /Odt /RTCsu
rtc$TMZ	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_pfnGetThreadACP$ = -164				; size = 4
_ver$ = -156						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 41					; 00000029H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );

	mov	DWORD PTR _ver$[ebp], 148		; 00000094H

; 139  : 	::GetVersionEx( &ver );

	mov	esi, esp
	lea	eax, DWORD PTR _ver$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

	cmp	DWORD PTR _ver$[ebp+16], 2
	jne	SHORT $L75781
	cmp	DWORD PTR _ver$[ebp+4], 5
	jb	SHORT $L75781

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal

; 144  : 	}
; 145  : 	else

	jmp	SHORT $L75782
$L75781:

; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

	mov	DWORD PTR _pfnGetThreadACP$[ebp], OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L75782:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	mov	ecx, DWORD PTR _pfnGetThreadACP$[ebp]
	push	ecx
	push	OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 152  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211725
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L211725:
	DD	1
	DD	$L211724
$L211724:
	DD	-156					; ffffff64H
	DD	148					; 00000094H
	DD	$L211721
$L211721:
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 91   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

	mov	esi, esp
	mov	eax, DWORD PTR _pNew$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pp$[ebp]
	push	ecx
	call	DWORD PTR __imp__InterlockedExchange@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 93   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
EXTRN	__imp__GetACP@0:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_pch$75769 = -32					; size = 4
_szACP$ = -24						; size = 7
_lcidThread$ = -12					; size = 4
_nACP$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 102  : 	UINT nACP = 0;

	mov	DWORD PTR _nACP$[ebp], 0

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

	mov	esi, esp
	call	DWORD PTR __imp__GetThreadLocale@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lcidThread$[ebp], eax

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

	mov	esi, esp
	push	7
	lea	eax, DWORD PTR _szACP$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _lcidThread$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetLocaleInfoA@16
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L75768

; 111  : 	{
; 112  : 		char* pch = szACP;

	lea	edx, DWORD PTR _szACP$[ebp]
	mov	DWORD PTR _pch$75769[ebp], edx
$L75771:

; 113  : 		while (*pch != '\0')

	mov	eax, DWORD PTR _pch$75769[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L75768

; 114  : 		{
; 115  : 			nACP *= 10;

	mov	edx, DWORD PTR _nACP$[ebp]
	imul	edx, 10					; 0000000aH
	mov	DWORD PTR _nACP$[ebp], edx

; 116  : 			nACP += *pch++ - '0';

	mov	eax, DWORD PTR _pch$75769[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _nACP$[ebp]
	lea	eax, DWORD PTR [edx+ecx-48]
	mov	DWORD PTR _nACP$[ebp], eax
	mov	ecx, DWORD PTR _pch$75769[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$75769[ebp], ecx

; 117  : 		}

	jmp	SHORT $L75771
$L75768:

; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

	cmp	DWORD PTR _nACP$[ebp], 0
	jne	SHORT $L75773

; 121  : 		nACP = ::GetACP();

	mov	esi, esp
	call	DWORD PTR __imp__GetACP@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nACP$[ebp], eax
$L75773:

; 122  : 
; 123  : 	return nACP;

	mov	eax, DWORD PTR _nACP$[ebp]

; 124  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211738
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L211738:
	DD	1
	DD	$L211737
$L211737:
	DD	-24					; ffffffe8H
	DD	7
	DD	$L211735
$L211735:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	67					; 00000043H
	DB	80					; 00000050H
	DB	0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 127  : {

	push	ebp
	mov	ebp, esp

; 128  : 	return( CP_THREAD_ACP );

	mov	eax, 3

; 129  : }

	pop	ebp
	ret	0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z	; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 183  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

	mov	eax, DWORD PTR __imp__GetEnvironmentVariableW@12
	push	eax
	push	OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ; ATL::GetEnvironmentVariableWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

	mov	esi, esp
	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
	cmp	esi, esp
	call	__RTC_CheckEsp

; 188  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?GetEnvironmentVariableWThunk@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 115  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

	mov	eax, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	and	eax, 1
	jne	SHORT $L198446
	mov	ecx, DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, ecx
	mov	esi, esp
	call	DWORD PTR __imp__GetVersion@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	and	eax, -2147483648			; 80000000H
	neg	eax
	sbb	eax, eax
	neg	eax
	mov	BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L198446:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

	movzx	edx, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
	test	edx, edx
	je	SHORT $L198448

; 125  : 		pfn = pfnWin9x;

	mov	eax, DWORD PTR _pfnWin9x$[ebp]
	mov	DWORD PTR _pfn$[ebp], eax

; 126  : 	else

	jmp	SHORT $L198449
$L198448:

; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

	mov	ecx, DWORD PTR _pfnNT$[ebp]
	mov	DWORD PTR _pfn$[ebp], ecx
$L198449:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

	mov	edx, DWORD PTR _pfn$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppThunk$[ebp]
	push	eax
	call	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ; InterlockedExchangePointer

; 136  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
PUBLIC	??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z		; ATL::CW2AEX<128>::CW2AEX<128>
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
PUBLIC	??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@	; `string'
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
EXTRN	__imp__MultiByteToWideChar@24:NEAR
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__CrtDbgReport:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T211765 DD	0ffffffffH
	DD	FLAT:$L211752
	DD	00H
	DD	FLAT:$L211753
$T211757 DD	019930520H
	DD	02H
	DD	FLAT:$T211765
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
CONST	SEGMENT
??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@ DB 'nSize >= nSizeW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\cs'
	DB	'tringt.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
_TEXT	SEGMENT
$T211751 = -316						; size = 4
$T211749 = -312						; size = 4
$T211748 = -308						; size = 4
_pszNameA$ = -300					; size = 132
_pszBufferA$ = -160					; size = 132
_nSizeW$ = -24						; size = 4
_nSizeA$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 304				; 00000130H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-316]
	mov	ecx, 76					; 0000004cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 163  : 	CW2A pszNameA(pszName);

	mov	eax, DWORD PTR _pszName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z	; ATL::CW2AEX<128>::CW2AEX<128>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeA$[ebp], eax

; 166  : 	if (nSizeA == 0)

	cmp	DWORD PTR _nSizeA$[ebp], 0
	jne	SHORT $L198520

; 167  : 		return 0;

	mov	DWORD PTR $T211748[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211748[ebp]
	jmp	$L198492
$L198520:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

	mov	ecx, DWORD PTR _nSizeA$[ebp]
	shl	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

	mov	esi, esp
	mov	edx, DWORD PTR _nSizeA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ		; ATL::CW2AEX<128>::operator char *
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

	mov	esi, esp
	push	0
	push	0
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nSizeW$[ebp], eax

; 173  : 	if (nSize == 0)

	cmp	DWORD PTR _nSize$[ebp], 0
	jne	SHORT $L198522

; 174  : 		return nSizeW;

	mov	eax, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T211749[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211749[ebp]
	jmp	$L198492
$L198522:

; 175  : 	ATLASSERT(nSize >= nSizeW);

	mov	ecx, DWORD PTR _nSize$[ebp]
	cmp	ecx, DWORD PTR _nSizeW$[ebp]
	jae	SHORT $L211750
	push	OFFSET FLAT:??_C@_0BA@CLMJJCOM@nSize?5?$DO?$DN?5nSizeW?$AA@
	push	0
	push	175					; 000000afH
	push	OFFSET FLAT:??_C@_0FB@DNILBHEN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211750
	int	3
$L211750:

; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

	mov	esi, esp
	mov	eax, DWORD PTR _nSizeW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszBuffer$[ebp]
	push	ecx
	push	-1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 177  : 
; 178  : 	return nSizeW;

	mov	edx, DWORD PTR _nSizeW$[ebp]
	mov	DWORD PTR $T211751[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	call	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211751[ebp]
$L198492:

; 179  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211764
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 316				; 0000013cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L211764:
	DD	2
	DD	$L211763
$L211763:
	DD	-160					; ffffff60H
	DD	132					; 00000084H
	DD	$L211758
	DD	-300					; fffffed4H
	DD	132					; 00000084H
	DD	$L211759
$L211759:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	0
$L211758:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211752:
	lea	ecx, DWORD PTR _pszBufferA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L211753:
	lea	ecx, DWORD PTR _pszNameA$[ebp]
	jmp	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ		; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z:
	mov	eax, OFFSET FLAT:$T211757
	jmp	___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPBGPAGK@Z ENDP	; ATL::GetEnvironmentVariableWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 157  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 158  : 	return( g_pfnGetThreadACP() );

	mov	esi, esp
	call	DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
	cmp	esi, esp
	call	__RTC_CheckEsp

; 159  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?CompareStringWFake@ATL@@YGHKKPBGH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 216  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

	mov	eax, DWORD PTR __imp__CompareStringW@24
	push	eax
	push	OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ; ATL::CompareStringWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

	mov	esi, esp
	mov	ecx, DWORD PTR _nLength2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszString2$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLength1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszString1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwFlags$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	24					; 00000018H
?CompareStringWThunk@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPBGHI@Z			; AtlW2AHelper
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__imp__lstrlenW@4:NEAR
EXTRN	__imp__CompareStringA@24:NEAR
EXTRN	__alloca_probe:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T211792 DD	0ffffffffH
	DD	FLAT:$L211784
$T211786 DD	019930520H
	DD	01H
	DD	FLAT:$T211792
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
_TEXT	SEGMENT
tv147 = -76						; size = 4
tv142 = -72						; size = 4
tv149 = -68						; size = 4
tv89 = -64						; size = 4
tv84 = -60						; size = 4
tv91 = -56						; size = 4
$T211783 = -52						; size = 4
_pszAString2$ = -48					; size = 4
_pszAString1$ = -44					; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-76]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 193  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;

	mov	DWORD PTR _pszAString1$[ebp], 0

; 196  : 	if(pszString1 != NULL)

	cmp	DWORD PTR _pszString1$[ebp], 0
	je	$L198547

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString1$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L211777
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L211778
$L211777:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L211775
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L211775
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv84[ebp], esp
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $L211776
$L211775:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv89[ebp], eax
$L211776:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv91[ebp], eax
$L211778:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _pszAString1$[ebp], edx

; 199  : 		if(pszAString1 == NULL)

	cmp	DWORD PTR _pszAString1$[ebp], 0
	jne	SHORT $L198547

; 200  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L198547:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;

	mov	DWORD PTR _pszAString2$[ebp], 0

; 204  : 	if(pszString2 != NULL)

	cmp	DWORD PTR _pszString2$[ebp], 0
	je	$L198553

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _pszString2$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L211781
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $L211782
$L211781:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L211779
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L211779
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv142[ebp], esp
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR tv147[ebp], edx
	jmp	SHORT $L211780
$L211779:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv147[ebp], eax
$L211780:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv147[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv149[ebp], eax
$L211782:
	mov	edx, DWORD PTR tv149[ebp]
	mov	DWORD PTR _pszAString2$[ebp], edx

; 207  : 		if(pszAString2 == NULL)

	cmp	DWORD PTR _pszAString2$[ebp], 0
	jne	SHORT $L198553

; 208  : 			AtlThrow(E_OUTOFMEMORY);

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L198553:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

	mov	esi, esp
	mov	eax, DWORD PTR _nLength2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszAString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength1$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszAString1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR __imp__CompareStringA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T211783[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211783[ebp]
$L211774:

; 212  : }

	lea	esp, DWORD PTR [ebp-84]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211791
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$L211791:
	DD	1
	DD	$L211790
$L211790:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L211788
$L211788:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211784:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPBGH0H@Z:
	mov	eax, OFFSET FLAT:$T211786
	jmp	___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPBGH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__resetstkoflw:NEAR
EXTRN	__except_handler3:NEAR
;	COMDAT CONST
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
$T211803 DD	0ffffffffH
	DD	FLAT:$L211798
	DD	FLAT:$L211799
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
tv65 = -48						; size = 4
$T211802 = -44						; size = 4
_p$75736 = -36						; size = 4
_bStackAvailable$ = -25					; size = 1
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET FLAT:$T211803
	push	OFFSET FLAT:__except_handler3
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	add	esp, -32				; ffffffe0H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

	mov	BYTE PTR _bStackAvailable$[ebp], 1

; 333  : 
; 334  :     __try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

	mov	eax, DWORD PTR _Size$[ebp]
	add	eax, 8195				; 00002003H
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv65[ebp], esp
	mov	DWORD PTR __$SEHRec$[ebp], esp
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR _p$75736[ebp], eax
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $L211801
$L211798:
$L211810:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T211802[ebp], eax
	mov	eax, DWORD PTR $T211802[ebp]
	sub	eax, -1073741571			; c00000fdH
	neg	eax
	sbb	eax, eax
	inc	eax
$L211800:
$L211809:
	ret	0
$L211799:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

	mov	BYTE PTR _bStackAvailable$[ebp], 0

; 344  :         _resetstkoflw();

	call	__resetstkoflw
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
$L211801:

; 345  :     }
; 346  :     return bStackAvailable;

	mov	al, BYTE PTR _bStackAvailable$[ebp]
$L211797:

; 347  : }

	lea	esp, DWORD PTR [ebp-60]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211808
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L211808:
	DD	1
	DD	$L211807
$L211807:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L211805
$L211805:
	DB	112					; 00000070H
	DB	0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
EXTRN	__imp__WideCharToMultiByte@32:NEAR
;	COMDAT ??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
CONST	SEGMENT
??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@ DB 'lpw != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lconv.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@ DB 'lpa != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPBGHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPBGHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 574  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L211815
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	574					; 0000023eH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211815
	int	3
$L211815:

; 575  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L211816
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	575					; 0000023fH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211816
	int	3
$L211816:

; 576  : 	if (lpa == NULL || lpw == NULL)

	cmp	DWORD PTR _lpa$[ebp], 0
	je	SHORT $L75957
	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L75956
$L75957:

; 577  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75953
$L75956:

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';

	mov	edx, DWORD PTR _lpa$[ebp]
	mov	BYTE PTR [edx], 0

; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpa$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpw$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 583  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75959

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L211817
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	585					; 00000249H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211817
	int	3
$L211817:

; 586  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75953
$L75959:

; 587  : 	}
; 588  : 	return lpa;

	mov	eax, DWORD PTR _lpa$[ebp]
$L75953:

; 589  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlW2AHelper@@YGPADPADPBGHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	??BCTraceCategory@ATL@@QBEKXZ			; ATL::CTraceCategory::operator unsigned long
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??0CAtlException@ATL@@QAE@J@Z			; ATL::CAtlException::CAtlException
PUBLIC	??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ ; `string'
PUBLIC	__TI1?AVCAtlException@ATL@@
PUBLIC	__CTA1?AVCAtlException@ATL@@
PUBLIC	??_R0?AVCAtlException@ATL@@@8			; ATL::CAtlException `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCAtlException@ATL@@@84
EXTRN	?atlTraceException@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceException
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	__CxxThrowException@8:NEAR
;	COMDAT ??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
CONST	SEGMENT
??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@ DB 'AtlThrow: hr '
	DB	'= 0x%x', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lexcept.h', 00H				; `string'
CONST	ENDS
;	COMDAT __TI1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__TI1?AVCAtlException@ATL@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCAtlException@ATL@@
xdata$x	ENDS
;	COMDAT __CTA1?AVCAtlException@ATL@@
xdata$x	SEGMENT
__CTA1?AVCAtlException@ATL@@ DD 01H
	DD	FLAT:__CT??_R0?AVCAtlException@ATL@@@84
xdata$x	ENDS
;	COMDAT __CT??_R0?AVCAtlException@ATL@@@84
xdata$x	SEGMENT
__CT??_R0?AVCAtlException@ATL@@@84 DD 00H
	DD	FLAT:??_R0?AVCAtlException@ATL@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCAtlException@ATL@@@8
_DATA	SEGMENT
??_R0?AVCAtlException@ATL@@@8 DD FLAT:??_7type_info@@6B@ ; ATL::CAtlException `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAtlException@ATL@@', 00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T211822 = -16						; size = 4
$T211821 = -12						; size = 4
$T211820 = -8						; size = 8
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BF@IAAKIJDJ@AtlThrow?3?5hr?5?$DN?50x?$CFx?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceException@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceException
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	62					; 0000003eH
	push	OFFSET FLAT:??_C@_0FC@CFIFHLCH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T211820[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )
; 65   : 	{
; 66   : 		AfxThrowMemoryException();
; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );
; 71   : 	}
; 72   : #else
; 73   : 	throw CAtlException( hr );

	mov	ecx, DWORD PTR _hr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T211822[ebp]
	call	??0CAtlException@ATL@@QAE@J@Z		; ATL::CAtlException::CAtlException
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T211821[ebp], edx
	push	OFFSET FLAT:__TI1?AVCAtlException@ATL@@
	lea	eax, DWORD PTR $T211821[ebp]
	push	eax
	call	__CxxThrowException@8
$L211819:

; 74   : #endif
; 75   : };

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltrace.h
_TEXT	ENDS
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC NEAR	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 158  : 	{}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pszFileName$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nLineNo$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
PUBLIC	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z		; ATL::CTrace::TraceV
EXTRN	?s_trace@CTrace@ATL@@2V12@A:QWORD		; ATL::CTrace::s_trace
; Function compile flags: /Odt /RTCsu
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ
_TEXT	SEGMENT
_ptr$ = -4						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ PROC NEAR	; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 161  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 162  : 		va_list ptr; va_start(ptr, pszFmt);

	lea	eax, DWORD PTR _pszFmt$[ebp+4]
	mov	DWORD PTR _ptr$[ebp], eax

; 163  : 		ATL::CTrace::s_trace.TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

	mov	ecx, DWORD PTR _ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFmt$[ebp]
	push	edx
	mov	eax, DWORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwCategory$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET FLAT:?s_trace@CTrace@ATL@@2V12@A
	call	?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z	; ATL::CTrace::TraceV
	add	esp, 28					; 0000001cH

; 164  : 		va_end(ptr);

	mov	DWORD PTR _ptr$[ebp], 0

; 165  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
EXTRN	_AtlTraceVA:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pszFileName$ = 12					; size = 4
_nLine$ = 16						; size = 4
_dwCategory$ = 20					; size = 4
_nLevel$ = 24						; size = 4
_pszFmt$ = 28						; size = 4
_args$ = 32						; size = 4
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z PROC NEAR		; ATL::CTrace::TraceV, COMDAT

; 121  : 	{

	push	ebp
	mov	ebp, esp

; 122  : 		AtlTraceVA(m_dwModule, pszFileName, nLine, dwCategory, nLevel, pszFmt, args);

	mov	eax, DWORD PTR _args$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwCategory$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_AtlTraceVA
	add	esp, 28					; 0000001cH

; 123  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?TraceV@CTrace@ATL@@QBAXPBDHKI0PAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCTraceCategory@ATL@@QBEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCTraceCategory@ATL@@QBEKXZ PROC NEAR			; ATL::CTraceCategory::operator unsigned long, COMDAT
; _this$ = ecx

; 202  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 	return( m_dwCategory );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BCTraceCategory@ATL@@QBEKXZ ENDP			; ATL::CTraceCategory::operator unsigned long
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ??0CAtlException@ATL@@QAE@J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hr$ = 8						; size = 4
??0CAtlException@ATL@@QAE@J@Z PROC NEAR			; ATL::CAtlException::CAtlException, COMDAT
; _this$ = ecx

; 40   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR [eax], ecx

; 41   : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CAtlException@ATL@@QAE@J@Z ENDP			; ATL::CAtlException::CAtlException
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 240  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

	mov	eax, DWORD PTR __imp__GetStringTypeExW@20
	push	eax
	push	OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ; ATL::GetStringTypeExWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

	mov	esi, esp
	mov	ecx, DWORD PTR _pwCharType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwInfoType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 244  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	20					; 00000014H
?GetStringTypeExWThunk@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T211848 DD	0ffffffffH
	DD	FLAT:$L211840
$T211842 DD	019930520H
	DD	01H
	DD	FLAT:$T211848
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
_TEXT	SEGMENT
$T211839 = -164						; size = 4
_pszA$ = -156						; size = 132
_nLengthA$ = -20					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 152				; 00000098H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-164]
	mov	ecx, 38					; 00000026H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _nLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszSrc$[ebp]
	push	ecx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nLengthA$[ebp], eax

; 229  : 	pszA.Allocate(nLengthA);

	mov	edx, DWORD PTR _nLengthA$[ebp]
	push	edx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	ecx, DWORD PTR _nLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszSrc$[ebp]
	push	edx
	push	0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp

; 231  : 
; 232  : 	if (nLength == -1)

	cmp	DWORD PTR _nLength$[ebp], -1
	jne	SHORT $L198579

; 233  : 		nLengthA = -1;

	mov	DWORD PTR _nLengthA$[ebp], -1
$L198579:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

	mov	esi, esp
	mov	eax, DWORD PTR _pwCharType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLengthA$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	edx, DWORD PTR _dwInfoType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	call	DWORD PTR __imp__GetStringTypeExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR $T211839[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pszA$[ebp]
	call	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211839[ebp]

; 236  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211847
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 164				; 000000a4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L211847:
	DD	1
	DD	$L211846
$L211846:
	DD	-156					; ffffff64H
	DD	132					; 00000084H
	DD	$L211843
$L211843:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	65					; 00000041H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211840:
	lea	ecx, DWORD PTR _pszA$[ebp]
	jmp	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z:
	mov	eax, OFFSET FLAT:$T211842
	jmp	___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPBGHPAG@Z ENDP		; ATL::GetStringTypeExWFake
PUBLIC	?lstrcmpiWFake@ATL@@YGHPBG0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPBG0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 254  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

	mov	eax, DWORD PTR __imp__lstrcmpiW@8
	push	eax
	push	OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPBG0@Z ; ATL::lstrcmpiWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _psz1$[ebp]
	push	edx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 258  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?lstrcmpiWThunk@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
EXTRN	__imp__lstrcmpiA@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPBG0@Z
_TEXT	SEGMENT
tv91 = -32						; size = 4
tv94 = -28						; size = 4
tv76 = -24						; size = 4
tv79 = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPBG0@Z PROC NEAR			; ATL::lstrcmpiWFake, COMDAT

; 247  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 248  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

	mov	eax, DWORD PTR _psz2$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L211855
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $L211856
$L211855:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv76[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv79[ebp], eax
$L211856:
	mov	ecx, DWORD PTR _psz1$[ebp]
	mov	DWORD PTR __lpw$[ebp], ecx
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L211857
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L211858
$L211857:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv91[ebp], esp
	mov	ecx, DWORD PTR __acp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv91[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv94[ebp], eax
$L211858:
	mov	esi, esp
	mov	edx, DWORD PTR tv79[ebp]
	push	edx
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 251  : }

	lea	esp, DWORD PTR [ebp-36]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?lstrcmpiWFake@ATL@@YGHPBG0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPAGPAG@Z			; ATL::CharLowerWFake
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 273  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

	mov	eax, DWORD PTR __imp__CharLowerW@4
	push	eax
	push	OFFSET FLAT:?CharLowerWFake@ATL@@YGPAGPAG@Z ; ATL::CharLowerWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 277  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharLowerWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPAGPAGPBDHI@Z			; AtlA2WHelper
EXTRN	__imp__CharLowerA@4:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	_wcscpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharLowerWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 262  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L211863
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L211864
$L211863:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L211864:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 266  : 	::CharLowerA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharLowerA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 267  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L211865
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L211866
$L211865:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L211866:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 268  : 
; 269  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 270  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharLowerWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharLowerWFake
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPAGPAGPBDHI@Z
_TEXT	SEGMENT
_ret$ = -4						; size = 4
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPAGPAGPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 555  : 	ATLASSERT(lpa != NULL);

	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L211869
	push	OFFSET FLAT:??_C@_08DMHHBMMN@lpa?5?$CB?$DN?50?$AA@
	push	0
	push	555					; 0000022bH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211869
	int	3
$L211869:

; 556  : 	ATLASSERT(lpw != NULL);

	cmp	DWORD PTR _lpw$[ebp], 0
	jne	SHORT $L211870
	push	OFFSET FLAT:??_C@_08DIHJLFDJ@lpw?5?$CB?$DN?50?$AA@
	push	0
	push	556					; 0000022cH
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211870
	int	3
$L211870:

; 557  : 	if (lpw == NULL || lpa == NULL)

	cmp	DWORD PTR _lpw$[ebp], 0
	je	SHORT $L75943
	cmp	DWORD PTR _lpa$[ebp], 0
	jne	SHORT $L75942
$L75943:

; 558  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75936
$L75942:

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';

	mov	edx, DWORD PTR _lpw$[ebp]
	mov	WORD PTR [edx], 0

; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

	mov	esi, esp
	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpw$[ebp]
	push	ecx
	push	-1
	mov	edx, DWORD PTR _lpa$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _acp$[ebp]
	push	eax
	call	DWORD PTR __imp__MultiByteToWideChar@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _ret$[ebp], eax

; 564  : 	if(ret == 0)

	cmp	DWORD PTR _ret$[ebp], 0
	jne	SHORT $L75945

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L211871
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	566					; 00000236H
	push	OFFSET FLAT:??_C@_0FA@OHHMODBN@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211871
	int	3
$L211871:

; 567  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L75936
$L75945:

; 568  : 	}		
; 569  : 	return lpw;

	mov	eax, DWORD PTR _lpw$[ebp]
$L75936:

; 570  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?AtlA2WHelper@@YGPAGPAGPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPAGPAG@Z			; ATL::CharUpperWFake
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ?CharUpperWThunk@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 292  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

	mov	eax, DWORD PTR __imp__CharUpperW@4
	push	eax
	push	OFFSET FLAT:?CharUpperWFake@ATL@@YGPAGPAG@Z ; ATL::CharUpperWFake
	push	OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	call	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ; ATL::_AtlInstallStringThunk
	add	esp, 12					; 0000000cH

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 296  : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?CharUpperWThunk@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CharUpperWFake@ATL@@YGPAGPAG@Z
_TEXT	SEGMENT
tv90 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_pszA$ = -20						; size = 4
__lpa$ = -16						; size = 4
__lpw$ = -12						; size = 4
__acp$ = -8						; size = 4
__convert$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPAGPAG@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 281  : 	USES_CONVERSION;

	mov	DWORD PTR __convert$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$[ebp], eax
	mov	DWORD PTR __lpw$[ebp], 0
	mov	DWORD PTR __lpa$[ebp], 0

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

	mov	eax, DWORD PTR _psz$[ebp]
	mov	DWORD PTR __lpw$[ebp], eax
	cmp	DWORD PTR __lpw$[ebp], 0
	jne	SHORT $L211876
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $L211877
$L211876:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert$[ebp], edx
	mov	eax, DWORD PTR __convert$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv75[ebp], esp
	mov	eax, DWORD PTR __acp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpw$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv78[ebp], eax
$L211877:
	mov	ecx, DWORD PTR tv78[ebp]
	mov	DWORD PTR _pszA$[ebp], ecx

; 285  : 	::CharUpperA(pszA);

	mov	esi, esp
	mov	edx, DWORD PTR _pszA$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 286  : 	wcscpy(psz, A2W(pszA));

	mov	eax, DWORD PTR _pszA$[ebp]
	mov	DWORD PTR __lpa$[ebp], eax
	cmp	DWORD PTR __lpa$[ebp], 0
	jne	SHORT $L211878
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L211879
$L211878:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$[ebp], eax
	mov	eax, DWORD PTR __convert$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv90[ebp], esp
	mov	edx, DWORD PTR __acp$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv90[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv94[ebp], eax
$L211879:
	mov	eax, DWORD PTR tv94[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	_wcscpy
	add	esp, 8

; 287  : 
; 288  : 	return psz;

	mov	eax, DWORD PTR _psz$[ebp]

; 289  : }

	lea	esp, DWORD PTR [ebp-40]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?CharUpperWFake@ATL@@YGPAGPAG@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
PUBLIC	?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceS
EXTRN	?RegEntries@CSignature@@2PAU_ATL_REGMAP_ENTRY@ATL@@A:BYTE ; CSignature::RegEntries
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.h
;	COMDAT ?UpdateRegistry@CSignature@@SGJH@Z
_TEXT	SEGMENT
_bRegister$ = 8						; size = 4
?UpdateRegistry@CSignature@@SGJH@Z PROC NEAR		; CSignature::UpdateRegistry, COMDAT

; 431  : 	{

	push	ebp
	mov	ebp, esp

; 432  : 		return _Module.UpdateRegistryFromResource(IDR_SIGNATURE, bRegister, RegEntries);

	push	OFFSET FLAT:?RegEntries@CSignature@@2PAU_ATL_REGMAP_ENTRY@ATL@@A ; CSignature::RegEntries
	mov	eax, DWORD PTR _bRegister$[ebp]
	push	eax
	push	101					; 00000065H
	push	OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceS

; 433  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?UpdateRegistry@CSignature@@SGJH@Z ENDP			; CSignature::UpdateRegistry
_TEXT	ENDS
PUBLIC	?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResourceS
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CComModule::UpdateRegistryFromResourceS, COMDAT

; 4145 : 	{

	push	ebp
	mov	ebp, esp

; 4146 : #ifdef _ATL_STATIC_REGISTRY
; 4147 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(nResID, bRegister, pMapEntries);

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegister$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nResID$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResourceS

; 4148 : #else
; 4149 : 		(nResID);
; 4150 : 		(bRegister);
; 4151 : 		(pMapEntries);
; 4152 : 		return E_FAIL;
; 4153 : #endif
; 4154 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	16					; 00000010H
?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceS
_TEXT	ENDS
PUBLIC	?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z	; ATL::CAtlModule::EscapeSingleQuote
PUBLIC	?AtlHresultFromLastError@ATL@@YAJXZ		; ATL::AtlHresultFromLastError
PUBLIC	?ocslen@@YAHPBG@Z				; ocslen
PUBLIC	?ocscpy@@YAPAGPAGPBG@Z				; ocscpy
PUBLIC	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
PUBLIC	??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@ ; `string'
PUBLIC	??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??1CRegObject@ATL@@UAE@XZ			; ATL::CRegObject::~CRegObject
PUBLIC	??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@ ; `string'
PUBLIC	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z	; ATL::CRegObject::AddReplacement
PUBLIC	??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ ; `string'
PUBLIC	?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z	; ATL::CRegObject::ResourceRegister
PUBLIC	?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z	; ATL::CRegObject::ResourceUnregister
PUBLIC	??0CRegObject@ATL@@QAE@XZ			; ATL::CRegObject::CRegObject
EXTRN	__imp__GetModuleFileNameA@12:NEAR
EXTRN	__imp__GetModuleHandleA@4:NEAR
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
;	COMDAT ??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@
CONST	SEGMENT
??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@ DB '0 != pMa'
	DB	'pEntries->szData', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lbase.h', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@ DB 'M', 00H, 'o'
	DB	00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@ DB 'M'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'R', 00H, 'a', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@ DB 'R'
	DB	00H, 'E', 00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H, 'R', 00H
	DB	'Y', 00H, 00H, 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
tv203 = -2504						; size = 4
tv158 = -2500						; size = 4
tv151 = -2496						; size = 4
tv160 = -2492						; size = 4
$T211900 = -2488					; size = 4
$T211897 = -2484					; size = 4
$T211896 = -2480					; size = 4
$T211895 = -2476					; size = 4
$T211890 = -2472					; size = 4
$T211889 = -2468					; size = 4
$T211888 = -2464					; size = 4
_szType$ = -2460					; size = 4
_nLen$90983 = -2456					; size = 4
_pszModuleQuote$90982 = -2448				; size = 1048
_hRes$ = -1396						; size = 4
_pszModuleUnquoted$ = -1388				; size = 1040
_pszModule$ = -344					; size = 4
_dwFLen$ = -340						; size = 4
_hInst$ = -336						; size = 4
_szModule$ = -328					; size = 260
__AtlSafeAllocaManager$ = -60				; size = 4
__lpa_ex$ = -52						; size = 4
__lpw_ex$ = -48						; size = 4
__acp_ex$ = -44						; size = 4
__convert_ex$ = -40					; size = 4
_hr$ = -36						; size = 4
_ro$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CAtlModule::UpdateRegistryFromResourceS, COMDAT

; 5506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2504				; 000009c8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2504]
	mov	ecx, 626				; 00000272H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5507 : 	CRegObject ro;

	lea	ecx, DWORD PTR _ro$[ebp]
	call	??0CRegObject@ATL@@QAE@XZ

; 5508 : 
; 5509 : 	if (pMapEntries != NULL)

	cmp	DWORD PTR _pMapEntries$[ebp], 0
	je	SHORT $L90944
$L90946:

; 5510 : 	{
; 5511 : 		while (pMapEntries->szKey != NULL)

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L90944

; 5512 : 		{
; 5513 : 			ATLASSERT(NULL != pMapEntries->szData);

	mov	ecx, DWORD PTR _pMapEntries$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L211887
	push	OFFSET FLAT:??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@
	push	0
	push	5513					; 00001589H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211887
	int	3
$L211887:

; 5514 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pMapEntries$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement

; 5515 : 			pMapEntries++;

	mov	edx, DWORD PTR _pMapEntries$[ebp]
	add	edx, 8
	mov	DWORD PTR _pMapEntries$[ebp], edx

; 5516 : 		}

	jmp	SHORT $L90946
$L90944:

; 5517 : 	}
; 5518 : 
; 5519 : 	HRESULT hr = AddCommonRGSReplacements(&ro);

	mov	esi, esp
	lea	eax, DWORD PTR _ro$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 5520 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90951

; 5521 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T211888[ebp], eax
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211888[ebp]
	jmp	$L90942
$L90951:

; 5522 : 
; 5523 : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>

; 5524 : 	TCHAR szModule[MAX_PATH];
; 5525 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	DWORD PTR _hInst$[ebp], eax

; 5526 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szModule$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInst$[ebp]
	push	edx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFLen$[ebp], eax

; 5527 : 	if( dwFLen == 0 )

	cmp	DWORD PTR _dwFLen$[ebp], 0
	jne	SHORT $L90961

; 5528 : 		return AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR $T211889[ebp], eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211889[ebp]
	jmp	$L90942
$L90961:

; 5529 : 	else if( dwFLen == MAX_PATH )

	cmp	DWORD PTR _dwFLen$[ebp], 260		; 00000104H
	jne	SHORT $L90963

; 5530 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	mov	DWORD PTR $T211890[ebp], -2147024774	; 8007007aH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211890[ebp]
	jmp	$L90942
$L90963:

; 5531 : 
; 5532 : 	LPOLESTR pszModule;
; 5533 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szModule$[ebp]
	mov	DWORD PTR __lpa_ex$[ebp], eax
	cmp	DWORD PTR __lpa_ex$[ebp], 0
	jne	SHORT $L211893
	mov	DWORD PTR tv160[ebp], 0
	jmp	$L211894
$L211893:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$[ebp], eax
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L211891
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L211891
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv151[ebp], esp
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv158[ebp], edx
	jmp	SHORT $L211892
$L211891:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv158[ebp], eax
$L211892:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv158[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv160[ebp], eax
$L211894:
	mov	edx, DWORD PTR tv160[ebp]
	mov	DWORD PTR _pszModule$[ebp], edx

; 5534 : #ifndef _UNICODE
; 5535 : 	if(pszModule == NULL) 

	cmp	DWORD PTR _pszModule$[ebp], 0
	jne	SHORT $L90975

; 5536 : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T211895[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211895[ebp]
	jmp	$L90942
$L90975:

; 5537 : #endif
; 5538 : 
; 5539 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 5540 : 	EscapeSingleQuote(pszModuleUnquoted, pszModule);

	mov	eax, DWORD PTR _pszModule$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszModuleUnquoted$[ebp]
	push	ecx
	call	?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z ; ATL::CAtlModule::EscapeSingleQuote
	add	esp, 8

; 5541 : 	
; 5542 : 	HRESULT hRes;
; 5543 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $L90981
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetModuleHandleA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _hInst$[ebp], eax
	jne	SHORT $L90980
$L90981:

; 5544 : 	{
; 5545 : 		// If Registering as an EXE, then we quote the resultant path.
; 5546 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 5547 : 		// quoted
; 5548 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2]; 		
; 5549 : 		pszModuleQuote[0] = OLESTR('\"');

	mov	WORD PTR _pszModuleQuote$90982[ebp], 34	; 00000022H

; 5550 : 		ocscpy(pszModuleQuote + 1, pszModuleUnquoted);

	lea	edx, DWORD PTR _pszModuleUnquoted$[ebp]
	push	edx
	lea	eax, DWORD PTR _pszModuleQuote$90982[ebp+2]
	push	eax
	call	?ocscpy@@YAPAGPAGPBG@Z			; ocscpy
	add	esp, 8

; 5551 : 		int nLen = ocslen(pszModuleQuote);

	lea	ecx, DWORD PTR _pszModuleQuote$90982[ebp]
	push	ecx
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	mov	DWORD PTR _nLen$90983[ebp], eax

; 5552 : 		pszModuleQuote[nLen] = OLESTR('\"');

	mov	edx, DWORD PTR _nLen$90983[ebp]
	mov	WORD PTR _pszModuleQuote$90982[ebp+edx*2], 34 ; 00000022H

; 5553 : 		pszModuleQuote[nLen + 1] = 0;

	mov	eax, DWORD PTR _nLen$90983[ebp]
	mov	WORD PTR _pszModuleQuote$90982[ebp+eax*2+2], 0

; 5554 : 
; 5555 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

	lea	ecx, DWORD PTR _pszModuleQuote$90982[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
	lea	edx, DWORD PTR _ro$[ebp]
	push	edx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax

; 5556 : 	}
; 5557 : 	else

	jmp	SHORT $L90984
$L90980:

; 5558 : 	{
; 5559 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);

	lea	eax, DWORD PTR _pszModuleUnquoted$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax
$L90984:

; 5560 : 	}	
; 5561 : 
; 5562 : 	if(FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L90986

; 5563 : 		return hRes;

	mov	edx, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T211896[ebp], edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211896[ebp]
	jmp	$L90942
$L90986:

; 5564 : 		
; 5565 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);

	lea	eax, DWORD PTR _pszModuleUnquoted$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax

; 5566 : 	if(FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L90989

; 5567 : 		return hRes;

	mov	edx, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T211897[ebp], edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211897[ebp]
	jmp	SHORT $L90942
$L90989:

; 5568 : 
; 5569 : 	LPCOLESTR szType = OLESTR("REGISTRY");

	mov	DWORD PTR _szType$[ebp], OFFSET FLAT:??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@

; 5570 : 	hr = (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
; 5571 : 		ro.ResourceUnregister(pszModule, nResID, szType);

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	SHORT $L211898
	mov	eax, DWORD PTR _szType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nResID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszModule$[ebp]
	push	edx
	lea	eax, DWORD PTR _ro$[ebp]
	push	eax
	call	?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z ; ATL::CRegObject::ResourceRegister
	mov	DWORD PTR tv203[ebp], eax
	jmp	SHORT $L211899
$L211898:
	mov	ecx, DWORD PTR _szType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nResID$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszModule$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z ; ATL::CRegObject::ResourceUnregister
	mov	DWORD PTR tv203[ebp], eax
$L211899:
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR _hr$[ebp], edx

; 5572 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T211900[ebp], eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T211900[ebp]
$L90942:

; 5573 : }

	lea	esp, DWORD PTR [ebp-2512]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211908
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L211908:
	DD	5
	DD	$L211907
$L211907:
	DD	-28					; ffffffe4H
	DD	20					; 00000014H
	DD	$L211901
	DD	-60					; ffffffc4H
	DD	4
	DD	$L211902
	DD	-328					; fffffeb8H
	DD	260					; 00000104H
	DD	$L211903
	DD	-1388					; fffffa94H
	DD	1040					; 00000410H
	DD	$L211904
	DD	-2448					; fffff670H
	DD	1048					; 00000418H
	DD	$L211905
$L211905:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	81					; 00000051H
	DB	117					; 00000075H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$L211904:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$L211903:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L211902:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L211901:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CAtlModule::UpdateRegistryFromResourceS
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?ocslen@@YAHPBG@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?ocslen@@YAHPBG@Z PROC NEAR				; ocslen, COMDAT

; 679  : 	inline int ocslen(LPCOLESTR x) throw() { return lstrlenW(x); }

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	mov	eax, DWORD PTR _x$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?ocslen@@YAHPBG@Z ENDP					; ocslen
_TEXT	ENDS
EXTRN	_memcpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?ocscpy@@YAPAGPAGPBG@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
?ocscpy@@YAPAGPAGPBG@Z PROC NEAR			; ocscpy, COMDAT

; 682  : 	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	mov	eax, DWORD PTR _src$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	ecx, DWORD PTR [eax+eax+2]
	push	ecx
	mov	edx, DWORD PTR _src$[ebp]
	push	edx
	mov	eax, DWORD PTR _dest$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?ocscpy@@YAPAGPAGPBG@Z ENDP				; ocscpy
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ PROC NEAR ; ATL::CAtlBaseModule::GetModuleInstance, COMDAT
; _this$ = ecx

; 206  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 207  : 		return m_hInst;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 208  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ENDP ; ATL::CAtlBaseModule::GetModuleInstance
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwErr$ = -4						; size = 4
?AtlHresultFromLastError@ATL@@YAJXZ PROC NEAR		; ATL::AtlHresultFromLastError, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 27   : 	DWORD dwErr = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwErr$[ebp], eax

; 28   : 	return HRESULT_FROM_WIN32(dwErr);

	cmp	DWORD PTR _dwErr$[ebp], 0
	jg	SHORT $L211917
	mov	eax, DWORD PTR _dwErr$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L211918
$L211917:
	mov	ecx, DWORD PTR _dwErr$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv69[ebp], ecx
$L211918:
	mov	eax, DWORD PTR tv69[ebp]

; 29   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlHresultFromLastError@ATL@@YAJXZ ENDP		; ATL::AtlHresultFromLastError
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z
_TEXT	SEGMENT
_lpDest$ = 8						; size = 4
_lp$ = 12						; size = 4
?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z PROC NEAR ; ATL::CAtlModule::EscapeSingleQuote, COMDAT

; 2765 : 	{

	push	ebp
	mov	ebp, esp
$L88240:

; 2766 : 		while (*lp)

	mov	eax, DWORD PTR _lp$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $L88241

; 2767 : 		{
; 2768 : 			*lpDest++ = *lp;

	mov	edx, DWORD PTR _lpDest$[ebp]
	mov	eax, DWORD PTR _lp$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _lpDest$[ebp]
	add	edx, 2
	mov	DWORD PTR _lpDest$[ebp], edx

; 2769 : 			if (*lp == '\'')

	mov	eax, DWORD PTR _lp$[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $L88242

; 2770 : 				*lpDest++ = *lp;

	mov	edx, DWORD PTR _lpDest$[ebp]
	mov	eax, DWORD PTR _lp$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx
	mov	edx, DWORD PTR _lpDest$[ebp]
	add	edx, 2
	mov	DWORD PTR _lpDest$[ebp], edx
$L88242:

; 2771 : 			lp++;

	mov	eax, DWORD PTR _lp$[ebp]
	add	eax, 2
	mov	DWORD PTR _lp$[ebp], eax

; 2772 : 		}

	jmp	SHORT $L88240
$L88241:

; 2773 : 		*lpDest = NULL;

	mov	ecx, DWORD PTR _lpDest$[ebp]
	mov	WORD PTR [ecx], 0

; 2774 : 	}

	pop	ebp
	ret	0
?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z ENDP	; ATL::CAtlModule::EscapeSingleQuote
_TEXT	ENDS
PUBLIC	??1CExpansionVector@ATL@@QAE@XZ			; ATL::CExpansionVector::~CExpansionVector
PUBLIC	?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::QueryInterface
PUBLIC	?AddRef@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::AddRef
PUBLIC	?Release@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::Release
PUBLIC	?ClearReplacements@CRegObject@ATL@@UAGJXZ	; ATL::CRegObject::ClearReplacements
PUBLIC	??_7CRegObject@ATL@@6B@				; ATL::CRegObject::`vftable'
PUBLIC	??_GCRegObject@ATL@@UAEPAXI@Z			; ATL::CRegObject::`scalar deleting destructor'
EXTRN	??_ECRegObject@ATL@@UAEPAXI@Z:NEAR		; ATL::CRegObject::`vector deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
xdata$x	SEGMENT
$T211927 DD	0ffffffffH
	DD	FLAT:$L211923
$T211925 DD	019930520H
	DD	01H
	DD	FLAT:$T211927
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT
??_7CRegObject@ATL@@6B@ DD FLAT:?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::`vftable'
	DD	FLAT:?AddRef@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?Release@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z
	DD	FLAT:?ClearReplacements@CRegObject@ATL@@UAGJXZ
	DD	FLAT:??_ECRegObject@ATL@@UAEPAXI@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CRegObject@ATL@@UAE@XZ PROC NEAR			; ATL::CRegObject::~CRegObject, COMDAT
; _this$ = ecx

; 276  : 	virtual ~CRegObject(){ClearReplacements();}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CRegObject@ATL@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CRegObject@ATL@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?ClearReplacements@CRegObject@ATL@@UAGJXZ ; ATL::CRegObject::ClearReplacements
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1CExpansionVector@ATL@@QAE@XZ		; ATL::CExpansionVector::~CExpansionVector
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211923:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CExpansionVector@ATL@@QAE@XZ		; ATL::CExpansionVector::~CExpansionVector
__ehhandler$??1CRegObject@ATL@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T211925
	jmp	___CxxFrameHandler
text$x	ENDS
??1CRegObject@ATL@@UAE@XZ ENDP				; ATL::CRegObject::~CRegObject
PUBLIC	??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
PUBLIC	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ	; ATL::CExpansionVector::ClearReplacements
;	COMDAT xdata$x
xdata$x	SEGMENT
$T211936 DD	0ffffffffH
	DD	FLAT:$L211932
$T211934 DD	019930520H
	DD	01H
	DD	FLAT:$T211936
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CExpansionVector@ATL@@QAE@XZ PROC NEAR		; ATL::CExpansionVector::~CExpansionVector, COMDAT
; _this$ = ecx

; 88   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CExpansionVector@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 89   : 		 ClearReplacements();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 90   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211932:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
__ehhandler$??1CExpansionVector@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T211934
	jmp	___CxxFrameHandler
text$x	ENDS
??1CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::~CExpansionVector
PUBLIC	?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetSize
PUBLIC	?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::RemoveAll
PUBLIC	?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
PUBLIC	?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetValueAt
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Odt /RTCsu
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT
$T211942 = -16						; size = 4
$T211941 = -12						; size = 4
_i$89740 = -8						; size = 4
_this$ = -4						; size = 4
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ PROC NEAR ; ATL::CExpansionVector::ClearReplacements, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		for (int i = 0; i < GetSize(); i++)

	mov	DWORD PTR _i$89740[ebp], 0
	jmp	SHORT $L89741
$L89742:
	mov	eax, DWORD PTR _i$89740[ebp]
	add	eax, 1
	mov	DWORD PTR _i$89740[ebp], eax
$L89741:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetSize
	cmp	DWORD PTR _i$89740[ebp], eax
	jge	SHORT $L89743

; 128  : 		{
; 129  : 			delete []GetKeyAt(i);

	mov	ecx, DWORD PTR _i$89740[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T211941[ebp], edx
	mov	eax, DWORD PTR $T211941[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 130  : 			delete []GetValueAt(i);

	mov	ecx, DWORD PTR _i$89740[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetValueAt
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T211942[ebp], edx
	mov	eax, DWORD PTR $T211942[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 131  : 		}

	jmp	SHORT $L89742
$L89743:

; 132  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::RemoveAll

; 133  : 		return S_OK;

	xor	eax, eax

; 134  : 	}

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ENDP	; ATL::CExpansionVector::ClearReplacements
_TEXT	ENDS
PUBLIC	??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@ ; `string'
PUBLIC	??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@ ; `string'
;	COMDAT ??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@
CONST	SEGMENT
??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@ DB 'statically l'
	DB	'inked in CRegObject is not a com object. Do not callthis func'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@
CONST	SEGMENT
??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@ DB '"staticall'
	DB	'y linked in CRegObject is not a com object. Do not callthis f'
	DB	'unction"', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\st'
	DB	'atreg.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CRegObject::QueryInterface, COMDAT

; 260  : 	{

	push	ebp
	mov	ebp, esp

; 261  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));

	mov	eax, OFFSET FLAT:??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@
	test	eax, eax
	jne	SHORT $L211945
	push	OFFSET FLAT:??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@
	push	0
	push	261					; 00000105H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211945
	int	3
$L211945:

; 262  : 		return E_NOTIMPL;

	mov	eax, -2147467263			; 80004001H

; 263  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CRegObject::QueryInterface
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CRegObject@ATL@@UAGKXZ PROC NEAR		; ATL::CRegObject::AddRef, COMDAT

; 266  : 	{

	push	ebp
	mov	ebp, esp

; 267  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));

	mov	eax, OFFSET FLAT:??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@
	test	eax, eax
	jne	SHORT $L211948
	push	OFFSET FLAT:??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@
	push	0
	push	267					; 0000010bH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211948
	int	3
$L211948:

; 268  : 		return 1;

	mov	eax, 1

; 269  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?AddRef@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::AddRef
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CRegObject@ATL@@UAGKXZ PROC NEAR		; ATL::CRegObject::Release, COMDAT

; 271  : 	{

	push	ebp
	mov	ebp, esp

; 272  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));

	mov	eax, OFFSET FLAT:??_C@_0EO@FOFJGMBM@statically?5linked?5in?5CRegObject?5@
	test	eax, eax
	jne	SHORT $L211951
	push	OFFSET FLAT:??_C@_0FA@KFANAKFG@?$CCstatically?5linked?5in?5CRegObject@
	push	0
	push	272					; 00000110H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211951
	int	3
$L211951:

; 273  : 		return 0;

	xor	eax, eax

; 274  : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?Release@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::Release
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCRegObject@ATL@@UAEPAXI@Z PROC NEAR			; ATL::CRegObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L89977
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L89977:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCRegObject@ATL@@UAEPAXI@Z ENDP			; ATL::CRegObject::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Lock@CComFakeCriticalSection@ATL@@QAEJXZ	; ATL::CComFakeCriticalSection::Lock
PUBLIC	?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ	; ATL::CComFakeCriticalSection::Unlock
PUBLIC	?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z		; ATL::CExpansionVector::Add
;	COMDAT xdata$x
xdata$x	SEGMENT
$T211969 DD	0ffffffffH
	DD	FLAT:$L211962
$T211964 DD	019930520H
	DD	01H
	DD	FLAT:$T211969
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z
_TEXT	SEGMENT
tv92 = -68						; size = 4
tv87 = -64						; size = 4
tv94 = -60						; size = 4
$T211961 = -56						; size = 4
$T211960 = -52						; size = 4
_bRet$ = -48						; size = 4
_lpszT$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszKey$ = 12						; size = 4
_lpszItem$ = 16						; size = 4
?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z PROC NEAR	; ATL::CRegObject::AddReplacement, COMDAT

; 324  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 14					; 0000000eH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 325  : 	if (lpszKey == NULL || lpszItem == NULL)

	cmp	DWORD PTR _lpszKey$[ebp], 0
	je	SHORT $L89984
	cmp	DWORD PTR _lpszItem$[ebp], 0
	jne	SHORT $L89983
$L89984:

; 326  : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L89982
$L89983:

; 327  : 	m_csMap.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Lock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Lock

; 328  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 329  : 	
; 330  : 	LPCTSTR lpszT = OLE2CT_EX(lpszKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _lpszKey$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L211958
	mov	DWORD PTR tv94[ebp], 0
	jmp	SHORT $L211959
$L211958:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L211956
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L211956
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv87[ebp], esp
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv92[ebp], edx
	jmp	SHORT $L211957
$L211956:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv92[ebp], eax
$L211957:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv92[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv94[ebp], eax
$L211959:
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR _lpszT$[ebp], edx

; 331  : 
; 332  : #ifndef _UNICODE
; 333  : 	if(lpszT == NULL)

	cmp	DWORD PTR _lpszT$[ebp], 0
	jne	SHORT $L89995

; 334  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T211960[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211960[ebp]
	jmp	SHORT $L89982
$L89995:

; 335  : #endif
; 336  : 	
; 337  : 	BOOL bRet = m_RepMap.Add(lpszT, lpszItem);

	mov	eax, DWORD PTR _lpszItem$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszT$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z	; ATL::CExpansionVector::Add
	mov	DWORD PTR _bRet$[ebp], eax

; 338  : 	m_csMap.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Unlock

; 339  : 	return bRet ? S_OK : E_OUTOFMEMORY;

	xor	edx, edx
	cmp	DWORD PTR _bRet$[ebp], 0
	setne	dl
	dec	edx
	and	edx, -2147024882			; 8007000eH
	mov	DWORD PTR $T211961[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T211961[ebp]
$L89982:

; 340  : }

	lea	esp, DWORD PTR [ebp-76]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211968
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L211968:
	DD	1
	DD	$L211967
$L211967:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L211965
$L211965:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L211962:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z:
	mov	eax, OFFSET FLAT:$T211964
	jmp	___CxxFrameHandler
text$x	ENDS
?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ENDP		; ATL::CRegObject::AddReplacement
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Lock@CComFakeCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Lock@CComFakeCriticalSection@ATL@@QAEJXZ PROC NEAR	; ATL::CComFakeCriticalSection::Lock, COMDAT
; _this$ = ecx

; 175  : 	HRESULT Lock() throw() { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Lock@CComFakeCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComFakeCriticalSection::Lock
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ PROC NEAR	; ATL::CComFakeCriticalSection::Unlock, COMDAT
; _this$ = ecx

; 176  : 	HRESULT Unlock() throw() { return S_OK; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ ENDP	; ATL::CComFakeCriticalSection::Unlock
_TEXT	ENDS
PUBLIC	?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Add
PUBLIC	??_C@_0BP@DILLEFPO@lpszKey?5?$CB?$DN?50?5?$CG?$CG?5lpszValue?5?$CB?$DN?50?$AA@ ; `string'
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
xdata$x	SEGMENT
$T211995 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T211997 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L211985
$T211998 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L211987
$T211996 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T211997
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T211998
$T211989 DD	019930520H
	DD	04H
	DD	FLAT:$T211995
	DD	02H
	DD	FLAT:$T211996
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BP@DILLEFPO@lpszKey?5?$CB?$DN?50?5?$CG?$CG?5lpszValue?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BP@DILLEFPO@lpszKey?5?$CB?$DN?50?5?$CG?$CG?5lpszValue?5?$CB?$DN?50?$AA@ DB 'l'
	DB	'pszKey != 0 && lpszValue != 0', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z
_TEXT	SEGMENT
tv141 = -80						; size = 4
tv140 = -76						; size = 4
$T211983 = -72						; size = 4
$T211982 = -68						; size = 4
$T211981 = -64						; size = 4
$T211980 = -60						; size = 4
_szValue$ = -52						; size = 4
_cbValue$ = -44						; size = 4
_szKey$ = -36						; size = 4
_cbKey$ = -28						; size = 4
_hRes$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_lpszKey$ = 8						; size = 4
_lpszValue$ = 12					; size = 4
?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z PROC NEAR	; ATL::CExpansionVector::Add, COMDAT
; _this$ = ecx

; 93   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-80]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 		ATLASSERT(lpszKey != NULL && lpszValue != NULL);

	cmp	DWORD PTR _lpszKey$[ebp], 0
	je	SHORT $L211978
	cmp	DWORD PTR _lpszValue$[ebp], 0
	jne	SHORT $L211979
$L211978:
	push	OFFSET FLAT:??_C@_0BP@DILLEFPO@lpszKey?5?$CB?$DN?50?5?$CG?$CG?5lpszValue?5?$CB?$DN?50?$AA@
	push	0
	push	94					; 0000005eH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L211979
	int	3
$L211979:

; 95   : 		if (lpszKey == NULL || lpszValue == NULL)

	cmp	DWORD PTR _lpszKey$[ebp], 0
	je	SHORT $L89712
	cmp	DWORD PTR _lpszValue$[ebp], 0
	jne	SHORT $L89711
$L89712:

; 96   : 			return FALSE;

	xor	eax, eax
	jmp	$L89707
$L89711:

; 97   : 
; 98   : 		HRESULT hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 99   : 
; 100  : 		size_t cbKey = (lstrlen(lpszKey)+1)*sizeof(TCHAR);

	mov	esi, esp
	mov	ecx, DWORD PTR _lpszKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _cbKey$[ebp], eax

; 101  : 		TCHAR* szKey = NULL;

	mov	DWORD PTR _szKey$[ebp], 0

; 102  : 
; 103  : 		ATLTRY(szKey = new TCHAR[cbKey];)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edx, DWORD PTR _cbKey$[ebp]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv140[ebp], eax
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR $T211980[ebp], eax
	mov	ecx, DWORD PTR $T211980[ebp]
	mov	DWORD PTR _szKey$[ebp], ecx
	jmp	SHORT $L211984
$L211985:
	mov	eax, $L211984
	ret	0
$L211984:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 104  : 
; 105  : 		size_t cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);

	mov	edx, DWORD PTR _lpszValue$[ebp]
	push	edx
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR _cbValue$[ebp], eax

; 106  : 		LPOLESTR szValue = NULL;

	mov	DWORD PTR _szValue$[ebp], 0

; 107  : 		ATLTRY(szValue = new OLECHAR[cbValue];)

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR _cbValue$[ebp]
	shl	ecx, 1
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR tv141[ebp]
	mov	DWORD PTR $T211981[ebp], edx
	mov	eax, DWORD PTR $T211981[ebp]
	mov	DWORD PTR _szValue$[ebp], eax
	jmp	SHORT $L211986
$L211987:
	mov	eax, $L211986
	ret	0
$L211986:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 108  : 
; 109  : 		if (szKey == NULL || szValue == NULL)

	cmp	DWORD PTR _szKey$[ebp], 0
	je	SHORT $L89728
	cmp	DWORD PTR _szValue$[ebp], 0
	jne	SHORT $L89727
$L89728:

; 110  : 			hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH

; 111  : 		else

	jmp	SHORT $L89730
$L89727:

; 112  : 		{
; 113  : 			memcpy(szKey, lpszKey, cbKey);

	mov	ecx, DWORD PTR _cbKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _szKey$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 114  : 			memcpy(szValue, lpszValue, cbValue);

	mov	ecx, DWORD PTR _cbValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szValue$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 115  : 			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))

	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKey$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Add
	test	eax, eax
	jne	SHORT $L89730

; 116  : 				hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH
$L89730:

; 117  : 		}
; 118  : 		if (FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L89734

; 119  : 		{
; 120  : 			delete []szKey;

	mov	eax, DWORD PTR _szKey$[ebp]
	mov	DWORD PTR $T211982[ebp], eax
	mov	ecx, DWORD PTR $T211982[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 121  : 			delete []szValue;

	mov	edx, DWORD PTR _szValue$[ebp]
	mov	DWORD PTR $T211983[ebp], edx
	mov	eax, DWORD PTR $T211983[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L89734:

; 122  : 		}
; 123  : 		return SUCCEEDED(hRes);

	xor	eax, eax
	cmp	DWORD PTR _hRes$[ebp], 0
	setge	al
$L89707:

; 124  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L211994
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 80					; 00000050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L211994:
	DD	2
	DD	$L211993
$L211993:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L211990
	DD	-52					; ffffffccH
	DD	4
	DD	$L211991
$L211991:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$L211990:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z:
	mov	eax, OFFSET FLAT:$T211989
	jmp	___CxxFrameHandler
text$x	ENDS
?Add@CExpansionVector@ATL@@QAEHPBDPBG@Z ENDP		; ATL::CExpansionVector::Add
PUBLIC	?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ; ATL::CRegObject::RegisterFromResource
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212016 DD	0ffffffffH
	DD	FLAT:$L212009
$T212011 DD	019930520H
	DD	01H
	DD	FLAT:$T212016
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z
_TEXT	SEGMENT
tv88 = -64						; size = 4
tv83 = -60						; size = 4
tv90 = -56						; size = 4
$T212008 = -52						; size = 4
$T212007 = -48						; size = 4
_lpszT$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z PROC NEAR	; ATL::CRegObject::ResourceRegister, COMDAT

; 428  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 429  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 430  : 
; 431  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szType$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L212005
	mov	DWORD PTR tv90[ebp], 0
	jmp	SHORT $L212006
$L212005:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L212003
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212003
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv83[ebp], esp
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $L212004
$L212003:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv88[ebp], eax
$L212004:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv88[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv90[ebp], eax
$L212006:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _lpszT$[ebp], edx

; 432  : #ifndef _UNICODE
; 433  : 	if (lpszT == NULL)

	cmp	DWORD PTR _lpszT$[ebp], 0
	jne	SHORT $L90104

; 434  : 	{
; 435  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T212007[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212007[ebp]
	jmp	SHORT $L90094
$L90104:

; 436  : 	}
; 437  : #endif // _UNICODE
; 438  : 
; 439  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, TRUE);

	push	1
	mov	eax, DWORD PTR _lpszT$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ; ATL::CRegObject::RegisterFromResource
	mov	DWORD PTR $T212008[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212008[ebp]
$L90094:

; 440  : }

	lea	esp, DWORD PTR [ebp-72]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212015
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L212015:
	DD	1
	DD	$L212014
$L212014:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L212012
$L212012:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212009:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z:
	mov	eax, OFFSET FLAT:$T212011
	jmp	___CxxFrameHandler
text$x	ENDS
?ResourceRegister@CRegObject@ATL@@QAGJPBGI0@Z ENDP	; ATL::CRegObject::ResourceRegister
PUBLIC	??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z	; ATL::CRegParser::CRegParser
PUBLIC	?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z	; ATL::CRegParser::RegisterBuffer
PUBLIC	??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
PUBLIC	??_C@_0BN@HGJLNPOD@Failed?5to?5LoadLibrary?5on?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@KJDBLEOI@Failed?5to?5FindResource?5on?5ID?3?$CFd?5@ ; `string'
PUBLIC	??_C@_0CJ@COPMGFKA@Failed?5to?5FindResource?5on?5ID?3?$CFs?5@ ; `string'
PUBLIC	??_C@_0BI@LNHJMEOP@Failed?5to?5LoadResource?6?$AA@ ; `string'
EXTRN	__imp__FreeLibrary@4:NEAR
EXTRN	?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceRegistrar
EXTRN	__imp__LoadLibraryExA@12:NEAR
EXTRN	__imp__LoadResource@8:NEAR
EXTRN	__imp__SizeofResource@8:NEAR
EXTRN	__imp__FindResourceA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212046 DD	0ffffffffH
	DD	FLAT:$L212035
	DD	00H
	DD	FLAT:$L212036
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T212048 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212034
$T212047 DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T212048
$T212038 DD	019930520H
	DD	04H
	DD	FLAT:$T212046
	DD	01H
	DD	FLAT:$T212047
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BN@HGJLNPOD@Failed?5to?5LoadLibrary?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@HGJLNPOD@Failed?5to?5LoadLibrary?5on?5?$CFs?6?$AA@ DB 'Failed t'
	DB	'o LoadLibrary on %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KJDBLEOI@Failed?5to?5FindResource?5on?5ID?3?$CFd?5@
CONST	SEGMENT
??_C@_0CJ@KJDBLEOI@Failed?5to?5FindResource?5on?5ID?3?$CFd?5@ DB 'Failed '
	DB	'to FindResource on ID:%d TYPE:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@COPMGFKA@Failed?5to?5FindResource?5on?5ID?3?$CFs?5@
CONST	SEGMENT
??_C@_0CJ@COPMGFKA@Failed?5to?5FindResource?5on?5ID?3?$CFs?5@ DB 'Failed '
	DB	'to FindResource on ID:%s TYPE:%s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LNHJMEOP@Failed?5to?5LoadResource?6?$AA@
CONST	SEGMENT
??_C@_0BI@LNHJMEOP@Failed?5to?5LoadResource?6?$AA@ DB 'Failed to LoadReso'
	DB	'urce', 0aH, 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z
_TEXT	SEGMENT
tv162 = -1180						; size = 4
tv93 = -1176						; size = 4
tv88 = -1172						; size = 4
tv95 = -1168						; size = 4
$T212032 = -1164					; size = 4
$T212031 = -1160					; size = 8
$T212028 = -1152					; size = 8
$T212027 = -1144					; size = 8
$T212026 = -1136					; size = 4
_lpszBSTRFileName$ = -1132				; size = 4
_szReg$ = -1124						; size = 1028
_szRegA$ = -92						; size = 4
_dwSize$ = -88						; size = 4
_hReg$ = -84						; size = 4
_hrscReg$ = -80						; size = 4
_hInstResDll$ = -76					; size = 4
_parser$ = -68						; size = 8
_hr$ = -56						; size = 4
__AtlSafeAllocaManager$ = -48				; size = 4
__lpa_ex$ = -40						; size = 4
__lpw_ex$ = -36						; size = 4
__acp_ex$ = -32						; size = 4
__convert_ex$ = -28					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_bstrFileName$ = 8					; size = 4
_szID$ = 12						; size = 4
_szType$ = 16						; size = 4
_bRegister$ = 20					; size = 4
?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z PROC NEAR ; ATL::CRegObject::RegisterFromResource, COMDAT
; _this$ = ecx

; 344  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 1164				; 0000048cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-1180]
	mov	ecx, 291				; 00000123H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 345  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 346  : 
; 347  : 	HRESULT     hr;
; 348  : 	CRegParser  parser(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _parser$[ebp]
	call	??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z ; ATL::CRegParser::CRegParser

; 349  : 	HINSTANCE   hInstResDll;
; 350  : 	HRSRC       hrscReg;
; 351  : 	HGLOBAL     hReg;
; 352  : 	DWORD       dwSize;
; 353  : 	LPSTR       szRegA;
; 354  : 	CTempBuffer<TCHAR, 1024> szReg;	

	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 355  : 
; 356  : 	LPCTSTR lpszBSTRFileName = OLE2CT_EX(bstrFileName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	ecx, DWORD PTR _bstrFileName$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], ecx
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L212024
	mov	DWORD PTR tv95[ebp], 0
	jmp	$L212025
$L212024:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw_ex$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], eax
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L212022
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	push	ecx
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $L212022
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv88[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, DWORD PTR tv88[ebp]
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $L212023
$L212022:
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv93[ebp], eax
$L212023:
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv93[ebp]
	push	edx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv95[ebp], eax
$L212025:
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR _lpszBSTRFileName$[ebp], eax

; 357  : #ifndef _UNICODE
; 358  : 	if (lpszBSTRFileName == NULL)

	cmp	DWORD PTR _lpszBSTRFileName$[ebp], 0
	jne	SHORT $L90059

; 359  : 	{
; 360  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T212026[ebp], -2147024882	; 8007000eH
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212026[ebp]
	jmp	$L90008
$L90059:

; 361  : 	}
; 362  : #endif // _UNICODE
; 363  : 
; 364  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

	mov	esi, esp
	push	2
	push	0
	mov	ecx, DWORD PTR _lpszBSTRFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadLibraryExA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hInstResDll$[ebp], eax

; 365  : 
; 366  : 	if (NULL == hInstResDll)

	cmp	DWORD PTR _hInstResDll$[ebp], 0
	jne	SHORT $L90062

; 367  : 	{
; 368  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), bstrFileName);

	mov	edx, DWORD PTR _bstrFileName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BN@HGJLNPOD@Failed?5to?5LoadLibrary?5on?5?$CFs?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	368					; 00000170H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212027[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 369  : 		hr = AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR _hr$[ebp], eax

; 370  : 		goto ReturnHR;

	jmp	$ReturnHR$90065
$L90062:

; 371  : 	}
; 372  : 
; 373  : 	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	mov	esi, esp
	mov	eax, DWORD PTR _szType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstResDll$[ebp]
	push	edx
	call	DWORD PTR __imp__FindResourceA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hrscReg$[ebp], eax

; 374  : 
; 375  : 	if (NULL == hrscReg)

	cmp	DWORD PTR _hrscReg$[ebp], 0
	jne	SHORT $L90068

; 376  : 	{
; 377  : 		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == NULL) ? 

	mov	eax, DWORD PTR _szID$[ebp]
	shr	eax, 16					; 00000010H
	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L212029
	mov	DWORD PTR tv162[ebp], OFFSET FLAT:??_C@_0CJ@KJDBLEOI@Failed?5to?5FindResource?5on?5ID?3?$CFd?5@
	jmp	SHORT $L212030
$L212029:
	mov	DWORD PTR tv162[ebp], OFFSET FLAT:??_C@_0CJ@COPMGFKA@Failed?5to?5FindResource?5on?5ID?3?$CFs?5@
$L212030:
	mov	edx, DWORD PTR _szType$[ebp]
	push	edx
	mov	eax, DWORD PTR _szID$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv162[ebp]
	push	ecx
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	377					; 00000179H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212028[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 24					; 00000018H

; 378  : 			_T("Failed to FindResource on ID:%d TYPE:%s\n") : 
; 379  : 			_T("Failed to FindResource on ID:%s TYPE:%s\n"), 
; 380  : 			szID, szType);
; 381  : 		hr = AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR _hr$[ebp], eax

; 382  : 		goto ReturnHR;

	jmp	$ReturnHR$90065
$L90068:

; 383  : 	}
; 384  : 
; 385  : 	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	mov	esi, esp
	mov	edx, DWORD PTR _hrscReg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInstResDll$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadResource@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hReg$[ebp], eax

; 386  : 
; 387  : 	if (NULL == hReg)

	cmp	DWORD PTR _hReg$[ebp], 0
	jne	SHORT $L90076

; 388  : 	{
; 389  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));

	push	OFFSET FLAT:??_C@_0BI@LNHJMEOP@Failed?5to?5LoadResource?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	389					; 00000185H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212031[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 390  : 		hr = AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR _hr$[ebp], eax

; 391  : 		goto ReturnHR;

	jmp	$ReturnHR$90065
$L90076:

; 392  : 	}
; 393  : 
; 394  : 	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);

	mov	esi, esp
	mov	ecx, DWORD PTR _hrscReg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstResDll$[ebp]
	push	edx
	call	DWORD PTR __imp__SizeofResource@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwSize$[ebp], eax

; 395  : 	szRegA = (LPSTR)hReg;

	mov	eax, DWORD PTR _hReg$[ebp]
	mov	DWORD PTR _szRegA$[ebp], eax

; 396  : 
; 397  : 	// Allocate extra space for NULL.
; 398  : 	ATLTRY(szReg.Allocate(dwSize + 1));

	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	ecx, DWORD PTR _dwSize$[ebp]
	add	ecx, 1
	push	ecx
	lea	ecx, DWORD PTR _szReg$[ebp]
	call	?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
	jmp	SHORT $L212033
$L212034:
	mov	eax, $L212033
	ret	0
$L212033:
	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 399  : 	if (szReg == NULL)

	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
	test	eax, eax
	jne	SHORT $L90083

; 400  : 	{
; 401  : 		hr = E_OUTOFMEMORY;

	mov	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH

; 402  : 		goto ReturnHR;

	jmp	SHORT $ReturnHR$90065
$L90083:

; 403  : 	}
; 404  : 
; 405  : #ifdef _UNICODE
; 406  : 	if (::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize) == 0)
; 407  : 	{
; 408  : 		hr = AtlHresultFromLastError();
; 409  : 		goto ReturnHR;
; 410  : 	}
; 411  : #else
; 412  : 	memcpy(szReg, szRegA, dwSize);

	mov	edx, DWORD PTR _dwSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _szRegA$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 413  : #endif
; 414  : 
; 415  : 	// Append a NULL at the end.
; 416  : 	szReg[dwSize] = NULL;

	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
	mov	ecx, DWORD PTR _dwSize$[ebp]
	mov	BYTE PTR [eax+ecx], 0

; 417  : 
; 418  : 	hr = parser.RegisterBuffer(szReg, bRegister);

	mov	edx, DWORD PTR _bRegister$[ebp]
	push	edx
	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
	push	eax
	lea	ecx, DWORD PTR _parser$[ebp]
	call	?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ; ATL::CRegParser::RegisterBuffer
	mov	DWORD PTR _hr$[ebp], eax
$ReturnHR$90065:

; 419  : 
; 420  : ReturnHR:
; 421  : 
; 422  : 	if (NULL != hInstResDll)

	cmp	DWORD PTR _hInstResDll$[ebp], 0
	je	SHORT $L90086

; 423  : 		FreeLibrary((HMODULE)hInstResDll);

	mov	esi, esp
	mov	eax, DWORD PTR _hInstResDll$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4
	cmp	esi, esp
	call	__RTC_CheckEsp
$L90086:

; 424  : 	return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212032[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR _szReg$[ebp]
	call	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212032[ebp]
$L90008:

; 425  : }

	lea	esp, DWORD PTR [ebp-1192]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212045
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L212045:
	DD	3
	DD	$L212044
$L212044:
	DD	-48					; ffffffd0H
	DD	4
	DD	$L212039
	DD	-68					; ffffffbcH
	DD	8
	DD	$L212040
	DD	-1124					; fffffb9cH
	DD	1028					; 00000404H
	DD	$L212041
$L212041:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	0
$L212040:
	DB	112					; 00000070H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212039:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212035:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L212036:
	lea	ecx, DWORD PTR _szReg$[ebp]
	jmp	??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
__ehhandler$?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z:
	mov	eax, OFFSET FLAT:$T212038
	jmp	___CxxFrameHandler
text$x	ENDS
?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ENDP ; ATL::CRegObject::RegisterFromResource
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212066 DD	0ffffffffH
	DD	FLAT:$L212059
$T212061 DD	019930520H
	DD	01H
	DD	FLAT:$T212066
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z
_TEXT	SEGMENT
tv88 = -64						; size = 4
tv83 = -60						; size = 4
tv90 = -56						; size = 4
$T212058 = -52						; size = 4
$T212057 = -48						; size = 4
_lpszT$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_nID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z PROC NEAR ; ATL::CRegObject::ResourceUnregister, COMDAT

; 460  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 461  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 462  : 
; 463  : 	LPCTSTR lpszT = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szType$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L212055
	mov	DWORD PTR tv90[ebp], 0
	jmp	SHORT $L212056
$L212055:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L212053
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212053
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv83[ebp], esp
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR tv88[ebp], edx
	jmp	SHORT $L212054
$L212053:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv88[ebp], eax
$L212054:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv88[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv90[ebp], eax
$L212056:
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR _lpszT$[ebp], edx

; 464  : #ifndef _UNICODE
; 465  : 	if (lpszT == NULL)

	cmp	DWORD PTR _lpszT$[ebp], 0
	jne	SHORT $L90154

; 466  : 	{
; 467  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T212057[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212057[ebp]
	jmp	SHORT $L90144
$L90154:

; 468  : 	}
; 469  : #endif // _UNICODE
; 470  : 	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), lpszT, FALSE);

	push	0
	mov	eax, DWORD PTR _lpszT$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ; ATL::CRegObject::RegisterFromResource
	mov	DWORD PTR $T212058[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212058[ebp]
$L90144:

; 471  : }

	lea	esp, DWORD PTR [ebp-72]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212065
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L212065:
	DD	1
	DD	$L212064
$L212064:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L212062
$L212062:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212059:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z:
	mov	eax, OFFSET FLAT:$T212061
	jmp	___CxxFrameHandler
text$x	ENDS
?ResourceUnregister@CRegObject@ATL@@QAGJPBGI0@Z ENDP	; ATL::CRegObject::ResourceUnregister
; Function compile flags: /Odt /RTCsu
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_this$ = 8						; size = 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ PROC NEAR	; ATL::CRegObject::ClearReplacements, COMDAT

; 510  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 511  : 	m_csMap.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Lock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Lock

; 512  : 	HRESULT hr = m_RepMap.ClearReplacements();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
	mov	DWORD PTR _hr$[ebp], eax

; 513  : 	m_csMap.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Unlock

; 514  : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 515  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?ClearReplacements@CRegObject@ATL@@UAGJXZ ENDP		; ATL::CRegObject::ClearReplacements
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pRegObj$ = 8						; size = 4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z PROC NEAR	; ATL::CRegParser::CRegParser, COMDAT
; _this$ = ecx

; 737  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 738  : 	m_pRegObj           = pRegObj;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pRegObj$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 739  : 	m_pchCur            = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 740  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CRegParser@ATL@@QAE@PAVCRegObject@1@@Z ENDP		; ATL::CRegParser::CRegParser
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0BN@HJIJAHEL@HKeyFromString?5failed?5on?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@JJEGIHLG@Syntax?5error?0?5expecting?5a?5?$HL?0?5fou@ ; `string'
PUBLIC	??_C@_0CC@MOJNOPNN@Failed?5to?5register?0?5cleaning?5up?$CB@ ; `string'
PUBLIC	?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
PUBLIC	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ		; ATL::CRegParser::SkipWhiteSpace
PUBLIC	?NextToken@CRegParser@ATL@@IAEJPAD@Z		; ATL::CRegParser::NextToken
PUBLIC	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
PUBLIC	?GenerateError@CRegParser@ATL@@IAEJI@Z		; ATL::CRegParser::GenerateError
PUBLIC	?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ; ATL::CRegParser::HKeyFromString
EXTRN	__chkstk:NEAR
EXTRN	__imp__CoTaskMemFree@4:NEAR
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HJIJAHEL@HKeyFromString?5failed?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BN@HJIJAHEL@HKeyFromString?5failed?5on?5?$CFs?6?$AA@ DB 'HKeyFromS'
	DB	'tring failed on %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JJEGIHLG@Syntax?5error?0?5expecting?5a?5?$HL?0?5fou@
CONST	SEGMENT
??_C@_0CJ@JJEGIHLG@Syntax?5error?0?5expecting?5a?5?$HL?0?5fou@ DB 'Syntax'
	DB	' error, expecting a {, found a %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MOJNOPNN@Failed?5to?5register?0?5cleaning?5up?$CB@
CONST	SEGMENT
??_C@_0CC@MOJNOPNN@Failed?5to?5register?0?5cleaning?5up?$CB@ DB 'Failed t'
	DB	'o register, cleaning up!', 0aH, 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z
_TEXT	SEGMENT
$T212080 = -4176					; size = 8
$T212079 = -4168					; size = 8
$T212078 = -4160					; size = 8
$T212077 = -4152					; size = 8
$T212076 = -4144					; size = 8
_szRegAtRegister$90727 = -4136				; size = 4
_hkBase$90717 = -4132					; size = 4
_szReg$ = -4124						; size = 4
_hr$ = -4116						; size = 4
_szToken$ = -4108					; size = 4096
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szBuffer$ = 8						; size = 4
_bRegister$ = 12					; size = 4
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z PROC NEAR	; ATL::CRegParser::RegisterBuffer, COMDAT
; _this$ = ecx

; 1092 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4176				; 00001050H
	call	__chkstk
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-4176]
	mov	ecx, 1044				; 00000414H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1093 : 	TCHAR   szToken[MAX_VALUE];
; 1094 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 1095 : 
; 1096 : 	LPTSTR szReg = NULL;

	mov	DWORD PTR _szReg$[ebp], 0

; 1097 : 	hr = PreProcessBuffer(szBuffer, &szReg);

	lea	eax, DWORD PTR _szReg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ; ATL::CRegParser::PreProcessBuffer
	mov	DWORD PTR _hr$[ebp], eax

; 1098 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90708

; 1099 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L90702
$L90708:

; 1100 : 
; 1101 : 	ATLTRACE(atlTraceRegistrar, 0, szReg);

	mov	edx, DWORD PTR _szReg$[ebp]
	push	edx
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1101					; 0000044dH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212076[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 1102 : 	ATLTRACE(atlTraceRegistrar, 0, _T("\n"));

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1102					; 0000044eH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212077[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 1103 : 
; 1104 : 	m_pchCur = szReg;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _szReg$[ebp]
	mov	DWORD PTR [eax], ecx
$L90713:

; 1105 : 
; 1106 : 	// Preprocess szReg
; 1107 : 
; 1108 : 	while (NULL != *m_pchCur)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$L90714

; 1109 : 	{
; 1110 : 		if (FAILED(hr = NextToken(szToken)))

	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90716

; 1111 : 			break;

	jmp	$L90714
$L90716:

; 1112 : 		HKEY hkBase;
; 1113 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

	lea	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ; ATL::CRegParser::HKeyFromString
	add	esp, 4
	mov	DWORD PTR _hkBase$90717[ebp], eax
	cmp	DWORD PTR _hkBase$90717[ebp], 0
	jne	SHORT $L90718

; 1114 : 		{
; 1115 : 			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);

	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BN@HJIJAHEL@HKeyFromString?5failed?5on?5?$CFs?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1115					; 0000045bH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212078[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1116 : 			hr = GenerateError(E_ATL_BAD_HKEY);

	push	524					; 0000020cH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR _hr$[ebp], eax

; 1117 : 			break;

	jmp	$L90714
$L90718:

; 1118 : 		}
; 1119 : 
; 1120 : 		if (FAILED(hr = NextToken(szToken)))

	lea	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90722

; 1121 : 			break;

	jmp	$L90714
$L90722:

; 1122 : 
; 1123 : 		if (chLeftBracket != *szToken)

	movsx	eax, BYTE PTR _szToken$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $L90723

; 1124 : 		{
; 1125 : 			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);

	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CJ@JJEGIHLG@Syntax?5error?0?5expecting?5a?5?$HL?0?5fou@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1125					; 00000465H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212079[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1126 : 			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);

	push	525					; 0000020dH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR _hr$[ebp], eax

; 1127 : 			break;

	jmp	$L90714
$L90723:

; 1128 : 		}
; 1129 : 		if (bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	$L90726

; 1130 : 		{
; 1131 : 			LPTSTR szRegAtRegister = m_pchCur;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _szRegAtRegister$90727[ebp], eax

; 1132 : 			hr = RegisterSubkeys(szToken, hkBase, bRegister);

	push	0
	mov	ecx, DWORD PTR _bRegister$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hkBase$90717[ebp]
	push	edx
	lea	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
	mov	DWORD PTR _hr$[ebp], eax

; 1133 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90729

; 1134 : 			{
; 1135 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));

	push	OFFSET FLAT:??_C@_0CC@MOJNOPNN@Failed?5to?5register?0?5cleaning?5up?$CB@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1135					; 0000046fH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212080[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 1136 : 				m_pchCur = szRegAtRegister;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _szRegAtRegister$90727[ebp]
	mov	DWORD PTR [ecx], edx

; 1137 : 				RegisterSubkeys(szToken, hkBase, FALSE);

	push	0
	push	0
	mov	eax, DWORD PTR _hkBase$90717[ebp]
	push	eax
	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys

; 1138 : 				break;

	jmp	SHORT $L90714
$L90729:

; 1139 : 			}
; 1140 : 		}
; 1141 : 		else

	jmp	SHORT $L90732
$L90726:

; 1142 : 		{
; 1143 : 			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))

	push	0
	mov	edx, DWORD PTR _bRegister$[ebp]
	push	edx
	mov	eax, DWORD PTR _hkBase$90717[ebp]
	push	eax
	lea	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90732

; 1144 : 				break;

	jmp	SHORT $L90714
$L90732:

; 1145 : 		}
; 1146 : 
; 1147 : 		SkipWhiteSpace();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ	; ATL::CRegParser::SkipWhiteSpace

; 1148 : 	}

	jmp	$L90713
$L90714:

; 1149 : 	CoTaskMemFree(szReg);

	mov	esi, esp
	mov	edx, DWORD PTR _szReg$[ebp]
	push	edx
	call	DWORD PTR __imp__CoTaskMemFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1150 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L90702:

; 1151 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212086
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 4176				; 00001050H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L212086:
	DD	2
	DD	$L212085
$L212085:
	DD	-4108					; ffffeff4H
	DD	4096					; 00001000H
	DD	$L212081
	DD	-4124					; ffffefe4H
	DD	4
	DD	$L212082
$L212082:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	0
$L212081:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	84					; 00000054H
	DB	111					; 0000006fH
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	0
?RegisterBuffer@CRegParser@ATL@@QAEJPADH@Z ENDP		; ATL::CRegParser::RegisterBuffer
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GenerateError@CRegParser@ATL@@IAEJI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?GenerateError@CRegParser@ATL@@IAEJI@Z PROC NEAR	; ATL::CRegParser::GenerateError, COMDAT
; _this$ = ecx

; 161  : 	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, -2147352567			; 80020009H
	mov	esp, ebp
	pop	ebp
	ret	4
?GenerateError@CRegParser@ATL@@IAEJI@Z ENDP		; ATL::CRegParser::GenerateError
_TEXT	ENDS
PUBLIC	?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B ; `ATL::CRegParser::HKeyFromString'::`3'::map
PUBLIC	??_C@_04OHBKMIBJ@HKCR?$AA@			; `string'
PUBLIC	??_C@_04KIFLFONO@HKCU?$AA@			; `string'
PUBLIC	??_C@_04CBBMIBLK@HKLM?$AA@			; `string'
PUBLIC	??_C@_03DLBIJLAB@HKU?$AA@			; `string'
PUBLIC	??_C@_04OFOCGAOH@HKPD?$AA@			; `string'
PUBLIC	??_C@_04POMNGLEL@HKDD?$AA@			; `string'
PUBLIC	??_C@_04LEMDOLAJ@HKCC?$AA@			; `string'
PUBLIC	??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@	; `string'
PUBLIC	??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@	; `string'
PUBLIC	??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@	; `string'
PUBLIC	??_C@_0L@OEMMANAM@HKEY_USERS?$AA@		; `string'
PUBLIC	??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@	; `string'
PUBLIC	??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@		; `string'
PUBLIC	??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@	; `string'
;	COMDAT ?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B
CONST	SEGMENT
?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B DD FLAT:??_C@_04OHBKMIBJ@HKCR?$AA@ ; `ATL::CRegParser::HKeyFromString'::`3'::map
	DD	080000000H
	DD	FLAT:??_C@_04KIFLFONO@HKCU?$AA@
	DD	080000001H
	DD	FLAT:??_C@_04CBBMIBLK@HKLM?$AA@
	DD	080000002H
	DD	FLAT:??_C@_03DLBIJLAB@HKU?$AA@
	DD	080000003H
	DD	FLAT:??_C@_04OFOCGAOH@HKPD?$AA@
	DD	080000004H
	DD	FLAT:??_C@_04POMNGLEL@HKDD?$AA@
	DD	080000006H
	DD	FLAT:??_C@_04LEMDOLAJ@HKCC?$AA@
	DD	080000005H
	DD	FLAT:??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
	DD	080000000H
	DD	FLAT:??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
	DD	080000001H
	DD	FLAT:??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
	DD	080000002H
	DD	FLAT:??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
	DD	080000003H
	DD	FLAT:??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
	DD	080000004H
	DD	FLAT:??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
	DD	080000006H
	DD	FLAT:??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
	DD	080000005H
CONST	ENDS
;	COMDAT ??_C@_04OHBKMIBJ@HKCR?$AA@
CONST	SEGMENT
??_C@_04OHBKMIBJ@HKCR?$AA@ DB 'HKCR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KIFLFONO@HKCU?$AA@
CONST	SEGMENT
??_C@_04KIFLFONO@HKCU?$AA@ DB 'HKCU', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CBBMIBLK@HKLM?$AA@
CONST	SEGMENT
??_C@_04CBBMIBLK@HKLM?$AA@ DB 'HKLM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLBIJLAB@HKU?$AA@
CONST	SEGMENT
??_C@_03DLBIJLAB@HKU?$AA@ DB 'HKU', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OFOCGAOH@HKPD?$AA@
CONST	SEGMENT
??_C@_04OFOCGAOH@HKPD?$AA@ DB 'HKPD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POMNGLEL@HKDD?$AA@
CONST	SEGMENT
??_C@_04POMNGLEL@HKDD?$AA@ DB 'HKDD', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LEMDOLAJ@HKCC?$AA@
CONST	SEGMENT
??_C@_04LEMDOLAJ@HKCC?$AA@ DB 'HKCC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@
CONST	SEGMENT
??_C@_0BC@JBJOLKMF@HKEY_CLASSES_ROOT?$AA@ DB 'HKEY_CLASSES_ROOT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@
CONST	SEGMENT
??_C@_0BC@GMMMKLBI@HKEY_CURRENT_USER?$AA@ DB 'HKEY_CURRENT_USER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@
CONST	SEGMENT
??_C@_0BD@GIIFIKDM@HKEY_LOCAL_MACHINE?$AA@ DB 'HKEY_LOCAL_MACHINE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OEMMANAM@HKEY_USERS?$AA@
CONST	SEGMENT
??_C@_0L@OEMMANAM@HKEY_USERS?$AA@ DB 'HKEY_USERS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@
CONST	SEGMENT
??_C@_0BG@IDBEHNDO@HKEY_PERFORMANCE_DATA?$AA@ DB 'HKEY_PERFORMANCE_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@
CONST	SEGMENT
??_C@_0O@MJDLIIGK@HKEY_DYN_DATA?$AA@ DB 'HKEY_DYN_DATA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@NLNNHLLF@HKEY_CURRENT_CONFIG?$AA@ DB 'HKEY_CURRENT_CONFIG', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z
_TEXT	SEGMENT
_i$90390 = -4						; size = 4
_szToken$ = 8						; size = 4
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z PROC NEAR ; ATL::CRegParser::HKeyFromString, COMDAT

; 686  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 687  : 	struct keymap
; 688  : 	{
; 689  : 		LPCTSTR lpsz;
; 690  : 		HKEY hkey;
; 691  : 	};
; 692  : 	static const keymap map[] = {
; 693  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 694  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 695  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 696  : 		{_T("HKU"),  HKEY_USERS},
; 697  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 698  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 699  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 700  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 701  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 702  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 703  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 704  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 705  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 706  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 707  : 	};
; 708  : 
; 709  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

	mov	DWORD PTR _i$90390[ebp], 0
	jmp	SHORT $L90392
$L90393:
	mov	eax, DWORD PTR _i$90390[ebp]
	add	eax, 1
	mov	DWORD PTR _i$90390[ebp], eax
$L90392:
	cmp	DWORD PTR _i$90390[ebp], 14		; 0000000eH
	jae	SHORT $L90394

; 710  : 	{
; 711  : 		if (!lstrcmpi(szToken, map[i].lpsz))

	mov	esi, esp
	mov	ecx, DWORD PTR _i$90390[ebp]
	mov	edx, DWORD PTR ?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B[ecx*8]
	push	edx
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L90395

; 712  : 			return map[i].hkey;

	mov	ecx, DWORD PTR _i$90390[ebp]
	mov	eax, DWORD PTR ?map@?2??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z@4QBUkeymap@23@B[ecx*8+4]
	jmp	SHORT $L90322
$L90395:

; 713  : 	}

	jmp	SHORT $L90393
$L90394:

; 714  : 	return NULL;

	xor	eax, eax
$L90322:

; 715  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PAD@Z ENDP	; ATL::CRegParser::HKeyFromString
_TEXT	ENDS
PUBLIC	?IsSpace@CRegParser@ATL@@IAEHD@Z		; ATL::CRegParser::IsSpace
EXTRN	__imp__CharNextA@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ PROC NEAR	; ATL::CRegParser::SkipWhiteSpace, COMDAT
; _this$ = ecx

; 757  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L90423:

; 758  : 	while(IsSpace(*m_pchCur))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSpace@CRegParser@ATL@@IAEHD@Z	; ATL::CRegParser::IsSpace
	test	eax, eax
	je	SHORT $L90421

; 759  : 		m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $L90423
$L90421:

; 760  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ENDP		; ATL::CRegParser::SkipWhiteSpace
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEHD@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_ch$ = 8						; size = 1
?IsSpace@CRegParser@ATL@@IAEHD@Z PROC NEAR		; ATL::CRegParser::IsSpace, COMDAT
; _this$ = ecx

; 743  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 744  : 	switch (ch)

	movsx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 9
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 23			; 00000017H
	ja	SHORT $L90415
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $L212095[edx]
	jmp	DWORD PTR $L212096[eax*4]
$L90418:

; 745  : 	{
; 746  : 		case _T(' '):
; 747  : 		case _T('\t'):
; 748  : 		case _T('\r'):
; 749  : 		case _T('\n'):
; 750  : 				return TRUE;

	mov	eax, 1
	jmp	SHORT $L90413
$L90415:

; 751  : 	}
; 752  : 
; 753  : 	return FALSE;

	xor	eax, eax
$L90413:

; 754  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$L212096:
	DD	$L90418
	DD	$L90415
$L212095:
	DB	0
	DB	0
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
?IsSpace@CRegParser@ATL@@IAEHD@Z ENDP			; ATL::CRegParser::IsSpace
_TEXT	ENDS
PUBLIC	??_C@_0CE@HPLFHOFC@NextToken?5?3?5Unexpected?5End?5of?5Fi@ ; `string'
PUBLIC	?EndOfVar@CRegParser@ATL@@IAEHXZ		; ATL::CRegParser::EndOfVar
;	COMDAT ??_C@_0CE@HPLFHOFC@NextToken?5?3?5Unexpected?5End?5of?5Fi@
CONST	SEGMENT
??_C@_0CE@HPLFHOFC@NextToken?5?3?5Unexpected?5End?5of?5Fi@ DB 'NextToken '
	DB	': Unexpected End of File', 0aH, 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
$T212099 = -32						; size = 8
_i$90453 = -24						; size = 4
_pchPrev$90450 = -20					; size = 4
_i$90439 = -16						; size = 4
_pchPrev$90436 = -12					; size = 4
_szOrig$ = -8						; size = 4
_this$ = -4						; size = 4
_szToken$ = 8						; size = 4
?NextToken@CRegParser@ATL@@IAEJPAD@Z PROC NEAR		; ATL::CRegParser::NextToken, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 764  : 	SkipWhiteSpace();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ	; ATL::CRegParser::SkipWhiteSpace

; 765  : 
; 766  : 	// NextToken cannot be called at EOS
; 767  : 	if (NULL == *m_pchCur)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L90429

; 768  : 		return GenerateError(E_ATL_UNEXPECTED_EOS);

	push	515					; 00000203H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	jmp	$L90428
$L90429:

; 769  : 
; 770  : 	LPCTSTR szOrig = szToken;

	mov	eax, DWORD PTR _szToken$[ebp]
	mov	DWORD PTR _szOrig$[ebp], eax

; 771  : 	// handle quoted value / key
; 772  : 	if (chQuote == *m_pchCur)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	jne	$L90448

; 773  : 	{
; 774  : 		m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L90433:

; 775  : 
; 776  : 		while (NULL != *m_pchCur && !EndOfVar())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$L90434
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EndOfVar@CRegParser@ATL@@IAEHXZ	; ATL::CRegParser::EndOfVar
	test	eax, eax
	jne	$L90434

; 777  : 		{
; 778  : 			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $L90435

; 779  : 				m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L90435:

; 780  : 
; 781  : 			LPTSTR pchPrev = m_pchCur;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pchPrev$90436[ebp], eax

; 782  : 			m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 783  : 
; 784  : 			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)

	mov	edx, DWORD PTR _szToken$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _szOrig$[ebp]
	add	eax, 4096				; 00001000H
	cmp	edx, eax
	jb	SHORT $L90438

; 785  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);

	push	533					; 00000215H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	jmp	$L90428
$L90438:

; 786  : 			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)

	mov	DWORD PTR _i$90439[ebp], 0
	jmp	SHORT $L90440
$L90441:
	mov	ecx, DWORD PTR _i$90439[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$90439[ebp], ecx
	mov	edx, DWORD PTR _szToken$[ebp]
	add	edx, 1
	mov	DWORD PTR _szToken$[ebp], edx
$L90440:
	mov	eax, DWORD PTR _pchPrev$90436[ebp]
	add	eax, DWORD PTR _i$90439[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $L90442

; 787  : 				*szToken = *(pchPrev+i);

	mov	edx, DWORD PTR _pchPrev$90436[ebp]
	add	edx, DWORD PTR _i$90439[ebp]
	mov	eax, DWORD PTR _szToken$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $L90441
$L90442:

; 788  : 		}

	jmp	$L90433
$L90434:

; 789  : 
; 790  : 		if (NULL == *m_pchCur)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $L90443

; 791  : 		{
; 792  : 			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));

	push	OFFSET FLAT:??_C@_0CE@HPLFHOFC@NextToken?5?3?5Unexpected?5End?5of?5Fi@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	792					; 00000318H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212099[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 793  : 			return GenerateError(E_ATL_UNEXPECTED_EOS);

	push	515					; 00000203H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	jmp	$L90428
$L90443:

; 794  : 		}
; 795  : 
; 796  : 		*szToken = NULL;

	mov	edx, DWORD PTR _szToken$[ebp]
	mov	BYTE PTR [edx], 0

; 797  : 		m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 798  : 	}
; 799  : 
; 800  : 	else

	jmp	$L90446
$L90448:

; 801  : 	{   
; 802  : 		// Handle non-quoted ie parse up till first "White Space"
; 803  : 		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L90449
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?IsSpace@CRegParser@ATL@@IAEHD@Z	; ATL::CRegParser::IsSpace
	test	eax, eax
	jne	SHORT $L90449

; 804  : 		{
; 805  : 			LPTSTR pchPrev = m_pchCur;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pchPrev$90450[ebp], ecx

; 806  : 			m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 807  : 			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)

	mov	edx, DWORD PTR _szToken$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _szOrig$[ebp]
	add	eax, 4096				; 00001000H
	cmp	edx, eax
	jb	SHORT $L90452

; 808  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);

	push	533					; 00000215H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	jmp	SHORT $L90428
$L90452:

; 809  : 			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)

	mov	DWORD PTR _i$90453[ebp], 0
	jmp	SHORT $L90454
$L90455:
	mov	ecx, DWORD PTR _i$90453[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$90453[ebp], ecx
	mov	edx, DWORD PTR _szToken$[ebp]
	add	edx, 1
	mov	DWORD PTR _szToken$[ebp], edx
$L90454:
	mov	eax, DWORD PTR _pchPrev$90450[ebp]
	add	eax, DWORD PTR _i$90453[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx]
	jae	SHORT $L90456

; 810  : 				*szToken = *(pchPrev+i);

	mov	edx, DWORD PTR _pchPrev$90450[ebp]
	add	edx, DWORD PTR _i$90453[ebp]
	mov	eax, DWORD PTR _szToken$[ebp]
	mov	cl, BYTE PTR [edx]
	mov	BYTE PTR [eax], cl
	jmp	SHORT $L90455
$L90456:

; 811  : 		}

	jmp	$L90448
$L90449:

; 812  : 
; 813  : 		*szToken = NULL;

	mov	edx, DWORD PTR _szToken$[ebp]
	mov	BYTE PTR [edx], 0
$L90446:

; 814  : 	}
; 815  : 	return S_OK;

	xor	eax, eax
$L90428:

; 816  : }

	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?NextToken@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::NextToken
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?EndOfVar@CRegParser@ATL@@IAEHXZ PROC NEAR		; ATL::CRegParser::EndOfVar, COMDAT
; _this$ = ecx

; 165  : 	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $L212102
	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 39					; 00000027H
	je	SHORT $L212102
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $L212103
$L212102:
	mov	DWORD PTR tv71[ebp], 0
$L212103:
	mov	eax, DWORD PTR tv71[ebp]
	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?EndOfVar@CRegParser@ATL@@IAEHXZ ENDP			; ATL::CRegParser::EndOfVar
_TEXT	ENDS
PUBLIC	??_C@_0N@FCNKJMCG@lpszReg?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0N@HMGHIDAH@ppszReg?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0BK@LLGNALDE@Error?5no?5closing?5?$CF?5found?6?$AA@ ; `string'
PUBLIC	?StrChrA@CRegParser@ATL@@KAPADPADD@Z		; ATL::CRegParser::StrChrA
PUBLIC	??0CParseBuffer@CRegParser@ATL@@QAE@H@Z		; ATL::CRegParser::CParseBuffer::CParseBuffer
PUBLIC	??1CParseBuffer@CRegParser@ATL@@QAE@XZ		; ATL::CRegParser::CParseBuffer::~CParseBuffer
PUBLIC	?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z	; ATL::CRegParser::CParseBuffer::AddChar
PUBLIC	?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z ; ATL::CRegParser::CParseBuffer::AddString
PUBLIC	?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ	; ATL::CRegParser::CParseBuffer::Detach
PUBLIC	?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z		; ATL::CRegObject::StrFromMap
EXTRN	__imp__lstrcpynA@12:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212121 DD	0ffffffffH
	DD	FLAT:$L212112
$T212114 DD	019930520H
	DD	01H
	DD	FLAT:$T212121
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0N@FCNKJMCG@lpszReg?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@FCNKJMCG@lpszReg?5?$CB?$DN?50?$AA@ DB 'lpszReg != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HMGHIDAH@ppszReg?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@HMGHIDAH@ppszReg?5?$CB?$DN?50?$AA@ DB 'ppszReg != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LLGNALDE@Error?5no?5closing?5?$CF?5found?6?$AA@
CONST	SEGMENT
??_C@_0BK@LLGNALDE@Error?5no?5closing?5?$CF?5found?6?$AA@ DB 'Error no cl'
	DB	'osing % found', 0aH, 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
_TEXT	SEGMENT
$T212111 = -116						; size = 4
$T212110 = -112						; size = 8
$T212109 = -104						; size = 4
_lpszVar$90685 = -100					; size = 4
_buf$90684 = -92					; size = 32
_nLength$90683 = -56					; size = 4
_lpszNext$90677 = -52					; size = 4
_hr$ = -48						; size = 4
_pb$ = -40						; size = 12
_nSize$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpszReg$ = 8						; size = 4
_ppszReg$ = 12						; size = 4
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z PROC NEAR ; ATL::CRegParser::PreProcessBuffer, COMDAT
; _this$ = ecx

; 1014 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 104				; 00000068H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-116]
	mov	ecx, 26					; 0000001aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1015 : 	ATLASSERT(lpszReg != NULL);

	cmp	DWORD PTR _lpszReg$[ebp], 0
	jne	SHORT $L212107
	push	OFFSET FLAT:??_C@_0N@FCNKJMCG@lpszReg?5?$CB?$DN?50?$AA@
	push	0
	push	1015					; 000003f7H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212107
	int	3
$L212107:

; 1016 : 	ATLASSERT(ppszReg != NULL);

	cmp	DWORD PTR _ppszReg$[ebp], 0
	jne	SHORT $L212108
	push	OFFSET FLAT:??_C@_0N@HMGHIDAH@ppszReg?5?$CB?$DN?50?$AA@
	push	0
	push	1016					; 000003f8H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212108
	int	3
$L212108:

; 1017 : 
; 1018 : 	if (lpszReg == NULL || ppszReg == NULL)

	cmp	DWORD PTR _lpszReg$[ebp], 0
	je	SHORT $L90660
	cmp	DWORD PTR _ppszReg$[ebp], 0
	jne	SHORT $L90659
$L90660:

; 1019 : 		return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L90654
$L90659:

; 1020 : 	
; 1021 : 	*ppszReg = NULL;

	mov	edx, DWORD PTR _ppszReg$[ebp]
	mov	DWORD PTR [edx], 0

; 1022 : 	int nSize = lstrlen(lpszReg)*2;

	mov	esi, esp
	mov	eax, DWORD PTR _lpszReg$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	shl	eax, 1
	mov	DWORD PTR _nSize$[ebp], eax

; 1023 : 	CParseBuffer pb(nSize);

	mov	ecx, DWORD PTR _nSize$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pb$[ebp]
	call	??0CParseBuffer@CRegParser@ATL@@QAE@H@Z	; ATL::CRegParser::CParseBuffer::CParseBuffer
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1024 : 	if (pb.p == NULL)

	cmp	DWORD PTR _pb$[ebp+8], 0
	jne	SHORT $L90664

; 1025 : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T212109[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pb$[ebp]
	call	??1CParseBuffer@CRegParser@ATL@@QAE@XZ	; ATL::CRegParser::CParseBuffer::~CParseBuffer
	mov	eax, DWORD PTR $T212109[ebp]
	jmp	$L90654
$L90664:

; 1026 : 	m_pchCur = lpszReg;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpszReg$[ebp]
	mov	DWORD PTR [edx], eax

; 1027 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0
$L90670:

; 1028 : 
; 1029 : 	while (*m_pchCur != NULL) // look for end

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L90671

; 1030 : 	{
; 1031 : 		if (*m_pchCur == _T('%'))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	$L90672

; 1032 : 		{
; 1033 : 			m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1034 : 			if (*m_pchCur == _T('%'))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 37					; 00000025H
	jne	SHORT $L90673

; 1035 : 			{
; 1036 : 				if (!pb.AddChar(m_pchCur))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _pb$[ebp]
	call	?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ; ATL::CRegParser::CParseBuffer::AddChar
	test	eax, eax
	jne	SHORT $L90674

; 1037 : 				{
; 1038 : 					hr = E_OUTOFMEMORY;

	mov	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH

; 1039 : 					break;

	jmp	$L90671
$L90674:

; 1040 : 				}
; 1041 : 			}
; 1042 : 			else

	jmp	$L90676
$L90673:

; 1043 : 			{
; 1044 : 				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));

	push	37					; 00000025H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?StrChrA@CRegParser@ATL@@KAPADPADD@Z	; ATL::CRegParser::StrChrA
	add	esp, 8
	mov	DWORD PTR _lpszNext$90677[ebp], eax

; 1045 : 				if (lpszNext == NULL)

	cmp	DWORD PTR _lpszNext$90677[ebp], 0
	jne	SHORT $L90678

; 1046 : 				{
; 1047 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing % found\n"));

	push	OFFSET FLAT:??_C@_0BK@LLGNALDE@Error?5no?5closing?5?$CF?5found?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1047					; 00000417H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212110[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 1048 : 					hr = GenerateError(E_ATL_UNEXPECTED_EOS);

	push	515					; 00000203H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR _hr$[ebp], eax

; 1049 : 					break;

	jmp	$L90671
$L90678:

; 1050 : 				}
; 1051 : 				if ((lpszNext-m_pchCur) > 31)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lpszNext$90677[ebp]
	sub	ecx, DWORD PTR [eax]
	cmp	ecx, 31					; 0000001fH
	jle	SHORT $L90681

; 1052 : 				{
; 1053 : 					hr = E_FAIL;

	mov	DWORD PTR _hr$[ebp], -2147467259	; 80004005H

; 1054 : 					break;

	jmp	$L90671
$L90681:

; 1055 : 				}
; 1056 : 				int nLength = int(lpszNext - m_pchCur);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _lpszNext$90677[ebp]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _nLength$90683[ebp], eax

; 1057 : 				TCHAR buf[32];
; 1058 : 				lstrcpyn(buf, m_pchCur, nLength+1);

	mov	ecx, DWORD PTR _nLength$90683[ebp]
	add	ecx, 1
	mov	esi, esp
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _buf$90684[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpynA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1059 : 				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

	lea	edx, DWORD PTR _buf$90684[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z	; ATL::CRegObject::StrFromMap
	mov	DWORD PTR _lpszVar$90685[ebp], eax

; 1060 : 				if (lpszVar == NULL)

	cmp	DWORD PTR _lpszVar$90685[ebp], 0
	jne	SHORT $L90686

; 1061 : 				{
; 1062 : 					hr = GenerateError(E_ATL_NOT_IN_MAP);

	push	514					; 00000202H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR _hr$[ebp], eax

; 1063 : 					break;

	jmp	SHORT $L90671
$L90686:

; 1064 : 				}
; 1065 : 				if (!pb.AddString(lpszVar))

	mov	ecx, DWORD PTR _lpszVar$90685[ebp]
	push	ecx
	lea	ecx, DWORD PTR _pb$[ebp]
	call	?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z ; ATL::CRegParser::CParseBuffer::AddString
	test	eax, eax
	jne	SHORT $L90690

; 1066 : 				{
; 1067 : 					hr = E_OUTOFMEMORY;

	mov	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH

; 1068 : 					break;

	jmp	SHORT $L90671
$L90690:

; 1069 : 				}
; 1070 : 
; 1071 : 				while (m_pchCur != lpszNext)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lpszNext$90677[ebp]
	je	SHORT $L90676

; 1072 : 					m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $L90690
$L90676:

; 1073 : 			}
; 1074 : 		}
; 1075 : 		else

	jmp	SHORT $L90692
$L90672:

; 1076 : 		{
; 1077 : 			if (!pb.AddChar(m_pchCur))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _pb$[ebp]
	call	?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ; ATL::CRegParser::CParseBuffer::AddChar
	test	eax, eax
	jne	SHORT $L90692

; 1078 : 			{
; 1079 : 				hr = E_OUTOFMEMORY;

	mov	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH

; 1080 : 				break;

	jmp	SHORT $L90671
$L90692:

; 1081 : 			}
; 1082 : 		}
; 1083 : 
; 1084 : 		m_pchCur = CharNext(m_pchCur);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 1085 : 	}

	jmp	$L90670
$L90671:

; 1086 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L90696

; 1087 : 		*ppszReg = pb.Detach();

	lea	ecx, DWORD PTR _pb$[ebp]
	call	?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ ; ATL::CRegParser::CParseBuffer::Detach
	mov	edx, DWORD PTR _ppszReg$[ebp]
	mov	DWORD PTR [edx], eax
$L90696:

; 1088 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212111[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _pb$[ebp]
	call	??1CParseBuffer@CRegParser@ATL@@QAE@XZ	; ATL::CRegParser::CParseBuffer::~CParseBuffer
	mov	eax, DWORD PTR $T212111[ebp]
$L90654:

; 1089 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212120
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 116				; 00000074H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L212120:
	DD	2
	DD	$L212119
$L212119:
	DD	-40					; ffffffd8H
	DD	12					; 0000000cH
	DD	$L212115
	DD	-92					; ffffffa4H
	DD	32					; 00000020H
	DD	$L212116
$L212116:
	DB	98					; 00000062H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	0
$L212115:
	DB	112					; 00000070H
	DB	98					; 00000062H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212112:
	lea	ecx, DWORD PTR _pb$[ebp]
	jmp	??1CParseBuffer@CRegParser@ATL@@QAE@XZ	; ATL::CRegParser::CParseBuffer::~CParseBuffer
__ehhandler$?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z:
	mov	eax, OFFSET FLAT:$T212114
	jmp	___CxxFrameHandler
text$x	ENDS
?PreProcessBuffer@CRegParser@ATL@@QAEJPADPAPAD@Z ENDP	; ATL::CRegParser::PreProcessBuffer
EXTRN	__imp__CoTaskMemAlloc@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nInitial$ = 8						; size = 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z PROC NEAR	; ATL::CRegParser::CParseBuffer::CParseBuffer, COMDAT
; _this$ = ecx

; 182  : 		CParseBuffer(int nInitial)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 183  : 		{
; 184  : 			if (nInitial < 100)

	cmp	DWORD PTR _nInitial$[ebp], 100		; 00000064H
	jge	SHORT $L89839

; 185  : 				nInitial = 1000;

	mov	DWORD PTR _nInitial$[ebp], 1000		; 000003e8H
$L89839:

; 186  : 			nPos = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 187  : 			nSize = nInitial;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nInitial$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 188  : 			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__CoTaskMemAlloc@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 189  : 			if (p != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $L89838

; 190  : 				*p = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [edx], 0
$L89838:

; 191  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ENDP		; ATL::CRegParser::CParseBuffer::CParseBuffer
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1CParseBuffer@CRegParser@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CParseBuffer@CRegParser@ATL@@QAE@XZ PROC NEAR	; ATL::CRegParser::CParseBuffer::~CParseBuffer, COMDAT
; _this$ = ecx

; 193  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 194  : 			CoTaskMemFree(p);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR __imp__CoTaskMemFree@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 195  : 		}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CParseBuffer@CRegParser@ATL@@QAE@XZ ENDP		; ATL::CRegParser::CParseBuffer::~CParseBuffer
_TEXT	ENDS
PUBLIC	?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z	; ATL::CRegParser::CParseBuffer::Append
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z
_TEXT	SEGMENT
_nChars$ = -8						; size = 4
_this$ = -4						; size = 4
_pch$ = 8						; size = 4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z PROC NEAR ; ATL::CRegParser::CParseBuffer::AddChar, COMDAT
; _this$ = ecx

; 215  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 216  : #ifndef _UNICODE		
; 217  : 			int nChars = int(CharNext(pch) - pch);

	mov	esi, esp
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	sub	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _nChars$[ebp], eax

; 218  : #else
; 219  : 			int nChars = 1;
; 220  : #endif
; 221  : 			return Append(pch, nChars);

	mov	ecx, DWORD PTR _nChars$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append

; 222  : 
; 223  : 		}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AddChar@CParseBuffer@CRegParser@ATL@@QAEHPBD@Z ENDP	; ATL::CRegParser::CParseBuffer::AddChar
_TEXT	ENDS
PUBLIC	??_C@_06JALMKDEH@p?5?$CB?$DN?50?$AA@		; `string'
EXTRN	__imp__CoTaskMemRealloc@8:NEAR
;	COMDAT ??_C@_06JALMKDEH@p?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_06JALMKDEH@p?5?$CB?$DN?50?$AA@ DB 'p != 0', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z
_TEXT	SEGMENT
_pTemp$89853 = -8					; size = 4
_this$ = -4						; size = 4
_pch$ = 8						; size = 4
_nChars$ = 12						; size = 4
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z PROC NEAR ; ATL::CRegParser::CParseBuffer::Append, COMDAT
; _this$ = ecx

; 197  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 			ATLASSERT(p != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $L212132
	push	OFFSET FLAT:??_C@_06JALMKDEH@p?5?$CB?$DN?50?$AA@
	push	0
	push	198					; 000000c6H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212132
	int	3
$L212132:

; 199  : 			if ((nPos + nChars + 1) >= nSize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nChars$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jl	SHORT $L89849
$L89851:

; 200  : 			{
; 201  : 				while ((nPos + nChars + 1) >= nSize)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _nChars$[ebp]
	lea	ecx, DWORD PTR [edx+eax+1]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+4]
	jl	SHORT $L89852

; 202  : 					nSize *=2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shl	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $L89851
$L89852:

; 203  : 				LPTSTR pTemp = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR __imp__CoTaskMemRealloc@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _pTemp$89853[ebp], eax

; 204  : 				if (pTemp == NULL)

	cmp	DWORD PTR _pTemp$89853[ebp], 0
	jne	SHORT $L89856

; 205  : 					return FALSE;

	xor	eax, eax
	jmp	SHORT $L89846
$L89856:

; 206  : 				p = pTemp;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pTemp$89853[ebp]
	mov	DWORD PTR [ecx+8], edx
$L89849:

; 207  : 			}
; 208  : 			memcpy(p + nPos, pch, int(nChars * sizeof(TCHAR)));

	mov	eax, DWORD PTR _nChars$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 209  : 			nPos += nChars;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _nChars$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 210  : 			*(p + nPos) = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [eax+edx], 0

; 211  : 			return TRUE;			

	mov	eax, 1
$L89846:

; 212  : 		}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ENDP	; ATL::CRegParser::CParseBuffer::Append
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212147 DD	0ffffffffH
	DD	FLAT:$L212140
$T212142 DD	019930520H
	DD	01H
	DD	FLAT:$T212147
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z
_TEXT	SEGMENT
tv89 = -64						; size = 4
tv84 = -60						; size = 4
tv91 = -56						; size = 4
$T212139 = -52						; size = 4
_lpszT$ = -48						; size = 4
__AtlSafeAllocaManager$ = -40				; size = 4
__lpa_ex$ = -32						; size = 4
__lpw_ex$ = -28						; size = 4
__acp_ex$ = -24						; size = 4
__convert_ex$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpsz$ = 8						; size = 4
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z PROC NEAR ; ATL::CRegParser::CParseBuffer::AddString, COMDAT
; _this$ = ecx

; 225  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 			if (lpsz == NULL)

	cmp	DWORD PTR _lpsz$[ebp], 0
	jne	SHORT $L89863

; 227  : 				return FALSE;

	xor	eax, eax
	jmp	$L89862
$L89863:

; 228  : 			USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 229  : 			LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _lpsz$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L212137
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $L212138
$L212137:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L212135
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212135
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv84[ebp], esp
	mov	edx, DWORD PTR tv84[ebp]
	mov	DWORD PTR tv89[ebp], edx
	jmp	SHORT $L212136
$L212135:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv89[ebp], eax
$L212136:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv89[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv91[ebp], eax
$L212138:
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR _lpszT$[ebp], edx

; 230  : #ifdef _UNICODE
; 231  : 			if (lpszT == NULL)
; 232  : 				return FALSE;
; 233  : #endif
; 234  : 			return Append(lpszT, (int)lstrlen(lpszT));

	mov	esi, esp
	mov	eax, DWORD PTR _lpszT$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _lpszT$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@CParseBuffer@CRegParser@ATL@@QAEHPBDH@Z ; ATL::CRegParser::CParseBuffer::Append
	mov	DWORD PTR $T212139[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212139[ebp]
$L89862:

; 235  : 		}

	lea	esp, DWORD PTR [ebp-72]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212146
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$L212146:
	DD	1
	DD	$L212145
$L212145:
	DD	-40					; ffffffd8H
	DD	4
	DD	$L212143
$L212143:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212140:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z:
	mov	eax, OFFSET FLAT:$T212142
	jmp	___CxxFrameHandler
text$x	ENDS
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPBG@Z ENDP	; ATL::CRegParser::CParseBuffer::AddString
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ
_TEXT	SEGMENT
_lp$ = -8						; size = 4
_this$ = -4						; size = 4
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ PROC NEAR	; ATL::CRegParser::CParseBuffer::Detach, COMDAT
; _this$ = ecx

; 237  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 			LPTSTR lp = p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lp$[ebp], ecx

; 239  : 			p = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 240  : 			nSize = nPos = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 241  : 			return lp;

	mov	eax, DWORD PTR _lp$[ebp]

; 242  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Detach@CParseBuffer@CRegParser@ATL@@QAEPADXZ ENDP	; ATL::CRegParser::CParseBuffer::Detach
_TEXT	ENDS
PUBLIC	??_C@_0BF@KHDDAOIJ@Map?5Entry?5not?5found?6?$AA@ ; `string'
PUBLIC	?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Lookup
;	COMDAT ??_C@_0BF@KHDDAOIJ@Map?5Entry?5not?5found?6?$AA@
CONST	SEGMENT
??_C@_0BF@KHDDAOIJ@Map?5Entry?5not?5found?6?$AA@ DB 'Map Entry not found', 0aH
	DB	00H						; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z
_TEXT	SEGMENT
$T212154 = -16						; size = 8
_lpsz$ = -8						; size = 4
_this$ = -4						; size = 4
_lpszKey$ = 8						; size = 4
?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z PROC NEAR	; ATL::CRegObject::StrFromMap, COMDAT
; _this$ = ecx

; 519  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 520  : 	m_csMap.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Lock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Lock

; 521  : 	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);

	lea	eax, DWORD PTR _lpszKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Lookup
	mov	DWORD PTR _lpsz$[ebp], eax

; 522  : 	if (lpsz == NULL) // not found!!

	cmp	DWORD PTR _lpsz$[ebp], 0
	jne	SHORT $L90219

; 523  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Map Entry not found\n"));

	push	OFFSET FLAT:??_C@_0BF@KHDDAOIJ@Map?5Entry?5not?5found?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	523					; 0000020bH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212154[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H
$L90219:

; 524  : 	m_csMap.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Unlock@CComFakeCriticalSection@ATL@@QAEJXZ ; ATL::CComFakeCriticalSection::Unlock

; 525  : 	return lpsz;

	mov	eax, DWORD PTR _lpsz$[ebp]

; 526  : }

	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?StrFromMap@CRegObject@ATL@@QAEPBGPAD@Z ENDP		; ATL::CRegObject::StrFromMap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?StrChrA@CRegParser@ATL@@KAPADPADD@Z
_TEXT	SEGMENT
_p$ = -4						; size = 4
_lpsz$ = 8						; size = 4
_ch$ = 12						; size = 1
?StrChrA@CRegParser@ATL@@KAPADPADD@Z PROC NEAR		; ATL::CRegParser::StrChrA, COMDAT

; 718  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 719  : 	LPTSTR p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 720  : 
; 721  : 	if (lpsz == NULL)

	cmp	DWORD PTR _lpsz$[ebp], 0
	jne	SHORT $L90403

; 722  : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L90399
$L90403:

; 723  : 	
; 724  : 	while (*lpsz)

	mov	eax, DWORD PTR _lpsz$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L90404

; 725  : 	{
; 726  : 		if (*lpsz == ch)

	mov	edx, DWORD PTR _lpsz$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _ch$[ebp]
	cmp	eax, ecx
	jne	SHORT $L90405

; 727  : 		{
; 728  : 			p = lpsz;

	mov	edx, DWORD PTR _lpsz$[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 729  : 			break;

	jmp	SHORT $L90404
$L90405:

; 730  : 		}
; 731  : 		lpsz = CharNext(lpsz);

	mov	esi, esp
	mov	eax, DWORD PTR _lpsz$[ebp]
	push	eax
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lpsz$[ebp], eax

; 732  : 	}

	jmp	SHORT $L90403
$L90404:

; 733  : 	return p;

	mov	eax, DWORD PTR _p$[ebp]
$L90399:

; 734  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?StrChrA@CRegParser@ATL@@KAPADPADD@Z ENDP		; ATL::CRegParser::StrChrA
_TEXT	ENDS
PUBLIC	?AtlHresultFromWin32@ATL@@YAJK@Z		; ATL::AtlHresultFromWin32
PUBLIC	??_C@_0O@EHICPHFJ@Num?5Els?5?$DN?5?$CFd?6?$AA@	; `string'
PUBLIC	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
PUBLIC	?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z	; ATL::CRegParser::CanForceRemoveKey
PUBLIC	?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z	; ATL::CRegParser::HasSubKeys
PUBLIC	??_C@_0N@GKIPNAL@Deleting?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0BB@POOIJOEN@Creating?5key?5?$CFs?6?$AA@	; `string'
PUBLIC	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::SkipAssignment
PUBLIC	??_C@_0P@IONAJCEO@Opened?5Key?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0CM@LEFFDKCG@Ignoring?5Open?5key?5on?5?$CFs?5?3?5In?5Rec@ ; `string'
PUBLIC	??_C@_0BG@OEFMOOAA@Ending?5Recovery?5Mode?6?$AA@ ; `string'
PUBLIC	??_C@_0CH@OEJDLABI@Deleting?5non?9empty?5subkey?5?$CFs?5by?5@ ; `string'
PUBLIC	??_C@_0BB@FDAMNOMP@Deleting?5Key?5?$CFs?6?$AA@	; `string'
PUBLIC	??0CRegKey@ATL@@QAE@XZ				; ATL::CRegKey::CRegKey
PUBLIC	??1CRegKey@ATL@@QAE@XZ				; ATL::CRegKey::~CRegKey
PUBLIC	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ		; ATL::CRegKey::operator HKEY__ *
PUBLIC	?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ; ATL::CRegKey::Create
PUBLIC	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z	; ATL::CRegKey::Open
PUBLIC	?Close@CRegKey@ATL@@QAEJXZ			; ATL::CRegKey::Close
PUBLIC	?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ		; ATL::CRegKey::Detach
PUBLIC	?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z		; ATL::CRegKey::Attach
PUBLIC	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z		; ATL::CRegKey::DeleteSubKey
PUBLIC	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::RecurseDeleteKey
PUBLIC	?DeleteValue@CRegKey@ATL@@QAEJPBD@Z		; ATL::CRegKey::DeleteValue
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212198 DD	0ffffffffH
	DD	FLAT:$L212176
	DD	00H
	DD	FLAT:$L212177
	DD	00H
	DD	FLAT:$L212178
$T212182 DD	019930520H
	DD	03H
	DD	FLAT:$T212198
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0O@EHICPHFJ@Num?5Els?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0O@EHICPHFJ@Num?5Els?5?$DN?5?$CFd?6?$AA@ DB 'Num Els = %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GKIPNAL@Deleting?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0N@GKIPNAL@Deleting?5?$CFs?6?$AA@ DB 'Deleting %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@POOIJOEN@Creating?5key?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@POOIJOEN@Creating?5key?5?$CFs?6?$AA@ DB 'Creating key %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IONAJCEO@Opened?5Key?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0P@IONAJCEO@Opened?5Key?5?$CFs?6?$AA@ DB 'Opened Key %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@LEFFDKCG@Ignoring?5Open?5key?5on?5?$CFs?5?3?5In?5Rec@
CONST	SEGMENT
??_C@_0CM@LEFFDKCG@Ignoring?5Open?5key?5on?5?$CFs?5?3?5In?5Rec@ DB 'Ignor'
	DB	'ing Open key on %s : In Recovery mode', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OEFMOOAA@Ending?5Recovery?5Mode?6?$AA@
CONST	SEGMENT
??_C@_0BG@OEFMOOAA@Ending?5Recovery?5Mode?6?$AA@ DB 'Ending Recovery Mode'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OEJDLABI@Deleting?5non?9empty?5subkey?5?$CFs?5by?5@
CONST	SEGMENT
??_C@_0CH@OEJDLABI@Deleting?5non?9empty?5subkey?5?$CFs?5by?5@ DB 'Deletin'
	DB	'g non-empty subkey %s by force', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FDAMNOMP@Deleting?5Key?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@FDAMNOMP@Deleting?5Key?5?$CFs?6?$AA@ DB 'Deleting Key %s', 0aH, 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
_TEXT	SEGMENT
$T212175 = -732						; size = 4
$T212174 = -728						; size = 8
$T212173 = -720						; size = 4
$T212172 = -716						; size = 8
$T212171 = -708						; size = 8
$T212170 = -700						; size = 8
$T212169 = -692						; size = 8
$T212168 = -684						; size = 4
$T212167 = -680						; size = 8
$T212166 = -672						; size = 4
$T212165 = -668						; size = 8
$T212164 = -660						; size = 4
$T212163 = -656						; size = 4
$T212162 = -652						; size = 4
$T212161 = -648						; size = 4
$T212160 = -644						; size = 8
_rkParent$90850 = -632					; size = 4
_rkParent$90795 = -620					; size = 4
_rk$90786 = -608					; size = 4
_szValueName$90778 = -596				; size = 260
_rkForceRemove$90763 = -328				; size = 4
_bTokenDelete$90757 = -320				; size = 4
_hr$ = -316						; size = 4
_bInRecovery$ = -312					; size = 4
_bDelete$ = -308					; size = 4
_szKey$ = -300						; size = 260
_lRes$ = -36						; size = 4
_keyCur$ = -28						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_szToken$ = 8						; size = 4
_hkParent$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_bRecover$ = 20						; size = 4
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z PROC NEAR ; ATL::CRegParser::RegisterSubkeys, COMDAT
; _this$ = ecx

; 1154 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 720				; 000002d0H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-732]
	mov	ecx, 180				; 000000b4H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 1155 : 	CRegKey keyCur;

	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1156 : 	LONG    lRes;
; 1157 : 	TCHAR  szKey[_MAX_PATH];
; 1158 : 	BOOL    bDelete = TRUE;

	mov	DWORD PTR _bDelete$[ebp], 1

; 1159 : 	BOOL    bInRecovery = bRecover;

	mov	eax, DWORD PTR _bRecover$[ebp]
	mov	DWORD PTR _bInRecovery$[ebp], eax

; 1160 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 1161 : 
; 1162 : 	ATLTRACE(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);

	push	12					; 0000000cH
	push	OFFSET FLAT:??_C@_0O@EHICPHFJ@Num?5Els?5?$DN?5?$CFd?6?$AA@
	push	2
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1162					; 0000048aH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212160[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1163 : 	if (FAILED(hr = NextToken(szToken)))

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90755

; 1164 : 		return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212161[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212161[ebp]
	jmp	$L90741
$L90755:

; 1165 : 
; 1166 : 
; 1167 : 	while (*szToken != chRightBracket) // Continue till we see a }

	mov	eax, DWORD PTR _szToken$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 125				; 0000007dH
	je	$L90756

; 1168 : 	{
; 1169 : 		bDelete = TRUE;

	mov	DWORD PTR _bDelete$[ebp], 1

; 1170 : 		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

	mov	esi, esp
	mov	edx, DWORD PTR _szDelete
	push	edx
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	DWORD PTR _bTokenDelete$90757[ebp], eax

; 1171 : 
; 1172 : 		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)

	mov	esi, esp
	mov	ecx, DWORD PTR _szForceRemove
	push	ecx
	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L90759
	cmp	DWORD PTR _bTokenDelete$90757[ebp], 0
	je	$L90758
$L90759:

; 1173 : 		{
; 1174 : 			if (FAILED(hr = NextToken(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90761

; 1175 : 				break;

	jmp	$L90756
$L90761:

; 1176 : 
; 1177 : 			if (bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	$L90758

; 1178 : 			{
; 1179 : 				CRegKey rkForceRemove;

	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1180 : 
; 1181 : 				if (StrChr(szToken, chDirSep) != NULL)

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	call	?StrChrA@CRegParser@ATL@@KAPADPADD@Z	; ATL::CRegParser::StrChrA
	add	esp, 8
	test	eax, eax
	je	SHORT $L90764

; 1182 : 					return GenerateError(E_ATL_COMPOUND_KEY);

	push	529					; 00000211H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR $T212162[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212162[ebp]
	jmp	$L90741
$L90764:

; 1183 : 
; 1184 : 				if (CanForceRemoveKey(szToken))

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ; ATL::CRegParser::CanForceRemoveKey
	test	eax, eax
	je	SHORT $L90766

; 1185 : 				{
; 1186 : 					rkForceRemove.Attach(hkParent);

	mov	eax, DWORD PTR _hkParent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z	; ATL::CRegKey::Attach

; 1187 : 					// Error not returned. We will overwrite the values any way.
; 1188 : 					rkForceRemove.RecurseDeleteKey(szToken);

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey

; 1189 : 					rkForceRemove.Detach();

	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ	; ATL::CRegKey::Detach
$L90766:

; 1190 : 				}
; 1191 : 				if (bTokenDelete)

	cmp	DWORD PTR _bTokenDelete$90757[ebp], 0
	je	SHORT $L90767

; 1192 : 				{
; 1193 : 					if (FAILED(hr = NextToken(szToken)))

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90769

; 1194 : 						break;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	jmp	$L90756
$L90769:

; 1195 : 					if (FAILED(hr = SkipAssignment(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90773

; 1196 : 						break;

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	jmp	$L90756
$L90773:

; 1387 : 		}
; 1388 : 
; 1389 : EndCheck:

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey

; 1197 : 					goto EndCheck;

	jmp	$EndCheck$90772
$L90767:

; 1198 : 				}
; 1199 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$L90758:

; 1200 : 
; 1201 : 		}
; 1202 : 
; 1203 : 		if (!lstrcmpi(szToken, szNoRemove))

	mov	esi, esp
	mov	ecx, DWORD PTR _szNoRemove
	push	ecx
	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L90774

; 1204 : 		{
; 1205 : 			bDelete = FALSE;    // set even for register

	mov	DWORD PTR _bDelete$[ebp], 0

; 1206 : 			if (FAILED(hr = NextToken(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90774

; 1207 : 				break;

	jmp	$L90756
$L90774:

; 1208 : 		}
; 1209 : 
; 1210 : 		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent

	mov	esi, esp
	mov	ecx, DWORD PTR _szValToken
	push	ecx
	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	$L90777

; 1211 : 		{
; 1212 : 			TCHAR  szValueName[_MAX_PATH];
; 1213 : 
; 1214 : 			if (FAILED(hr = NextToken(szValueName)))

	lea	eax, DWORD PTR _szValueName$90778[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90780

; 1215 : 				break;

	jmp	$L90756
$L90780:

; 1216 : 			if (FAILED(hr = NextToken(szToken)))

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90782

; 1217 : 				break;

	jmp	$L90756
$L90782:

; 1218 : 
; 1219 : 
; 1220 : 			if (*szToken != chEquals)

	mov	edx, DWORD PTR _szToken$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $L90783

; 1221 : 				return GenerateError(E_ATL_EXPECTING_EQUAL);

	push	518					; 00000206H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR $T212163[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212163[ebp]
	jmp	$L90741
$L90783:

; 1222 : 
; 1223 : 			if (bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	$L90785

; 1224 : 			{
; 1225 : 				CRegKey rk;

	lea	ecx, DWORD PTR _rk$90786[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1226 : 
; 1227 : 				rk.Attach(hkParent);

	mov	ecx, DWORD PTR _hkParent$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _rk$90786[ebp]
	call	?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z	; ATL::CRegKey::Attach

; 1228 : 				hr = AddValue(rk, szValueName, szToken);

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	lea	eax, DWORD PTR _szValueName$90778[ebp]
	push	eax
	lea	ecx, DWORD PTR _rk$90786[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
	mov	DWORD PTR _hr$[ebp], eax

; 1229 : 				rk.Detach();

	lea	ecx, DWORD PTR _rk$90786[ebp]
	call	?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ	; ATL::CRegKey::Detach

; 1230 : 
; 1231 : 				if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90790

; 1232 : 					return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212164[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rk$90786[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212164[ebp]
	jmp	$L90741
$L90790:

; 1387 : 		}
; 1388 : 
; 1389 : EndCheck:

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _rk$90786[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey

; 1233 : 
; 1234 : 				goto EndCheck;

	jmp	$EndCheck$90772
$L90785:

; 1235 : 			}
; 1236 : 			else
; 1237 : 			{
; 1238 : 				if (!bRecover && bDelete)

	cmp	DWORD PTR _bRecover$[ebp], 0
	jne	$L90792
	cmp	DWORD PTR _bDelete$[ebp], 0
	je	$L90792

; 1239 : 				{
; 1240 : 					ATLTRACE(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);

	lea	eax, DWORD PTR _szValueName$90778[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0N@GKIPNAL@Deleting?5?$CFs?6?$AA@
	push	1
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1240					; 000004d8H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212165[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1241 : 					// We have to open the key for write to be able to delete.
; 1242 : 					CRegKey rkParent;

	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey

; 1243 : 					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);

	push	131078					; 00020006H
	push	0
	mov	ecx, DWORD PTR _hkParent$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$[ebp], eax

; 1244 : 					if (lRes == ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	jne	SHORT $L90796

; 1245 : 					{
; 1246 : 						lRes = rkParent.DeleteValue(szValueName);

	lea	edx, DWORD PTR _szValueName$90778[ebp]
	push	edx
	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	?DeleteValue@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::DeleteValue
	mov	DWORD PTR _lRes$[ebp], eax

; 1247 : 						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90797
	cmp	DWORD PTR _lRes$[ebp], 2
	je	SHORT $L90797

; 1248 : 						{
; 1249 : 							// Key not present is not an error
; 1250 : 							hr = AtlHresultFromWin32(lRes);

	mov	eax, DWORD PTR _lRes$[ebp]
	push	eax
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1251 : 							break;

	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	jmp	$L90756
$L90797:

; 1252 : 						}
; 1253 : 					}
; 1254 : 					else

	jmp	SHORT $L90798
$L90796:

; 1255 : 					{
; 1256 : 						hr = AtlHresultFromWin32(lRes);

	mov	ecx, DWORD PTR _lRes$[ebp]
	push	ecx
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1257 : 						break;

	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	jmp	$L90756
$L90798:

; 1258 : 					}
; 1259 : 				}

	lea	ecx, DWORD PTR _rkParent$90795[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$L90792:

; 1260 : 				if (FAILED(hr = SkipAssignment(szToken)))

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90800

; 1261 : 					break;

	jmp	$L90756
$L90800:

; 1262 : 				continue;  // can never have a subkey

	jmp	$L90755
$L90777:

; 1263 : 			}
; 1264 : 		}
; 1265 : 
; 1266 : 		if (StrChr(szToken, chDirSep) != NULL)

	push	92					; 0000005cH
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	?StrChrA@CRegParser@ATL@@KAPADPADD@Z	; ATL::CRegParser::StrChrA
	add	esp, 8
	test	eax, eax
	je	SHORT $L90801

; 1267 : 			return GenerateError(E_ATL_COMPOUND_KEY);

	push	529					; 00000211H
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	mov	DWORD PTR $T212166[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212166[ebp]
	jmp	$L90741
$L90801:

; 1268 : 
; 1269 : 		if (bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	$L90803

; 1270 : 		{
; 1271 : 			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);

	push	131103					; 0002001fH
	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hkParent$[ebp]
	push	edx
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$[ebp], eax

; 1272 : 			if (ERROR_SUCCESS != lRes)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	$L90804

; 1273 : 			{
; 1274 : 				// Failed all access try read only
; 1275 : 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

	push	131097					; 00020019H
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hkParent$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$[ebp], eax

; 1276 : 				if (ERROR_SUCCESS != lRes)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	$L90804

; 1277 : 				{
; 1278 : 					// Finally try creating it
; 1279 : 					ATLTRACE(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@POOIJOEN@Creating?5key?5?$CFs?6?$AA@
	push	2
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1279					; 000004ffH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212167[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1280 : 					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);

	push	0
	push	0
	push	131103					; 0002001fH
	push	0
	push	0
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hkParent$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ; ATL::CRegKey::Create
	mov	DWORD PTR _lRes$[ebp], eax

; 1281 : 					if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90804

; 1282 : 						return AtlHresultFromWin32(lRes);

	mov	edx, DWORD PTR _lRes$[ebp]
	push	edx
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR $T212168[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212168[ebp]
	jmp	$L90741
$L90804:

; 1283 : 				}
; 1284 : 			}
; 1285 : 
; 1286 : 			if (FAILED(hr = NextToken(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90811

; 1287 : 				break;

	jmp	$L90756
$L90811:

; 1288 : 
; 1289 : 
; 1290 : 			if (*szToken == chEquals)

	mov	ecx, DWORD PTR _szToken$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 61					; 0000003dH
	jne	SHORT $L90812

; 1291 : 			{
; 1292 : 				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _keyCur$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ; ATL::CRegParser::AddValue
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90812

; 1293 : 					break;

	jmp	$L90756
$L90812:

; 1294 : 			}
; 1295 : 		}
; 1296 : 		else

	jmp	$EndCheck$90772
$L90803:

; 1297 : 		{
; 1298 : 			if (!bRecover)

	cmp	DWORD PTR _bRecover$[ebp], 0
	jne	SHORT $L90816

; 1299 : 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

	push	131097					; 00020019H
	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	eax, DWORD PTR _hkParent$[ebp]
	push	eax
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$[ebp], eax

; 1300 : 			else

	jmp	SHORT $L90817
$L90816:

; 1301 : 				lRes = ERROR_FILE_NOT_FOUND;

	mov	DWORD PTR _lRes$[ebp], 2
$L90817:

; 1302 : 
; 1303 : 
; 1304 : 			// Open failed set recovery mode
; 1305 : 			if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90818

; 1306 : 				bRecover = true;

	mov	DWORD PTR _bRecover$[ebp], 1
$L90818:

; 1307 : 
; 1308 : 			// TRACE out Key open status and if in recovery mode
; 1309 : #ifdef _DEBUG
; 1310 : 			if (!bRecover)

	cmp	DWORD PTR _bRecover$[ebp], 0
	jne	SHORT $L90819

; 1311 : 				ATLTRACE(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0P@IONAJCEO@Opened?5Key?5?$CFs?6?$AA@
	push	1
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1311					; 0000051fH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212169[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1312 : 			else

	jmp	SHORT $L90822
$L90819:

; 1313 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CM@LEFFDKCG@Ignoring?5Open?5key?5on?5?$CFs?5?3?5In?5Rec@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1313					; 00000521H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212170[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H
$L90822:

; 1314 : #endif //_DEBUG
; 1315 : 
; 1316 : 			// Remember Subkey
; 1317 : 			lstrcpyn(szKey, szToken, _MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKey$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpynA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 1318 : 
; 1319 : 			if (FAILED(hr = NextToken(szToken)))

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90826

; 1320 : 				break;

	jmp	$L90756
$L90826:

; 1321 : 			if (FAILED(hr = SkipAssignment(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ; ATL::CRegParser::SkipAssignment
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90828

; 1322 : 				break;

	jmp	$L90756
$L90828:

; 1323 : 
; 1324 : 			if (*szToken == chLeftBracket)

	mov	ecx, DWORD PTR _szToken$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 123				; 0000007bH
	jne	SHORT $L90829

; 1325 : 			{
; 1326 : 				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);

	mov	eax, DWORD PTR _bRecover$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegister$[ebp]
	push	ecx
	mov	edx, DWORD PTR _keyCur$[ebp]
	push	edx
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
	mov	DWORD PTR _hr$[ebp], eax

; 1327 : 				// In recover mode ignore error
; 1328 : 				if (FAILED(hr) && !bRecover)

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90831
	cmp	DWORD PTR _bRecover$[ebp], 0
	jne	SHORT $L90831

; 1329 : 					break;

	jmp	$L90756
$L90831:

; 1330 : 				// Skip the }
; 1331 : 				if (FAILED(hr = NextToken(szToken)))

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90829

; 1332 : 					break;

	jmp	$L90756
$L90829:

; 1333 : 			}
; 1334 : 
; 1335 : #ifdef _DEBUG
; 1336 : 			if (bRecover != bInRecovery)

	mov	edx, DWORD PTR _bRecover$[ebp]
	cmp	edx, DWORD PTR _bInRecovery$[ebp]
	je	SHORT $L90834

; 1337 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));

	push	OFFSET FLAT:??_C@_0BG@OEFMOOAA@Ending?5Recovery?5Mode?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1337					; 00000539H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212171[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H
$L90834:

; 1338 : #endif
; 1339 : 			bRecover = bInRecovery;

	mov	eax, DWORD PTR _bInRecovery$[ebp]
	mov	DWORD PTR _bRecover$[ebp], eax

; 1340 : 
; 1341 : 			if (lRes == ERROR_FILE_NOT_FOUND)

	cmp	DWORD PTR _lRes$[ebp], 2
	jne	SHORT $L90837

; 1342 : 				// Key already not present so not an error.
; 1343 : 				continue;

	jmp	$L90755
$L90837:

; 1344 : 
; 1345 : 			if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90838

; 1346 : 			{
; 1347 : 				// We are recovery mode continue on errors else break
; 1348 : 				if (bRecover)

	cmp	DWORD PTR _bRecover$[ebp], 0
	je	SHORT $L90839

; 1349 : 					continue;

	jmp	$L90755
$L90839:

; 1350 : 				else
; 1351 : 				{
; 1352 : 					hr = AtlHresultFromWin32(lRes);

	mov	ecx, DWORD PTR _lRes$[ebp]
	push	ecx
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1353 : 					break;

	jmp	$L90756
$L90838:

; 1354 : 				}
; 1355 : 			}
; 1356 : 
; 1357 : 			// If in recovery mode
; 1358 : 			if (bRecover && HasSubKeys(keyCur))

	cmp	DWORD PTR _bRecover$[ebp], 0
	je	SHORT $L90841
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys
	test	eax, eax
	je	SHORT $L90841

; 1359 : 			{
; 1360 : 				// See if the KEY is in the NeverDelete list and if so, don't
; 1361 : 				if (CanForceRemoveKey(szKey) && bDelete)

	lea	edx, DWORD PTR _szKey$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ; ATL::CRegParser::CanForceRemoveKey
	test	eax, eax
	je	SHORT $L90842
	cmp	DWORD PTR _bDelete$[ebp], 0
	je	SHORT $L90842

; 1362 : 				{
; 1363 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);

	lea	eax, DWORD PTR _szKey$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CH@OEJDLABI@Deleting?5non?9empty?5subkey?5?$CFs?5by?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1363					; 00000553H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212172[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1364 : 					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
; 1365 : 					keyCur.RecurseDeleteKey(szKey);

	lea	ecx, DWORD PTR _szKey$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey
$L90842:

; 1366 : 				}
; 1367 : 				continue;

	jmp	$L90755
$L90841:

; 1368 : 			}
; 1369 : 
; 1370 : 			lRes = keyCur.Close();

	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close
	mov	DWORD PTR _lRes$[ebp], eax

; 1371 : 			if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90845

; 1372 : 			   return AtlHresultFromWin32(lRes);

	mov	edx, DWORD PTR _lRes$[ebp]
	push	edx
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR $T212173[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212173[ebp]
	jmp	$L90741
$L90845:

; 1373 : 
; 1374 : 			if (bDelete)

	cmp	DWORD PTR _bDelete$[ebp], 0
	je	$EndCheck$90772

; 1375 : 			{
; 1376 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);

	lea	eax, DWORD PTR _szKey$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BB@FDAMNOMP@Deleting?5Key?5?$CFs?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	1376					; 00000560H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212174[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 1377 : 				CRegKey rkParent;

	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey

; 1378 : 				rkParent.Attach(hkParent);

	mov	ecx, DWORD PTR _hkParent$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z	; ATL::CRegKey::Attach

; 1379 : 				lRes = rkParent.DeleteSubKey(szKey);

	lea	edx, DWORD PTR _szKey$[ebp]
	push	edx
	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::DeleteSubKey
	mov	DWORD PTR _lRes$[ebp], eax

; 1380 : 				rkParent.Detach();

	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ	; ATL::CRegKey::Detach

; 1381 : 				if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90851

; 1382 : 				{
; 1383 : 					hr = AtlHresultFromWin32(lRes);

	mov	eax, DWORD PTR _lRes$[ebp]
	push	eax
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	mov	DWORD PTR _hr$[ebp], eax

; 1384 : 					break;

	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	jmp	SHORT $L90756
$L90851:

; 1385 : 				}
; 1386 : 			}

	lea	ecx, DWORD PTR _rkParent$90850[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$EndCheck$90772:

; 1390 : 
; 1391 : 		if (bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	SHORT $L90852

; 1392 : 		{
; 1393 : 			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)

	mov	ecx, DWORD PTR _szToken$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 123				; 0000007bH
	jne	SHORT $L90852
	mov	esi, esp
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $L90852

; 1394 : 			{
; 1395 : 				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))

	push	0
	mov	ecx, DWORD PTR _bRegister$[ebp]
	push	ecx
	mov	edx, DWORD PTR _keyCur$[ebp]
	push	edx
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90855

; 1396 : 					break;

	jmp	SHORT $L90756
$L90855:

; 1397 : 				if (FAILED(hr = NextToken(szToken)))

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90852

; 1398 : 					break;

	jmp	SHORT $L90756
$L90852:

; 1399 : 			}
; 1400 : 		}
; 1401 : 	}

	jmp	$L90755
$L90756:

; 1402 : 
; 1403 : 	return hr;

	mov	edx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212175[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _keyCur$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212175[ebp]
$L90741:

; 1404 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212197
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 732				; 000002dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L212197:
	DD	7
	DD	$L212196
$L212196:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L212187
	DD	-300					; fffffed4H
	DD	260					; 00000104H
	DD	$L212188
	DD	-328					; fffffeb8H
	DD	4
	DD	$L212189
	DD	-596					; fffffdacH
	DD	260					; 00000104H
	DD	$L212190
	DD	-608					; fffffda0H
	DD	4
	DD	$L212191
	DD	-620					; fffffd94H
	DD	4
	DD	$L212192
	DD	-632					; fffffd88H
	DD	4
	DD	$L212193
$L212193:
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L212192:
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	116					; 00000074H
	DB	0
$L212191:
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	0
$L212190:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L212189:
	DB	114					; 00000072H
	DB	107					; 0000006bH
	DB	70					; 00000046H
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	111					; 0000006fH
	DB	118					; 00000076H
	DB	101					; 00000065H
	DB	0
$L212188:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$L212187:
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	67					; 00000043H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212176:
	lea	ecx, DWORD PTR _keyCur$[ebp]
	jmp	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$L212177:
	lea	ecx, DWORD PTR _rkForceRemove$90763[ebp]
	jmp	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$L212178:
	lea	ecx, DWORD PTR _rk$90786[ebp]
	jmp	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
__ehhandler$?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z:
	mov	eax, OFFSET FLAT:$T212182
	jmp	___CxxFrameHandler
text$x	ENDS
?RegisterSubkeys@CRegParser@ATL@@IAEJPADPAUHKEY__@@HH@Z ENDP ; ATL::CRegParser::RegisterSubkeys
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_nError$ = 8						; size = 4
?AtlHresultFromWin32@ATL@@YAJK@Z PROC NEAR		; ATL::AtlHresultFromWin32, COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 33   : 	return( HRESULT_FROM_WIN32( nError ) );

	cmp	DWORD PTR _nError$[ebp], 0
	jg	SHORT $L212203
	mov	eax, DWORD PTR _nError$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $L212204
$L212203:
	mov	ecx, DWORD PTR _nError$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv68[ebp], ecx
$L212204:
	mov	eax, DWORD PTR tv68[ebp]

; 34   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?AtlHresultFromWin32@ATL@@YAJK@Z ENDP			; ATL::AtlHresultFromWin32
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRegKey@ATL@@QAE@XZ PROC NEAR			; ATL::CRegKey::CRegKey, COMDAT
; _this$ = ecx

; 4788 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 4789 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CRegKey@ATL@@QAE@XZ ENDP				; ATL::CRegKey::CRegKey
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1CRegKey@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CRegKey@ATL@@QAE@XZ PROC NEAR			; ATL::CRegKey::~CRegKey, COMDAT
; _this$ = ecx

; 4803 : {Close();}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CRegKey@ATL@@QAE@XZ ENDP				; ATL::CRegKey::~CRegKey
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??BCRegKey@ATL@@QBEPAUHKEY__@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ PROC NEAR		; ATL::CRegKey::operator HKEY__ *, COMDAT
; _this$ = ecx

; 4814 : {return m_hKey;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	0
??BCRegKey@ATL@@QBEPAUHKEY__@@XZ ENDP			; ATL::CRegKey::operator HKEY__ *
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ
_TEXT	SEGMENT
_hKey$ = -8						; size = 4
_this$ = -4						; size = 4
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ PROC NEAR		; ATL::CRegKey::Detach, COMDAT
; _this$ = ecx

; 4817 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 4818 : 	HKEY hKey = m_hKey;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _hKey$[ebp], ecx

; 4819 : 	m_hKey = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 4820 : 	return hKey;

	mov	eax, DWORD PTR _hKey$[ebp]

; 4821 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Detach@CRegKey@ATL@@QAEPAUHKEY__@@XZ ENDP		; ATL::CRegKey::Detach
_TEXT	ENDS
PUBLIC	??_C@_0M@BNMKLGID@m_hKey?5?$DN?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0M@BNMKLGID@m_hKey?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0M@BNMKLGID@m_hKey?5?$DN?$DN?50?$AA@ DB 'm_hKey == 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hKey$ = 8						; size = 4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z PROC NEAR	; ATL::CRegKey::Attach, COMDAT
; _this$ = ecx

; 4824 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 4825 : 	ATLASSERT(m_hKey == NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L212215
	push	OFFSET FLAT:??_C@_0M@BNMKLGID@m_hKey?5?$DN?$DN?50?$AA@
	push	0
	push	4825					; 000012d9H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212215
	int	3
$L212215:

; 4826 : 	m_hKey = hKey;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _hKey$[ebp]
	mov	DWORD PTR [edx], eax

; 4827 : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Attach@CRegKey@ATL@@QAEXPAUHKEY__@@@Z ENDP		; ATL::CRegKey::Attach
_TEXT	ENDS
PUBLIC	??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@	; `string'
EXTRN	__imp__RegDeleteKeyA@8:NEAR
;	COMDAT ??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@ DB 'm_hKey != 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpszSubKey$ = 8					; size = 4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z PROC NEAR		; ATL::CRegKey::DeleteSubKey, COMDAT
; _this$ = ecx

; 4830 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 4831 : 	ATLASSERT(m_hKey != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212218
	push	OFFSET FLAT:??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
	push	0
	push	4831					; 000012dfH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212218
	int	3
$L212218:

; 4832 : 	return RegDeleteKey(m_hKey, lpszSubKey);

	mov	esi, esp
	mov	edx, DWORD PTR _lpszSubKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__RegDeleteKeyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4833 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteSubKey
_TEXT	ENDS
EXTRN	__imp__RegDeleteValueA@8:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?DeleteValue@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpszValue$ = 8						; size = 4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z PROC NEAR		; ATL::CRegKey::DeleteValue, COMDAT
; _this$ = ecx

; 4836 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 4837 : 	ATLASSERT(m_hKey != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212221
	push	OFFSET FLAT:??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
	push	0
	push	4837					; 000012e5H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212221
	int	3
$L212221:

; 4838 : 	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);

	mov	esi, esp
	mov	edx, DWORD PTR _lpszValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__RegDeleteValueA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 4839 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?DeleteValue@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::DeleteValue
_TEXT	ENDS
EXTRN	__imp__RegCloseKey@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT
_lRes$ = -8						; size = 4
_this$ = -4						; size = 4
?Close@CRegKey@ATL@@QAEJXZ PROC NEAR			; ATL::CRegKey::Close, COMDAT
; _this$ = ecx

; 4842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 4843 : 	LONG lRes = ERROR_SUCCESS;

	mov	DWORD PTR _lRes$[ebp], 0

; 4844 : 	if (m_hKey != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L89080

; 4845 : 	{
; 4846 : 		lRes = RegCloseKey(m_hKey);

	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__RegCloseKey@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$[ebp], eax

; 4847 : 		m_hKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L89080:

; 4848 : 	}
; 4849 : 	return lRes;

	mov	eax, DWORD PTR _lRes$[ebp]

; 4850 : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Close@CRegKey@ATL@@QAEJXZ ENDP				; ATL::CRegKey::Close
_TEXT	ENDS
PUBLIC	??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@	; `string'
EXTRN	__imp__RegCreateKeyExA@36:NEAR
;	COMDAT ??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@ DB 'hKeyParent != 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z
_TEXT	SEGMENT
_lRes$ = -32						; size = 4
_hKey$ = -24						; size = 4
_dw$ = -12						; size = 4
_this$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_lpszClass$ = 16					; size = 4
_dwOptions$ = 20					; size = 4
_samDesired$ = 24					; size = 4
_lpSecAttr$ = 28					; size = 4
_lpdwDisposition$ = 32					; size = 4
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z PROC NEAR ; ATL::CRegKey::Create, COMDAT
; _this$ = ecx

; 4883 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 4884 : 	ATLASSERT(hKeyParent != NULL);

	cmp	DWORD PTR _hKeyParent$[ebp], 0
	jne	SHORT $L212226
	push	OFFSET FLAT:??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@
	push	0
	push	4884					; 00001314H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212226
	int	3
$L212226:

; 4885 : 	DWORD dw;
; 4886 : 	HKEY hKey = NULL;

	mov	DWORD PTR _hKey$[ebp], 0

; 4887 : 	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
; 4888 : 		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);

	mov	esi, esp
	lea	ecx, DWORD PTR _dw$[ebp]
	push	ecx
	lea	edx, DWORD PTR _hKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSecAttr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _samDesired$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwOptions$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszClass$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpszKeyName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hKeyParent$[ebp]
	push	edx
	call	DWORD PTR __imp__RegCreateKeyExA@36
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$[ebp], eax

; 4889 : 	if (lpdwDisposition != NULL)

	cmp	DWORD PTR _lpdwDisposition$[ebp], 0
	je	SHORT $L89120

; 4890 : 		*lpdwDisposition = dw;

	mov	eax, DWORD PTR _lpdwDisposition$[ebp]
	mov	ecx, DWORD PTR _dw$[ebp]
	mov	DWORD PTR [eax], ecx
$L89120:

; 4891 : 	if (lRes == ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	jne	SHORT $L89121

; 4892 : 	{
; 4893 : 		lRes = Close();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close
	mov	DWORD PTR _lRes$[ebp], eax

; 4894 : 		m_hKey = hKey;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _hKey$[ebp]
	mov	DWORD PTR [edx], eax
$L89121:

; 4895 : 	}
; 4896 : 	return lRes;

	mov	eax, DWORD PTR _lRes$[ebp]

; 4897 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212230
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 32					; 00000020H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$L212230:
	DD	2
	DD	$L212229
$L212229:
	DD	-12					; fffffff4H
	DD	4
	DD	$L212227
	DD	-24					; ffffffe8H
	DD	4
	DD	$L212228
$L212228:
	DB	104					; 00000068H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$L212227:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	0
?Create@CRegKey@ATL@@QAEJPAUHKEY__@@PBDPADKKPAU_SECURITY_ATTRIBUTES@@PAK@Z ENDP ; ATL::CRegKey::Create
_TEXT	ENDS
PUBLIC	??_C@_0L@LBABFFHO@lRes?5?$DN?$DN?50L?$AA@	; `string'
EXTRN	__imp__RegOpenKeyExA@20:NEAR
;	COMDAT ??_C@_0L@LBABFFHO@lRes?5?$DN?$DN?50L?$AA@
CONST	SEGMENT
??_C@_0L@LBABFFHO@lRes?5?$DN?$DN?50L?$AA@ DB 'lRes == 0L', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z
_TEXT	SEGMENT
_lRes$ = -20						; size = 4
_hKey$ = -12						; size = 4
_this$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_samDesired$ = 16					; size = 4
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z PROC NEAR	; ATL::CRegKey::Open, COMDAT
; _this$ = ecx

; 4900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 4901 : 	ATLASSERT(hKeyParent != NULL);

	cmp	DWORD PTR _hKeyParent$[ebp], 0
	jne	SHORT $L212233
	push	OFFSET FLAT:??_C@_0BA@PCGOHLCP@hKeyParent?5?$CB?$DN?50?$AA@
	push	0
	push	4901					; 00001325H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212233
	int	3
$L212233:

; 4902 : 	HKEY hKey = NULL;

	mov	DWORD PTR _hKey$[ebp], 0

; 4903 : 	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

	mov	esi, esp
	lea	ecx, DWORD PTR _hKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _samDesired$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpszKeyName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hKeyParent$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegOpenKeyExA@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$[ebp], eax

; 4904 : 	if (lRes == ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	jne	SHORT $L89131

; 4905 : 	{
; 4906 : 		lRes = Close();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close
	mov	DWORD PTR _lRes$[ebp], eax

; 4907 : 		ATLASSERT(lRes == ERROR_SUCCESS);

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L212234
	push	OFFSET FLAT:??_C@_0L@LBABFFHO@lRes?5?$DN?$DN?50L?$AA@
	push	0
	push	4907					; 0000132bH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212234
	int	3
$L212234:

; 4908 : 		m_hKey = hKey;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hKey$[ebp]
	mov	DWORD PTR [eax], ecx
$L89131:

; 4909 : 	}
; 4910 : 	return lRes;

	mov	eax, DWORD PTR _lRes$[ebp]

; 4911 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212237
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 20					; 00000014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L212237:
	DD	1
	DD	$L212236
$L212236:
	DD	-12					; fffffff4H
	DD	4
	DD	$L212235
$L212235:
	DB	104					; 00000068H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ENDP		; ATL::CRegKey::Open
_TEXT	ENDS
PUBLIC	??_C@_0DP@JOHDIOJH@CRegKey?3?3RecurseDeleteKey?5?3?5Fail@ ; `string'
EXTRN	?atlTraceCOM@ATL@@3VCTraceCategory@1@A:DWORD	; ATL::atlTraceCOM
EXTRN	__imp__RegEnumKeyExA@32:NEAR
;	COMDAT ??_C@_0DP@JOHDIOJH@CRegKey?3?3RecurseDeleteKey?5?3?5Fail@
CONST	SEGMENT
??_C@_0DP@JOHDIOJH@CRegKey?3?3RecurseDeleteKey?5?3?5Fail@ DB 'CRegKey::Re'
	DB	'curseDeleteKey : Failed to Open Key %s(Error = %d)', 0aH, 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z
_TEXT	SEGMENT
$T212244 = -336						; size = 4
$T212243 = -332						; size = 4
$T212242 = -328						; size = 4
$T212241 = -324						; size = 8
_szBuffer$ = -312					; size = 256
_dwSize$ = -48						; size = 4
_time$ = -36						; size = 8
_lRes$ = -24						; size = 4
_key$ = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpszKey$ = 8						; size = 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z PROC NEAR	; ATL::CRegKey::RecurseDeleteKey, COMDAT
; _this$ = ecx

; 5246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 336				; 00000150H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-336]
	mov	ecx, 84					; 00000054H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 5247 : 	CRegKey key;

	lea	ecx, DWORD PTR _key$[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey

; 5248 : 	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);

	push	131103					; 0002001fH
	mov	eax, DWORD PTR _lpszKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _key$[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$[ebp], eax

; 5249 : 	if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L89450

; 5250 : 	{
; 5251 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)

	cmp	DWORD PTR _lRes$[ebp], 2
	je	SHORT $L89451
	cmp	DWORD PTR _lRes$[ebp], 3
	je	SHORT $L89451

; 5252 : 		{
; 5253 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %s(Error = %d)\n"), lpszKey, lRes);

	mov	eax, DWORD PTR _lRes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszKey$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DP@JOHDIOJH@CRegKey?3?3RecurseDeleteKey?5?3?5Fail@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	5253					; 00001485H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212241[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 24					; 00000018H
$L89451:

; 5254 : 		}
; 5255 : 		return lRes;

	mov	edx, DWORD PTR _lRes$[ebp]
	mov	DWORD PTR $T212242[ebp], edx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212242[ebp]
	jmp	$L89447
$L89450:

; 5256 : 	}
; 5257 : 	FILETIME time;
; 5258 : 	DWORD dwSize = 256;

	mov	DWORD PTR _dwSize$[ebp], 256		; 00000100H
$L89459:

; 5259 : 	TCHAR szBuffer[256];
; 5260 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 5261 : 		&time)==ERROR_SUCCESS)

	mov	esi, esp
	lea	eax, DWORD PTR _time$[ebp]
	push	eax
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _dwSize$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	call	DWORD PTR __imp__RegEnumKeyExA@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L89460

; 5262 : 	{
; 5263 : 		lRes = key.RecurseDeleteKey(szBuffer);

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _key$[ebp]
	call	?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ; ATL::CRegKey::RecurseDeleteKey
	mov	DWORD PTR _lRes$[ebp], eax

; 5264 : 		if (lRes != ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L89461

; 5265 : 			return lRes;

	mov	edx, DWORD PTR _lRes$[ebp]
	mov	DWORD PTR $T212243[ebp], edx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212243[ebp]
	jmp	SHORT $L89447
$L89461:

; 5266 : 		dwSize = 256;

	mov	DWORD PTR _dwSize$[ebp], 256		; 00000100H

; 5267 : 	}

	jmp	SHORT $L89459
$L89460:

; 5268 : 	key.Close();

	lea	ecx, DWORD PTR _key$[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close

; 5269 : 	return DeleteSubKey(lpszKey);

	mov	eax, DWORD PTR _lpszKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::DeleteSubKey
	mov	DWORD PTR $T212244[ebp], eax
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	mov	eax, DWORD PTR $T212244[ebp]
$L89447:

; 5270 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212251
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 336				; 00000150H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L212251:
	DD	4
	DD	$L212250
$L212250:
	DD	-16					; fffffff0H
	DD	4
	DD	$L212245
	DD	-36					; ffffffdcH
	DD	8
	DD	$L212246
	DD	-48					; ffffffd0H
	DD	4
	DD	$L212247
	DD	-312					; fffffec8H
	DD	256					; 00000100H
	DD	$L212248
$L212248:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	66					; 00000042H
	DB	117					; 00000075H
	DB	102					; 00000066H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212247:
	DB	100					; 00000064H
	DB	119					; 00000077H
	DB	83					; 00000053H
	DB	105					; 00000069H
	DB	122					; 0000007aH
	DB	101					; 00000065H
	DB	0
$L212246:
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L212245:
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
?RecurseDeleteKey@CRegKey@ATL@@QAEJPBD@Z ENDP		; ATL::CRegKey::RecurseDeleteKey
_TEXT	ENDS
PUBLIC	??_C@_0BH@IHOFLOMJ@?$CFs?5Type?5not?5supported?6?$AA@ ; `string'
PUBLIC	??_C@_07DLHCIBDH@default?$AA@			; `string'
PUBLIC	??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@ ; `string'
PUBLIC	??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
PUBLIC	?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
PUBLIC	??_C@_0BI@NDCHGJG@Setting?5Value?5?$CFd?5at?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@BAKOHBFP@Binary?5Data?5does?5not?5fall?5on?5BYT@ ; `string'
PUBLIC	??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
PUBLIC	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
PUBLIC	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
PUBLIC	?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
PUBLIC	?ChToByte@CRegParser@ATL@@KAED@Z		; ATL::CRegParser::ChToByte
PUBLIC	?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z	; ATL::CRegParser::VTFromRegType
PUBLIC	?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z		; ATL::CRegKey::SetDWORDValue
PUBLIC	?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z	; ATL::CRegKey::SetStringValue
PUBLIC	?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z	; ATL::CRegKey::SetMultiStringValue
EXTRN	__imp__VarUI4FromStr@16:NEAR
EXTRN	__imp__IsDBCSLeadByte@4:NEAR
EXTRN	_memset:NEAR
EXTRN	__imp__RegSetValueExA@24:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
xdata$x	SEGMENT
$T212292 DD	0ffffffffH
	DD	FLAT:$L212277
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L212278
	DD	0ffffffffH
	DD	FLAT:$L212279
	DD	04H
	DD	00H
	DD	04H
	DD	00H
$T212294 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212274
$T212295 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212276
$T212293 DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T212294
	DD	05H
	DD	05H
	DD	06H
	DD	01H
	DD	FLAT:$T212295
$T212281 DD	019930520H
	DD	07H
	DD	FLAT:$T212292
	DD	02H
	DD	FLAT:$T212293
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BH@IHOFLOMJ@?$CFs?5Type?5not?5supported?6?$AA@
CONST	SEGMENT
??_C@_0BH@IHOFLOMJ@?$CFs?5Type?5not?5supported?6?$AA@ DB '%s Type not sup'
	DB	'ported', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT
??_C@_07DLHCIBDH@default?$AA@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@ DB 'Setting Va'
	DB	'lue %s at %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDCHGJG@Setting?5Value?5?$CFd?5at?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BI@NDCHGJG@Setting?5Value?5?$CFd?5at?5?$CFs?6?$AA@ DB 'Setting Val'
	DB	'ue %d at %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BAKOHBFP@Binary?5Data?5does?5not?5fall?5on?5BYT@
CONST	SEGMENT
??_C@_0CN@BAKOHBFP@Binary?5Data?5does?5not?5fall?5on?5BYT@ DB 'Binary Dat'
	DB	'a does not fall on BYTE boundries', 0aH, 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
_TEXT	SEGMENT
tv323 = -4840						; size = 4
tv241 = -4836						; size = 4
tv223 = -4832						; size = 4
tv216 = -4828						; size = 4
tv225 = -4824						; size = 4
tv150 = -4820						; size = 4
tv136 = -4816						; size = 4
tv92 = -4812						; size = 4
$T212271 = -4808					; size = 4
$T212270 = -4804					; size = 8
$T212267 = -4796					; size = 8
$T212266 = -4788					; size = 4
$T212259 = -4784					; size = 8
$T212256 = -4776					; size = 8
$T212255 = -4768					; size = 8
_irg$90596 = -4760					; size = 4
_rgBinary$90591 = -4752					; size = 260
_cbValDiv2$90557 = -4488				; size = 4
_cbValue$90552 = -4484					; size = 4
_lpszV$90540 = -4480					; size = 4
__AtlSafeAllocaManager$90539 = -4472			; size = 4
__lpa_ex$90538 = -4464					; size = 4
__lpw_ex$90537 = -4460					; size = 4
__acp_ex$90536 = -4456					; size = 4
__convert_ex$90535 = -4452				; size = 4
_ulVal$90534 = -4444					; size = 4
_r$90528 = -4436					; size = 4
_q$90524 = -4432					; size = 4
_p$90523 = -4428					; size = 4
_pszDestValue$90520 = -4420				; size = 260
_nLen$90486 = -4156					; size = 4
_nIDRes$ = -4152					; size = 4
_lRes$ = -4148						; size = 4
_vt$ = -4140						; size = 2
_szValue$ = -4128					; size = 4096
_hr$ = -28						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_rkParent$ = 8						; size = 4
_szValueName$ = 12					; size = 4
_szToken$ = 16						; size = 4
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z PROC NEAR ; ATL::CRegParser::AddValue, COMDAT
; _this$ = ecx

; 819  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	eax, 4824				; 000012d8H
	call	__chkstk
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-4840]
	mov	ecx, 1206				; 000004b6H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 	HRESULT hr;
; 821  : 
; 822  : 	TCHAR		szValue[MAX_VALUE];
; 823  : 	VARTYPE     vt = VT_EMPTY;

	mov	WORD PTR _vt$[ebp], 0

; 824  : 	LONG        lRes = ERROR_SUCCESS;

	mov	DWORD PTR _lRes$[ebp], 0

; 825  : 	UINT        nIDRes = 0;

	mov	DWORD PTR _nIDRes$[ebp], 0

; 826  : 
; 827  : 	if (FAILED(hr = NextToken(szValue)))

	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90470

; 828  : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L90463
$L90470:

; 829  : 	if (!VTFromRegType(szValue, vt))

	lea	ecx, DWORD PTR _vt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szValue$[ebp]
	push	edx
	call	?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ; ATL::CRegParser::VTFromRegType
	add	esp, 8
	test	eax, eax
	jne	SHORT $L90471

; 830  : 	{
; 831  : 		ATLTRACE(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szValue);

	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BH@IHOFLOMJ@?$CFs?5Type?5not?5supported?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	831					; 0000033fH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212255[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 832  : 		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);

	push	527					; 0000020fH
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GenerateError@CRegParser@ATL@@IAEJI@Z	; ATL::CRegParser::GenerateError
	jmp	$L90463
$L90471:

; 833  : 	}
; 834  : 
; 835  : 	SkipWhiteSpace();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ	; ATL::CRegParser::SkipWhiteSpace

; 836  : 	if (FAILED(hr = NextToken(szValue)))

	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90475

; 837  : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	$L90463
$L90475:

; 838  : 
; 839  : 	switch (vt)

	movzx	edx, WORD PTR _vt$[ebp]
	mov	DWORD PTR tv92[ebp], edx
	cmp	DWORD PTR tv92[ebp], 19			; 00000013H
	jg	SHORT $L212272
	cmp	DWORD PTR tv92[ebp], 19			; 00000013H
	je	$L90533
	cmp	DWORD PTR tv92[ebp], 8
	je	SHORT $L90480
	cmp	DWORD PTR tv92[ebp], 17			; 00000011H
	je	$L90551
	jmp	$L90477
$L212272:
	cmp	DWORD PTR tv92[ebp], 16392		; 00004008H
	je	SHORT $L90484
	jmp	$L90477
$L90480:

; 840  : 	{
; 841  : 	case VT_BSTR:
; 842  : 		{
; 843  : 			lRes = rkParent.SetStringValue(szValueName, szValue);

	push	1
	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szValueName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rkParent$[ebp]
	call	?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ; ATL::CRegKey::SetStringValue
	mov	DWORD PTR _lRes$[ebp], eax

; 844  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);

	cmp	DWORD PTR _szValueName$[ebp], 0
	jne	SHORT $L212257
	mov	DWORD PTR tv136[ebp], OFFSET FLAT:??_C@_07DLHCIBDH@default?$AA@
	jmp	SHORT $L212258
$L212257:
	mov	edx, DWORD PTR _szValueName$[ebp]
	mov	DWORD PTR tv136[ebp], edx
$L212258:
	mov	eax, DWORD PTR tv136[ebp]
	push	eax
	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@
	push	2
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	844					; 0000034cH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212256[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 24					; 00000018H

; 845  : 			break;

	jmp	$L90477
$L90484:

; 846  : 		}
; 847  : 	case VT_BSTR | VT_BYREF:
; 848  : 		{
; 849  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);

	cmp	DWORD PTR _szValueName$[ebp], 0
	jne	SHORT $L212260
	mov	DWORD PTR tv150[ebp], OFFSET FLAT:??_C@_07DLHCIBDH@default?$AA@
	jmp	SHORT $L212261
$L212260:
	mov	edx, DWORD PTR _szValueName$[ebp]
	mov	DWORD PTR tv150[ebp], edx
$L212261:
	mov	eax, DWORD PTR tv150[ebp]
	push	eax
	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BI@MFJDFJCO@Setting?5Value?5?$CFs?5at?5?$CFs?6?$AA@
	push	2
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	849					; 00000351H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212259[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 24					; 00000018H

; 850  : 			int nLen = lstrlen(szValue) + 1;

	mov	esi, esp
	lea	edx, DWORD PTR _szValue$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLen$90486[ebp], eax

; 851  : 			CTempBuffer<TCHAR, 256> pszDestValue;

	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 852  : 			ATLTRY(pszDestValue.Allocate(nLen));

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	eax, DWORD PTR _nLen$90486[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
	jmp	SHORT $L212273
$L212274:
	mov	eax, $L212273
	ret	0
$L212273:
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 853  : 			if (pszDestValue != NULL)

	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
	test	eax, eax
	je	$L90522

; 854  : 			{
; 855  : 				TCHAR* p = pszDestValue;

	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
	mov	DWORD PTR _p$90523[ebp], eax

; 856  : 				TCHAR* q = szValue;

	lea	ecx, DWORD PTR _szValue$[ebp]
	mov	DWORD PTR _q$90524[ebp], ecx

; 857  : 				nLen = 0;

	mov	DWORD PTR _nLen$90486[ebp], 0
$L90526:

; 858  : 				while (*q != NULL)

	mov	edx, DWORD PTR _q$90524[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$L90527

; 859  : 				{
; 860  : 					TCHAR* r = CharNext(q);

	mov	esi, esp
	mov	ecx, DWORD PTR _q$90524[ebp]
	push	ecx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _r$90528[ebp], eax

; 861  : 					if (*q == '\\' && *r == '0')

	mov	edx, DWORD PTR _q$90524[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $L90529
	mov	ecx, DWORD PTR _r$90528[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jne	SHORT $L90529

; 862  : 					{
; 863  : 						*p++ = NULL;

	mov	eax, DWORD PTR _p$90523[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _p$90523[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$90523[ebp], ecx

; 864  : 						q = CharNext(r);

	mov	esi, esp
	mov	edx, DWORD PTR _r$90528[ebp]
	push	edx
	call	DWORD PTR __imp__CharNextA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _q$90524[ebp], eax

; 865  : 					}
; 866  : 					else

	jmp	SHORT $L90530
$L90529:

; 867  : 					{
; 868  : 						*p = *q;

	mov	eax, DWORD PTR _p$90523[ebp]
	mov	ecx, DWORD PTR _q$90524[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 869  : #ifndef _UNICODE
; 870  : 						if (IsDBCSLeadByte(*q))

	mov	esi, esp
	mov	eax, DWORD PTR _q$90524[ebp]
	mov	cl, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__IsDBCSLeadByte@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L90531

; 871  : 						{
; 872  : 							p++;

	mov	edx, DWORD PTR _p$90523[ebp]
	add	edx, 1
	mov	DWORD PTR _p$90523[ebp], edx

; 873  : 							q++;

	mov	eax, DWORD PTR _q$90524[ebp]
	add	eax, 1
	mov	DWORD PTR _q$90524[ebp], eax

; 874  : 							*p = *q;

	mov	ecx, DWORD PTR _p$90523[ebp]
	mov	edx, DWORD PTR _q$90524[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
$L90531:

; 875  : 						}
; 876  : #endif
; 877  : 						p++;

	mov	ecx, DWORD PTR _p$90523[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$90523[ebp], ecx

; 878  : 						q++;

	mov	edx, DWORD PTR _q$90524[ebp]
	add	edx, 1
	mov	DWORD PTR _q$90524[ebp], edx
$L90530:

; 879  : 					}
; 880  : 					nLen ++;

	mov	eax, DWORD PTR _nLen$90486[ebp]
	add	eax, 1
	mov	DWORD PTR _nLen$90486[ebp], eax

; 881  : 				}

	jmp	$L90526
$L90527:

; 882  : 				*p = NULL;

	mov	ecx, DWORD PTR _p$90523[ebp]
	mov	BYTE PTR [ecx], 0

; 883  : 				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);

	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
	push	eax
	mov	edx, DWORD PTR _szValueName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _rkParent$[ebp]
	call	?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ; ATL::CRegKey::SetMultiStringValue
	mov	DWORD PTR _lRes$[ebp], eax

; 884  : 			}
; 885  : 			else

	jmp	SHORT $L90532
$L90522:

; 886  : 			{
; 887  : 				lRes = ERROR_OUTOFMEMORY;

	mov	DWORD PTR _lRes$[ebp], 14		; 0000000eH
$L90532:

; 888  : 			}
; 889  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	call	??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>

; 890  : 		break;

	jmp	$L90477
$L90533:

; 891  : 	case VT_UI4:
; 892  : 		{
; 893  : 			ULONG ulVal;
; 894  : 			USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$90535[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$90536[ebp], eax
	mov	DWORD PTR __lpw_ex$90537[ebp], 0
	mov	DWORD PTR __lpa_ex$90538[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$90539[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], 3

; 895  : 
; 896  : 			LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szValue$[ebp]
	mov	DWORD PTR __lpa_ex$90538[ebp], eax
	cmp	DWORD PTR __lpa_ex$90538[ebp], 0
	jne	SHORT $L212264
	mov	DWORD PTR tv225[ebp], 0
	jmp	$L212265
$L212264:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$90538[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$90535[ebp], eax
	mov	edx, DWORD PTR __convert_ex$90535[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L212262
	mov	eax, DWORD PTR __convert_ex$90535[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212262
	mov	eax, DWORD PTR __convert_ex$90535[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv216[ebp], esp
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, DWORD PTR tv216[ebp]
	mov	DWORD PTR tv223[ebp], edx
	jmp	SHORT $L212263
$L212262:
	mov	eax, DWORD PTR __convert_ex$90535[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$90539[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv223[ebp], eax
$L212263:
	mov	ecx, DWORD PTR __acp_ex$90536[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$90535[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$90538[ebp]
	push	eax
	mov	ecx, DWORD PTR tv223[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv225[ebp], eax
$L212265:
	mov	edx, DWORD PTR tv225[ebp]
	mov	DWORD PTR _lpszV$90540[ebp], edx

; 897  : 	#ifndef _UNICODE
; 898  : 			if(lpszV == NULL) 

	cmp	DWORD PTR _lpszV$90540[ebp], 0
	jne	SHORT $L90546

; 899  : 				return E_OUTOFMEMORY;

	mov	DWORD PTR $T212266[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$90539[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212266[ebp]
	jmp	$L90463
$L90546:

; 900  : 	#endif	
; 901  : 			VarUI4FromStr(lpszV, 0, 0, &ulVal);

	mov	esi, esp
	lea	eax, DWORD PTR _ulVal$90534[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpszV$90540[ebp]
	push	ecx
	call	DWORD PTR __imp__VarUI4FromStr@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 902  : 			
; 903  : 			lRes = rkParent.SetDWORDValue(szValueName, ulVal);

	mov	edx, DWORD PTR _ulVal$90534[ebp]
	push	edx
	mov	eax, DWORD PTR _szValueName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rkParent$[ebp]
	call	?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z	; ATL::CRegKey::SetDWORDValue
	mov	DWORD PTR _lRes$[ebp], eax

; 904  : 			ATLTRACE(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);

	cmp	DWORD PTR _szValueName$[ebp], 0
	jne	SHORT $L212268
	mov	DWORD PTR tv241[ebp], OFFSET FLAT:??_C@_07DLHCIBDH@default?$AA@
	jmp	SHORT $L212269
$L212268:
	mov	ecx, DWORD PTR _szValueName$[ebp]
	mov	DWORD PTR tv241[ebp], ecx
$L212269:
	mov	edx, DWORD PTR tv241[ebp]
	push	edx
	mov	eax, DWORD PTR _ulVal$90534[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BI@NDCHGJG@Setting?5Value?5?$CFd?5at?5?$CFs?6?$AA@
	push	2
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	904					; 00000388H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212267[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 24					; 00000018H

; 905  : 			break;

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$90539[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	jmp	$L90477
$L90551:

; 906  : 		}
; 907  : 	case VT_UI1:
; 908  : 		{
; 909  : 			int cbValue = lstrlen(szValue);

	mov	esi, esp
	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _cbValue$90552[ebp], eax

; 910  : 			if (cbValue & 0x00000001)

	mov	edx, DWORD PTR _cbValue$90552[ebp]
	and	edx, 1
	je	SHORT $L90553

; 911  : 			{
; 912  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));

	push	OFFSET FLAT:??_C@_0CN@BAKOHBFP@Binary?5Data?5does?5not?5fall?5on?5BYT@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	912					; 00000390H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212270[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 913  : 				return E_FAIL;

	mov	eax, -2147467259			; 80004005H
	jmp	$L90463
$L90553:

; 914  : 			}
; 915  : 			int cbValDiv2 = cbValue/2;

	mov	eax, DWORD PTR _cbValue$90552[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _cbValDiv2$90557[ebp], eax

; 916  : 			CTempBuffer<BYTE, 256> rgBinary;

	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 917  : 			ATLTRY(rgBinary.Allocate(cbValDiv2));			

	mov	BYTE PTR __$EHRec$[ebp+12], 5
	mov	eax, DWORD PTR _cbValDiv2$90557[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
	jmp	SHORT $L212275
$L212276:
	mov	eax, $L212275
	ret	0
$L212275:
	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 918  : 			if (rgBinary == NULL)

	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
	test	eax, eax
	jne	SHORT $L90593

; 919  : 				return E_FAIL;

	mov	DWORD PTR $T212271[ebp], -2147467259	; 80004005H
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212271[ebp]
	jmp	$L90463
$L90593:

; 920  : 			memset(rgBinary, 0, cbValDiv2);				

	mov	ecx, DWORD PTR _cbValDiv2$90557[ebp]
	push	ecx
	push	0
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 921  : 			for (int irg = 0; irg < cbValue; irg++)

	mov	DWORD PTR _irg$90596[ebp], 0
	jmp	SHORT $L90597
$L90598:
	mov	edx, DWORD PTR _irg$90596[ebp]
	add	edx, 1
	mov	DWORD PTR _irg$90596[ebp], edx
$L90597:
	mov	eax, DWORD PTR _irg$90596[ebp]
	cmp	eax, DWORD PTR _cbValue$90552[ebp]
	jge	SHORT $L90599

; 922  : 				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));

	mov	eax, DWORD PTR _irg$90596[ebp]
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
	add	eax, esi
	mov	DWORD PTR tv323[ebp], eax
	mov	ecx, DWORD PTR _irg$90596[ebp]
	and	ecx, 1
	mov	esi, 1
	sub	esi, ecx
	shl	esi, 2
	mov	edx, DWORD PTR _irg$90596[ebp]
	mov	al, BYTE PTR _szValue$[ebp+edx]
	push	eax
	call	?ChToByte@CRegParser@ATL@@KAED@Z	; ATL::CRegParser::ChToByte
	add	esp, 4
	movzx	edx, al
	mov	ecx, esi
	shl	edx, cl
	mov	eax, DWORD PTR tv323[ebp]
	movzx	ecx, BYTE PTR [eax]
	or	ecx, edx
	mov	edx, DWORD PTR tv323[ebp]
	mov	BYTE PTR [edx], cl
	jmp	$L90598
$L90599:

; 923  : 			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);

	mov	esi, esp
	mov	eax, DWORD PTR _cbValDiv2$90557[ebp]
	push	eax
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
	push	eax
	push	3
	push	0
	mov	ecx, DWORD PTR _szValueName$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _rkParent$[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$[ebp], eax

; 924  : 			break;

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	call	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
$L90477:

; 925  : 		}
; 926  : 	}
; 927  : 
; 928  : 	if (ERROR_SUCCESS != lRes)

	cmp	DWORD PTR _lRes$[ebp], 0
	je	SHORT $L90600

; 929  : 	{
; 930  : 		nIDRes = E_ATL_VALUE_SET_FAILED;

	mov	DWORD PTR _nIDRes$[ebp], 516		; 00000204H

; 931  : 		return AtlHresultFromWin32(lRes);

	mov	edx, DWORD PTR _lRes$[ebp]
	push	edx
	call	?AtlHresultFromWin32@ATL@@YAJK@Z	; ATL::AtlHresultFromWin32
	add	esp, 4
	jmp	SHORT $L90463
$L90600:

; 932  : 	}
; 933  : 
; 934  : 	if (FAILED(hr = NextToken(szToken)))

	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90602

; 935  : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $L90463
$L90602:

; 936  : 
; 937  : 	return S_OK;

	xor	eax, eax
$L90463:

; 938  : }

	lea	esp, DWORD PTR [ebp-4852]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212291
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L212291:
	DD	6
	DD	$L212290
$L212290:
	DD	-4128					; ffffefe0H
	DD	4096					; 00001000H
	DD	$L212282
	DD	-4140					; ffffefd4H
	DD	2
	DD	$L212283
	DD	-4420					; ffffeebcH
	DD	260					; 00000104H
	DD	$L212284
	DD	-4444					; ffffeea4H
	DD	4
	DD	$L212285
	DD	-4472					; ffffee88H
	DD	4
	DD	$L212286
	DD	-4752					; ffffed70H
	DD	260					; 00000104H
	DD	$L212287
$L212287:
	DB	114					; 00000072H
	DB	103					; 00000067H
	DB	66					; 00000042H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	121					; 00000079H
	DB	0
$L212286:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212285:
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	0
$L212284:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	101					; 00000065H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
$L212283:
	DB	118					; 00000076H
	DB	116					; 00000074H
	DB	0
$L212282:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212277:
	lea	ecx, DWORD PTR _pszDestValue$90520[ebp]
	jmp	??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
$L212278:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$90539[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L212279:
	lea	ecx, DWORD PTR _rgBinary$90591[ebp]
	jmp	??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
__ehhandler$?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z:
	mov	eax, OFFSET FLAT:$T212281
	jmp	___CxxFrameHandler
text$x	ENDS
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PBDPAD@Z ENDP ; ATL::CRegParser::AddValue
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszValueName$ = 8					; size = 4
_dwValue$ = 12						; size = 4
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z PROC NEAR	; ATL::CRegKey::SetDWORDValue, COMDAT
; _this$ = ecx

; 5167 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 5168 : 	ATLASSERT(m_hKey != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212300
	push	OFFSET FLAT:??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
	push	0
	push	5168					; 00001430H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212300
	int	3
$L212300:

; 5169 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));

	mov	esi, esp
	push	4
	lea	edx, DWORD PTR _dwValue$[ebp]
	push	edx
	push	4
	push	0
	mov	eax, DWORD PTR _pszValueName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5170 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetDWORDValue@CRegKey@ATL@@QAEJPBDK@Z ENDP		; ATL::CRegKey::SetDWORDValue
_TEXT	ENDS
PUBLIC	??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0CH@EEDIHPHE@?$CIdwType?5?$DN?$DN?5?$CI?51?5?$CJ?$CJ?5?$HM?$HM?5?$CIdwType?5?$DN?$DN?5@ ; `string'
;	COMDAT ??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@ DB 'pszValue != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@EEDIHPHE@?$CIdwType?5?$DN?$DN?5?$CI?51?5?$CJ?$CJ?5?$HM?$HM?5?$CIdwType?5?$DN?$DN?5@
CONST	SEGMENT
??_C@_0CH@EEDIHPHE@?$CIdwType?5?$DN?$DN?5?$CI?51?5?$CJ?$CJ?5?$HM?$HM?5?$CIdwType?5?$DN?$DN?5@ DB '('
	DB	'dwType == ( 1 )) || (dwType == ( 2 ))', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
_dwType$ = 16						; size = 4
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z PROC NEAR	; ATL::CRegKey::SetStringValue, COMDAT
; _this$ = ecx

; 5179 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 5180 : 	ATLASSERT(m_hKey != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212303
	push	OFFSET FLAT:??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
	push	0
	push	5180					; 0000143cH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212303
	int	3
$L212303:

; 5181 : 	ATLASSERT(pszValue != NULL);

	cmp	DWORD PTR _pszValue$[ebp], 0
	jne	SHORT $L212304
	push	OFFSET FLAT:??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@
	push	0
	push	5181					; 0000143dH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212304
	int	3
$L212304:

; 5182 : 	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));

	cmp	DWORD PTR _dwType$[ebp], 1
	je	SHORT $L212305
	cmp	DWORD PTR _dwType$[ebp], 2
	je	SHORT $L212305
	push	OFFSET FLAT:??_C@_0CH@EEDIHPHE@?$CIdwType?5?$DN?$DN?5?$CI?51?5?$CJ?$CJ?5?$HM?$HM?5?$CIdwType?5?$DN?$DN?5@
	push	0
	push	5182					; 0000143eH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212305
	int	3
$L212305:

; 5183 : 
; 5184 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, reinterpret_cast<const BYTE*>(pszValue), (lstrlen(pszValue)+1)*sizeof(TCHAR));

	mov	esi, esp
	mov	ecx, DWORD PTR _pszValue$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _pszValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwType$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pszValueName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5185 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetStringValue@CRegKey@ATL@@QAEJPBD0K@Z ENDP		; ATL::CRegKey::SetStringValue
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z
_TEXT	SEGMENT
_nLength$ = -16						; size = 4
_nBytes$ = -12						; size = 4
_pszTemp$ = -8						; size = 4
_this$ = -4						; size = 4
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z PROC NEAR	; ATL::CRegKey::SetMultiStringValue, COMDAT
; _this$ = ecx

; 5188 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 5189 : 	LPCTSTR pszTemp;
; 5190 : 	ULONG nBytes;
; 5191 : 	ULONG nLength;
; 5192 : 
; 5193 : 	ATLASSERT(m_hKey != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212308
	push	OFFSET FLAT:??_C@_0M@LINKMMAA@m_hKey?5?$CB?$DN?50?$AA@
	push	0
	push	5193					; 00001449H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212308
	int	3
$L212308:

; 5194 : 	ATLASSERT(pszValue != NULL);

	cmp	DWORD PTR _pszValue$[ebp], 0
	jne	SHORT $L212309
	push	OFFSET FLAT:??_C@_0O@DKGIOJGA@pszValue?5?$CB?$DN?50?$AA@
	push	0
	push	5194					; 0000144aH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212309
	int	3
$L212309:

; 5195 : 
; 5196 : 	// Find the total length (in bytes) of all of the strings, including the
; 5197 : 	// terminating '\0' of each string, and the second '\0' that terminates
; 5198 : 	// the list.
; 5199 : 	nBytes = 0;

	mov	DWORD PTR _nBytes$[ebp], 0

; 5200 : 	pszTemp = pszValue;

	mov	eax, DWORD PTR _pszValue$[ebp]
	mov	DWORD PTR _pszTemp$[ebp], eax
$L89403:

; 5201 : 	do
; 5202 : 	{
; 5203 : 		nLength = lstrlen(pszTemp)+1;

	mov	esi, esp
	mov	ecx, DWORD PTR _pszTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLength$[ebp], eax

; 5204 : 		pszTemp += nLength;

	mov	edx, DWORD PTR _pszTemp$[ebp]
	add	edx, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _pszTemp$[ebp], edx

; 5205 : 		nBytes += nLength*sizeof(TCHAR);

	mov	eax, DWORD PTR _nBytes$[ebp]
	add	eax, DWORD PTR _nLength$[ebp]
	mov	DWORD PTR _nBytes$[ebp], eax

; 5206 : 	} while (nLength != 1);

	cmp	DWORD PTR _nLength$[ebp], 1
	jne	SHORT $L89403

; 5207 : 
; 5208 : 	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),
; 5209 : 		nBytes);

	mov	esi, esp
	mov	ecx, DWORD PTR _nBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszValue$[ebp]
	push	edx
	push	7
	push	0
	mov	eax, DWORD PTR _pszValueName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__RegSetValueExA@24
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5210 : }

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?SetMultiStringValue@CRegKey@ATL@@QAEJPBD0@Z ENDP	; ATL::CRegKey::SetMultiStringValue
_TEXT	ENDS
PUBLIC	?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B ; `ATL::CRegParser::VTFromRegType'::`3'::map
PUBLIC	?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA ; `ATL::CRegParser::VTFromRegType'::`3'::$S4
;	COMDAT ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
_BSS	SEGMENT
?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B DQ 04H DUP (?) ; `ATL::CRegParser::VTFromRegType'::`3'::map
_BSS	ENDS
;	COMDAT ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA
_BSS	SEGMENT
?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA DD 01H DUP (?) ; `ATL::CRegParser::VTFromRegType'::`3'::$S4
; Function compile flags: /Odt /RTCsu
_BSS	ENDS
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z
_TEXT	SEGMENT
_i$90297 = -4						; size = 4
_szValueType$ = 8					; size = 4
_vt$ = 12						; size = 4
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z PROC NEAR	; ATL::CRegParser::VTFromRegType, COMDAT

; 618  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 619  : 	struct typemap
; 620  : 	{
; 621  : 		LPCTSTR lpsz;
; 622  : 		VARTYPE vt;
; 623  : 	};
; 624  : #pragma warning (push)
; 625  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 626  : 
; 627  : 	static const typemap map[] = {
; 628  : 		{szStringVal, VT_BSTR},

	mov	eax, DWORD PTR ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA
	and	eax, 1
	jne	SHORT $L90296
	mov	ecx, DWORD PTR ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S4@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4IA, ecx
	mov	edx, DWORD PTR _szStringVal
	mov	DWORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B, edx
	mov	WORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+4, 8

; 629  : 		{multiszStringVal, VT_BSTR | VT_BYREF},

	mov	eax, DWORD PTR _multiszStringVal
	mov	DWORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+8, eax
	mov	WORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+12, 16392 ; 00004008H

; 630  : 		{szDwordVal,  VT_UI4},

	mov	ecx, DWORD PTR _szDwordVal
	mov	DWORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+16, ecx
	mov	WORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+20, 19 ; 00000013H

; 631  : 		{szBinaryVal, VT_UI1}

	mov	edx, DWORD PTR _szBinaryVal
	mov	DWORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+24, edx
	mov	WORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B+28, 17 ; 00000011H
$L90296:

; 632  : 	};
; 633  : 
; 634  : #pragma warning (pop)
; 635  : 
; 636  : 	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)

	mov	DWORD PTR _i$90297[ebp], 0
	jmp	SHORT $L90299
$L90300:
	mov	eax, DWORD PTR _i$90297[ebp]
	add	eax, 1
	mov	DWORD PTR _i$90297[ebp], eax
$L90299:
	cmp	DWORD PTR _i$90297[ebp], 4
	jae	SHORT $L90301

; 637  : 	{
; 638  : 		if (!lstrcmpi(szValueType, map[i].lpsz))

	mov	esi, esp
	mov	ecx, DWORD PTR _i$90297[ebp]
	mov	edx, DWORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B[ecx*8]
	push	edx
	mov	eax, DWORD PTR _szValueType$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L90302

; 639  : 		{
; 640  : 			vt = map[i].vt;

	mov	ecx, DWORD PTR _vt$[ebp]
	mov	edx, DWORD PTR _i$90297[ebp]
	mov	ax, WORD PTR ?map@?2??VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z@4QBUtypemap@23@B[edx*8+4]
	mov	WORD PTR [ecx], ax

; 641  : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $L90282
$L90302:

; 642  : 		}
; 643  : 	}

	jmp	SHORT $L90300
$L90301:

; 644  : 
; 645  : 	return FALSE;

	xor	eax, eax
$L90282:

; 646  : 
; 647  : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?VTFromRegType@CRegParser@ATL@@KAHPBDAAG@Z ENDP		; ATL::CRegParser::VTFromRegType
_TEXT	ENDS
PUBLIC	??_C@_0CL@PILPOMLI@Bogus?5value?5?$CFc?5passed?5as?5binary?5@ ; `string'
;	COMDAT ??_C@_0CL@PILPOMLI@Bogus?5value?5?$CFc?5passed?5as?5binary?5@
CONST	SEGMENT
??_C@_0CL@PILPOMLI@Bogus?5value?5?$CFc?5passed?5as?5binary?5@ DB 'Bogus v'
	DB	'alue %c passed as binary Hex value', 0aH, 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?ChToByte@CRegParser@ATL@@KAED@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
$T212317 = -8						; size = 8
_ch$ = 8						; size = 1
?ChToByte@CRegParser@ATL@@KAED@Z PROC NEAR		; ATL::CRegParser::ChToByte, COMDAT

; 650  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 651  : 	switch (ch)

	movsx	eax, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 54			; 00000036H
	ja	SHORT $L90316
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $L212318[edx]
	jmp	DWORD PTR $L212319[eax*4]
$L90310:

; 652  : 	{
; 653  : 		case '0':
; 654  : 		case '1':
; 655  : 		case '2':
; 656  : 		case '3':
; 657  : 		case '4':
; 658  : 		case '5':
; 659  : 		case '6':
; 660  : 		case '7':
; 661  : 		case '8':
; 662  : 		case '9':
; 663  : 				return (BYTE) (ch - '0');

	movsx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 48					; 00000030H
	jmp	SHORT $L90305
$L90312:

; 664  : 		case 'A':
; 665  : 		case 'B':
; 666  : 		case 'C':
; 667  : 		case 'D':
; 668  : 		case 'E':
; 669  : 		case 'F':
; 670  : 				return (BYTE) (10 + (ch - 'A'));

	movsx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 55					; 00000037H
	jmp	SHORT $L90305
$L90314:

; 671  : 		case 'a':
; 672  : 		case 'b':
; 673  : 		case 'c':
; 674  : 		case 'd':
; 675  : 		case 'e':
; 676  : 		case 'f':
; 677  : 				return (BYTE) (10 + (ch - 'a'));

	movsx	eax, BYTE PTR _ch$[ebp]
	sub	eax, 87					; 00000057H
	jmp	SHORT $L90305
$L90316:

; 678  : 		default:
; 679  : 				ATLASSERT(FALSE);

	xor	ecx, ecx
	jne	SHORT $L212316
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	679					; 000002a7H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212316
	int	3
$L212316:

; 680  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);

	movsx	eax, BYTE PTR _ch$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CL@PILPOMLI@Bogus?5value?5?$CFc?5passed?5as?5binary?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	680					; 000002a8H
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212317[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 681  : 				return 0;

	xor	al, al
$L90305:

; 682  : 	}
; 683  : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$L212319:
	DD	$L90310
	DD	$L90312
	DD	$L90314
	DD	$L90316
$L212318:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
?ChToByte@CRegParser@ATL@@KAED@Z ENDP			; ATL::CRegParser::ChToByte
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z
_TEXT	SEGMENT
_iNoDel$90608 = -8					; size = 4
_this$ = -4						; size = 4
_szKey$ = 8						; size = 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z PROC NEAR	; ATL::CRegParser::CanForceRemoveKey, COMDAT
; _this$ = ecx

; 941  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 942  : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

	mov	DWORD PTR _iNoDel$90608[ebp], 0
	jmp	SHORT $L90609
$L90610:
	mov	eax, DWORD PTR _iNoDel$90608[ebp]
	add	eax, 1
	mov	DWORD PTR _iNoDel$90608[ebp], eax
$L90609:
	cmp	DWORD PTR _iNoDel$90608[ebp], 12	; 0000000cH
	jge	SHORT $L90611

; 943  : 		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))

	mov	esi, esp
	mov	ecx, DWORD PTR _iNoDel$90608[ebp]
	mov	edx, DWORD PTR ?rgszNeverDelete@CRegParser@ATL@@1QBQBDB[ecx*4]
	push	edx
	mov	eax, DWORD PTR _szKey$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L90612

; 944  : 			 return FALSE;                       // We cannot delete it

	xor	eax, eax
	jmp	SHORT $L90607
$L90612:

; 945  : 
; 946  : 	return TRUE;

	jmp	SHORT $L90610
$L90611:
	mov	eax, 1
$L90607:

; 947  : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPBD@Z ENDP	; ATL::CRegParser::CanForceRemoveKey
_TEXT	ENDS
PUBLIC	??_C@_0BG@OFKLEKA@Should?5not?5be?5here?$CB?$CB?6?$AA@ ; `string'
EXTRN	__imp__RegQueryInfoKeyA@48:NEAR
;	COMDAT ??_C@_0BG@OFKLEKA@Should?5not?5be?5here?$CB?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@OFKLEKA@Should?5not?5be?5here?$CB?$CB?6?$AA@ DB 'Should not be '
	DB	'here!!', 0aH, 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT
$T212324 = -24						; size = 8
_cbSubKeys$ = -12					; size = 4
_this$ = -4						; size = 4
_hkey$ = 8						; size = 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z PROC NEAR	; ATL::CRegParser::HasSubKeys, COMDAT
; _this$ = ecx

; 950  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 951  : 	DWORD       cbSubKeys = 0;

	mov	DWORD PTR _cbSubKeys$[ebp], 0

; 952  : 
; 953  : 	if (RegQueryInfoKey(hkey, NULL, NULL, NULL,
; 954  : 							   &cbSubKeys, NULL, NULL,
; 955  : 							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _cbSubKeys$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _hkey$[ebp]
	push	ecx
	call	DWORD PTR __imp__RegQueryInfoKeyA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $L90618

; 956  : 	{
; 957  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));

	push	OFFSET FLAT:??_C@_0BG@OFKLEKA@Should?5not?5be?5here?$CB?$CB?6?$AA@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceRegistrar@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceRegistrar
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	957					; 000003bdH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212324[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 958  : 		ATLASSERT(FALSE);

	xor	edx, edx
	jne	SHORT $L212325
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	958					; 000003beH
	push	OFFSET FLAT:??_C@_0FA@NNGGBFPH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212325
	int	3
$L212325:

; 959  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $L90616
$L90618:

; 960  : 	}
; 961  : 
; 962  : 	return cbSubKeys > 0;

	xor	ecx, ecx
	cmp	ecx, DWORD PTR _cbSubKeys$[ebp]
	sbb	eax, eax
	neg	eax
$L90616:

; 963  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212328
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 24					; 00000018H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L212328:
	DD	1
	DD	$L212327
$L212327:
	DD	-12					; fffffff4H
	DD	4
	DD	$L212326
$L212326:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	0
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ENDP	; ATL::CRegParser::HasSubKeys
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z
_TEXT	SEGMENT
_szValue$ = -4112					; size = 4096
_hr$ = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_szToken$ = 8						; size = 4
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z PROC NEAR	; ATL::CRegParser::SkipAssignment, COMDAT
; _this$ = ecx

; 994  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4116				; 00001014H
	call	__chkstk
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-4116]
	mov	ecx, 1029				; 00000405H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 	HRESULT hr;
; 996  : 	TCHAR szValue[MAX_VALUE];
; 997  : 
; 998  : 	if (*szToken == chEquals)

	mov	eax, DWORD PTR _szToken$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	jne	SHORT $L90642

; 999  : 	{
; 1000 : 		if (FAILED(hr = NextToken(szToken)))

	mov	edx, DWORD PTR _szToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90644

; 1001 : 			return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $L90639
$L90644:

; 1002 : 		// Skip assignment
; 1003 : 		SkipWhiteSpace();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ	; ATL::CRegParser::SkipWhiteSpace

; 1004 : 		if (FAILED(hr = NextToken(szValue)))

	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90646

; 1005 : 			return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $L90639
$L90646:

; 1006 : 		if (FAILED(hr = NextToken(szToken)))

	mov	ecx, DWORD PTR _szToken$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?NextToken@CRegParser@ATL@@IAEJPAD@Z	; ATL::CRegParser::NextToken
	mov	DWORD PTR _hr$[ebp], eax
	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90642

; 1007 : 			return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $L90639
$L90642:

; 1008 : 	}
; 1009 : 
; 1010 : 	return S_OK;

	xor	eax, eax
$L90639:

; 1011 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212335
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	add	esp, 4116				; 00001014H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L212335:
	DD	1
	DD	$L212334
$L212334:
	DD	-4112					; ffffeff0H
	DD	4096					; 00001000H
	DD	$L212332
$L212332:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	86					; 00000056H
	DB	97					; 00000061H
	DB	108					; 0000006cH
	DB	117					; 00000075H
	DB	101					; 00000065H
	DB	0
?SkipAssignment@CRegParser@ATL@@IAEJPAD@Z ENDP		; ATL::CRegParser::SkipAssignment
_TEXT	ENDS
PUBLIC	??0IRegistrarBase@@QAE@XZ			; IRegistrarBase::IRegistrarBase
PUBLIC	??0CExpansionVector@ATL@@QAE@XZ			; ATL::CExpansionVector::CExpansionVector
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CRegObject@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CRegObject@ATL@@QAE@XZ PROC NEAR			; ATL::CRegObject::CRegObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IRegistrarBase@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CRegObject@ATL@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CExpansionVector@ATL@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CRegObject@ATL@@QAE@XZ ENDP				; ATL::CRegObject::CRegObject
_TEXT	ENDS
PUBLIC	??0IUnknown@@QAE@XZ				; IUnknown::IUnknown
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0IRegistrarBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IRegistrarBase@@QAE@XZ PROC NEAR			; IRegistrarBase::IRegistrarBase, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0IRegistrarBase@@QAE@XZ ENDP				; IRegistrarBase::IRegistrarBase
_TEXT	ENDS
PUBLIC	??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CExpansionVector@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CExpansionVector@ATL@@QAE@XZ PROC NEAR		; ATL::CExpansionVector::CExpansionVector, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CExpansionVector@ATL@@QAE@XZ ENDP			; ATL::CExpansionVector::CExpansionVector
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0IUnknown@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IUnknown@@QAE@XZ PROC NEAR				; IUnknown::IUnknown, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0IUnknown@@QAE@XZ ENDP				; IUnknown::IUnknown
_TEXT	ENDS
PUBLIC	?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B ; `CSignature::GetCategoryMap'::`2'::pMap
EXTRN	_CATID_SafeForScripting:BYTE
EXTRN	_CATID_SafeForInitializing:BYTE
;	COMDAT ?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B
; File c:\activex\xmlsign\signature.h
CONST	SEGMENT
?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B DD 01H ; `CSignature::GetCategoryMap'::`2'::pMap
	DD	FLAT:_CATID_SafeForScripting
	DD	01H
	DD	FLAT:_CATID_SafeForInitializing
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT
?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ PROC NEAR ; CSignature::GetCategoryMap, COMDAT

; 436  : BEGIN_CATEGORY_MAP(CSignature)

	push	ebp
	mov	ebp, esp

; 437  : 	IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
; 438  : 	IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
; 439  : END_CATEGORY_MAP()

	mov	eax, OFFSET FLAT:?pMap@?1??GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ@4QBU34@B ; `CSignature::GetCategoryMap'::`2'::pMap
	pop	ebp
	ret	0
?GetCategoryMap@CSignature@@SAPBU_ATL_CATMAP_ENTRY@ATL@@XZ ENDP ; CSignature::GetCategoryMap
_TEXT	ENDS
PUBLIC	?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ; ATL::CComModule::Init
PUBLIC	?Term@CComModule@ATL@@QAEXXZ			; ATL::CComModule::Term
PUBLIC	_DllMain@12
EXTRN	__imp__DisableThreadLibraryCalls@4:NEAR
EXTRN	_strlen:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\xmlsign.cpp
_TEXT	SEGMENT
tv86 = -308						; size = 4
tv90 = -304						; size = 4
_pszModulePath$207819 = -300				; size = 4
__lpa$207818 = -296					; size = 4
__lpw$207817 = -292					; size = 4
__acp$207816 = -288					; size = 4
__convert$207815 = -284					; size = 4
_i$207810 = -280					; size = 4
_len$207809 = -276					; size = 4
_ModulePath$207808 = -268				; size = 260
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hInstance$ = 8						; size = 4
_dwReason$ = 12						; size = 4
___formal$ = 16						; size = 4
_DllMain@12 PROC NEAR

; 63   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-308]
	mov	ecx, 77					; 0000004dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 64   :     if (dwReason == DLL_PROCESS_ATTACH)

	cmp	DWORD PTR _dwReason$[ebp], 1
	jne	$L207807

; 65   :     {
; 66   : 		TCHAR ModulePath[MAX_PATH];
; 67   : 
; 68   : 		hInst = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst, eax

; 69   : 
; 70   : 		// Find and store this DLL module path as OLECHAR array
; 71   : 
; 72   : 		::GetModuleFileName(hInstance, ModulePath, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	ecx, DWORD PTR _ModulePath$207808[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 73   : 		int len = _tcslen(ModulePath);

	lea	eax, DWORD PTR _ModulePath$207808[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _len$207809[ebp], eax

; 74   : 
; 75   : 		for ( int i = len; i > 0; i--)

	mov	ecx, DWORD PTR _len$207809[ebp]
	mov	DWORD PTR _i$207810[ebp], ecx
	jmp	SHORT $L207811
$L207812:
	mov	edx, DWORD PTR _i$207810[ebp]
	sub	edx, 1
	mov	DWORD PTR _i$207810[ebp], edx
$L207811:
	cmp	DWORD PTR _i$207810[ebp], 0
	jle	$L207813

; 76   : 			if ( ModulePath[i] == _T('\\'))

	mov	eax, DWORD PTR _i$207810[ebp]
	movsx	ecx, BYTE PTR _ModulePath$207808[ebp+eax]
	cmp	ecx, 92					; 0000005cH
	jne	$L207814

; 77   : 			{
; 78   : 				USES_CONVERSION;

	mov	DWORD PTR __convert$207815[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp$207816[ebp], eax
	mov	DWORD PTR __lpw$207817[ebp], 0
	mov	DWORD PTR __lpa$207818[ebp], 0

; 79   : 				ModulePath[i] = _T('\0');

	mov	edx, DWORD PTR _i$207810[ebp]
	mov	BYTE PTR _ModulePath$207808[ebp+edx], 0

; 80   : 
; 81   : 				OLECHAR* pszModulePath = T2OLE(ModulePath);

	lea	eax, DWORD PTR _ModulePath$207808[ebp]
	mov	DWORD PTR __lpa$207818[ebp], eax
	cmp	DWORD PTR __lpa$207818[ebp], 0
	jne	SHORT $L212351
	mov	DWORD PTR tv90[ebp], 0
	jmp	SHORT $L212352
$L212351:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa$207818[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert$207815[ebp], eax
	mov	eax, DWORD PTR __convert$207815[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv86[ebp], esp
	mov	edx, DWORD PTR __acp$207816[ebp]
	push	edx
	mov	eax, DWORD PTR __convert$207815[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpa$207818[ebp]
	push	ecx
	mov	edx, DWORD PTR tv86[ebp]
	push	edx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv90[ebp], eax
$L212352:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _pszModulePath$207819[ebp], eax

; 82   : 				wcscpy( szModulePath, pszModulePath);

	mov	ecx, DWORD PTR _pszModulePath$207819[ebp]
	push	ecx
	push	OFFSET FLAT:?szModulePath@@3PAGA	; szModulePath
	call	_wcscpy
	add	esp, 8

; 83   : 				break;

	jmp	SHORT $L207813
$L207814:

; 84   : 			}
; 85   : 
; 86   :         _Module.Init(ObjectMap, hInstance, &LIBID_XMLSIGNLib);

	jmp	$L207812
$L207813:
	push	OFFSET FLAT:_LIBID_XMLSIGNLib
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	push	OFFSET FLAT:_ObjectMap
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ; ATL::CComModule::Init

; 87   : 		
; 88   :         DisableThreadLibraryCalls(hInstance);

	mov	esi, esp
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__DisableThreadLibraryCalls@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 89   :     }
; 90   :     else if (dwReason == DLL_PROCESS_DETACH)

	jmp	SHORT $L207821
$L207807:
	cmp	DWORD PTR _dwReason$[ebp], 0
	jne	SHORT $L207821

; 91   :         _Module.Term();

	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?Term@CComModule@ATL@@QAEXXZ		; ATL::CComModule::Term
$L207821:

; 92   :     return TRUE;    // ok

	mov	eax, 1

; 93   : }

	lea	esp, DWORD PTR [ebp-316]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212356
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L212356:
	DD	1
	DD	$L212355
$L212355:
	DD	-268					; fffffef4H
	DD	260					; 00000104H
	DD	$L212353
$L212353:
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
_DllMain@12 ENDP
_TEXT	ENDS
PUBLIC	?GetLockCount@CAtlModule@ATL@@UAEJXZ		; ATL::CAtlModule::GetLockCount
PUBLIC	_DllCanUnloadNow@0
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_DllCanUnloadNow@0 PROC NEAR

; 99   : {

	push	ebp
	mov	ebp, esp

; 100  :     return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?GetLockCount@CAtlModule@ATL@@UAEJXZ	; ATL::CAtlModule::GetLockCount
	neg	eax
	sbb	eax, eax
	neg	eax

; 101  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_DllCanUnloadNow@0 ENDP
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?GetLockCount@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLockCount@CAtlModule@ATL@@UAEJXZ PROC NEAR		; ATL::CAtlModule::GetLockCount, COMDAT
; _this$ = ecx

; 2672 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2673 : 		return m_nLockCnt;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 2674 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLockCount@CAtlModule@ATL@@UAEJXZ ENDP		; ATL::CAtlModule::GetLockCount
_TEXT	ENDS
PUBLIC	?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ; ATL::CComModule::GetClassObject
PUBLIC	_DllGetClassObject@12
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\xmlsign.cpp
_TEXT	SEGMENT
_rclsid$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
_DllGetClassObject@12 PROC NEAR

; 107  : {

	push	ebp
	mov	ebp, esp

; 108  :     return _Module.GetClassObject(rclsid, riid, ppv);

	mov	eax, DWORD PTR _ppv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _riid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rclsid$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ; ATL::CComModule::GetClassObject

; 109  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
_DllGetClassObject@12 ENDP
_TEXT	ENDS
PUBLIC	?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::RegisterServer
PUBLIC	_DllRegisterServer@0
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_DllRegisterServer@0 PROC NEAR

; 115  : {

	push	ebp
	mov	ebp, esp

; 116  :     // registers object, typelib and all interfaces in typelib
; 117  :     return _Module.RegisterServer(TRUE);

	push	0
	push	1
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::RegisterServer

; 118  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_DllRegisterServer@0 ENDP
_TEXT	ENDS
PUBLIC	?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::UnregisterServer
PUBLIC	_DllUnregisterServer@0
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_DllUnregisterServer@0 PROC NEAR

; 124  : {

	push	ebp
	mov	ebp, esp

; 125  :     return _Module.UnregisterServer(TRUE);

	push	0
	push	1
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::UnregisterServer

; 126  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_DllUnregisterServer@0 ENDP
_TEXT	ENDS
EXTRN	?_AtlComModule@ATL@@3VCAtlComModule@1@A:BYTE	; ATL::_AtlComModule
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z
_TEXT	SEGMENT
_ppEntry$91709 = -12					; size = 4
_pEntry$ = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
___formal$ = 12						; size = 4
_plibid$ = 16						; size = 4
?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z PROC NEAR ; ATL::CComModule::Init, COMDAT
; _this$ = ecx

; 6475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 6476 : 	if (plibid != NULL)

	cmp	DWORD PTR _plibid$[ebp], 0
	je	SHORT $L91701

; 6477 : 		m_libid = *plibid;

	mov	eax, DWORD PTR _plibid$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?m_libid@CAtlModule@ATL@@2U_GUID@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?m_libid@CAtlModule@ATL@@2U_GUID@@A+4, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR ?m_libid@CAtlModule@ATL@@2U_GUID@@A+8, ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR ?m_libid@CAtlModule@ATL@@2U_GUID@@A+12, edx
$L91701:

; 6478 : 
; 6479 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 6480 : 	if (p != (_ATL_OBJMAP_ENTRY*)-1)

	cmp	DWORD PTR _p$[ebp], -1
	je	SHORT $L91704

; 6481 : 	{
; 6482 : 		m_pObjMap = p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 6483 : 		if (m_pObjMap != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $L91704

; 6484 : 		{
; 6485 : 			pEntry = m_pObjMap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _pEntry$[ebp], ecx
$L91707:

; 6486 : 			while (pEntry->pclsid != NULL)

	mov	edx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L91704

; 6487 : 			{
; 6488 : 				pEntry->pfnObjectMain(true); //initialize class resources

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _pEntry$[ebp]
	call	DWORD PTR [eax+32]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6489 : 				pEntry++;

	mov	ecx, DWORD PTR _pEntry$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR _pEntry$[ebp], ecx

; 6490 : 			}

	jmp	SHORT $L91707
$L91704:

; 6491 : 		}
; 6492 : 	}
; 6493 : 	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

	mov	edx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
	mov	DWORD PTR _ppEntry$91709[ebp], edx
	jmp	SHORT $L91710
$L91711:
	mov	eax, DWORD PTR _ppEntry$91709[ebp]
	add	eax, 4
	mov	DWORD PTR _ppEntry$91709[ebp], eax
$L91710:
	mov	ecx, DWORD PTR _ppEntry$91709[ebp]
	cmp	ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
	jae	SHORT $L91712

; 6494 : 	{
; 6495 : 		if (*ppEntry != NULL)

	mov	edx, DWORD PTR _ppEntry$91709[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L91713

; 6496 : 			(*ppEntry)->pfnObjectMain(true); //initialize class resources

	mov	esi, esp
	push	1
	mov	eax, DWORD PTR _ppEntry$91709[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91713:

; 6497 : 	}

	jmp	SHORT $L91711
$L91712:

; 6498 : 	return S_OK;

	xor	eax, eax

; 6499 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ENDP ; ATL::CComModule::Init
_TEXT	ENDS
PUBLIC	?Term@CAtlWinModule@ATL@@QAEXXZ			; ATL::CAtlWinModule::Term
PUBLIC	?Term@CAtlModule@ATL@@QAEXXZ			; ATL::CAtlModule::Term
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_ppEntry$91724 = -12					; size = 4
_pEntry$ = -8						; size = 4
_this$ = -4						; size = 4
?Term@CComModule@ATL@@QAEXXZ PROC NEAR			; ATL::CComModule::Term, COMDAT
; _this$ = ecx

; 6501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 6502 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 6503 : 	if (m_pObjMap != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $L91719

; 6504 : 	{
; 6505 : 		pEntry = m_pObjMap;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _pEntry$[ebp], edx
$L91721:

; 6506 : 		while (pEntry->pclsid != NULL)

	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L91719

; 6507 : 		{
; 6508 : 			if (pEntry->pCF != NULL)

	mov	ecx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L91723

; 6509 : 				pEntry->pCF->Release();

	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91723:

; 6510 : 			pEntry->pCF = NULL;

	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 6511 : 			pEntry->pfnObjectMain(false); //cleanup class resources

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _pEntry$[ebp]
	call	DWORD PTR [edx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6512 : 			pEntry++;

	mov	eax, DWORD PTR _pEntry$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _pEntry$[ebp], eax

; 6513 : 		}

	jmp	SHORT $L91721
$L91719:

; 6514 : 	}
; 6515 : 	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

	mov	ecx, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
	mov	DWORD PTR _ppEntry$91724[ebp], ecx
	jmp	SHORT $L91725
$L91726:
	mov	edx, DWORD PTR _ppEntry$91724[ebp]
	add	edx, 4
	mov	DWORD PTR _ppEntry$91724[ebp], edx
$L91725:
	mov	eax, DWORD PTR _ppEntry$91724[ebp]
	cmp	eax, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
	jae	SHORT $L91727

; 6516 : 	{
; 6517 : 		if (*ppEntry != NULL)

	mov	ecx, DWORD PTR _ppEntry$91724[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L91728

; 6518 : 			(*ppEntry)->pfnObjectMain(false); //cleanup class resources

	mov	esi, esp
	push	0
	mov	edx, DWORD PTR _ppEntry$91724[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91728:

; 6519 : 	}

	jmp	SHORT $L91726
$L91727:

; 6520 : #ifdef _DEBUG
; 6521 : 	// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 6522 : 	_AtlWinModule.Term();		

	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 6523 : #endif	// _DEBUG
; 6524 : 
; 6525 : 	CAtlModuleT<CComModule>::Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlModule@ATL@@QAEXXZ		; ATL::CAtlModule::Term

; 6526 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComModule@ATL@@QAEXXZ ENDP			; ATL::CComModule::Term
_TEXT	ENDS
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlWinModule@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CAtlWinModule@ATL@@QAEXXZ PROC NEAR		; ATL::CAtlWinModule::Term, COMDAT
; _this$ = ecx

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2588 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm

; 2589 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlWinModule@ATL@@QAEXXZ ENDP			; ATL::CAtlWinModule::Term
_TEXT	ENDS
PUBLIC	?Term@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Term
EXTRN	?AtlCallTermFunc@ATL@@YGXPAU_ATL_MODULE70@1@@Z:NEAR ; ATL::AtlCallTermFunc
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Term@CAtlModule@ATL@@QAEXXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?Term@CAtlModule@ATL@@QAEXXZ PROC NEAR			; ATL::CAtlModule::Term, COMDAT
; _this$ = ecx

; 2636 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2637 : 		// cbSize == 0 indicates that Term has already been called
; 2638 : 		if (cbSize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $L88210

; 2639 : 			return;

	jmp	SHORT $L88209
$L88210:

; 2640 : 
; 2641 : 		// Call term functions
; 2642 : 		if (m_pTermFuncs != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L88211

; 2643 : 		{
; 2644 : 			AtlCallTermFunc(this);

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $L212370
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	mov	DWORD PTR tv70[ebp], edx
	jmp	SHORT $L212371
$L212370:
	mov	DWORD PTR tv70[ebp], 0
$L212371:
	mov	eax, DWORD PTR tv70[ebp]
	push	eax
	call	?AtlCallTermFunc@ATL@@YGXPAU_ATL_MODULE70@1@@Z ; ATL::AtlCallTermFunc

; 2645 : 			m_pTermFuncs = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
$L88211:

; 2646 : 		}
; 2647 : 
; 2648 : 		if (m_pGIT != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $L88212

; 2649 : 			m_pGIT->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L88212:

; 2650 : 
; 2651 : 		m_csStaticDataInitAndTypeInfo.Term();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 2652 : 
; 2653 : 		cbSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], 0
$L88209:

; 2654 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CAtlModule@ATL@@QAEXXZ ENDP			; ATL::CAtlModule::Term
_TEXT	ENDS
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Term@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Term, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		DeleteCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 149  : 		return S_OK;

	xor	eax, eax

; 150  : 	}	

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Term@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Term
_TEXT	ENDS
PUBLIC	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
EXTRN	__imp__UnregisterClassA@8:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_i$91551 = -4						; size = 4
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC NEAR ; ATL::AtlWinModuleTerm, COMDAT

; 6215 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6216 : 	if (pWinModule == NULL)

	cmp	DWORD PTR _pWinModule$[ebp], 0
	jne	SHORT $L91544

; 6217 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L91543
$L91544:

; 6218 : 	if (pWinModule->cbSize == 0)

	mov	eax, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L91546

; 6219 : 		return S_OK;

	xor	eax, eax
	jmp	SHORT $L91543
$L91546:

; 6220 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	cmp	DWORD PTR [ecx], 44			; 0000002cH
	je	SHORT $L91549

; 6221 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	SHORT $L91543
$L91549:

; 6222 : 
; 6223 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

	mov	DWORD PTR _i$91551[ebp], 0
	jmp	SHORT $L91552
$L91553:
	mov	edx, DWORD PTR _i$91551[ebp]
	add	edx, 1
	mov	DWORD PTR _i$91551[ebp], edx
$L91552:
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
	cmp	DWORD PTR _i$91551[ebp], eax
	jge	SHORT $L91554

; 6224 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

	mov	esi, esp
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$91551[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
	movzx	edx, WORD PTR [eax]
	push	edx
	call	DWORD PTR __imp__UnregisterClassA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	jmp	SHORT $L91553
$L91554:

; 6225 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 32					; 00000020H
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 6226 : 	pWinModule->m_csWindowCreate.Term();

	mov	ecx, DWORD PTR _pWinModule$[ebp]
	add	ecx, 4
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 6227 : 	pWinModule->cbSize = 0;

	mov	eax, DWORD PTR _pWinModule$[ebp]
	mov	DWORD PTR [eax], 0

; 6228 : 	return S_OK;

	xor	eax, eax
$L91543:

; 6229 : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
PUBLIC	??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z ; ATL::CComCritSecLock<ATL::CComCriticalSection>::CComCritSecLock<ATL::CComCriticalSection>
PUBLIC	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
PUBLIC	?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock
PUBLIC	??_C@_0EH@BABLPHCB@ERROR?5?3?5Unable?5to?5lock?5critical?5@ ; `string'
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	_InlineIsEqualGUID
EXTRN	?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z:NEAR ; ATL::AtlComModuleGetClassObject
;	COMDAT ??_C@_0EH@BABLPHCB@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT
??_C@_0EH@BABLPHCB@ERROR?5?3?5Unable?5to?5lock?5critical?5@ DB 'ERROR : U'
	DB	'nable to lock critical section in CComModule::GetClassObject', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z
_TEXT	SEGMENT
$T212378 = -36						; size = 8
_lock$91764 = -24					; size = 8
_pEntry$ = -12						; size = 4
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_rclsid$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z PROC NEAR ; ATL::CComModule::GetClassObject, COMDAT
; _this$ = ecx

; 6529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 6530 : 	if (ppv == NULL)

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L91735

; 6531 : 		return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L91734
$L91735:

; 6532 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 6533 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 6534 : 	if (m_pObjMap != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$L91740

; 6535 : 	{
; 6536 : 		pEntry = m_pObjMap;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR _pEntry$[ebp], edx
$L91742:

; 6537 : 		while (pEntry->pclsid != NULL)

	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$L91740

; 6538 : 		{
; 6539 : 			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))

	mov	ecx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	$L91744
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _rclsid$[ebp]
	push	ecx
	call	_InlineIsEqualGUID
	add	esp, 8
	test	eax, eax
	je	$L91744

; 6540 : 			{
; 6541 : 				if (pEntry->pCF == NULL)

	mov	edx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	$L91745

; 6542 : 				{
; 6543 : 					CComCritSecLock<CComCriticalSection> lock(_AtlComModule.m_csObjMap, false);

	push	0
	push	OFFSET FLAT:?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
	lea	ecx, DWORD PTR _lock$91764[ebp]
	call	??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z ; ATL::CComCritSecLock<ATL::CComCriticalSection>::CComCritSecLock<ATL::CComCriticalSection>

; 6544 : 					hr = lock.Lock();

	lea	ecx, DWORD PTR _lock$91764[ebp]
	call	?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock
	mov	DWORD PTR _hr$[ebp], eax

; 6545 : 					if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91766

; 6546 : 					{
; 6547 : 						ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CComModule::GetClassObject\n"));

	push	OFFSET FLAT:??_C@_0EH@BABLPHCB@ERROR?5?3?5Unable?5to?5lock?5critical?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	6547					; 00001993H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212378[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 6548 : 						ATLASSERT(0);

	xor	eax, eax
	jne	SHORT $L212379
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	6548					; 00001994H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212379
	int	3
$L212379:

; 6549 : 						break;

	lea	ecx, DWORD PTR _lock$91764[ebp]
	call	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
	jmp	SHORT $L91740
$L91766:

; 6550 : 					}
; 6551 : 					if (pEntry->pCF == NULL)

	mov	edx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $L91770

; 6552 : 						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);

	mov	eax, DWORD PTR _pEntry$[ebp]
	add	eax, 16					; 00000010H
	mov	esi, esp
	push	eax
	push	OFFSET FLAT:__GUID_00000000_0000_0000_c000_000000000046
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pEntry$[ebp]
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L91770:

; 6553 : 				}

	lea	ecx, DWORD PTR _lock$91764[ebp]
	call	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
$L91745:

; 6554 : 				if (pEntry->pCF != NULL)

	mov	ecx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $L91772

; 6555 : 					hr = pEntry->pCF->QueryInterface(riid, ppv);

	mov	esi, esp
	mov	edx, DWORD PTR _ppv$[ebp]
	push	edx
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [edx]
	push	ecx
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L91772:

; 6556 : 				break;

	jmp	SHORT $L91740
$L91744:

; 6557 : 			}
; 6558 : 			pEntry++;

	mov	eax, DWORD PTR _pEntry$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR _pEntry$[ebp], eax

; 6559 : 		}

	jmp	$L91742
$L91740:

; 6560 : 	}
; 6561 : 	if (*ppv == NULL && hr == S_OK)

	mov	ecx, DWORD PTR _ppv$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L91774
	cmp	DWORD PTR _hr$[ebp], 0
	jne	SHORT $L91774

; 6562 : 		hr = AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);

	mov	edx, DWORD PTR _ppv$[ebp]
	push	edx
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rclsid$[ebp]
	push	ecx
	push	OFFSET FLAT:?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
	call	?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z ; ATL::AtlComModuleGetClassObject
	mov	DWORD PTR _hr$[ebp], eax
$L91774:

; 6563 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L91734:

; 6564 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212382
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	esi
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L212382:
	DD	1
	DD	$L212381
$L212381:
	DD	-24					; ffffffe8H
	DD	8
	DD	$L212380
$L212380:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ENDP ; ATL::CComModule::GetClassObject
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\platformsdk\include\guiddef.h
_TEXT	ENDS
;	COMDAT _InlineIsEqualGUID
_TEXT	SEGMENT
tv74 = -4						; size = 4
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_InlineIsEqualGUID PROC NEAR				; COMDAT

; 151  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 152  :    return (
; 153  :       ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
; 154  :       ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
; 155  :       ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
; 156  :       ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);

	mov	eax, DWORD PTR _rguid1$[ebp]
	mov	ecx, DWORD PTR _rguid2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $L212385
	mov	eax, DWORD PTR _rguid1$[ebp]
	mov	ecx, DWORD PTR _rguid2$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $L212385
	mov	eax, DWORD PTR _rguid1$[ebp]
	mov	ecx, DWORD PTR _rguid2$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $L212385
	mov	eax, DWORD PTR _rguid1$[ebp]
	mov	ecx, DWORD PTR _rguid2$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $L212385
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $L212386
$L212385:
	mov	DWORD PTR tv74[ebp], 0
$L212386:
	mov	eax, DWORD PTR tv74[ebp]

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InlineIsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
PUBLIC	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
PUBLIC	_IsEqualGUID
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_pEntry$ = -12						; size = 4
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CComModule::RegisterServer, COMDAT
; _this$ = ecx

; 6621 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 6622 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 6623 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _pEntry$[ebp], ecx

; 6624 : 	if (pEntry != NULL)

	cmp	DWORD PTR _pEntry$[ebp], 0
	je	SHORT $L91825

; 6625 : 	{
; 6626 : 		for (;pEntry->pclsid != NULL; pEntry++)

	jmp	SHORT $L91826
$L91827:
	mov	edx, DWORD PTR _pEntry$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR _pEntry$[ebp], edx
$L91826:
	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L91825

; 6627 : 		{
; 6628 : 			if (pCLSID != NULL)

	cmp	DWORD PTR _pCLSID$[ebp], 0
	je	SHORT $L91829

; 6629 : 			{
; 6630 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))

	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $L91829

; 6631 : 					continue;

	jmp	SHORT $L91827
$L91829:

; 6632 : 			}
; 6633 : 			hr = pEntry->pfnUpdateRegistry(TRUE);

	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR _pEntry$[ebp]
	call	DWORD PTR [ecx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 6634 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91832

; 6635 : 				break;

	jmp	SHORT $L91825
$L91832:

; 6636 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 6637 : 				pEntry->pfnGetCategoryMap(), TRUE );

	push	1
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	esi, esp
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	eax, DWORD PTR _pEntry$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
	mov	DWORD PTR _hr$[ebp], eax

; 6638 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91834

; 6639 : 				break;

	jmp	SHORT $L91825
$L91834:

; 6640 : 		}

	jmp	SHORT $L91827
$L91825:

; 6641 : 	}
; 6642 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91836

; 6643 : 		hr = CAtlModuleT<CComModule>::RegisterServer(bRegTypeLib, pCLSID);

	mov	edx, DWORD PTR _pCLSID$[ebp]
	push	edx
	mov	eax, DWORD PTR _bRegTypeLib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
	mov	DWORD PTR _hr$[ebp], eax
$L91836:

; 6644 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 6645 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP	; ATL::CComModule::RegisterServer
_TEXT	ENDS
EXTRN	_memcmp:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\platformsdk\include\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC NEAR					; COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	push	16					; 00000010H
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _rguid1$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	inc	eax

; 162  : }

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ ; ATL::CComPtrBase<ICatRegister>::operator&
PUBLIC	??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ; ATL::CComPtrBase<ICatRegister>::operator->
PUBLIC	??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ	; ATL::CComPtr<ICatRegister>::CComPtr<ICatRegister>
PUBLIC	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ	; ATL::CComPtr<ICatRegister>::~CComPtr<ICatRegister>
PUBLIC	??_C@_0HE@GOKGCPDA@0?5?$CG?$CG?5?$CCUse?5OBJECT_ENTRY_NON_CREAT@ ; `string'
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@ ; `string'
PUBLIC	??_C@_06JHNIBAJK@CLSID?2?$AA@			; `string'
PUBLIC	??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@	; `string'
PUBLIC	??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@ ; `string'
PUBLIC	??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z		; ATL::CRegKey::CRegKey
EXTRN	__imp__lstrcpyA@8:NEAR
EXTRN	__imp__lstrcatA@8:NEAR
EXTRN	_CLSID_StdComponentCategoriesMgr:BYTE
EXTRN	_GUID_NULL:BYTE
EXTRN	__imp__CoCreateInstance@20:NEAR
EXTRN	__imp__StringFromGUID2@12:NEAR
;	COMDAT ??_C@_0HE@GOKGCPDA@0?5?$CG?$CG?5?$CCUse?5OBJECT_ENTRY_NON_CREAT@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CONST	SEGMENT
??_C@_0HE@GOKGCPDA@0?5?$CG?$CG?5?$CCUse?5OBJECT_ENTRY_NON_CREAT@ DB '0 &&'
	DB	' "Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to reg'
	DB	'ister class categories for non creatable objects."', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@
CONST	SEGMENT
??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@ DB 'pEntry->iType '
	DB	'== 2', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHNIBAJK@CLSID?2?$AA@
CONST	SEGMENT
??_C@_06JHNIBAJK@CLSID?2?$AA@ DB 'CLSID\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@
CONST	SEGMENT
??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@ DB '\Required Categories', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@
CONST	SEGMENT
??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@ DB '\Implemented Catego'
	DB	'ries', 00H					; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z
_TEXT	SEGMENT
tv215 = -440						; size = 4
tv210 = -436						; size = 4
tv217 = -432						; size = 4
tv180 = -428						; size = 4
tv162 = -424						; size = 4
tv150 = -420						; size = 4
tv131 = -416						; size = 4
$T212405 = -412						; size = 4
$T212399 = -408						; size = 4
$T212397 = -404						; size = 4
$T212396 = -400						; size = 4
$T212394 = -396						; size = 4
_lRes$91530 = -392					; size = 4
_cbSubKeys$91529 = -384					; size = 4
_key$91528 = -372					; size = 4
_root$91527 = -360					; size = 4
_szKey$91521 = -348					; size = 128
_pszGUID$91517 = -216					; size = 4
__AtlSafeAllocaManager$91516 = -208			; size = 4
__lpa_ex$91515 = -200					; size = 4
__lpw_ex$91514 = -196					; size = 4
__acp_ex$91513 = -192					; size = 4
__convert_ex$91512 = -188				; size = 4
_szGUID$91511 = -180					; size = 128
_catid$ = -44						; size = 16
_pEntry$ = -24						; size = 4
_hResult$ = -20						; size = 4
_pCatRegister$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_clsid$ = 8						; size = 4
_pCatMap$ = 12						; size = 4
_bRegister$ = 16					; size = 4
?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z PROC NEAR ; ATL::AtlRegisterClassCategoriesHelper, COMDAT

; 6099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 440				; 000001b8H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-440]
	mov	ecx, 110				; 0000006eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6100 :    CComPtr< ICatRegister > pCatRegister;

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ ; ATL::CComPtr<ICatRegister>::CComPtr<ICatRegister>

; 6101 :    HRESULT hResult;
; 6102 :    const struct _ATL_CATMAP_ENTRY* pEntry;
; 6103 :    CATID catid;
; 6104 : 
; 6105 :    if( pCatMap == NULL )

	cmp	DWORD PTR _pCatMap$[ebp], 0
	jne	SHORT $L91469

; 6106 :    {
; 6107 : 	  return( S_OK );

	mov	DWORD PTR $T212394[ebp], 0
	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR $T212394[ebp]
	jmp	$L91390
$L91469:

; 6108 :    }
; 6109 : 
; 6110 :    if (InlineIsEqualGUID(clsid, GUID_NULL))

	push	OFFSET FLAT:_GUID_NULL
	mov	eax, DWORD PTR _clsid$[ebp]
	push	eax
	call	_InlineIsEqualGUID
	add	esp, 8
	test	eax, eax
	je	SHORT $L91472

; 6111 :    {
; 6112 : 	  ATLASSERT(0 && _T("Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to register class categories for non creatable objects."));

	xor	ecx, ecx
	jne	SHORT $L212395
	push	OFFSET FLAT:??_C@_0HE@GOKGCPDA@0?5?$CG?$CG?5?$CCUse?5OBJECT_ENTRY_NON_CREAT@
	push	0
	push	6112					; 000017e0H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212395
	int	3
$L212395:

; 6113 : 	  return S_OK;

	mov	DWORD PTR $T212396[ebp], 0
	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR $T212396[ebp]
	jmp	$L91390
$L91472:

; 6114 :    }
; 6115 : 
; 6116 :    hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
; 6117 : 	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ ; ATL::CComPtrBase<ICatRegister>::operator&
	mov	esi, esp
	push	eax
	push	OFFSET FLAT:__GUID_0002e012_0000_0000_c000_000000000046
	push	1
	push	0
	push	OFFSET FLAT:_CLSID_StdComponentCategoriesMgr
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 6118 :    if( FAILED( hResult ) )

	cmp	DWORD PTR _hResult$[ebp], 0
	jge	SHORT $L91480

; 6119 :    {
; 6120 : 	  // Since not all systems have the category manager installed, we'll allow
; 6121 : 	  // the registration to succeed even though we didn't register our
; 6122 : 	  // categories.  If you really want to register categories on a system
; 6123 : 	  // without the category manager, you can either manually add the
; 6124 : 	  // appropriate entries to your registry script (.rgs), or you can
; 6125 : 	  // redistribute comcat.dll.
; 6126 : 	  return( S_OK );

	mov	DWORD PTR $T212397[ebp], 0
	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR $T212397[ebp]
	jmp	$L91390
$L91480:

; 6127 :    }
; 6128 : 
; 6129 :    hResult = S_OK;

	mov	DWORD PTR _hResult$[ebp], 0

; 6130 :    pEntry = pCatMap;

	mov	eax, DWORD PTR _pCatMap$[ebp]
	mov	DWORD PTR _pEntry$[ebp], eax
$L91485:

; 6131 :    while( pEntry->iType != _ATL_CATMAP_ENTRY_END )

	mov	ecx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$L91486

; 6132 :    {
; 6133 : 	  catid = *pEntry->pcatid;

	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _catid$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _catid$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _catid$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _catid$[ebp+12], edx

; 6134 : 	  if( bRegister )

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	$L91487

; 6135 : 	  {
; 6136 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )

	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 1
	jne	SHORT $L91488

; 6137 : 		 {
; 6138 : 			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
; 6139 : 			   &catid );

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ; ATL::CComPtrBase<ICatRegister>::operator->
	mov	DWORD PTR tv131[ebp], eax
	mov	esi, esp
	lea	ecx, DWORD PTR _catid$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _clsid$[ebp]
	push	edx
	mov	eax, DWORD PTR tv131[ebp]
	push	eax
	mov	ecx, DWORD PTR tv131[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax

; 6140 : 		 }
; 6141 : 		 else

	jmp	SHORT $L91500
$L91488:

; 6142 : 		 {
; 6143 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );

	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 2
	je	SHORT $L212398
	push	OFFSET FLAT:??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@
	push	0
	push	6143					; 000017ffH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212398
	int	3
$L212398:

; 6144 : 			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
; 6145 : 			   &catid );

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ; ATL::CComPtrBase<ICatRegister>::operator->
	mov	DWORD PTR tv150[ebp], eax
	mov	esi, esp
	lea	edx, DWORD PTR _catid$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _clsid$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv150[ebp]
	push	ecx
	mov	edx, DWORD PTR tv150[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hResult$[ebp], eax
$L91500:

; 6146 : 		 }
; 6147 : 		 if( FAILED( hResult ) )

	cmp	DWORD PTR _hResult$[ebp], 0
	jge	SHORT $L91504

; 6148 : 		 {
; 6149 : 			return( hResult );

	mov	ecx, DWORD PTR _hResult$[ebp]
	mov	DWORD PTR $T212399[ebp], ecx
	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR $T212399[ebp]
	jmp	$L91390
$L91504:

; 6150 : 		 }
; 6151 : 	  }
; 6152 : 	  else

	jmp	$L91506
$L91487:

; 6153 : 	  {
; 6154 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )

	mov	edx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $L91507

; 6155 : 		 {
; 6156 : 			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ; ATL::CComPtrBase<ICatRegister>::operator->
	mov	DWORD PTR tv162[ebp], eax
	mov	esi, esp
	lea	eax, DWORD PTR _catid$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _clsid$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv162[ebp]
	push	edx
	mov	eax, DWORD PTR tv162[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+24]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6157 : 		 }
; 6158 : 		 else

	jmp	SHORT $L91506
$L91507:

; 6159 : 		 {
; 6160 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );

	mov	edx, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [edx], 2
	je	SHORT $L212400
	push	OFFSET FLAT:??_C@_0BD@OCKIHNLB@pEntry?9?$DOiType?5?$DN?$DN?52?$AA@
	push	0
	push	6160					; 00001810H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212400
	int	3
$L212400:

; 6161 : 			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );

	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ; ATL::CComPtrBase<ICatRegister>::operator->
	mov	DWORD PTR tv180[ebp], eax
	mov	esi, esp
	lea	ecx, DWORD PTR _catid$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _clsid$[ebp]
	push	edx
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	mov	ecx, DWORD PTR tv180[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91506:

; 6162 : 		 }
; 6163 : 	  }
; 6164 : 	  pEntry++;

	mov	eax, DWORD PTR _pEntry$[ebp]
	add	eax, 8
	mov	DWORD PTR _pEntry$[ebp], eax

; 6165 :    }

	jmp	$L91485
$L91486:

; 6166 : 
; 6167 :    // When unregistering remove "Implemented Categories" and "Required Categories" subkeys if they are empty.
; 6168 :    if (!bRegister)

	cmp	DWORD PTR _bRegister$[ebp], 0
	jne	$L91510

; 6169 :    {
; 6170 : 		OLECHAR szGUID[64];
; 6171 : 		::StringFromGUID2(clsid, szGUID, 64);

	mov	esi, esp
	push	64					; 00000040H
	lea	ecx, DWORD PTR _szGUID$91511[ebp]
	push	ecx
	mov	edx, DWORD PTR _clsid$[ebp]
	push	edx
	call	DWORD PTR __imp__StringFromGUID2@12
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6172 : 		USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$91512[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$91513[ebp], eax
	mov	DWORD PTR __lpw_ex$91514[ebp], 0
	mov	DWORD PTR __lpa_ex$91515[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$91516[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>

; 6173 : 		TCHAR* pszGUID = OLE2T_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szGUID$91511[ebp]
	mov	DWORD PTR __lpw_ex$91514[ebp], eax
	cmp	DWORD PTR __lpw_ex$91514[ebp], 0
	jne	SHORT $L212403
	mov	DWORD PTR tv217[ebp], 0
	jmp	$L212404
$L212403:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$91514[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$91512[ebp], edx
	cmp	DWORD PTR __convert_ex$91512[ebp], 1024	; 00000400H
	jg	SHORT $L212401
	mov	eax, DWORD PTR __convert_ex$91512[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212401
	mov	eax, DWORD PTR __convert_ex$91512[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv210[ebp], esp
	mov	edx, DWORD PTR tv210[ebp]
	mov	DWORD PTR tv215[ebp], edx
	jmp	SHORT $L212402
$L212401:
	mov	eax, DWORD PTR __convert_ex$91512[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$91516[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv215[ebp], eax
$L212402:
	mov	ecx, DWORD PTR __acp_ex$91513[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$91512[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$91514[ebp]
	push	eax
	mov	ecx, DWORD PTR tv215[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv217[ebp], eax
$L212404:
	mov	edx, DWORD PTR tv217[ebp]
	mov	DWORD PTR _pszGUID$91517[ebp], edx

; 6174 : 		if (pszGUID != NULL)

	cmp	DWORD PTR _pszGUID$91517[ebp], 0
	je	$L91520

; 6175 : 		{
; 6176 : 			TCHAR szKey[128];
; 6177 : 			lstrcpy(szKey, _T("CLSID\\"));

	mov	esi, esp
	push	OFFSET FLAT:??_C@_06JHNIBAJK@CLSID?2?$AA@
	lea	eax, DWORD PTR _szKey$91521[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6178 : 			lstrcat(szKey, pszGUID);

	mov	esi, esp
	mov	ecx, DWORD PTR _pszGUID$91517[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKey$91521[ebp]
	push	edx
	call	DWORD PTR __imp__lstrcatA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6179 : 			lstrcat(szKey, _T("\\Required Categories"));

	mov	esi, esp
	push	OFFSET FLAT:??_C@_0BF@CCIMKLEB@?2Required?5Categories?$AA@
	lea	eax, DWORD PTR _szKey$91521[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6180 : 
; 6181 : 			CRegKey root(HKEY_CLASSES_ROOT);

	push	-2147483648				; 80000000H
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z	; ATL::CRegKey::CRegKey

; 6182 : 			CRegKey key;

	lea	ecx, DWORD PTR _key$91528[ebp]
	call	??0CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::CRegKey

; 6183 : 			DWORD cbSubKeys = 0;

	mov	DWORD PTR _cbSubKeys$91529[ebp], 0

; 6184 : 
; 6185 : 			LRESULT lRes = key.Open(root, szKey, KEY_READ);

	push	131097					; 00020019H
	lea	ecx, DWORD PTR _szKey$91521[ebp]
	push	ecx
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	lea	ecx, DWORD PTR _key$91528[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$91530[ebp], eax

; 6186 : 			if (lRes == ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$91530[ebp], 0
	jne	SHORT $L91531

; 6187 : 			{
; 6188 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _cbSubKeys$91529[ebp]
	push	edx
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _key$91528[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	call	DWORD PTR __imp__RegQueryInfoKeyA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$91530[ebp], eax

; 6189 : 				key.Close();

	lea	ecx, DWORD PTR _key$91528[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close

; 6190 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)

	cmp	DWORD PTR _lRes$91530[ebp], 0
	jne	SHORT $L91531
	cmp	DWORD PTR _cbSubKeys$91529[ebp], 0
	jne	SHORT $L91531

; 6191 : 				{
; 6192 : 					root.DeleteSubKey(szKey);

	lea	eax, DWORD PTR _szKey$91521[ebp]
	push	eax
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::DeleteSubKey
$L91531:

; 6193 : 				}
; 6194 : 			}
; 6195 : 
; 6196 : 			lstrcpy(szKey, _T("CLSID\\"));

	mov	esi, esp
	push	OFFSET FLAT:??_C@_06JHNIBAJK@CLSID?2?$AA@
	lea	ecx, DWORD PTR _szKey$91521[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6197 : 			lstrcat(szKey, pszGUID);

	mov	esi, esp
	mov	edx, DWORD PTR _pszGUID$91517[ebp]
	push	edx
	lea	eax, DWORD PTR _szKey$91521[ebp]
	push	eax
	call	DWORD PTR __imp__lstrcatA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6198 : 			lstrcat(szKey, _T("\\Implemented Categories"));

	mov	esi, esp
	push	OFFSET FLAT:??_C@_0BI@LFOHFLDB@?2Implemented?5Categories?$AA@
	lea	ecx, DWORD PTR _szKey$91521[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcatA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 6199 : 			lRes = key.Open(root, szKey, KEY_READ);

	push	131097					; 00020019H
	lea	edx, DWORD PTR _szKey$91521[ebp]
	push	edx
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	lea	ecx, DWORD PTR _key$91528[ebp]
	call	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PBDK@Z ; ATL::CRegKey::Open
	mov	DWORD PTR _lRes$91530[ebp], eax

; 6200 : 			if (lRes == ERROR_SUCCESS)

	cmp	DWORD PTR _lRes$91530[ebp], 0
	jne	SHORT $L91534

; 6201 : 			{
; 6202 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	mov	esi, esp
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _cbSubKeys$91529[ebp]
	push	eax
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _key$91528[ebp]
	call	??BCRegKey@ATL@@QBEPAUHKEY__@@XZ	; ATL::CRegKey::operator HKEY__ *
	push	eax
	call	DWORD PTR __imp__RegQueryInfoKeyA@48
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lRes$91530[ebp], eax

; 6203 : 				key.Close();

	lea	ecx, DWORD PTR _key$91528[ebp]
	call	?Close@CRegKey@ATL@@QAEJXZ		; ATL::CRegKey::Close

; 6204 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)

	cmp	DWORD PTR _lRes$91530[ebp], 0
	jne	SHORT $L91534
	cmp	DWORD PTR _cbSubKeys$91529[ebp], 0
	jne	SHORT $L91534

; 6205 : 				{
; 6206 : 					root.DeleteSubKey(szKey);

	lea	ecx, DWORD PTR _szKey$91521[ebp]
	push	ecx
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	?DeleteSubKey@CRegKey@ATL@@QAEJPBD@Z	; ATL::CRegKey::DeleteSubKey
$L91534:

; 6207 : 				}
; 6208 : 			}
; 6209 : 		}

	lea	ecx, DWORD PTR _key$91528[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
	lea	ecx, DWORD PTR _root$91527[ebp]
	call	??1CRegKey@ATL@@QAE@XZ			; ATL::CRegKey::~CRegKey
$L91520:

; 6210 :    }

	lea	ecx, DWORD PTR __AtlSafeAllocaManager$91516[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L91510:

; 6211 :    return( S_OK );

	mov	DWORD PTR $T212405[ebp], 0
	lea	ecx, DWORD PTR _pCatRegister$[ebp]
	call	??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR $T212405[ebp]
$L91390:

; 6212 : }

	lea	esp, DWORD PTR [ebp-448]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212416
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L212416:
	DD	8
	DD	$L212415
$L212415:
	DD	-12					; fffffff4H
	DD	4
	DD	$L212406
	DD	-44					; ffffffd4H
	DD	16					; 00000010H
	DD	$L212407
	DD	-180					; ffffff4cH
	DD	128					; 00000080H
	DD	$L212408
	DD	-208					; ffffff30H
	DD	4
	DD	$L212409
	DD	-348					; fffffea4H
	DD	128					; 00000080H
	DD	$L212410
	DD	-360					; fffffe98H
	DD	4
	DD	$L212411
	DD	-372					; fffffe8cH
	DD	4
	DD	$L212412
	DD	-384					; fffffe80H
	DD	4
	DD	$L212413
$L212413:
	DB	99					; 00000063H
	DB	98					; 00000062H
	DB	83					; 00000053H
	DB	117					; 00000075H
	DB	98					; 00000062H
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	115					; 00000073H
	DB	0
$L212412:
	DB	107					; 0000006bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$L212411:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	0
$L212410:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	75					; 0000004bH
	DB	101					; 00000065H
	DB	121					; 00000079H
	DB	0
$L212409:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212408:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	71					; 00000047H
	DB	85					; 00000055H
	DB	73					; 00000049H
	DB	68					; 00000044H
	DB	0
$L212407:
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	100					; 00000064H
	DB	0
$L212406:
	DB	112					; 00000070H
	DB	67					; 00000043H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	82					; 00000052H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ENDP ; ATL::AtlRegisterClassCategoriesHelper
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hKey$ = 8						; size = 4
??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z PROC NEAR		; ATL::CRegKey::CRegKey, COMDAT
; _this$ = ecx

; 4799 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _hKey$[ebp]
	mov	DWORD PTR [eax], ecx

; 4800 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CRegKey@ATL@@QAE@PAUHKEY__@@@Z ENDP			; ATL::CRegKey::CRegKey
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ICatRegister>::~CComPtrBase<ICatRegister>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<ICatRegister>::~CComPtr<ICatRegister>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ICatRegister>::~CComPtrBase<ICatRegister>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtr@UICatRegister@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ICatRegister>::~CComPtr<ICatRegister>
_TEXT	ENDS
PUBLIC	?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
; Function compile flags: /Odt /RTCsu
;	COMDAT ?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_pEntry$ = -12						; size = 4
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_bUnRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CComModule::UnregisterServer, COMDAT
; _this$ = ecx

; 6648 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 6649 : 	HRESULT hr = S_OK;	

	mov	DWORD PTR _hr$[ebp], 0

; 6650 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _pEntry$[ebp], ecx

; 6651 : 	if (pEntry != NULL)

	cmp	DWORD PTR _pEntry$[ebp], 0
	je	SHORT $L91845

; 6652 : 	{
; 6653 : 		for (;pEntry->pclsid != NULL; pEntry++)

	jmp	SHORT $L91846
$L91847:
	mov	edx, DWORD PTR _pEntry$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR _pEntry$[ebp], edx
$L91846:
	mov	eax, DWORD PTR _pEntry$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L91845

; 6654 : 		{
; 6655 : 			if (pCLSID != NULL)

	cmp	DWORD PTR _pCLSID$[ebp], 0
	je	SHORT $L91849

; 6656 : 			{
; 6657 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))

	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $L91849

; 6658 : 					continue;

	jmp	SHORT $L91847
$L91849:

; 6659 : 			}
; 6660 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 6661 : 				pEntry->pfnGetCategoryMap(), FALSE );

	push	0
	mov	ecx, DWORD PTR _pEntry$[ebp]
	mov	esi, esp
	call	DWORD PTR [ecx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	edx, DWORD PTR _pEntry$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
	mov	DWORD PTR _hr$[ebp], eax

; 6662 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91852

; 6663 : 				break;

	jmp	SHORT $L91845
$L91852:

; 6664 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister

	mov	esi, esp
	push	0
	mov	ecx, DWORD PTR _pEntry$[ebp]
	call	DWORD PTR [ecx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 6665 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91854

; 6666 : 				break;

	jmp	SHORT $L91845
$L91854:

; 6667 : 		}

	jmp	SHORT $L91847
$L91845:

; 6668 : 	}
; 6669 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91856

; 6670 : 		hr = CAtlModuleT<CComModule>::UnregisterServer(bUnRegTypeLib, pCLSID);

	mov	edx, DWORD PTR _pCLSID$[ebp]
	push	edx
	mov	eax, DWORD PTR _bUnRegTypeLib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
	mov	DWORD PTR _hr$[ebp], eax
$L91856:

; 6671 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 6672 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CComModule::UnregisterServer
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	push	eax
	mov	edx, DWORD PTR _psz$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z	; ATL::CW2AEX<128>::Init

; 421  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CW2AEX@$0IA@@ATL@@QAE@PBG@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
EXTRN	_free:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 428  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 429  : 		if( m_psz != m_szBuffer )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L208176

; 430  : 		{
; 431  : 			free( m_psz );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_free
	add	esp, 4
$L208176:

; 432  : 		}
; 433  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 436  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		return( m_psz );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 438  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ
_TEXT	SEGMENT
?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ PROC NEAR ; ATL::CComCoClass<CSignature,&CLSID_Signature>::GetObjectDescription, COMDAT

; 3412 : 	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}

	push	ebp
	mov	ebp, esp
	xor	eax, eax
	pop	ebp
	ret	0
?GetObjectDescription@?$CComCoClass@VCSignature@@$1?CLSID_Signature@@3U_GUID@@B@ATL@@SGPBDXZ ENDP ; ATL::CComCoClass<CSignature,&CLSID_Signature>::GetObjectDescription
_TEXT	ENDS
PUBLIC	?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z	; ATL::CComClassFactory::SetVoid
PUBLIC	??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::CComObjectCached<ATL::CComClassFactory>
PUBLIC	??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ	; ATL::CComObjectRootBase::FinalConstruct
PUBLIC	?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::_AtlFinalConstruct
PUBLIC	?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructAddRef
PUBLIC	?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructRelease
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212448 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L212444
	DD	0ffffffffH
	DD	00H
$T212450 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212443
$T212449 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T212450
$T212446 DD	019930520H
	DD	03H
	DD	FLAT:$T212448
	DD	01H
	DD	FLAT:$T212449
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@ DB 'ppv != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lcom.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv142 = -56						; size = 4
tv82 = -52						; size = 4
tv147 = -48						; size = 4
tv145 = -44						; size = 4
$T212439 = -40						; size = 4
$T212438 = -36						; size = 4
$T212435 = -32						; size = 4
$T212434 = -28						; size = 4
_p$ = -24						; size = 4
_hRes$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance, COMDAT

; 1751 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1752 : 		ATLASSERT(ppv != NULL);

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L212433
	push	OFFSET FLAT:??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
	push	0
	push	1752					; 000006d8H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212433
	int	3
$L212433:

; 1753 : 		if (ppv == NULL)

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L208337

; 1754 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L208335
$L208337:

; 1755 : 		*ppv = NULL;

	mov	ecx, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [ecx], 0

; 1756 : 
; 1757 : 		HRESULT hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH

; 1758 : 		T1* p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 1759 : 		ATLTRY(p = new T1(pv))

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	60					; 0000003cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR $T212435[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T212435[ebp], 0
	je	SHORT $L212436
	mov	eax, DWORD PTR _pv$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T212435[ebp]
	call	??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::CComObjectCached<ATL::CComClassFactory>
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $L212437
$L212436:
	mov	DWORD PTR tv82[ebp], 0
$L212437:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T212434[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR $T212434[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $L212442
$L212443:
	mov	eax, $L212442
	ret	0
$L212442:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1760 : 		if (p != NULL)

	cmp	DWORD PTR _p$[ebp], 0
	je	$L208372

; 1761 : 		{
; 1762 : 			p->SetVoid(pv);

	mov	ecx, DWORD PTR _pv$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p$[ebp]
	call	?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z ; ATL::CComClassFactory::SetVoid

; 1763 : 			p->InternalFinalConstructAddRef();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructAddRef

; 1764 : 			hRes = p->FinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::FinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax

; 1765 : 			if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	SHORT $L208374

; 1766 : 				hRes = p->_AtlFinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::_AtlFinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax
$L208374:

; 1767 : 			p->InternalFinalConstructRelease();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructRelease

; 1768 : 			if (hRes == S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	jne	SHORT $L208376

; 1769 : 				hRes = p->QueryInterface(riid, ppv);

	mov	esi, esp
	mov	edx, DWORD PTR _ppv$[ebp]
	push	edx
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L208376:

; 1770 : 			if (hRes != S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	je	SHORT $L208372

; 1771 : 				delete p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T212439[ebp], ecx
	mov	edx, DWORD PTR $T212439[ebp]
	mov	DWORD PTR $T212438[ebp], edx
	cmp	DWORD PTR $T212438[ebp], 0
	je	SHORT $L212440
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T212438[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T212438[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $L208372
$L212440:
	mov	DWORD PTR tv142[ebp], 0
$L208372:

; 1772 : 		}
; 1773 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
$L208335:

; 1774 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212444:
	mov	eax, DWORD PTR $T212435[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET FLAT:$T212446
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance
PUBLIC	?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObject<CSignature> >::CreateInstance
PUBLIC	?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComAggObject<CSignature> >::CreateInstance
; Function compile flags: /Odt /RTCsu
;	COMDAT ?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv82 = -4						; size = 4
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CSignature> >,ATL::CComCreator<ATL::CComAggObject<CSignature> > >::CreateInstance, COMDAT

; 1827 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 1828 : 		ATLASSERT(ppv != NULL);

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L212455
	push	OFFSET FLAT:??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
	push	0
	push	1828					; 00000724H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212455
	int	3
$L212455:

; 1829 : 
; 1830 : 		return (pv == NULL) ? 
; 1831 : 			T1::CreateInstance(NULL, riid, ppv) : 
; 1832 : 			T2::CreateInstance(pv, riid, ppv);

	cmp	DWORD PTR _pv$[ebp], 0
	jne	SHORT $L212456
	mov	ecx, DWORD PTR _ppv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _riid$[ebp]
	push	edx
	push	0
	call	?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObject<CSignature> >::CreateInstance
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $L212457
$L212456:
	mov	eax, DWORD PTR _ppv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _riid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pv$[ebp]
	push	edx
	call	?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComAggObject<CSignature> >::CreateInstance
	mov	DWORD PTR tv82[ebp], eax
$L212457:
	mov	eax, DWORD PTR tv82[ebp]

; 1833 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<CSignature> >,ATL::CComCreator<ATL::CComAggObject<CSignature> > >::CreateInstance
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ PROC NEAR ; ATL::CComObjectRootBase::FinalConstruct, COMDAT
; _this$ = ecx

; 2133 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2134 : 		return S_OK;

	xor	eax, eax

; 2135 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ENDP	; ATL::CComObjectRootBase::FinalConstruct
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ PROC NEAR ; ATL::CComObjectRootBase::_AtlFinalConstruct, COMDAT
; _this$ = ecx

; 2138 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2139 : 		return S_OK;

	xor	eax, eax

; 2140 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ENDP	; ATL::CComObjectRootBase::_AtlFinalConstruct
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
EXTRN	_malloc:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z
_TEXT	SEGMENT
_nLengthA$ = -12					; size = 4
_nLengthW$ = -8						; size = 4
_this$ = -4						; size = 4
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 		if (psz == NULL)

	cmp	DWORD PTR _psz$[ebp], 0
	jne	SHORT $L208839

; 444  : 		{
; 445  : 			m_psz = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 446  : 			return;

	jmp	$L212463
$L208839:

; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

	mov	esi, esp
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR _nLengthW$[ebp], eax

; 449  : 		int nLengthA = nLengthW*2;

	mov	edx, DWORD PTR _nLengthW$[ebp]
	shl	edx, 1
	mov	DWORD PTR _nLengthA$[ebp], edx

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

	cmp	DWORD PTR _nLengthA$[ebp], 128		; 00000080H
	jle	SHORT $L208842

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 454  : 			if (m_psz == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $L208842

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L208842:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _nLengthA$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _nLengthW$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psz$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nCodePage$[ebp]
	push	edx
	call	DWORD PTR __imp__WideCharToMultiByte@32
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L212463

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

	call	?AtlThrowLastWin32@ATL@@YGXXZ		; ATL::AtlThrowLastWin32
$L212463:

; 463  : 		}
; 464  : 	}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPBGI@Z ENDP		; ATL::CW2AEX<128>::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_dwError$ = -4						; size = 4
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 80   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 81   : 	DWORD dwError = ::GetLastError();

	mov	esi, esp
	call	DWORD PTR __imp__GetLastError@0
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwError$[ebp], eax

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

	cmp	DWORD PTR _dwError$[ebp], 0
	jg	SHORT $L212466
	mov	eax, DWORD PTR _dwError$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L212467
$L212466:
	mov	ecx, DWORD PTR _dwError$[ebp]
	and	ecx, 65535				; 0000ffffH
	or	ecx, 458752				; 00070000H
	or	ecx, -2147483648			; 80000000H
	mov	DWORD PTR tv69[ebp], ecx
$L212467:
	mov	edx, DWORD PTR tv69[ebp]
	push	edx
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L212465:

; 83   : }

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z PROC NEAR	; ATL::CComObjectRootBase::ObjectMain, COMDAT

; 2155 : 	static void WINAPI ObjectMain(bool /* bStarting */) {}

	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	4
?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z ENDP	; ATL::CComObjectRootBase::ObjectMain
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ PROC NEAR ; ATL::CComObjectRootBase::InternalFinalConstructAddRef, COMDAT
; _this$ = ecx

; 2193 : 	void InternalFinalConstructAddRef() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ ENDP ; ATL::CComObjectRootBase::InternalFinalConstructAddRef
_TEXT	ENDS
PUBLIC	??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@ DB 'm_dwRef == 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ PROC NEAR ; ATL::CComObjectRootBase::InternalFinalConstructRelease, COMDAT
; _this$ = ecx

; 2195 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2196 : 		ATLASSERT(m_dwRef == 0);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L93181
	push	OFFSET FLAT:??_C@_0N@JELNCKOF@m_dwRef?5?$DN?$DN?50?$AA@
	push	0
	push	2196					; 00000894H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L93181
	int	3
$L93181:

; 2197 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ ENDP ; ATL::CComObjectRootBase::InternalFinalConstructRelease
_TEXT	ENDS
PUBLIC	??1CComClassFactory@ATL@@UAE@XZ			; ATL::CComClassFactory::~CComClassFactory
PUBLIC	?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z ; ATL::CComClassFactory::CreateInstance
PUBLIC	?LockServer@CComClassFactory@ATL@@UAGJH@Z	; ATL::CComClassFactory::LockServer
PUBLIC	??0CComClassFactory@ATL@@QAE@XZ			; ATL::CComClassFactory::CComClassFactory
PUBLIC	?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef
PUBLIC	?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ; ATL::CComObjectCached<ATL::CComClassFactory>::Release
PUBLIC	?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface
PUBLIC	??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@ ; ATL::CComObjectCached<ATL::CComClassFactory>::`vftable'
PUBLIC	??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor'
PUBLIC	??0CComAutoCriticalSection@ATL@@QAE@XZ		; ATL::CComAutoCriticalSection::CComAutoCriticalSection
EXTRN	??_E?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z:NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212482 DD	0ffffffffH
	DD	FLAT:$L212477
$T212480 DD	019930520H
	DD	01H
	DD	FLAT:$T212482
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::`vftable'
	DD	FLAT:?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
	DD	FLAT:?LockServer@CComClassFactory@ATL@@UAGJH@Z
	DD	FLAT:??_E?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::CComObjectCached<ATL::CComClassFactory>, COMDAT
; _this$ = ecx

; 2564 : 	CComObjectCached(void* = NULL){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComClassFactory@ATL@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0CComAutoCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoCriticalSection::CComAutoCriticalSection
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212477:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CComClassFactory@ATL@@UAE@XZ		; ATL::CComClassFactory::~CComClassFactory
__ehhandler$??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z:
	mov	eax, OFFSET FLAT:$T212480
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::CComObjectCached<ATL::CComClassFactory>
PUBLIC	??0CComCriticalSection@ATL@@QAE@XZ		; ATL::CComCriticalSection::CComCriticalSection
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ??0CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CComAutoCriticalSection@ATL@@QAE@XZ PROC NEAR	; ATL::CComAutoCriticalSection::CComAutoCriticalSection, COMDAT
; _this$ = ecx

; 157  : 	CComAutoCriticalSection()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection

; 158  : 	{
; 159  : 		HRESULT hr = CComCriticalSection::Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	mov	DWORD PTR _hr$[ebp], eax

; 160  : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L77376

; 161  : 			AtlThrow(hr);

	mov	eax, DWORD PTR _hr$[ebp]
	push	eax
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L77376:

; 162  : 	}

	mov	eax, DWORD PTR _this$[ebp]
$L212486:
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComAutoCriticalSection@ATL@@QAE@XZ ENDP		; ATL::CComAutoCriticalSection::CComAutoCriticalSection
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComCriticalSection@ATL@@QAE@XZ PROC NEAR		; ATL::CComCriticalSection::CComCriticalSection, COMDAT
; _this$ = ecx

; 114  : 	CComCriticalSection() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 	{
; 116  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

	push	24					; 00000018H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 117  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComCriticalSection@ATL@@QAE@XZ ENDP			; ATL::CComCriticalSection::CComCriticalSection
_TEXT	ENDS
EXTRN	__imp__InitializeCriticalSection@4:NEAR
;	COMDAT CONST
CONST	SEGMENT
$T212497 DD	0ffffffffH
	DD	FLAT:$L212492
	DD	FLAT:$L212493
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
$T212496 = -36						; size = 4
_hRes$ = -32						; size = 4
_this$ = -28						; size = 4
__$SEHRec$ = -24					; size = 24
?Init@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 129  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	OFFSET FLAT:$T212497
	push	OFFSET FLAT:__except_handler3
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	add	esp, -20				; ffffffecH
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp-36], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-32], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-28], -858993460		; ccccccccH
	mov	DWORD PTR __$SEHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		HRESULT hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 131  : 		__try

	mov	DWORD PTR __$SEHRec$[ebp+20], 0

; 132  : 		{
; 133  : 			InitializeCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
	jmp	SHORT $L212495
$L212492:
$L212500:

; 134  : 		}
; 135  : 		// structured exception may be raised in low memory situations
; 136  : 		__except(EXCEPTION_EXECUTE_HANDLER)

	mov	ecx, DWORD PTR __$SEHRec$[ebp+4]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T212496[ebp], eax
	mov	eax, 1
$L212494:
$L212499:
	ret	0
$L212493:
	mov	esp, DWORD PTR __$SEHRec$[ebp]

; 137  : 		{
; 138  : 			if (STATUS_NO_MEMORY == GetExceptionCode())

	cmp	DWORD PTR $T212496[ebp], -1073741801	; c0000017H
	jne	SHORT $L77355

; 139  : 				hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH

; 140  : 			else

	jmp	SHORT $L77357
$L77355:

; 141  : 				hRes = E_FAIL;

	mov	DWORD PTR _hRes$[ebp], -2147467259	; 80004005H
$L77357:
	mov	DWORD PTR __$SEHRec$[ebp+20], -1
$L212495:

; 142  : 		}
; 143  : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
$L212491:

; 144  : 	}

	mov	ecx, DWORD PTR __$SEHRec$[ebp+8]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 36					; 00000024H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
PUBLIC	?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalAddRef
PUBLIC	?Lock@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Lock
PUBLIC	?Unlock@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Unlock
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
;	COMDAT ?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_l$ = -4						; size = 4
_this$ = 8						; size = 4
?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef, COMDAT

; 2578 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2579 : 		m_csCached.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Lock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Lock

; 2580 : 		ULONG l = InternalAddRef();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalAddRef
	mov	DWORD PTR _l$[ebp], eax

; 2581 : 		if (m_dwRef == 2)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 2
	jne	SHORT $L208898

; 2582 : 			_pAtlModule->Lock();

	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208898:

; 2583 : 		m_csCached.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Unlock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Unlock

; 2584 : 		return l;

	mov	eax, DWORD PTR _l$[ebp]

; 2585 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef
_TEXT	ENDS
EXTRN	__imp__EnterCriticalSection@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
;	COMDAT ?Lock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Lock@CComCriticalSection@ATL@@QAEJXZ PROC NEAR		; ATL::CComCriticalSection::Lock, COMDAT
; _this$ = ecx

; 119  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		EnterCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__EnterCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 121  : 		return S_OK;

	xor	eax, eax

; 122  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Lock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Lock
_TEXT	ENDS
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Unlock@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlock@CComCriticalSection@ATL@@QAEJXZ PROC NEAR	; ATL::CComCriticalSection::Unlock, COMDAT
; _this$ = ecx

; 124  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		LeaveCriticalSection(&m_sec);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR __imp__LeaveCriticalSection@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 126  : 		return S_OK;

	xor	eax, eax

; 127  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Unlock@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Unlock
_TEXT	ENDS
PUBLIC	?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalRelease
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
;	COMDAT ?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
tv80 = -16						; size = 4
$T212512 = -12						; size = 4
$T212511 = -8						; size = 4
_l$ = -4						; size = 4
_this$ = 8						; size = 4
?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::Release, COMDAT

; 2587 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2588 : 		m_csCached.Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Lock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Lock

; 2589 : 		InternalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalRelease

; 2590 : 		ULONG l = m_dwRef;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _l$[ebp], ecx

; 2591 : 		m_csCached.Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?Unlock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Unlock

; 2592 : 		if (l == 0)

	cmp	DWORD PTR _l$[ebp], 0
	jne	SHORT $L208902

; 2593 : 			delete this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T212512[ebp], edx
	mov	eax, DWORD PTR $T212512[ebp]
	mov	DWORD PTR $T212511[ebp], eax
	cmp	DWORD PTR $T212511[ebp], 0
	je	SHORT $L212513
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T212511[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T212511[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L212514
$L212513:
	mov	DWORD PTR tv80[ebp], 0
$L212514:

; 2594 : 		else if (l == 1)

	jmp	SHORT $L208905
$L208902:
	cmp	DWORD PTR _l$[ebp], 1
	jne	SHORT $L208905

; 2595 : 			_pAtlModule->Unlock();

	mov	eax, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L208905:

; 2596 : 		return l;

	mov	eax, DWORD PTR _l$[ebp]

; 2597 : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::Release
_TEXT	ENDS
PUBLIC	?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z ; ATL::CComClassFactory::_InternalQueryInterface
; Function compile flags: /Odt /RTCsu
;	COMDAT ?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface, COMDAT

; 2600 : 	{return _InternalQueryInterface(iid, ppvObject);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z ; ATL::CComClassFactory::_InternalQueryInterface
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface
_TEXT	ENDS
PUBLIC	?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ ; ATL::CComClassFactory::_GetEntries
PUBLIC	?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z ; ATL::CComObjectRootBase::InternalQueryInterface
; Function compile flags: /Odt /RTCsu
;	COMDAT ?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iid$ = 8						; size = 4
_ppvObject$ = 12					; size = 4
?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComClassFactory::_InternalQueryInterface, COMDAT
; _this$ = ecx

; 3156 : 	BEGIN_COM_MAP(CComClassFactory)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	call	?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ ; ATL::CComClassFactory::_GetEntries
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z ; ATL::CComObjectRootBase::InternalQueryInterface
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_InternalQueryInterface@CComClassFactory@ATL@@QAEJABU_GUID@@PAPAX@Z ENDP ; ATL::CComClassFactory::_InternalQueryInterface
_TEXT	ENDS
PUBLIC	??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@ ; `string'
EXTRN	?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z:NEAR ; ATL::AtlInternalQueryInterface
;	COMDAT ??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@ DB 'ppvObject != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@ DB 'pThis != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
CONST	SEGMENT
??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@ DB 'p'
	DB	'Entries->pFunc == ((ATL::_ATL_CREATORARGFUNC*)1)', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_hRes$ = -4						; size = 4
_pThis$ = 8						; size = 4
_pEntries$ = 12						; size = 4
_iid$ = 16						; size = 4
_ppvObject$ = 20					; size = 4
?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComObjectRootBase::InternalQueryInterface, COMDAT

; 2160 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2161 : 		// Only Assert here. AtlInternalQueryInterface will return the correct HRESULT if ppvObject == NULL
; 2162 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 2163 : 		ATLASSERT(ppvObject != NULL);

	cmp	DWORD PTR _ppvObject$[ebp], 0
	jne	SHORT $L212521
	push	OFFSET FLAT:??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
	push	0
	push	2163					; 00000873H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212521
	int	3
$L212521:

; 2164 : #endif
; 2165 : 		ATLASSERT(pThis != NULL);

	cmp	DWORD PTR _pThis$[ebp], 0
	jne	SHORT $L212522
	push	OFFSET FLAT:??_C@_0L@DBHNDLKF@pThis?5?$CB?$DN?50?$AA@
	push	0
	push	2165					; 00000875H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212522
	int	3
$L212522:

; 2166 : 		// First entry in the com map should be a simple map entry
; 2167 : 		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);

	mov	edx, DWORD PTR _pEntries$[ebp]
	cmp	DWORD PTR [edx+8], 1
	je	SHORT $L212523
	push	OFFSET FLAT:??_C@_0DC@BBKMJDPM@pEntries?9?$DOpFunc?5?$DN?$DN?5?$CI?$CIATL?3?3_ATL_C@
	push	0
	push	2167					; 00000877H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212523
	int	3
$L212523:

; 2168 : 	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
; 2169 : 		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
; 2170 : 	#endif // _ATL_DEBUG_INTERFACES
; 2171 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

	mov	ecx, DWORD PTR _ppvObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iid$[ebp]
	push	edx
	mov	eax, DWORD PTR _pEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pThis$[ebp]
	push	ecx
	call	?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface
	mov	DWORD PTR _hRes$[ebp], eax

; 2172 : 	#ifdef _ATL_DEBUG_INTERFACES
; 2173 : 		_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
; 2174 : 	#endif // _ATL_DEBUG_INTERFACES
; 2175 : 		return _ATLDUMPIID(iid, pszClassName, hRes);

	mov	eax, DWORD PTR _hRes$[ebp]

; 2176 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z ENDP ; ATL::CComObjectRootBase::InternalQueryInterface
_TEXT	ENDS
PUBLIC	??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z	; ATL::CComObject<CSignature>::CComObject<CSignature>
PUBLIC	?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z	; ATL::CComObjectRootBase::SetVoid
PUBLIC	?InternalFinalConstructAddRef@CSignature@@QAEXXZ ; CSignature::InternalFinalConstructAddRef
PUBLIC	?InternalFinalConstructRelease@CSignature@@QAEXXZ ; CSignature::InternalFinalConstructRelease
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212539 DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T212541 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212535
$T212540 DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T212541
$T212537 DD	019930520H
	DD	02H
	DD	FLAT:$T212539
	DD	01H
	DD	FLAT:$T212540
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv140 = -48						; size = 4
tv80 = -44						; size = 4
tv142 = -40						; size = 4
$T212531 = -36						; size = 4
$T212530 = -32						; size = 4
$T212527 = -28						; size = 4
_p$ = -24						; size = 4
_hRes$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComCreator<ATL::CComObject<CSignature> >::CreateInstance, COMDAT

; 1751 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-48], eax
	mov	DWORD PTR [ebp-44], eax
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1752 : 		ATLASSERT(ppv != NULL);

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L212526
	push	OFFSET FLAT:??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
	push	0
	push	1752					; 000006d8H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212526
	int	3
$L212526:

; 1753 : 		if (ppv == NULL)

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L208911

; 1754 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L208909
$L208911:

; 1755 : 		*ppv = NULL;

	mov	ecx, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [ecx], 0

; 1756 : 
; 1757 : 		HRESULT hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH

; 1758 : 		T1* p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 1759 : 		ATLTRY(p = new T1(pv))

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	3428					; 00000d64H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv142[ebp], eax
	mov	edx, DWORD PTR tv142[ebp]
	mov	DWORD PTR $T212527[ebp], edx
	cmp	DWORD PTR $T212527[ebp], 0
	je	SHORT $L212528
	mov	eax, DWORD PTR _pv$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T212527[ebp]
	call	??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z ; ATL::CComObject<CSignature>::CComObject<CSignature>
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $L212529
$L212528:
	mov	DWORD PTR tv80[ebp], 0
$L212529:
	mov	ecx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $L212534
$L212535:
	mov	eax, $L212534
	ret	0
$L212534:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1760 : 		if (p != NULL)

	cmp	DWORD PTR _p$[ebp], 0
	je	$L208950

; 1761 : 		{
; 1762 : 			p->SetVoid(pv);

	mov	edx, DWORD PTR _pv$[ebp]
	push	edx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 12					; 0000000cH
	call	?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z ; ATL::CComObjectRootBase::SetVoid

; 1763 : 			p->InternalFinalConstructAddRef();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?InternalFinalConstructAddRef@CSignature@@QAEXXZ ; CSignature::InternalFinalConstructAddRef

; 1764 : 			hRes = p->FinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 12					; 0000000cH
	call	?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::FinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax

; 1765 : 			if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	SHORT $L208952

; 1766 : 				hRes = p->_AtlFinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 12					; 0000000cH
	call	?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::_AtlFinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax
$L208952:

; 1767 : 			p->InternalFinalConstructRelease();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?InternalFinalConstructRelease@CSignature@@QAEXXZ ; CSignature::InternalFinalConstructRelease

; 1768 : 			if (hRes == S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	jne	SHORT $L208954

; 1769 : 				hRes = p->QueryInterface(riid, ppv);

	mov	esi, esp
	mov	eax, DWORD PTR _ppv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _riid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L208954:

; 1770 : 			if (hRes != S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	je	SHORT $L208950

; 1771 : 				delete p;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T212531[ebp], edx
	mov	eax, DWORD PTR $T212531[ebp]
	mov	DWORD PTR $T212530[ebp], eax
	cmp	DWORD PTR $T212530[ebp], 0
	je	SHORT $L212532
	mov	esi, esp
	push	1
	mov	ecx, DWORD PTR $T212530[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T212530[ebp]
	call	DWORD PTR [edx+896]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv140[ebp], eax
	jmp	SHORT $L208950
$L212532:
	mov	DWORD PTR tv140[ebp], 0
$L208950:

; 1772 : 		}
; 1773 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
$L208909:

; 1774 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 48					; 00000030H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET FLAT:$T212537
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateInstance@?$CComCreator@V?$CComObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComObject<CSignature> >::CreateInstance
PUBLIC	?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.h
;	COMDAT ?InternalFinalConstructAddRef@CSignature@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalFinalConstructAddRef@CSignature@@QAEXXZ PROC NEAR ; CSignature::InternalFinalConstructAddRef, COMDAT
; _this$ = ecx

; 286  : DECLARE_PROTECT_FINAL_CONSTRUCT()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalFinalConstructAddRef@CSignature@@QAEXXZ ENDP	; CSignature::InternalFinalConstructAddRef
_TEXT	ENDS
PUBLIC	?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InternalFinalConstructRelease@CSignature@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalFinalConstructRelease@CSignature@@QAEXXZ PROC NEAR ; CSignature::InternalFinalConstructRelease, COMDAT
; _this$ = ecx

; 286  : DECLARE_PROTECT_FINAL_CONSTRUCT()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalFinalConstructRelease@CSignature@@QAEXXZ ENDP	; CSignature::InternalFinalConstructRelease
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z PROC NEAR	; ATL::CComObjectRootBase::SetVoid, COMDAT
; _this$ = ecx

; 2192 : 	void SetVoid(void*) {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z ENDP		; ATL::CComObjectRootBase::SetVoid
_TEXT	ENDS
PUBLIC	??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@	; `string'
PUBLIC	?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z	; ATL::CComSingleThreadModel::Increment
;	COMDAT ??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
CONST	SEGMENT
??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@ DB 'm_dwRef != -1L', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef, COMDAT
; _this$ = ecx

; 2326 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2327 : 		ATLASSERT(m_dwRef != -1L);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $L212552
	push	OFFSET FLAT:??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
	push	0
	push	2327					; 00000917H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212552
	int	3
$L212552:

; 2328 : 		return _ThreadModel::Increment(&m_dwRef);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z ; ATL::CComSingleThreadModel::Increment

; 2329 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ENDP ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z PROC NEAR ; ATL::CComSingleThreadModel::Increment, COMDAT

; 357  : 	static ULONG WINAPI Increment(LPLONG p) throw() {return ++(*p);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	ebp
	ret	4
?Increment@CComSingleThreadModel@ATL@@SGKPAJ@Z ENDP	; ATL::CComSingleThreadModel::Increment
_TEXT	ENDS
PUBLIC	??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@ ; `string'
PUBLIC	?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z	; ATL::CComSingleThreadModel::Decrement
;	COMDAT ??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
CONST	SEGMENT
??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@ DB '0'
	DB	' && "Release called on a pointer that has already been releas'
	DB	'ed"', 00H					; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT
_nRef$ = -8						; size = 4
_this$ = -4						; size = 4
?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease, COMDAT
; _this$ = ecx

; 2331 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2332 : #ifdef _DEBUG
; 2333 : 		long nRef = _ThreadModel::Decrement(&m_dwRef);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z ; ATL::CComSingleThreadModel::Decrement
	mov	DWORD PTR _nRef$[ebp], eax

; 2334 : 		if (nRef < -(LONG_MAX / 2))

	cmp	DWORD PTR _nRef$[ebp], -1073741823	; c0000001H
	jge	SHORT $L93275

; 2335 : 		{
; 2336 : 			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));

	xor	ecx, ecx
	jne	SHORT $L93275
	push	OFFSET FLAT:??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
	push	0
	push	2336					; 00000920H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L93275
	int	3
$L93275:

; 2337 : 		}
; 2338 : 		return nRef;

	mov	eax, DWORD PTR _nRef$[ebp]

; 2339 : #else
; 2340 : 		return _ThreadModel::Decrement(&m_dwRef);
; 2341 : #endif	
; 2342 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ENDP ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z PROC NEAR ; ATL::CComSingleThreadModel::Decrement, COMDAT

; 358  : 	static ULONG WINAPI Decrement(LPLONG p) throw() {return --(*p);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [eax]
	pop	ebp
	ret	4
?Decrement@CComSingleThreadModel@ATL@@SGKPAJ@Z ENDP	; ATL::CComSingleThreadModel::Decrement
_TEXT	ENDS
PUBLIC	?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
PUBLIC	??_C@_0BB@PADCHBLN@CComClassFactory?$AA@	; `string'
PUBLIC	__GUID_00000001_0000_0000_c000_000000000046
;	COMDAT ?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
CONST	SEGMENT
?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B DD 00H ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
	DD	FLAT:??_C@_0BB@PADCHBLN@CComClassFactory?$AA@
	DD	00H
	DD	FLAT:__GUID_00000001_0000_0000_c000_000000000046
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_0BB@PADCHBLN@CComClassFactory?$AA@
CONST	SEGMENT
??_C@_0BB@PADCHBLN@CComClassFactory?$AA@ DB 'CComClassFactory', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_00000001_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000001_0000_0000_c000_000000000046 DD 01H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ
_TEXT	SEGMENT
?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ PROC NEAR ; ATL::CComClassFactory::_GetEntries, COMDAT

; 3156 : 	BEGIN_COM_MAP(CComClassFactory)

	push	ebp
	mov	ebp, esp

; 3157 : 		COM_INTERFACE_ENTRY(IClassFactory)
; 3158 : 	END_COM_MAP()

	mov	eax, OFFSET FLAT:?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B+12
	pop	ebp
	ret	0
?_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@2@XZ ENDP ; ATL::CComClassFactory::_GetEntries
_TEXT	ENDS
PUBLIC	??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
PUBLIC	??_7CComClassFactory@ATL@@6B@			; ATL::CComClassFactory::`vftable'
PUBLIC	??_GCComClassFactory@ATL@@UAEPAXI@Z		; ATL::CComClassFactory::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_ECComClassFactory@ATL@@UAEPAXI@Z:NEAR	; ATL::CComClassFactory::`vector deleting destructor'
;	COMDAT ??_7CComClassFactory@ATL@@6B@
CONST	SEGMENT
??_7CComClassFactory@ATL@@6B@ DD FLAT:__purecall	; ATL::CComClassFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
	DD	FLAT:?LockServer@CComClassFactory@ATL@@UAGJH@Z
	DD	FLAT:??_ECComClassFactory@ATL@@UAEPAXI@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??1CComClassFactory@ATL@@UAE@XZ
_TEXT	SEGMENT
tv66 = -8						; size = 4
_this$ = -4						; size = 4
??1CComClassFactory@ATL@@UAE@XZ PROC NEAR		; ATL::CComClassFactory::~CComClassFactory, COMDAT
; _this$ = ecx

; 3161 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CComClassFactory@ATL@@6B@

; 3162 : 	}

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $L212564
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	mov	DWORD PTR tv66[ebp], ecx
	jmp	SHORT $L212565
$L212564:
	mov	DWORD PTR tv66[ebp], 0
$L212565:
	mov	ecx, DWORD PTR tv66[ebp]
	call	??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComClassFactory@ATL@@UAE@XZ ENDP			; ATL::CComClassFactory::~CComClassFactory
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HNHMIKBN@m_pfnCreateInstance?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0FH@OCMNPHBO@CComClassFactory?3?5asked?5for?5non?5@ ; `string'
PUBLIC	?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z	; ATL::InlineIsEqualUnknown
;	COMDAT ??_C@_0BJ@HNHMIKBN@m_pfnCreateInstance?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BJ@HNHMIKBN@m_pfnCreateInstance?5?$CB?$DN?50?$AA@ DB 'm_pfnCreateI'
	DB	'nstance != 0', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FH@OCMNPHBO@CComClassFactory?3?5asked?5for?5non?5@
CONST	SEGMENT
??_C@_0FH@OCMNPHBO@CComClassFactory?3?5asked?5for?5non?5@ DB 'CComClassFa'
	DB	'ctory: asked for non IUnknown interface while creating an agg'
	DB	'regated object', 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
$T212572 = -12						; size = 8
_hRes$ = -4						; size = 4
_this$ = 8						; size = 4
_pUnkOuter$ = 12					; size = 4
_riid$ = 16						; size = 4
_ppvObj$ = 20						; size = 4
?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComClassFactory::CreateInstance, COMDAT

; 3166 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 3167 : 		ATLASSERT(m_pfnCreateInstance != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 0
	jne	SHORT $L212571
	push	OFFSET FLAT:??_C@_0BJ@HNHMIKBN@m_pfnCreateInstance?5?$CB?$DN?50?$AA@
	push	0
	push	3167					; 00000c5fH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212571
	int	3
$L212571:

; 3168 : 		HRESULT hRes = E_POINTER;

	mov	DWORD PTR _hRes$[ebp], -2147467261	; 80004003H

; 3169 : 		if (ppvObj != NULL)

	cmp	DWORD PTR _ppvObj$[ebp], 0
	je	SHORT $L93581

; 3170 : 		{
; 3171 : 			*ppvObj = NULL;

	mov	edx, DWORD PTR _ppvObj$[ebp]
	mov	DWORD PTR [edx], 0

; 3172 : 			// can't ask for anything other than IUnknown when aggregating
; 3173 : 
; 3174 : 			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))

	cmp	DWORD PTR _pUnkOuter$[ebp], 0
	je	SHORT $L93582
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	call	?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
	test	eax, eax
	jne	SHORT $L93582

; 3175 : 			{
; 3176 : 				ATLTRACE(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));

	push	OFFSET FLAT:??_C@_0FH@OCMNPHBO@CComClassFactory?3?5asked?5for?5non?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3176					; 00000c68H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212572[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 3177 : 				hRes = CLASS_E_NOAGGREGATION;

	mov	DWORD PTR _hRes$[ebp], -2147221232	; 80040110H

; 3178 : 			}
; 3179 : 			else

	jmp	SHORT $L93581
$L93582:

; 3180 : 				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);

	mov	esi, esp
	mov	ecx, DWORD PTR _ppvObj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _riid$[ebp]
	push	edx
	mov	eax, DWORD PTR _pUnkOuter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [ecx+32]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L93581:

; 3181 : 		}
; 3182 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]

; 3183 : 	}

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z ENDP ; ATL::CComClassFactory::CreateInstance
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z
_TEXT	SEGMENT
tv71 = -4						; size = 4
_rguid1$ = 8						; size = 4
?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z PROC NEAR	; ATL::InlineIsEqualUnknown, COMDAT

; 727  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 728  :    return (
; 729  : 	  ((PLONG) &rguid1)[0] == 0 &&
; 730  : 	  ((PLONG) &rguid1)[1] == 0 &&
; 731  : #ifdef _ATL_BYTESWAP
; 732  : 	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
; 733  : 	  ((PLONG) &rguid1)[3] == 0x00000046);
; 734  : #else
; 735  : 	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
; 736  : 	  ((PLONG) &rguid1)[3] == 0x46000000);

	mov	eax, DWORD PTR _rguid1$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L212575
	mov	ecx, DWORD PTR _rguid1$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L212575
	mov	edx, DWORD PTR _rguid1$[ebp]
	cmp	DWORD PTR [edx+8], 192			; 000000c0H
	jne	SHORT $L212575
	mov	eax, DWORD PTR _rguid1$[ebp]
	cmp	DWORD PTR [eax+12], 1174405120		; 46000000H
	jne	SHORT $L212575
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $L212576
$L212575:
	mov	DWORD PTR tv71[ebp], 0
$L212576:
	mov	eax, DWORD PTR tv71[ebp]

; 737  : #endif
; 738  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ENDP		; ATL::InlineIsEqualUnknown
_TEXT	ENDS
PUBLIC	??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z	; ATL::CComAggObject<CSignature>::CComAggObject<CSignature>
PUBLIC	?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ ; ATL::CComAggObject<CSignature>::FinalConstruct
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
xdata$x	SEGMENT
$T212594 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L212590
	DD	0ffffffffH
	DD	00H
$T212596 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212589
$T212595 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T212596
$T212592 DD	019930520H
	DD	03H
	DD	FLAT:$T212594
	DD	01H
	DD	FLAT:$T212595
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv142 = -56						; size = 4
tv82 = -52						; size = 4
tv147 = -48						; size = 4
tv145 = -44						; size = 4
$T212585 = -40						; size = 4
$T212584 = -36						; size = 4
$T212581 = -32						; size = 4
$T212580 = -28						; size = 4
_p$ = -24						; size = 4
_hRes$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComCreator<ATL::CComAggObject<CSignature> >::CreateInstance, COMDAT

; 1751 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-56]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1752 : 		ATLASSERT(ppv != NULL);

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L212579
	push	OFFSET FLAT:??_C@_08NEPKAPOI@ppv?5?$CB?$DN?50?$AA@
	push	0
	push	1752					; 000006d8H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212579
	int	3
$L212579:

; 1753 : 		if (ppv == NULL)

	cmp	DWORD PTR _ppv$[ebp], 0
	jne	SHORT $L208961

; 1754 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L208959
$L208961:

; 1755 : 		*ppv = NULL;

	mov	ecx, DWORD PTR _ppv$[ebp]
	mov	DWORD PTR [ecx], 0

; 1756 : 
; 1757 : 		HRESULT hRes = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes$[ebp], -2147024882	; 8007000eH

; 1758 : 		T1* p = NULL;

	mov	DWORD PTR _p$[ebp], 0

; 1759 : 		ATLTRY(p = new T1(pv))

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	push	3436					; 00000d6cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR tv145[ebp], eax
	mov	edx, DWORD PTR tv145[ebp]
	mov	DWORD PTR $T212581[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T212581[ebp], 0
	je	SHORT $L212582
	mov	eax, DWORD PTR _pv$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T212581[ebp]
	call	??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z ; ATL::CComAggObject<CSignature>::CComAggObject<CSignature>
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv82[ebp], ecx
	jmp	SHORT $L212583
$L212582:
	mov	DWORD PTR tv82[ebp], 0
$L212583:
	mov	edx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T212580[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR $T212580[ebp]
	mov	DWORD PTR _p$[ebp], eax
	jmp	SHORT $L212588
$L212589:
	mov	eax, $L212588
	ret	0
$L212588:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1760 : 		if (p != NULL)

	cmp	DWORD PTR _p$[ebp], 0
	je	$L209029

; 1761 : 		{
; 1762 : 			p->SetVoid(pv);

	mov	ecx, DWORD PTR _pv$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?SetVoid@CComObjectRootBase@ATL@@QAEXPAX@Z ; ATL::CComObjectRootBase::SetVoid

; 1763 : 			p->InternalFinalConstructAddRef();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?InternalFinalConstructAddRef@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructAddRef

; 1764 : 			hRes = p->FinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ ; ATL::CComAggObject<CSignature>::FinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax

; 1765 : 			if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	SHORT $L209031

; 1766 : 				hRes = p->_AtlFinalConstruct();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?_AtlFinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::_AtlFinalConstruct
	mov	DWORD PTR _hRes$[ebp], eax
$L209031:

; 1767 : 			p->InternalFinalConstructRelease();

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 4
	call	?InternalFinalConstructRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::InternalFinalConstructRelease

; 1768 : 			if (hRes == S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	jne	SHORT $L209033

; 1769 : 				hRes = p->QueryInterface(riid, ppv);

	mov	esi, esp
	mov	edx, DWORD PTR _ppv$[ebp]
	push	edx
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L209033:

; 1770 : 			if (hRes != S_OK)

	cmp	DWORD PTR _hRes$[ebp], 0
	je	SHORT $L209029

; 1771 : 				delete p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR $T212585[ebp], ecx
	mov	edx, DWORD PTR $T212585[ebp]
	mov	DWORD PTR $T212584[ebp], edx
	cmp	DWORD PTR $T212584[ebp], 0
	je	SHORT $L212586
	mov	esi, esp
	push	1
	mov	eax, DWORD PTR $T212584[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T212584[ebp]
	call	DWORD PTR [edx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $L209029
$L212586:
	mov	DWORD PTR tv142[ebp], 0
$L209029:

; 1772 : 		}
; 1773 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
$L208959:

; 1774 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 56					; 00000038H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212590:
	mov	eax, DWORD PTR $T212581[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z:
	mov	eax, OFFSET FLAT:$T212592
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateInstance@?$CComCreator@V?$CComAggObject@VCSignature@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComAggObject<CSignature> >::CreateInstance
; Function compile flags: /Odt /RTCsu
;	COMDAT ?LockServer@CComClassFactory@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_fLock$ = 12						; size = 4
?LockServer@CComClassFactory@ATL@@UAGJH@Z PROC NEAR	; ATL::CComClassFactory::LockServer, COMDAT

; 3186 : 	{

	push	ebp
	mov	ebp, esp
	push	esi

; 3187 : 		if (fLock)

	cmp	DWORD PTR _fLock$[ebp], 0
	je	SHORT $L93589

; 3188 : 			_pAtlModule->Lock();

	mov	eax, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3189 : 		else

	jmp	SHORT $L93590
$L93589:

; 3190 : 			_pAtlModule->Unlock();

	mov	eax, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L93590:

; 3191 : 		return S_OK;

	xor	eax, eax

; 3192 : 	}

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
?LockServer@CComClassFactory@ATL@@UAGJH@Z ENDP		; ATL::CComClassFactory::LockServer
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pv$ = 8						; size = 4
?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z PROC NEAR	; ATL::CComClassFactory::SetVoid, COMDAT
; _this$ = ecx

; 3195 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3196 : 		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 3197 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetVoid@CComClassFactory@ATL@@QAEXPAX@Z ENDP		; ATL::CComClassFactory::SetVoid
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??_GCComClassFactory@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCComClassFactory@ATL@@UAEPAXI@Z PROC NEAR		; ATL::CComClassFactory::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComClassFactory@ATL@@UAE@XZ		; ATL::CComClassFactory::~CComClassFactory
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L93598
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L93598:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCComClassFactory@ATL@@UAEPAXI@Z ENDP		; ATL::CComClassFactory::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1CComAutoCriticalSection@ATL@@QAE@XZ		; ATL::CComAutoCriticalSection::~CComAutoCriticalSection
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1CComAutoCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoCriticalSection::~CComAutoCriticalSection
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcore.h
_TEXT	ENDS
;	COMDAT ??1CComAutoCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComAutoCriticalSection@ATL@@QAE@XZ PROC NEAR	; ATL::CComAutoCriticalSection::~CComAutoCriticalSection, COMDAT
; _this$ = ecx

; 164  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		CComCriticalSection::Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Term

; 166  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComAutoCriticalSection@ATL@@QAE@XZ ENDP		; ATL::CComAutoCriticalSection::~CComAutoCriticalSection
_TEXT	ENDS
PUBLIC	??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L209041
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L209041:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ	; ATL::CComObjectRootBase::FinalRelease
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
xdata$x	SEGMENT
$T212618 DD	0ffffffffH
	DD	FLAT:$L212613
	DD	00H
	DD	FLAT:$L212614
$T212616 DD	019930520H
	DD	02H
	DD	FLAT:$T212618
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ PROC NEAR ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>, COMDAT
; _this$ = ecx

; 2568 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 2569 : 		m_dwRef = -(LONG_MAX/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1073741823		; c0000001H

; 2570 : 		FinalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::FinalRelease

; 2571 : #ifdef _ATL_DEBUG_INTERFACES
; 2572 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2573 : #endif
; 2574 : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1CComAutoCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoCriticalSection::~CComAutoCriticalSection
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComClassFactory@ATL@@UAE@XZ		; ATL::CComClassFactory::~CComClassFactory
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212613:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CComClassFactory@ATL@@UAE@XZ		; ATL::CComClassFactory::~CComClassFactory
$L212614:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CComAutoCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoCriticalSection::~CComAutoCriticalSection
__ehhandler$??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T212616
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ PROC NEAR	; ATL::CComObjectRootBase::FinalRelease, COMDAT
; _this$ = ecx

; 2141 : 	void FinalRelease() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ ENDP	; ATL::CComObjectRootBase::FinalRelease
_TEXT	ENDS
PUBLIC	??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>
PUBLIC	??0IClassFactory@@QAE@XZ			; IClassFactory::IClassFactory
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CComClassFactory@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComClassFactory@ATL@@QAE@XZ PROC NEAR		; ATL::CComClassFactory::CComClassFactory, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IClassFactory@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CComClassFactory@ATL@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComClassFactory@ATL@@QAE@XZ ENDP			; ATL::CComClassFactory::CComClassFactory
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0IClassFactory@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0IClassFactory@@QAE@XZ PROC NEAR			; IClassFactory::IClassFactory, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0IClassFactory@@QAE@XZ ENDP				; IClassFactory::IClassFactory
_TEXT	ENDS
PUBLIC	??0CComObjectRootBase@ATL@@QAE@XZ		; ATL::CComObjectRootBase::CComObjectRootBase
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComObjectRootBase@ATL@@QAE@XZ	; ATL::CComObjectRootBase::CComObjectRootBase
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComAutoCriticalSection@ATL@@QAE@XZ	; ATL::CComAutoCriticalSection::CComAutoCriticalSection
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::CComObjectRootEx<ATL::CComMultiThreadModel>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0CComObjectRootBase@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComObjectRootBase@ATL@@QAE@XZ PROC NEAR		; ATL::CComObjectRootBase::CComObjectRootBase, COMDAT
; _this$ = ecx

; 2128 : 	CComObjectRootBase()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2129 : 	{
; 2130 : 		m_dwRef = 0L;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 2131 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComObjectRootBase@ATL@@QAE@XZ ENDP			; ATL::CComObjectRootBase::CComObjectRootBase
_TEXT	ENDS
PUBLIC	?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z	; ATL::CComMultiThreadModel::Increment
; Function compile flags: /Odt /RTCsu
;	COMDAT ?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalAddRef, COMDAT
; _this$ = ecx

; 2293 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2294 : 		ATLASSERT(m_dwRef != -1L);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $L212635
	push	OFFSET FLAT:??_C@_0P@IDNKKMJE@m_dwRef?5?$CB?$DN?5?91L?$AA@
	push	0
	push	2294					; 000008f6H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212635
	int	3
$L212635:

; 2295 : 		return _ThreadModel::Increment(&m_dwRef);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z ; ATL::CComMultiThreadModel::Increment

; 2296 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalAddRef@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalAddRef
_TEXT	ENDS
EXTRN	__imp__InterlockedIncrement@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z PROC NEAR	; ATL::CComMultiThreadModel::Increment, COMDAT

; 347  : 	static ULONG WINAPI Increment(LPLONG p) throw() {return InterlockedIncrement(p);}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR __imp__InterlockedIncrement@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z ENDP	; ATL::CComMultiThreadModel::Increment
_TEXT	ENDS
PUBLIC	?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z	; ATL::CComMultiThreadModel::Decrement
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
;	COMDAT ?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ
_TEXT	SEGMENT
_nRef$ = -8						; size = 4
_this$ = -4						; size = 4
?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalRelease, COMDAT
; _this$ = ecx

; 2298 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2299 : #ifdef _DEBUG
; 2300 : 		LONG nRef = _ThreadModel::Decrement(&m_dwRef);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z ; ATL::CComMultiThreadModel::Decrement
	mov	DWORD PTR _nRef$[ebp], eax

; 2301 : 		if (nRef < -(LONG_MAX / 2))

	cmp	DWORD PTR _nRef$[ebp], -1073741823	; c0000001H
	jge	SHORT $L209054

; 2302 : 		{
; 2303 : 			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));

	xor	ecx, ecx
	jne	SHORT $L209054
	push	OFFSET FLAT:??_C@_0EC@FOHBGNDM@0?5?$CG?$CG?5?$CCRelease?5called?5on?5a?5pointe@
	push	0
	push	2303					; 000008ffH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L209054
	int	3
$L209054:

; 2304 : 		}
; 2305 : 		return nRef;

	mov	eax, DWORD PTR _nRef$[ebp]

; 2306 : #else
; 2307 : 		return _ThreadModel::Decrement(&m_dwRef);
; 2308 : #endif
; 2309 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?InternalRelease@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEKXZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::InternalRelease
_TEXT	ENDS
EXTRN	__imp__InterlockedDecrement@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z PROC NEAR	; ATL::CComMultiThreadModel::Decrement, COMDAT

; 348  : 	static ULONG WINAPI Decrement(LPLONG p) throw() {return InterlockedDecrement(p);}

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, esp
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	DWORD PTR __imp__InterlockedDecrement@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z ENDP	; ATL::CComMultiThreadModel::Decrement
_TEXT	ENDS
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC NEAR ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $L93948
	push	OFFSET FLAT:??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $L93949
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L93949:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $L93947
$L93948:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L93951
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L93951:
	mov	eax, DWORD PTR _this$[ebp]
$L93947:
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::~CComBSTR
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC NEAR ; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
EXTRN	__imp__SysFreeString@4:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??1CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComBSTR@ATL@@QAE@XZ PROC NEAR			; ATL::CComBSTR::~CComBSTR, COMDAT
; _this$ = ecx

; 628  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 629  : 		::SysFreeString(m_str);

	mov	esi, esp
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 630  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::~CComBSTR
_TEXT	ENDS
PUBLIC	?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ	; ATL::CComObject<CSignature>::AddRef
PUBLIC	?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ	; ATL::CComObject<CSignature>::Release
PUBLIC	?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::QueryInterface
PUBLIC	??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComObject<CSignature>::`vftable'
PUBLIC	??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@ ; ATL::CComObject<CSignature>::`vftable'
PUBLIC	??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@ ; ATL::CComObject<CSignature>::`vftable'
PUBLIC	??_G?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z	; ATL::CComObject<CSignature>::`scalar deleting destructor'
PUBLIC	?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ	; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{4}'
PUBLIC	?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ ; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{4}'
PUBLIC	?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ	; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{8}'
PUBLIC	?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ ; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{8}'
PUBLIC	?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount
PUBLIC	?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo
PUBLIC	?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames
PUBLIC	?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::Invoke
EXTRN	?get_HMACPassword@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_HMACPassword
EXTRN	?put_HMACPassword@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_HMACPassword
EXTRN	?get_UseHMAC@CSignature@@UAGJPAH@Z:NEAR		; CSignature::get_UseHMAC
EXTRN	?put_UseHMAC@CSignature@@UAGJH@Z:NEAR		; CSignature::put_UseHMAC
EXTRN	?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z:NEAR ; CSignature::SignXMLXpathStr
EXTRN	?get_AddWindowImage@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_AddWindowImage
EXTRN	?put_AddWindowImage@CSignature@@UAGJH@Z:NEAR	; CSignature::put_AddWindowImage
EXTRN	?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z:NEAR ; CSignature::VerifyPFXCertCRL
EXTRN	?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z:NEAR ; CSignature::VerifyX509CertCRL
EXTRN	??_E?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z:NEAR ; ATL::CComObject<CSignature>::`vector deleting destructor'
EXTRN	?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z:NEAR ; CSignature::get_SigCertStatus
EXTRN	?get_CrlChecking@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_CrlChecking
EXTRN	?put_CrlChecking@CSignature@@UAGJH@Z:NEAR	; CSignature::put_CrlChecking
EXTRN	?get_HostOsType@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::get_HostOsType
EXTRN	?get_TimeStamping@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_TimeStamping
EXTRN	?put_TimeStamping@CSignature@@UAGJH@Z:NEAR	; CSignature::put_TimeStamping
EXTRN	?get_TimeStampURL@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_TimeStampURL
EXTRN	?put_TimeStampURL@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_TimeStampURL
EXTRN	?get_HostName@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_HostName
EXTRN	?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::PFXExportActiveCertificate
EXTRN	?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SetActivePFXFileCert
EXTRN	?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z:NEAR	; CSignature::VerifyXMLStr
EXTRN	?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::SelectActiveCertificate
EXTRN	?ViewAnyCertificate@CSignature@@UAGJPAG@Z:NEAR	; CSignature::ViewAnyCertificate
EXTRN	?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z:NEAR ; CSignature::QueryStatus
EXTRN	?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z:NEAR ; CSignature::Exec
EXTRN	?SetSite@CSignature@@UAGJPAUIUnknown@@@Z:NEAR	; CSignature::SetSite
EXTRN	?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z:NEAR	; CSignature::GetSite
EXTRN	?GetPropertyCount@CSignature@@UAGJJPAJ@Z:NEAR	; CSignature::GetPropertyCount
EXTRN	?GetLicenseStatus@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::GetLicenseStatus
EXTRN	?GetVersion@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::GetVersion
EXTRN	?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SignXMLEnveloped
EXTRN	?GetStoreName@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::GetStoreName
EXTRN	?SetStoreName@CSignature@@UAGJPAG@Z:NEAR	; CSignature::SetStoreName
EXTRN	?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::GetSignedFileObject
EXTRN	?SignFile@CSignature@@UAGJPAG0@Z:NEAR		; CSignature::SignFile
EXTRN	?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::GetSignedHTML
EXTRN	?SetCSP@CSignature@@UAGJPAG@Z:NEAR		; CSignature::SetCSP
EXTRN	?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::SecureXMLVerify
EXTRN	?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z:NEAR ; CSignature::SignHTML
EXTRN	?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::SaveXMLStr
EXTRN	?ReadAll@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::ReadAll
EXTRN	?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::SignXMLStr
EXTRN	?get_SignatureCount@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::get_SignatureCount
EXTRN	?get_FailedUri@CSignature@@UAGJJPAPAG@Z:NEAR	; CSignature::get_FailedUri
EXTRN	?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z:NEAR ; CSignature::get_FailedUriFullPath
EXTRN	?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z:NEAR ; CSignature::put_FailedUriFullPath
EXTRN	?get_TotalUriCount@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::get_TotalUriCount
EXTRN	?get_FailedUriCount@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::get_FailedUriCount
EXTRN	?FileExists@CSignature@@UAGJPAGPAH@Z:NEAR	; CSignature::FileExists
EXTRN	?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::get_CertSerialNumber
EXTRN	?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::get_CertExpiry
EXTRN	?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::get_CertIssuer
EXTRN	?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::get_SignerSubject
EXTRN	?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z:NEAR ; CSignature::get_SignedDocumentPath
EXTRN	?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z:NEAR ; CSignature::SetActiveCertificate
EXTRN	?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z:NEAR ; CSignature::GetCertificateInfo
EXTRN	?get_CertificateCount@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_CertificateCount
EXTRN	?ViewCertificate@CSignature@@UAGJPAG@Z:NEAR	; CSignature::ViewCertificate
EXTRN	?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::GetX509Certificate
EXTRN	?GetLastError@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::GetLastError
EXTRN	?VerifyDetached@CSignature@@UAGJPAGPAH@Z:NEAR	; CSignature::VerifyDetached
EXTRN	?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::PFXExportCertificate
EXTRN	?GetError@CSignature@@UAGJPAPAG@Z:NEAR		; CSignature::GetError
EXTRN	?Verify@CSignature@@UAGJPAGPAH@Z:NEAR		; CSignature::Verify
EXTRN	?SaveXMLSignature@CSignature@@UAGJPAG@Z:NEAR	; CSignature::SaveXMLSignature
EXTRN	?get_IncludeCamResponse@CSignature@@UAGJPAH@Z:NEAR ; CSignature::get_IncludeCamResponse
EXTRN	?put_IncludeCamResponse@CSignature@@UAGJH@Z:NEAR ; CSignature::put_IncludeCamResponse
EXTRN	?Sign@CSignature@@UAGJPAGPAPAG@Z:NEAR		; CSignature::Sign
EXTRN	?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_PhysicalSignatureFile
EXTRN	?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_PhysicalSignatureFile
EXTRN	?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_CapturedSignatureFile
EXTRN	?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_PhysicalSignatureUsage
EXTRN	?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z:NEAR ; CSignature::put_PhysicalSignatureUsage
EXTRN	?get_SignatureStatus@CSignature@@UAGJJPAH@Z:NEAR ; CSignature::get_SignatureStatus
EXTRN	?get_Language@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_Language
EXTRN	?put_Language@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_Language
EXTRN	?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z:NEAR ; CSignature::get_DigestObjectStatus
EXTRN	?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z:NEAR	; CSignature::get_DocumentURI
EXTRN	?get_Base64DecodeXML@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_Base64DecodeXML
EXTRN	?put_Base64DecodeXML@CSignature@@UAGJH@Z:NEAR	; CSignature::put_Base64DecodeXML
EXTRN	?get_Base64EncodeXML@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_Base64EncodeXML
EXTRN	?put_Base64EncodeXML@CSignature@@UAGJH@Z:NEAR	; CSignature::put_Base64EncodeXML
EXTRN	?get_Properties@CSignature@@UAGJJJPAPAG@Z:NEAR	; CSignature::get_Properties
EXTRN	?put_Properties@CSignature@@UAGJJJPAG@Z:NEAR	; CSignature::put_Properties
EXTRN	?get_SignatureID@CSignature@@UAGJJPAPAG@Z:NEAR	; CSignature::get_SignatureID
EXTRN	?put_SignatureID@CSignature@@UAGJJPAG@Z:NEAR	; CSignature::put_SignatureID
EXTRN	?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z:NEAR ; CSignature::get_SignerCertificate
EXTRN	?put_SignerCertificate@CSignature@@UAGJJPAG@Z:NEAR ; CSignature::put_SignerCertificate
EXTRN	?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_RecipientCertificateStore
EXTRN	?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_RecipientCertificateStore
EXTRN	?get_EnvelopingFlag@CSignature@@UAGJPAF@Z:NEAR	; CSignature::get_EnvelopingFlag
EXTRN	?put_EnvelopingFlag@CSignature@@UAGJF@Z:NEAR	; CSignature::put_EnvelopingFlag
EXTRN	?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_XpathNamespace
EXTRN	?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_RecipientCertificates
EXTRN	?EncryptStr@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::EncryptStr
EXTRN	?DecryptStr@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::DecryptStr
EXTRN	?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::EncryptFileA
EXTRN	?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::DecryptFileA
EXTRN	?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_TrustedRoots
EXTRN	?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_RecipientCertificateFiles
EXTRN	?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_DetachedObjects
EXTRN	?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_AttachedObjects
EXTRN	?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::ReadAllBase64
EXTRN	?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_DecryptionPFXCertFile
EXTRN	?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z:NEAR ; CSignature::put_DecryptUsingPFXFileCert
EXTRN	?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_DecryptionPFXPassword
EXTRN	?get_CamServerHost@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_CamServerHost
EXTRN	?put_CamServerHost@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_CamServerHost
EXTRN	?get_CamServerPort@CSignature@@UAGJPAG@Z:NEAR	; CSignature::get_CamServerPort
EXTRN	?put_CamServerPort@CSignature@@UAGJG@Z:NEAR	; CSignature::put_CamServerPort
EXTRN	?get_UseCam@CSignature@@UAGJPAH@Z:NEAR		; CSignature::get_UseCam
EXTRN	?put_UseCam@CSignature@@UAGJH@Z:NEAR		; CSignature::put_UseCam
EXTRN	?get_AgencyId@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_AgencyId
EXTRN	?put_AgencyId@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_AgencyId
EXTRN	?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_CamValidationResponse
EXTRN	?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z:NEAR ; CSignature::GetSigPropValueByName
EXTRN	?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::Base64DecodeBufferToFile
EXTRN	?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::Base64DecodeFileToFile
EXTRN	?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::GunZipFile
EXTRN	?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_CertSerialNumberFormat
EXTRN	?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z:NEAR ; CSignature::put_CertSerialNumberFormat
EXTRN	?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::SecureXMLVerifyFileToBuffer
EXTRN	?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SecureXMLVerifyFileToFile
EXTRN	?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::DeleteSignatureFromXMLStr
EXTRN	?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z:NEAR ; CSignature::DeleteSignatureFromFile
EXTRN	?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_AllowedCertIssuerNames
EXTRN	?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_CRLCacheDbConnectionString
EXTRN	?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_CRLCacheDbConnectionString
EXTRN	?get_UseCRLCache@CSignature@@UAGJPAH@Z:NEAR	; CSignature::get_UseCRLCache
EXTRN	?put_UseCRLCache@CSignature@@UAGJH@Z:NEAR	; CSignature::put_UseCRLCache
EXTRN	?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z:NEAR ; CSignature::put_CRLCacheTimeoutInMinutes
EXTRN	?put_CanonicalizationMethod@CSignature@@UAGJK@Z:NEAR ; CSignature::put_CanonicalizationMethod
EXTRN	?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_NetscapeStorePassword
EXTRN	?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_NetscapeStorePassword
EXTRN	?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SetActivePEMFileCert
EXTRN	?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z:NEAR	; CSignature::get_SecureXMLPath
EXTRN	?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z:NEAR ; CSignature::get_SignedDocumentCount
EXTRN	?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z:NEAR ; CSignature::SignXMLByteArray
EXTRN	?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:NEAR ; CSignature::SaveXMLByteArray
EXTRN	?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z:NEAR ; CSignature::ReadAllByteArray
EXTRN	?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z:NEAR ; CSignature::VerifyXMLByteArray
EXTRN	?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:NEAR ; CSignature::SecureXMLVerifyByteArray
EXTRN	?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z:NEAR ; CSignature::SignXMLXpathByteArray
EXTRN	?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z:NEAR ; CSignature::SignXMLEnvelopedByteArray
EXTRN	?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:NEAR ; CSignature::Base64DecodeByteArrayToFile
EXTRN	?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:NEAR ; CSignature::Base64DecodeByteArrayToByteArray
EXTRN	?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z:NEAR ; CSignature::Base64EncodeByteArrayToByteArray
EXTRN	?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:NEAR ; CSignature::Base64EncodeByteArrayToFile
EXTRN	?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::Base64EncodeStrToFile
EXTRN	?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::Base64EncodeStrToStr
EXTRN	?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SetActivePFXB64Data
EXTRN	?get_FloatingLicense@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_FloatingLicense
EXTRN	?put_FloatingLicense@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_FloatingLicense
EXTRN	?get_LicensedUserCount@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_LicensedUserCount
EXTRN	?put_IncludeCRLInSignature@CSignature@@UAGJH@Z:NEAR ; CSignature::put_IncludeCRLInSignature
EXTRN	?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z:NEAR ; CSignature::get_UsedCRLList
EXTRN	?GetErrorDetail@CSignature@@UAGJJPAPAG@Z:NEAR	; CSignature::GetErrorDetail
EXTRN	?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_PhysicalSignatureB64Str
EXTRN	?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::GetSignedInfoDigest
EXTRN	?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::GetX509CertificateChain
EXTRN	?put_SignerCertificateChain@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_SignerCertificateChain
EXTRN	?get_SignatureImageId@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_SignatureImageId
EXTRN	?put_SignatureImageId@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_SignatureImageId
EXTRN	?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z:NEAR ; CSignature::SignSignedInfoDigest
EXTRN	?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z:NEAR ; CSignature::ApplySignatureValue
EXTRN	?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:NEAR ; CSignature::GetSignedInfoDigestFromByteArray
EXTRN	?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z:NEAR ; CSignature::ApplySignatureValueGetByteArray
EXTRN	?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z:NEAR ; CSignature::GetSignedDocumentB64Str
EXTRN	?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z:NEAR ; CSignature::GetSignedDocumentByteArray
EXTRN	?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_CertValidationTransactionId
EXTRN	?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_CertValidationTransactionId
EXTRN	?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z:NEAR ; CSignature::get_IgnoreIncompleteSignature
EXTRN	?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z:NEAR ; CSignature::put_IgnoreIncompleteSignature
EXTRN	?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_SignatureIndexToVerify
EXTRN	?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z:NEAR ; CSignature::put_SignatureIndexToVerify
EXTRN	?get_UseOcsp@CSignature@@UAGJPAH@Z:NEAR		; CSignature::get_UseOcsp
EXTRN	?put_UseOcsp@CSignature@@UAGJH@Z:NEAR		; CSignature::put_UseOcsp
EXTRN	?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspTrustedRespSignerCertPath
EXTRN	?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_OcspTrustedRespSignerCertPath
EXTRN	?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspReqSignerPFXCertPath
EXTRN	?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_OcspReqSignerPFXCertPath
EXTRN	?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspReqSignerPFXCertPassword
EXTRN	?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_OcspReqSignerPFXCertPassword
EXTRN	?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspResponderURL
EXTRN	?put_OcspResponderURL@CSignature@@UAGJPAG@Z:NEAR ; CSignature::put_OcspResponderURL
EXTRN	?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspTextResponse
EXTRN	?get_OcspB64Response@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_OcspB64Response
EXTRN	?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::get_CertRevocationDate
EXTRN	?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_IncludeOcspResponse
EXTRN	?put_IncludeOcspResponse@CSignature@@UAGJJ@Z:NEAR ; CSignature::put_IncludeOcspResponse
EXTRN	?put_ProxyHost@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_ProxyHost
EXTRN	?put_ProxyPort@CSignature@@UAGJG@Z:NEAR		; CSignature::put_ProxyPort
EXTRN	?put_ProxyUserName@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_ProxyUserName
EXTRN	?put_ProxyPassword@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_ProxyPassword
EXTRN	?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_InclusiveNamespacePrefixList
EXTRN	?get_TimeStampFormat@CSignature@@UAGJPAJ@Z:NEAR	; CSignature::get_TimeStampFormat
EXTRN	?put_TimeStampFormat@CSignature@@UAGJJ@Z:NEAR	; CSignature::put_TimeStampFormat
EXTRN	?get_TimeStampCritical@CSignature@@UAGJPAJ@Z:NEAR ; CSignature::get_TimeStampCritical
EXTRN	?put_TimeStampCritical@CSignature@@UAGJJ@Z:NEAR	; CSignature::put_TimeStampCritical
EXTRN	??0CSignature@@QAE@XZ:NEAR			; CSignature::CSignature
EXTRN	?put_CertificateTrustExplicit@CSignature@@UAGJH@Z:NEAR ; CSignature::put_CertificateTrustExplicit
EXTRN	?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z:NEAR ; CSignature::get_CertificatePolicyExplicit
EXTRN	?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z:NEAR ; CSignature::put_CertificatePolicyExplicit
EXTRN	?put_DoDCompliance@CSignature@@UAGJH@Z:NEAR	; CSignature::put_DoDCompliance
EXTRN	?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z:NEAR ; CSignature::put_CertificatePathLengthChecking
EXTRN	?put_CertificateChainValidation@CSignature@@UAGJH@Z:NEAR ; CSignature::put_CertificateChainValidation
EXTRN	?put_CertificatePolicyChecking@CSignature@@UAGJH@Z:NEAR ; CSignature::put_CertificatePolicyChecking
EXTRN	?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z:NEAR ; CSignature::get_UserConstrainedPolicy
EXTRN	?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z:NEAR ; CSignature::get_AuthorityConstrainedPolicy
EXTRN	?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_CertificatePolicy
EXTRN	?VerifyActiveCertificate@CSignature@@UAGJPAH@Z:NEAR ; CSignature::VerifyActiveCertificate
EXTRN	?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z:NEAR ; CSignature::put_CRLLocation
EXTRN	?put_ConfigFileName@CSignature@@UAGJPAG@Z:NEAR	; CSignature::put_ConfigFileName
EXTRN	?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z:NEAR ; CSignature::SignFiles
EXTRN	?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z:NEAR	; CSignature::CoSignFile
EXTRN	?put_OverwriteFile@CSignature@@UAGJH@Z:NEAR	; CSignature::put_OverwriteFile
EXTRN	?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::CoSignXMLStr
EXTRN	?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z:NEAR ; CSignature::put_ExcludeSignerCertificate
EXTRN	?SignDataStr@CSignature@@UAGJPAGPAPAG@Z:NEAR	; CSignature::SignDataStr
EXTRN	?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z:NEAR ; CSignature::CaptureLiveSignature
EXTRN	?put_DetailedVerificationFlag@CSignature@@UAGJH@Z:NEAR ; CSignature::put_DetailedVerificationFlag
EXTRN	?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z:NEAR ; CSignature::ChangeOrAddProperty
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
CONST	SEGMENT
??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
	DD	FLAT:?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
	DD	FLAT:?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
	DD	FLAT:?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
	DD	FLAT:?get_EnvelopingFlag@CSignature@@UAGJPAF@Z
	DD	FLAT:?put_EnvelopingFlag@CSignature@@UAGJF@Z
	DD	FLAT:?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_SignerCertificate@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_SignatureID@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_SignatureID@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_Properties@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?put_Properties@CSignature@@UAGJJJPAG@Z
	DD	FLAT:?get_Base64EncodeXML@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_Base64EncodeXML@CSignature@@UAGJH@Z
	DD	FLAT:?get_Base64DecodeXML@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_Base64DecodeXML@CSignature@@UAGJH@Z
	DD	FLAT:?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z
	DD	FLAT:?get_Language@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_Language@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignatureStatus@CSignature@@UAGJJPAH@Z
	DD	FLAT:?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z
	DD	FLAT:?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?Sign@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_IncludeCamResponse@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_IncludeCamResponse@CSignature@@UAGJH@Z
	DD	FLAT:?SaveXMLSignature@CSignature@@UAGJPAG@Z
	DD	FLAT:?Verify@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?GetError@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OverwriteFile@CSignature@@UAGJH@Z
	DD	FLAT:?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?VerifyDetached@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?GetLastError@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?ViewCertificate@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CertificateCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?FileExists@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?get_FailedUriCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_TotalUriCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_FailedUri@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?get_SignatureCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?ReadAll@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z
	DD	FLAT:?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SetCSP@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SignFile@CSignature@@UAGJPAG0@Z
	DD	FLAT:?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SetStoreName@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetStoreName@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GetVersion@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?GetLicenseStatus@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetPropertyCount@CSignature@@UAGJJPAJ@Z
	DD	FLAT:?ViewAnyCertificate@CSignature@@UAGJPAG@Z
	DD	FLAT:?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_HostName@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_TimeStampURL@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_TimeStampURL@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_TimeStamping@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_TimeStamping@CSignature@@UAGJH@Z
	DD	FLAT:?get_HostOsType@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_CrlChecking@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CrlChecking@CSignature@@UAGJH@Z
	DD	FLAT:?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z
	DD	FLAT:?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z
	DD	FLAT:?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z
	DD	FLAT:?get_AddWindowImage@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_AddWindowImage@CSignature@@UAGJH@Z
	DD	FLAT:?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?VerifyActiveCertificate@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?put_CertificatePolicyChecking@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificateChainValidation@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z
	DD	FLAT:?put_ConfigFileName@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_DoDCompliance@CSignature@@UAGJH@Z
	DD	FLAT:?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificateTrustExplicit@CSignature@@UAGJH@Z
	DD	FLAT:?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z
	DD	FLAT:?get_UseHMAC@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseHMAC@CSignature@@UAGJH@Z
	DD	FLAT:?get_HMACPassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_HMACPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z
	DD	FLAT:?put_DetailedVerificationFlag@CSignature@@UAGJH@Z
	DD	FLAT:?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?SignDataStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z
	DD	FLAT:?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?EncryptStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?DecryptStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z
	DD	FLAT:?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_CamServerHost@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CamServerHost@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CamServerPort@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_CamServerPort@CSignature@@UAGJG@Z
	DD	FLAT:?get_UseCam@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseCam@CSignature@@UAGJH@Z
	DD	FLAT:?get_AgencyId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_AgencyId@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z
	DD	FLAT:?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z
	DD	FLAT:?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z
	DD	FLAT:?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_UseCRLCache@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseCRLCache@CSignature@@UAGJH@Z
	DD	FLAT:?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z
	DD	FLAT:?put_CanonicalizationMethod@CSignature@@UAGJK@Z
	DD	FLAT:?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z
	DD	FLAT:?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	DD	FLAT:?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	DD	FLAT:?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z
	DD	FLAT:?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z
	DD	FLAT:?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	DD	FLAT:?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_FloatingLicense@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_FloatingLicense@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_LicensedUserCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_IncludeCRLInSignature@CSignature@@UAGJH@Z
	DD	FLAT:?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?GetErrorDetail@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_SignerCertificateChain@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignatureImageId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_SignatureImageId@CSignature@@UAGJPAG@Z
	DD	FLAT:?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	DD	FLAT:?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z
	DD	FLAT:?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z
	DD	FLAT:?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z
	DD	FLAT:?get_UseOcsp@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseOcsp@CSignature@@UAGJH@Z
	DD	FLAT:?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspResponderURL@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_OcspB64Response@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_IncludeOcspResponse@CSignature@@UAGJJ@Z
	DD	FLAT:?put_ProxyHost@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_ProxyPort@CSignature@@UAGJG@Z
	DD	FLAT:?put_ProxyUserName@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_ProxyPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_TimeStampFormat@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_TimeStampFormat@CSignature@@UAGJJ@Z
	DD	FLAT:?get_TimeStampCritical@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_TimeStampCritical@CSignature@@UAGJJ@Z
	DD	FLAT:??_E?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
CONST	SEGMENT
??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@ DD FLAT:?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
	DD	FLAT:?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
	DD	FLAT:?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z
	DD	FLAT:?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@
CONST	SEGMENT
??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@ DD FLAT:?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
	DD	FLAT:?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
	DD	FLAT:?SetSite@CSignature@@UAGJPAUIUnknown@@@Z
	DD	FLAT:?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z PROC NEAR	; ATL::CComObject<CSignature>::CComObject<CSignature>, COMDAT
; _this$ = ecx

; 2489 : 	CComObject(void* = NULL) throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CSignature@@QAE@XZ			; CSignature::CSignature
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@

; 2490 : 	{
; 2491 : 		_pAtlModule->Lock();

	mov	eax, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [eax]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2492 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CComObject@VCSignature@@@ATL@@QAE@PAX@Z ENDP	; ATL::CComObject<CSignature>::CComObject<CSignature>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pctinfo$ = 12						; size = 4
?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z PROC NEAR ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount, COMDAT

; 4391 : 	{

	push	ebp
	mov	ebp, esp

; 4392 : 		if (pctinfo == NULL) 

	cmp	DWORD PTR _pctinfo$[ebp], 0
	jne	SHORT $L208325

; 4393 : 			return E_POINTER; 

	mov	eax, -2147467261			; 80004003H
	jmp	SHORT $L208324
$L208325:

; 4394 : 		*pctinfo = 1;

	mov	eax, DWORD PTR _pctinfo$[ebp]
	mov	DWORD PTR [eax], 1

; 4395 : 		return S_OK;

	xor	eax, eax
$L208324:

; 4396 : 	}

	pop	ebp
	ret	8
?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z ENDP ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount
_TEXT	ENDS
PUBLIC	?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTypeInfo
PUBLIC	?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::_tih
;	COMDAT ?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT
?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A DD FLAT:_IID_ISignature ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::_tih
	DD	FLAT:_LIBID_XMLSIGNLib
	DW	01H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Odt /RTCsu
_DATA	ENDS
;	COMDAT ?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_itinfo$ = 12						; size = 4
_lcid$ = 16						; size = 4
_pptinfo$ = 20						; size = 4
?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z PROC NEAR ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo, COMDAT

; 4398 : 	{

	push	ebp
	mov	ebp, esp

; 4399 : 		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);

	mov	eax, DWORD PTR _pptinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _itinfo$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
	call	?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTypeInfo

; 4400 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	16					; 00000010H
?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z ENDP ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo
_TEXT	ENDS
PUBLIC	?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z ; ATL::CComTypeInfoHolder::GetIDsOfNames
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_rgszNames$ = 16					; size = 4
_cNames$ = 20						; size = 4
_lcid$ = 24						; size = 4
_rgdispid$ = 28						; size = 4
?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z PROC NEAR ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames, COMDAT

; 4403 : 	{

	push	ebp
	mov	ebp, esp

; 4404 : 		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

	mov	eax, DWORD PTR _rgdispid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cNames$[ebp]
	push	edx
	mov	eax, DWORD PTR _rgszNames$[ebp]
	push	eax
	mov	ecx, DWORD PTR _riid$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
	call	?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z ; ATL::CComTypeInfoHolder::GetIDsOfNames

; 4405 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	24					; 00000018H
?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z ENDP ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames
_TEXT	ENDS
PUBLIC	?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::CComTypeInfoHolder::Invoke
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dispidMember$ = 12					; size = 4
_riid$ = 16						; size = 4
_lcid$ = 20						; size = 4
_wFlags$ = 24						; size = 2
_pdispparams$ = 28					; size = 4
_pvarResult$ = 32					; size = 4
_pexcepinfo$ = 36					; size = 4
_puArgErr$ = 40						; size = 4
?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z PROC NEAR ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::Invoke, COMDAT

; 4409 : 	{

	push	ebp
	mov	ebp, esp

; 4410 : 		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
; 4411 : 		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

	mov	eax, DWORD PTR _puArgErr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pexcepinfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvarResult$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdispparams$[ebp]
	push	eax
	mov	cx, WORD PTR _wFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	mov	eax, DWORD PTR _riid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dispidMember$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_tih@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
	call	?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::CComTypeInfoHolder::Invoke

; 4412 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	36					; 00000024H
?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ENDP ; ATL::IDispatchImpl<ISignature,&IID_ISignature,&LIBID_XMLSIGNLib,1,0,ATL::CComTypeInfoHolder>::Invoke
_TEXT	ENDS
PUBLIC	?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTI
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
_lcid$ = 12						; size = 4
_pptinfo$ = 16						; size = 4
?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z PROC NEAR ; ATL::CComTypeInfoHolder::GetTypeInfo, COMDAT
; _this$ = ecx

; 3544 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3545 : 		return GetTI(lcid, pptinfo);

	mov	eax, DWORD PTR _pptinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lcid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTI

; 3546 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetTypeInfo@CComTypeInfoHolder@ATL@@QAEJIKPAPAUITypeInfo@@@Z ENDP ; ATL::CComTypeInfoHolder::GetTypeInfo
_TEXT	ENDS
PUBLIC	?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z		; ATL::CComTypeInfoHolder::GetTI
PUBLIC	??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@ DB 'ppInfo != 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_lcid$ = 8						; size = 4
_ppInfo$ = 12						; size = 4
?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z PROC NEAR ; ATL::CComTypeInfoHolder::GetTI, COMDAT
; _this$ = ecx

; 3502 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3503 : 		ATLASSERT(ppInfo != NULL);

	cmp	DWORD PTR _ppInfo$[ebp], 0
	jne	SHORT $L212663
	push	OFFSET FLAT:??_C@_0M@NNHBFKBG@ppInfo?5?$CB?$DN?50?$AA@
	push	0
	push	3503					; 00000dafH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212663
	int	3
$L212663:

; 3504 : 		if (ppInfo == NULL)

	cmp	DWORD PTR _ppInfo$[ebp], 0
	jne	SHORT $L93872

; 3505 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	SHORT $L93869
$L93872:

; 3506 : 
; 3507 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3508 : 		if (m_pInfo == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $L93876

; 3509 : 			hr = GetTI(lcid);

	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z	; ATL::CComTypeInfoHolder::GetTI
	mov	DWORD PTR _hr$[ebp], eax
$L93876:

; 3510 : 		*ppInfo = m_pInfo;

	mov	eax, DWORD PTR _ppInfo$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx

; 3511 : 		if (m_pInfo != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L93877

; 3512 : 		{
; 3513 : 			m_pInfo->AddRef();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3514 : 			hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0
$L93877:

; 3515 : 		}
; 3516 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L93869:

; 3517 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ENDP ; ATL::CComTypeInfoHolder::GetTI
_TEXT	ENDS
PUBLIC	?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z	; ATL::CComTypeInfoHolder::EnsureTI
PUBLIC	??BCComBSTR@ATL@@QBEPAGXZ			; ATL::CComBSTR::operator unsigned short *
; Function compile flags: /Odt /RTCsu
;	COMDAT ?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z
_TEXT	SEGMENT
_j$93903 = -16						; size = 4
_n$93902 = -12						; size = 4
_hRes$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
_rgszNames$ = 12					; size = 4
_cNames$ = 16						; size = 4
_lcid$ = 20						; size = 4
_rgdispid$ = 24						; size = 4
?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z PROC NEAR ; ATL::CComTypeInfoHolder::GetIDsOfNames, COMDAT
; _this$ = ecx

; 3549 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3550 : 		HRESULT hRes = EnsureTI(lcid);

	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z ; ATL::CComTypeInfoHolder::EnsureTI
	mov	DWORD PTR _hRes$[ebp], eax

; 3551 : 		if (m_pInfo != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	$L93899

; 3552 : 		{
; 3553 : 			hRes = E_FAIL;

	mov	DWORD PTR _hRes$[ebp], -2147467259	; 80004005H

; 3554 : 			// Look in cache if
; 3555 : 			//	cache is populated
; 3556 : 			//	parameter names are not requested
; 3557 : 			if (m_pMap != NULL && cNames == 1)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	$L93901
	cmp	DWORD PTR _cNames$[ebp], 1
	jne	$L93901

; 3558 : 			{
; 3559 : 				int n = int( ocslen(rgszNames[0]) );

	mov	eax, DWORD PTR _rgszNames$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	mov	DWORD PTR _n$93902[ebp], eax

; 3560 : 				for (int j=m_nCount-1; j>=0; j--)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	sub	eax, 1
	mov	DWORD PTR _j$93903[ebp], eax
	jmp	SHORT $L93904
$L93905:
	mov	ecx, DWORD PTR _j$93903[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$93903[ebp], ecx
$L93904:
	cmp	DWORD PTR _j$93903[ebp], 0
	jl	SHORT $L93901

; 3561 : 				{
; 3562 : 					if ((n == m_pMap[j].nLen) &&
; 3563 : 						(memcmp(m_pMap[j].bstr, rgszNames[0], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))

	mov	edx, DWORD PTR _j$93903[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR _n$93902[ebp]
	cmp	eax, DWORD PTR [ecx+edx+4]
	jne	SHORT $L93908
	mov	ecx, DWORD PTR _j$93903[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+ecx+4]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _rgszNames$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _j$93903[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+20]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L93908

; 3564 : 					{
; 3565 : 						rgdispid[0] = m_pMap[j].id;

	mov	eax, DWORD PTR _j$93903[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _rgdispid$[ebp]
	mov	edx, DWORD PTR [edx+eax+8]
	mov	DWORD PTR [ecx], edx

; 3566 : 						hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 3567 : 						break;

	jmp	SHORT $L93901
$L93908:

; 3568 : 					}
; 3569 : 				}

	jmp	SHORT $L93905
$L93901:

; 3570 : 			}
; 3571 : 			// if cache is empty or name not in cache or parameter names are requested,
; 3572 : 			// delegate to ITypeInfo::GetIDsOfNames
; 3573 : 			if (FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L93899

; 3574 : 			{
; 3575 : 				hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);

	mov	esi, esp
	mov	eax, DWORD PTR _rgdispid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cNames$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rgszNames$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+40]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L93899:

; 3576 : 			}
; 3577 : 		}
; 3578 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]

; 3579 : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPAGIKPAJ@Z ENDP ; ATL::CComTypeInfoHolder::GetIDsOfNames
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ??BCComBSTR@ATL@@QBEPAGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BCComBSTR@ATL@@QBEPAGXZ PROC NEAR			; ATL::CComBSTR::operator unsigned short *, COMDAT
; _this$ = ecx

; 640  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return m_str;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 642  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??BCComBSTR@ATL@@QBEPAGXZ ENDP				; ATL::CComBSTR::operator unsigned short *
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_lcid$ = 8						; size = 4
?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z PROC NEAR	; ATL::CComTypeInfoHolder::EnsureTI, COMDAT
; _this$ = ecx

; 3520 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3521 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 3522 : 		if (m_pInfo == NULL || m_pMap == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $L93884
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $L93883
$L93884:

; 3523 : 			hr = GetTI(lcid);

	mov	edx, DWORD PTR _lcid$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z	; ATL::CComTypeInfoHolder::GetTI
	mov	DWORD PTR _hr$[ebp], eax
$L93883:

; 3524 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 3525 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z ENDP		; ATL::CComTypeInfoHolder::EnsureTI
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT
_hRes$ = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_dispidMember$ = 12					; size = 4
___formal$ = 16						; size = 4
_lcid$ = 20						; size = 4
_wFlags$ = 24						; size = 2
_pdispparams$ = 28					; size = 4
_pvarResult$ = 32					; size = 4
_pexcepinfo$ = 36					; size = 4
_puArgErr$ = 40						; size = 4
?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z PROC NEAR ; ATL::CComTypeInfoHolder::Invoke, COMDAT
; _this$ = ecx

; 3584 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 3585 : 		HRESULT hRes = EnsureTI(lcid);

	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnsureTI@CComTypeInfoHolder@ATL@@QAEJK@Z ; ATL::CComTypeInfoHolder::EnsureTI
	mov	DWORD PTR _hRes$[ebp], eax

; 3586 : 		if (m_pInfo != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L93915

; 3587 : 			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

	mov	esi, esp
	mov	edx, DWORD PTR _puArgErr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pexcepinfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvarResult$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdispparams$[ebp]
	push	edx
	mov	ax, WORD PTR _wFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dispidMember$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [ecx+44]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax
$L93915:

; 3588 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]

; 3589 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ENDP ; ATL::CComTypeInfoHolder::Invoke
_TEXT	ENDS
PUBLIC	?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z	; ATL::CAtlModule::AddTermFunc
PUBLIC	??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator&
PUBLIC	??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ; ATL::CComPtrBase<ITypeLib>::operator->
PUBLIC	??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
PUBLIC	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>
PUBLIC	?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z		; ATL::CComTypeInfoHolder::Cleanup
PUBLIC	?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::LoadNameCache
PUBLIC	??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@ ; `string'
PUBLIC	??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@ ; `string'
PUBLIC	??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@ ; `string'
PUBLIC	??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@ ; `string'
PUBLIC	??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@ ; `string'
PUBLIC	??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@ ; `string'
PUBLIC	??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@ ; `string'
PUBLIC	??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@ ; `string'
PUBLIC	??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ ; ATL::CComPtrBase<ITypeInfo>::operator&
PUBLIC	??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ ; ATL::CComPtrBase<ITypeInfo>::operator->
PUBLIC	?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ ; ATL::CComPtrBase<ITypeInfo>::Detach
PUBLIC	??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ ; ATL::CComPtrBase<ITypeInfo2>::operator&
PUBLIC	??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
PUBLIC	??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z	; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
PUBLIC	??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeInfo2>::CComPtr<ITypeInfo2>
PUBLIC	??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeInfo>::~CComPtr<ITypeInfo>
PUBLIC	??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ		; ATL::CComPtr<ITypeInfo2>::~CComPtr<ITypeInfo2>
PUBLIC	??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z ; IUnknown::QueryInterface<ITypeInfo2>
PUBLIC	??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
EXTRN	__imp__LoadTypeLib@8:NEAR
EXTRN	__imp__LoadRegTypeLib@20:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212721 DD	0ffffffffH
	DD	FLAT:$L212697
	DD	00H
	DD	FLAT:$L212698
	DD	00H
	DD	FLAT:$L212699
	DD	02H
	DD	FLAT:$L212700
	DD	00H
	DD	FLAT:$L212701
	DD	04H
	DD	FLAT:$L212702
	DD	05H
	DD	FLAT:$L212703
$T212705 DD	019930520H
	DD	07H
	DD	FLAT:$T212721
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@ DB 'm'
	DB	'_plibid != 0 && m_pguid != 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@
CONST	SEGMENT
??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@ DB 'Did you fo'
	DB	'rget to pass the LIBID to CComModule::Init?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@
CONST	SEGMENT
??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@ DB '!Inli'
	DB	'neIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pas'
	DB	's the LIBID to CComModule::Init?"', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@
CONST	SEGMENT
??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@ DB 'ERROR : U'
	DB	'nable to lock critical section in CComTypeInfoHolder::GetTI', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@
CONST	SEGMENT
??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@ DB 'Warning : C'
	DB	'ComTypeInfoHolder::GetTI : Loaded typelib does not match the '
	DB	'typelib in the module : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@
CONST	SEGMENT
??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@ DB 09H, 'See IDi'
	DB	'spatchImpl overview help topic for more information', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@
CONST	SEGMENT
??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@ DB 'ERROR : Un'
	DB	'able to load Typelibrary. (HRESULT = 0x%x)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@
CONST	SEGMENT
??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@ DB 09H, 'Verify'
	DB	' TypelibID and major version specified with', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@
CONST	SEGMENT
??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@ DB 09H, 'IDispa'
	DB	'tchImpl, CStockPropImpl, IProvideClassInfoImpl or IProvideCLa'
	DB	'ssInfo2Impl', 0aH, 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT
tv315 = -816						; size = 4
tv269 = -812						; size = 4
tv256 = -808						; size = 4
tv249 = -804						; size = 4
tv258 = -800						; size = 4
tv201 = -796						; size = 4
tv194 = -792						; size = 4
tv203 = -788						; size = 4
$T212696 = -784						; size = 4
$T212695 = -780						; size = 8
$T212694 = -772						; size = 8
$T212693 = -764						; size = 8
$T212692 = -756						; size = 8
$T212691 = -748						; size = 8
$T212686 = -740						; size = 4
$T212681 = -736						; size = 4
$T212679 = -732						; size = 8
_spTypeInfo2$94115 = -720				; size = 4
_spInfo$94040 = -708					; size = 4
_spTypeInfo$94037 = -696				; size = 4
_pLibAttr$94019 = -684					; size = 4
_pszFile$94008 = -676					; size = 4
_hRes2$94006 = -672					; size = 4
_spTypeLibModule$94005 = -664				; size = 4
__AtlSafeAllocaManager$94004 = -652			; size = 4
__lpa_ex$94003 = -644					; size = 4
__lpw_ex$94002 = -640					; size = 4
__acp_ex$94001 = -636					; size = 4
__convert_ex$94000 = -632				; size = 4
_dwFLen$93998 = -628					; size = 4
_szFilePath$93997 = -620				; size = 260
_pszFile$93985 = -356					; size = 4
__AtlSafeAllocaManager$93984 = -348			; size = 4
__lpa_ex$93983 = -340					; size = 4
__lpw_ex$93982 = -336					; size = 4
__acp_ex$93981 = -332					; size = 4
__convert_ex$93980 = -328				; size = 4
_dwFLen$93978 = -324					; size = 4
_szFilePath$93977 = -316				; size = 260
_pTypeLib$93975 = -48					; size = 4
_hRes$ = -40						; size = 4
_lock$ = -32						; size = 8
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z PROC NEAR	; ATL::CComTypeInfoHolder::GetTI, COMDAT
; _this$ = ecx

; 3632 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 804				; 00000324H
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-816]
	mov	ecx, 201				; 000000c9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 3633 : 	//If this assert occurs then most likely didn't initialize properly
; 3634 : 	ATLASSERT(m_plibid != NULL && m_pguid != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $L212675
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L212676
$L212675:
	push	OFFSET FLAT:??_C@_0BO@GHLKPFE@m_plibid?5?$CB?$DN?50?5?$CG?$CG?5m_pguid?5?$CB?$DN?50?$AA@
	push	0
	push	3634					; 00000e32H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212676
	int	3
$L212676:

; 3635 : 	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	push	OFFSET FLAT:_GUID_NULL
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_InlineIsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $L212677
	mov	edx, OFFSET FLAT:??_C@_0DG@CJCBGKEH@Did?5you?5forget?5to?5pass?5the?5LIBID@
	test	edx, edx
	jne	SHORT $L212678
$L212677:
	push	OFFSET FLAT:??_C@_0GE@MNEAPMLF@?$CBInlineIsEqualGUID?$CI?$CKm_plibid?0?5GU@
	push	0
	push	3635					; 00000e33H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212678
	int	3
$L212678:

; 3636 : 
; 3637 : 	if (m_pInfo != NULL && m_pMap != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L93963
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $L93963

; 3638 : 		return S_OK;

	xor	eax, eax
	jmp	$L93957
$L93963:

; 3639 : 
; 3640 : 	CComCritSecLock<CComCriticalSection> lock(_pAtlModule->m_csStaticDataInitAndTypeInfo, false);

	push	0
	mov	eax, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	add	eax, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z ; ATL::CComCritSecLock<ATL::CComCriticalSection>::CComCritSecLock<ATL::CComCriticalSection>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 3641 : 	HRESULT hRes = lock.Lock();

	lea	ecx, DWORD PTR _lock$[ebp]
	call	?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock
	mov	DWORD PTR _hRes$[ebp], eax

; 3642 : 	if (FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L93968

; 3643 : 	{
; 3644 : 		ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CComTypeInfoHolder::GetTI\n"));

	push	OFFSET FLAT:??_C@_0EG@JLAFHAGH@ERROR?5?3?5Unable?5to?5lock?5critical?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3644					; 00000e3cH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212679[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 3645 : 		ATLASSERT(0);

	xor	ecx, ecx
	jne	SHORT $L212680
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	3645					; 00000e3dH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212680
	int	3
$L212680:

; 3646 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T212681[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
	mov	eax, DWORD PTR $T212681[ebp]
	jmp	$L93957
$L93968:

; 3647 : 	}
; 3648 : 	hRes = E_FAIL;

	mov	DWORD PTR _hRes$[ebp], -2147467259	; 80004005H

; 3649 : 	if (m_pInfo == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$L93974

; 3650 : 	{
; 3651 : 		ITypeLib* pTypeLib = NULL;

	mov	DWORD PTR _pTypeLib$93975[ebp], 0

; 3652 : 		if (InlineIsEqualGUID(CAtlModule::m_libid, *m_plibid) && m_wMajor == 0xFFFF && m_wMinor == 0xFFFF)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET FLAT:?m_libid@CAtlModule@ATL@@2U_GUID@@A ; ATL::CAtlModule::m_libid
	call	_InlineIsEqualGUID
	add	esp, 8
	test	eax, eax
	je	$L93976
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+8]
	cmp	edx, 65535				; 0000ffffH
	jne	$L93976
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+10]
	cmp	ecx, 65535				; 0000ffffH
	jne	$L93976

; 3653 : 		{
; 3654 : 			TCHAR szFilePath[MAX_PATH];
; 3655 : 			DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	edx, DWORD PTR _szFilePath$93977[ebp]
	push	edx
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFLen$93978[ebp], eax

; 3656 : 			if( dwFLen != 0 && dwFLen != MAX_PATH )

	cmp	DWORD PTR _dwFLen$93978[ebp], 0
	je	$L93979
	cmp	DWORD PTR _dwFLen$93978[ebp], 260	; 00000104H
	je	$L93979

; 3657 : 			{
; 3658 : 				USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$93980[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$93981[ebp], eax
	mov	DWORD PTR __lpw_ex$93982[ebp], 0
	mov	DWORD PTR __lpa_ex$93983[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$93984[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 3659 : 				LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szFilePath$93977[ebp]
	mov	DWORD PTR __lpa_ex$93983[ebp], eax
	cmp	DWORD PTR __lpa_ex$93983[ebp], 0
	jne	SHORT $L212684
	mov	DWORD PTR tv203[ebp], 0
	jmp	$L212685
$L212684:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$93983[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$93980[ebp], eax
	mov	edx, DWORD PTR __convert_ex$93980[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L212682
	mov	eax, DWORD PTR __convert_ex$93980[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212682
	mov	eax, DWORD PTR __convert_ex$93980[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv194[ebp], esp
	mov	edx, DWORD PTR tv194[ebp]
	mov	DWORD PTR tv201[ebp], edx
	jmp	SHORT $L212683
$L212682:
	mov	eax, DWORD PTR __convert_ex$93980[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$93984[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv201[ebp], eax
$L212683:
	mov	ecx, DWORD PTR __acp_ex$93981[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$93980[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$93983[ebp]
	push	eax
	mov	ecx, DWORD PTR tv201[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv203[ebp], eax
$L212685:
	mov	edx, DWORD PTR tv203[ebp]
	mov	DWORD PTR _pszFile$93985[ebp], edx

; 3660 : #ifndef _UNICODE
; 3661 : 				if (pszFile == NULL)

	cmp	DWORD PTR _pszFile$93985[ebp], 0
	jne	SHORT $L93991

; 3662 : 					return E_OUTOFMEMORY;

	mov	DWORD PTR $T212686[ebp], -2147024882	; 8007000eH
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$93984[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
	mov	eax, DWORD PTR $T212686[ebp]
	jmp	$L93957
$L93991:

; 3663 : #endif
; 3664 : 				hRes = LoadTypeLib(pszFile, &pTypeLib);

	mov	esi, esp
	lea	eax, DWORD PTR _pTypeLib$93975[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFile$93985[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadTypeLib@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax

; 3665 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$93984[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L93979:

; 3666 : 		}
; 3667 : 		else

	jmp	$L93994
$L93976:

; 3668 : 		{
; 3669 : 			hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);

	mov	esi, esp
	lea	edx, DWORD PTR _pTypeLib$93975[ebp]
	push	edx
	mov	eax, DWORD PTR _lcid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dx, WORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cx, WORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__LoadRegTypeLib@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax

; 3670 : #ifdef _DEBUG			
; 3671 : 			if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	$L93996

; 3672 : 			{
; 3673 : 				// Trace out an warning if the requested TypelibID is the same as the modules TypelibID
; 3674 : 				// and versions do not match.
; 3675 : 				// 
; 3676 : 				// In most cases it is due to wrong version template parameters to IDispatchImpl, 
; 3677 : 				// IProvideClassInfoImpl or IProvideClassInfo2Impl.
; 3678 : 				// Set major and minor versions to 0xFFFF if the modules type lib has to be loaded
; 3679 : 				// irrespective of its version.
; 3680 : 				// 
; 3681 : 				// Get the module's file path
; 3682 : 				TCHAR szFilePath[MAX_PATH];
; 3683 : 				DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szFilePath$93997[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	push	eax
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFLen$93998[ebp], eax

; 3684 : 				if( dwFLen != 0 && dwFLen != MAX_PATH )

	cmp	DWORD PTR _dwFLen$93998[ebp], 0
	je	$L93999
	cmp	DWORD PTR _dwFLen$93998[ebp], 260	; 00000104H
	je	$L93999

; 3685 : 				{
; 3686 : 					USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$94000[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$94001[ebp], eax
	mov	DWORD PTR __lpw_ex$94002[ebp], 0
	mov	DWORD PTR __lpa_ex$94003[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$94004[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 3687 : 					CComPtr<ITypeLib> spTypeLibModule;

	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	call	??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ	; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 3688 : 					HRESULT hRes2 = S_OK;

	mov	DWORD PTR _hRes2$94006[ebp], 0

; 3689 : 					LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	edx, DWORD PTR _szFilePath$93997[ebp]
	mov	DWORD PTR __lpa_ex$94003[ebp], edx
	cmp	DWORD PTR __lpa_ex$94003[ebp], 0
	jne	SHORT $L212689
	mov	DWORD PTR tv258[ebp], 0
	jmp	$L212690
$L212689:
	mov	esi, esp
	mov	eax, DWORD PTR __lpa_ex$94003[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$94000[ebp], eax
	mov	ecx, DWORD PTR __convert_ex$94000[ebp]
	shl	ecx, 1
	cmp	ecx, 1024				; 00000400H
	ja	SHORT $L212687
	mov	edx, DWORD PTR __convert_ex$94000[ebp]
	shl	edx, 1
	push	edx
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L212687
	mov	eax, DWORD PTR __convert_ex$94000[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv249[ebp], esp
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR tv256[ebp], ecx
	jmp	SHORT $L212688
$L212687:
	mov	edx, DWORD PTR __convert_ex$94000[ebp]
	shl	edx, 1
	push	edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$94004[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv256[ebp], eax
$L212688:
	mov	eax, DWORD PTR __acp_ex$94001[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert_ex$94000[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpa_ex$94003[ebp]
	push	edx
	mov	eax, DWORD PTR tv256[ebp]
	push	eax
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv258[ebp], eax
$L212690:
	mov	ecx, DWORD PTR tv258[ebp]
	mov	DWORD PTR _pszFile$94008[ebp], ecx

; 3690 : 					if (pszFile == NULL)

	cmp	DWORD PTR _pszFile$94008[ebp], 0
	jne	SHORT $L94014

; 3691 : 						hRes2 = E_OUTOFMEMORY;

	mov	DWORD PTR _hRes2$94006[ebp], -2147024882 ; 8007000eH

; 3692 : 					else

	jmp	SHORT $L94016
$L94014:

; 3693 : 						hRes2 = LoadTypeLib(pszFile, &spTypeLibModule);

	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	call	??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator&
	mov	esi, esp
	push	eax
	mov	edx, DWORD PTR _pszFile$94008[ebp]
	push	edx
	call	DWORD PTR __imp__LoadTypeLib@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes2$94006[ebp], eax
$L94016:

; 3694 : 					if (SUCCEEDED(hRes2))

	cmp	DWORD PTR _hRes2$94006[ebp], 0
	jl	$L94018

; 3695 : 					{
; 3696 : 						TLIBATTR* pLibAttr;
; 3697 : 						hRes2 = spTypeLibModule->GetLibAttr(&pLibAttr);

	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	call	??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ; ATL::CComPtrBase<ITypeLib>::operator->
	mov	DWORD PTR tv269[ebp], eax
	mov	esi, esp
	lea	eax, DWORD PTR _pLibAttr$94019[ebp]
	push	eax
	mov	ecx, DWORD PTR tv269[ebp]
	push	ecx
	mov	edx, DWORD PTR tv269[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes2$94006[ebp], eax

; 3698 : 						if (SUCCEEDED(hRes2))

	cmp	DWORD PTR _hRes2$94006[ebp], 0
	jl	$L94018

; 3699 : 						{
; 3700 : 							if (InlineIsEqualGUID(pLibAttr->guid, *m_plibid) &&
; 3701 : 								(pLibAttr->wMajorVerNum != m_wMajor ||
; 3702 : 								pLibAttr->wMinorVerNum != m_wMinor))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pLibAttr$94019[ebp]
	push	eax
	call	_InlineIsEqualGUID
	add	esp, 8
	test	eax, eax
	je	$L94022
	mov	ecx, DWORD PTR _pLibAttr$94019[ebp]
	movzx	edx, WORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, WORD PTR [eax+8]
	cmp	edx, ecx
	jne	SHORT $L94023
	mov	edx, DWORD PTR _pLibAttr$94019[ebp]
	movzx	eax, WORD PTR [edx+26]
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, WORD PTR [ecx+10]
	cmp	eax, edx
	je	SHORT $L94022
$L94023:

; 3703 : 							{
; 3704 : 								ATLTRACE(atlTraceCOM, 0, _T("Warning : CComTypeInfoHolder::GetTI : Loaded typelib does not match the typelib in the module : %s\n"), szFilePath);

	lea	eax, DWORD PTR _szFilePath$93997[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0GE@IPBGNBKO@Warning?5?3?5CComTypeInfoHolder?3?3Ge@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3704					; 00000e78H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212691[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 3705 : 								ATLTRACE(atlTraceCOM, 0, _T("\tSee IDispatchImpl overview help topic for more information\n"), szFilePath);							

	lea	ecx, DWORD PTR _szFilePath$93997[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0DN@OOAEELGE@?7See?5IDispatchImpl?5overview?5help@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3705					; 00000e79H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212692[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H
$L94022:

; 3706 : 							}
; 3707 : 							spTypeLibModule->ReleaseTLibAttr(pLibAttr);

	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	call	??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ; ATL::CComPtrBase<ITypeLib>::operator->
	mov	DWORD PTR tv315[ebp], eax
	mov	esi, esp
	mov	edx, DWORD PTR _pLibAttr$94019[ebp]
	push	edx
	mov	eax, DWORD PTR tv315[ebp]
	push	eax
	mov	ecx, DWORD PTR tv315[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+48]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L94018:

; 3708 : 						}
; 3709 : 					}
; 3710 : 				}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	call	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$94004[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L93999:

; 3711 : 			}
; 3712 : 			else

	jmp	$L93994
$L93996:

; 3713 : 			{
; 3714 : 				ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to load Typelibrary. (HRESULT = 0x%x)\n"), hRes);

	mov	eax, DWORD PTR _hRes$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0DG@JANIJOBP@ERROR?5?3?5Unable?5to?5load?5Typelibra@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3714					; 00000e82H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212693[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 20					; 00000014H

; 3715 : 				ATLTRACE(atlTraceCOM, 0, _T("\tVerify TypelibID and major version specified with\n"));

	push	OFFSET FLAT:??_C@_0DE@PFCDKHBK@?7Verify?5TypelibID?5and?5major?5vers@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3715					; 00000e83H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212694[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 3716 : 				ATLTRACE(atlTraceCOM, 0, _T("\tIDispatchImpl, CStockPropImpl, IProvideClassInfoImpl or IProvideCLassInfo2Impl\n"));

	push	OFFSET FLAT:??_C@_0FB@GGFNIACC@?7IDispatchImpl?0?5CStockPropImpl?0?5@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceCOM@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceCOM
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	3716					; 00000e84H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T212695[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H
$L93994:

; 3717 : 			}
; 3718 : #endif		
; 3719 : 		}
; 3720 : 		if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	$L94036

; 3721 : 		{
; 3722 : 			CComPtr<ITypeInfo> spTypeInfo;

	lea	ecx, DWORD PTR _spTypeInfo$94037[ebp]
	call	??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ	; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 3723 : 			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);

	lea	ecx, DWORD PTR _spTypeInfo$94037[ebp]
	call	??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ ; ATL::CComPtrBase<ITypeInfo>::operator&
	mov	esi, esp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pTypeLib$93975[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pTypeLib$93975[ebp]
	push	edx
	call	DWORD PTR [ecx+24]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hRes$[ebp], eax

; 3724 : 			if (SUCCEEDED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jl	$L94039

; 3725 : 			{
; 3726 : 				CComPtr<ITypeInfo> spInfo(spTypeInfo);

	lea	eax, DWORD PTR _spTypeInfo$94037[ebp]
	push	eax
	lea	ecx, DWORD PTR _spInfo$94040[ebp]
	call	??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z ; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 3727 : 				CComPtr<ITypeInfo2> spTypeInfo2;

	lea	ecx, DWORD PTR _spTypeInfo2$94115[ebp]
	call	??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ	; ATL::CComPtr<ITypeInfo2>::CComPtr<ITypeInfo2>
	mov	BYTE PTR __$EHRec$[ebp+8], 6

; 3728 : 				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))

	lea	ecx, DWORD PTR _spTypeInfo2$94115[ebp]
	call	??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ ; ATL::CComPtrBase<ITypeInfo2>::operator&
	push	eax
	lea	ecx, DWORD PTR _spTypeInfo$94037[ebp]
	call	??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ ; ATL::CComPtrBase<ITypeInfo>::operator->
	push	eax
	call	??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z ; IUnknown::QueryInterface<ITypeInfo2>
	test	eax, eax
	jl	SHORT $L94120

; 3729 : 					spInfo = spTypeInfo2;

	lea	ecx, DWORD PTR _spTypeInfo2$94115[ebp]
	push	ecx
	lea	ecx, DWORD PTR _spInfo$94040[ebp]
	call	??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
$L94120:

; 3730 : 
; 3731 : 				m_pInfo = spInfo.Detach();

	lea	ecx, DWORD PTR _spInfo$94040[ebp]
	call	?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ ; ATL::CComPtrBase<ITypeInfo>::Detach
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], eax

; 3732 : #ifndef _ATL_DLL_IMPL
; 3733 : 				_pAtlModule->AddTermFunc(Cleanup, (DWORD_PTR)this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	push	OFFSET FLAT:?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z ; ATL::CComTypeInfoHolder::Cleanup
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z ; ATL::CAtlModule::AddTermFunc

; 3734 : #endif
; 3735 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR _spTypeInfo2$94115[ebp]
	call	??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR _spInfo$94040[ebp]
	call	??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
$L94039:

; 3736 : 			pTypeLib->Release();

	mov	ecx, DWORD PTR _pTypeLib$93975[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	eax, DWORD PTR _pTypeLib$93975[ebp]
	push	eax
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3737 : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _spTypeInfo$94037[ebp]
	call	??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
$L94036:

; 3738 : 	}
; 3739 : 	else

	jmp	SHORT $L94125
$L93974:

; 3740 : 	{
; 3741 : 		// Another thread has loaded the typeinfo so we're OK.
; 3742 : 		hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0
$L94125:

; 3743 : 	}
; 3744 : 
; 3745 : 	if (m_pInfo != NULL && m_pMap == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $L94127
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $L94127

; 3746 : 		LoadNameCache(m_pInfo);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::LoadNameCache
$L94127:

; 3747 : 
; 3748 : 	return hRes;

	mov	edx, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T212696[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lock$[ebp]
	call	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
	mov	eax, DWORD PTR $T212696[ebp]
$L93957:

; 3749 : }

	lea	esp, DWORD PTR [ebp-824]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212720
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$L212720:
	DD	11					; 0000000bH
	DD	$L212719
$L212719:
	DD	-32					; ffffffe0H
	DD	8
	DD	$L212706
	DD	-48					; ffffffd0H
	DD	4
	DD	$L212707
	DD	-316					; fffffec4H
	DD	260					; 00000104H
	DD	$L212708
	DD	-348					; fffffea4H
	DD	4
	DD	$L212709
	DD	-620					; fffffd94H
	DD	260					; 00000104H
	DD	$L212710
	DD	-652					; fffffd74H
	DD	4
	DD	$L212711
	DD	-664					; fffffd68H
	DD	4
	DD	$L212712
	DD	-684					; fffffd54H
	DD	4
	DD	$L212713
	DD	-696					; fffffd48H
	DD	4
	DD	$L212714
	DD	-708					; fffffd3cH
	DD	4
	DD	$L212715
	DD	-720					; fffffd30H
	DD	4
	DD	$L212716
$L212716:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	50					; 00000032H
	DB	0
$L212715:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$L212714:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	73					; 00000049H
	DB	110					; 0000006eH
	DB	102					; 00000066H
	DB	111					; 0000006fH
	DB	0
$L212713:
	DB	112					; 00000070H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	0
$L212712:
	DB	115					; 00000073H
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L212711:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212710:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L212709:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L212708:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
$L212707:
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	0
$L212706:
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212697:
	lea	ecx, DWORD PTR _lock$[ebp]
	jmp	??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
$L212698:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$93984[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L212699:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$94004[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
$L212700:
	lea	ecx, DWORD PTR _spTypeLibModule$94005[ebp]
	jmp	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
$L212701:
	lea	ecx, DWORD PTR _spTypeInfo$94037[ebp]
	jmp	??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
$L212702:
	lea	ecx, DWORD PTR _spInfo$94040[ebp]
	jmp	??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
$L212703:
	lea	ecx, DWORD PTR _spTypeInfo2$94115[ebp]
	jmp	??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
__ehhandler$?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z:
	mov	eax, OFFSET FLAT:$T212705
	jmp	___CxxFrameHandler
text$x	ENDS
?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z ENDP		; ATL::CComTypeInfoHolder::GetTI
EXTRN	?AtlModuleAddTermFunc@ATL@@YGJPAU_ATL_MODULE70@1@P6GXK@ZK@Z:NEAR ; ATL::AtlModuleAddTermFunc
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
_pFunc$ = 8						; size = 4
_dw$ = 12						; size = 4
?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z PROC NEAR	; ATL::CAtlModule::AddTermFunc, COMDAT
; _this$ = ecx

; 2677 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2678 : 		return AtlModuleAddTermFunc(this, pFunc, dw);

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $L212726
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $L212727
$L212726:
	mov	DWORD PTR tv69[ebp], 0
$L212727:
	mov	ecx, DWORD PTR _dw$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR tv69[ebp]
	push	eax
	call	?AtlModuleAddTermFunc@ATL@@YGJPAU_ATL_MODULE70@1@P6GXK@ZK@Z ; ATL::AtlModuleAddTermFunc

; 2679 : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z ENDP	; ATL::CAtlModule::AddTermFunc
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC NEAR		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::~CComPtr<ITypeLib>
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ITypeInfo>::~CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ PROC NEAR		; ATL::CComPtr<ITypeInfo>::~CComPtr<ITypeInfo>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ITypeInfo>::~CComPtrBase<ITypeInfo>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeInfo>::~CComPtr<ITypeInfo>
_TEXT	ENDS
PUBLIC	??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@		; `string'
;	COMDAT ??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
CONST	SEGMENT
??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@ DB 'dw != 0', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z
_TEXT	SEGMENT
tv89 = -16						; size = 4
$T212736 = -12						; size = 4
$T212735 = -8						; size = 4
_p$ = -4						; size = 4
_dw$ = 8						; size = 4
?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z PROC NEAR	; ATL::CComTypeInfoHolder::Cleanup, COMDAT

; 3530 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 3531 : 		ATLASSERT(dw != 0);

	cmp	DWORD PTR _dw$[ebp], 0
	jne	SHORT $L212734
	push	OFFSET FLAT:??_C@_07PJPEDDJP@dw?5?$CB?$DN?50?$AA@
	push	0
	push	3531					; 00000dcbH
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212734
	int	3
$L212734:

; 3532 : 		if (dw == 0)

	cmp	DWORD PTR _dw$[ebp], 0
	jne	SHORT $L93888

; 3533 : 			return;

	jmp	SHORT $L93885
$L93888:

; 3534 : 			
; 3535 : 		CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;

	mov	ecx, DWORD PTR _dw$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 3536 : 		if (p->m_pInfo != NULL)

	mov	edx, DWORD PTR _p$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $L93891

; 3537 : 			p->m_pInfo->Release();

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L93891:

; 3538 : 		p->m_pInfo = NULL;

	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [edx+12], 0

; 3539 : 		delete [] p->m_pMap;

	mov	eax, DWORD PTR _p$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T212736[ebp], ecx
	mov	edx, DWORD PTR $T212736[ebp]
	mov	DWORD PTR $T212735[ebp], edx
	cmp	DWORD PTR $T212735[ebp], 0
	je	SHORT $L212737
	push	3
	mov	ecx, DWORD PTR $T212735[ebp]
	call	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $L212738
$L212737:
	mov	DWORD PTR tv89[ebp], 0
$L212738:

; 3540 : 		p->m_pMap = NULL;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+20], 0
$L93885:

; 3541 : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z ENDP		; ATL::CComTypeInfoHolder::Cleanup
_TEXT	ENDS
PUBLIC	??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::stringdispid
PUBLIC	??0CComBSTR@ATL@@QAE@XZ				; ATL::CComBSTR::CComBSTR
PUBLIC	??ICComBSTR@ATL@@QAEPAPAGXZ			; ATL::CComBSTR::operator&
PUBLIC	?Attach@CComBSTR@ATL@@QAEXPAG@Z			; ATL::CComBSTR::Attach
PUBLIC	?Detach@CComBSTR@ATL@@QAEPAGXZ			; ATL::CComBSTR::Detach
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	__imp__SysStringLen@4:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212758 DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L212748
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L212749
$T212760 DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L212747
$T212759 DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T212760
$T212751 DD	019930520H
	DD	04H
	DD	FLAT:$T212758
	DD	01H
	DD	FLAT:$T212759
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z
_TEXT	SEGMENT
tv91 = -88						; size = 4
tv183 = -84						; size = 4
$T212743 = -80						; size = 4
$T212742 = -76						; size = 4
$T212741 = -72						; size = 4
_bstrName$93941 = -64					; size = 4
_pfd$93938 = -52					; size = 4
_i$93934 = -44						; size = 4
_pMap$93922 = -40					; size = 4
_hr$ = -36						; size = 4
_pta$ = -28						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
_pTypeInfo$ = 8						; size = 4
?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z PROC NEAR ; ATL::CComTypeInfoHolder::LoadNameCache, COMDAT
; _this$ = ecx

; 3591 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-88]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 3592 : 		TYPEATTR* pta;
; 3593 : 		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);

	mov	esi, esp
	lea	eax, DWORD PTR _pta$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTypeInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTypeInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 3594 : 		if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$L93921

; 3595 : 		{
; 3596 : 			stringdispid* pMap = NULL;

	mov	DWORD PTR _pMap$93922[ebp], 0

; 3597 : 			m_nCount = pta->cFuncs;

	mov	ecx, DWORD PTR _pta$[ebp]
	movzx	edx, WORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], edx

; 3598 : 			m_pMap = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0

; 3599 : 			if (m_nCount != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$L93923

; 3600 : 			{
; 3601 : 				ATLTRY(pMap = new stringdispid[m_nCount]);

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR $T212741[ebp], ecx
	mov	edx, DWORD PTR $T212741[ebp]
	imul	edx, 12					; 0000000cH
	add	edx, 4
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR tv183[ebp], eax
	mov	eax, DWORD PTR tv183[ebp]
	mov	DWORD PTR $T212743[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T212743[ebp], 0
	je	SHORT $L212744
	mov	ecx, DWORD PTR $T212743[ebp]
	mov	edx, DWORD PTR $T212741[ebp]
	mov	DWORD PTR [ecx], edx
	push	OFFSET FLAT:??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
	push	OFFSET FLAT:??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ; ATL::CComTypeInfoHolder::stringdispid::stringdispid
	mov	eax, DWORD PTR $T212741[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR $T212743[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T212743[ebp]
	add	edx, 4
	mov	DWORD PTR tv91[ebp], edx
	jmp	SHORT $L212745
$L212744:
	mov	DWORD PTR tv91[ebp], 0
$L212745:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR $T212742[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR $T212742[ebp]
	mov	DWORD PTR _pMap$93922[ebp], ecx
	jmp	SHORT $L212746
$L212747:
	mov	eax, $L212746
	ret	0
$L212746:
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 3602 : 				if (pMap == NULL)

	cmp	DWORD PTR _pMap$93922[ebp], 0
	jne	SHORT $L93923

; 3603 : 				{
; 3604 : 					pTypeInfo->ReleaseTypeAttr(pta);

	mov	esi, esp
	mov	edx, DWORD PTR _pta$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTypeInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTypeInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+76]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3605 : 					return E_OUTOFMEMORY;

	mov	eax, -2147024882			; 8007000eH
	jmp	$L93917
$L93923:

; 3606 : 				}
; 3607 : 			}
; 3608 : 			for (int i=0; i<m_nCount; i++)

	mov	DWORD PTR _i$93934[ebp], 0
	jmp	SHORT $L93935
$L93936:
	mov	eax, DWORD PTR _i$93934[ebp]
	add	eax, 1
	mov	DWORD PTR _i$93934[ebp], eax
$L93935:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$93934[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jge	$L93937

; 3609 : 			{
; 3610 : 				FUNCDESC* pfd;
; 3611 : 				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))

	mov	esi, esp
	lea	eax, DWORD PTR _pfd$93938[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$93934[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTypeInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTypeInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jl	$L93940

; 3612 : 				{
; 3613 : 					CComBSTR bstrName;

	lea	ecx, DWORD PTR _bstrName$93941[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	DWORD PTR __$EHRec$[ebp+12], 3

; 3614 : 					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))

	mov	esi, esp
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _bstrName$93941[ebp]
	call	??ICComBSTR@ATL@@QAEPAPAGXZ		; ATL::CComBSTR::operator&
	push	eax
	mov	edx, DWORD PTR _pfd$93938[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pTypeInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pTypeInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+48]
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jl	SHORT $L93943

; 3615 : 					{
; 3616 : 						pMap[i].bstr.Attach(bstrName.Detach());

	lea	ecx, DWORD PTR _bstrName$93941[ebp]
	call	?Detach@CComBSTR@ATL@@QAEPAGXZ		; ATL::CComBSTR::Detach
	push	eax
	mov	ecx, DWORD PTR _i$93934[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR _pMap$93922[ebp]
	call	?Attach@CComBSTR@ATL@@QAEXPAG@Z		; ATL::CComBSTR::Attach

; 3617 : 						pMap[i].nLen = SysStringLen(pMap[i].bstr);

	mov	esi, DWORD PTR _i$93934[ebp]
	imul	esi, 12					; 0000000cH
	mov	ecx, DWORD PTR _i$93934[ebp]
	imul	ecx, 12					; 0000000cH
	add	ecx, DWORD PTR _pMap$93922[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	mov	edi, esp
	push	eax
	call	DWORD PTR __imp__SysStringLen@4
	cmp	edi, esp
	call	__RTC_CheckEsp
	mov	ecx, DWORD PTR _pMap$93922[ebp]
	mov	DWORD PTR [ecx+esi+4], eax

; 3618 : 						pMap[i].id = pfd->memid;

	mov	edx, DWORD PTR _i$93934[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _pMap$93922[ebp]
	mov	ecx, DWORD PTR _pfd$93938[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+edx+8], ecx
$L93943:

; 3619 : 					}
; 3620 : 					pTypeInfo->ReleaseFuncDesc(pfd);

	mov	esi, esp
	mov	edx, DWORD PTR _pfd$93938[ebp]
	push	edx
	mov	eax, DWORD PTR _pTypeInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTypeInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+80]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 3621 : 				}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR _bstrName$93941[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
$L93940:

; 3622 : 			}

	jmp	$L93936
$L93937:

; 3623 : 			m_pMap = pMap;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pMap$93922[ebp]
	mov	DWORD PTR [eax+20], ecx

; 3624 : 			pTypeInfo->ReleaseTypeAttr(pta);

	mov	esi, esp
	mov	edx, DWORD PTR _pta$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTypeInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pTypeInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+76]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L93921:

; 3625 : 		}
; 3626 : 		return S_OK;

	xor	eax, eax
$L93917:

; 3627 : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212757
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 88					; 00000058H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$L212757:
	DD	3
	DD	$L212756
$L212756:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L212752
	DD	-52					; ffffffccH
	DD	4
	DD	$L212753
	DD	-64					; ffffffc0H
	DD	4
	DD	$L212754
$L212754:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	78					; 0000004eH
	DB	97					; 00000061H
	DB	109					; 0000006dH
	DB	101					; 00000065H
	DB	0
$L212753:
	DB	112					; 00000070H
	DB	102					; 00000066H
	DB	100					; 00000064H
	DB	0
$L212752:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	97					; 00000061H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212748:
	mov	eax, DWORD PTR $T212743[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
$L212749:
	lea	ecx, DWORD PTR _bstrName$93941[ebp]
	jmp	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
__ehhandler$?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z:
	mov	eax, OFFSET FLAT:$T212751
	jmp	___CxxFrameHandler
text$x	ENDS
?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ENDP ; ATL::CComTypeInfoHolder::LoadNameCache
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0CComBSTR@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComBSTR@ATL@@QAE@XZ PROC NEAR			; ATL::CComBSTR::CComBSTR, COMDAT
; _this$ = ecx

; 545  : 	CComBSTR() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 	{
; 547  : 		m_str = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 548  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComBSTR@ATL@@QAE@XZ ENDP				; ATL::CComBSTR::CComBSTR
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??ICComBSTR@ATL@@QAEPAPAGXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??ICComBSTR@ATL@@QAEPAPAGXZ PROC NEAR			; ATL::CComBSTR::operator&, COMDAT
; _this$ = ecx

; 644  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 645  : 		return &m_str;

	mov	eax, DWORD PTR _this$[ebp]

; 646  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??ICComBSTR@ATL@@QAEPAPAGXZ ENDP			; ATL::CComBSTR::operator&
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Attach@CComBSTR@ATL@@QAEXPAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_src$ = 8						; size = 4
?Attach@CComBSTR@ATL@@QAEXPAG@Z PROC NEAR		; ATL::CComBSTR::Attach, COMDAT
; _this$ = ecx

; 680  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		if (m_str != src)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _src$[ebp]
	je	SHORT $L81754

; 682  : 		{
; 683  : 			::SysFreeString(m_str);

	mov	esi, esp
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__SysFreeString@4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 684  : 			m_str = src;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _src$[ebp]
	mov	DWORD PTR [ecx], edx
$L81754:

; 685  : 		}
; 686  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Attach@CComBSTR@ATL@@QAEXPAG@Z ENDP			; ATL::CComBSTR::Attach
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Detach@CComBSTR@ATL@@QAEPAGXZ
_TEXT	SEGMENT
_s$ = -8						; size = 4
_this$ = -4						; size = 4
?Detach@CComBSTR@ATL@@QAEPAGXZ PROC NEAR		; ATL::CComBSTR::Detach, COMDAT
; _this$ = ecx

; 688  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		BSTR s = m_str;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _s$[ebp], ecx

; 690  : 		m_str = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 691  : 		return s;

	mov	eax, DWORD PTR _s$[ebp]

; 692  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Detach@CComBSTR@ATL@@QAEPAGXZ ENDP			; ATL::CComBSTR::Detach
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
_TEXT	ENDS
;	COMDAT ??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC NEAR ; ATL::CComTypeInfoHolder::stringdispid::stringdispid, COMDAT
; _this$ = ecx

; 3477 : 		stringdispid() : nLen(0), id(DISPID_UNKNOWN){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::stringdispid
_TEXT	ENDS
PUBLIC	??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ	; ATL::CComPtrBase<ITypeInfo2>::~CComPtrBase<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<ITypeInfo2>::~CComPtr<ITypeInfo2>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ ; ATL::CComPtrBase<ITypeInfo2>::~CComPtrBase<ITypeInfo2>
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeInfo2>::~CComPtr<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComObject<CSignature>::AddRef, COMDAT

; 2506 : 	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ ENDP	; ATL::CComObject<CSignature>::AddRef
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T212781 = -12						; size = 4
$T212780 = -8						; size = 4
_l$ = -4						; size = 4
_this$ = 8						; size = 4
?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComObject<CSignature>::Release, COMDAT

; 2508 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2509 : 		ULONG l = InternalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease
	mov	DWORD PTR _l$[ebp], eax

; 2510 : 		if (l == 0)

	cmp	DWORD PTR _l$[ebp], 0
	jne	SHORT $L209236

; 2511 : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T212781[ebp], eax
	mov	ecx, DWORD PTR $T212781[ebp]
	mov	DWORD PTR $T212780[ebp], ecx
	cmp	DWORD PTR $T212780[ebp], 0
	je	SHORT $L212782
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T212780[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T212780[ebp]
	call	DWORD PTR [eax+896]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $L209236
$L212782:
	mov	DWORD PTR tv74[ebp], 0
$L209236:

; 2512 : 		return l;

	mov	eax, DWORD PTR _l$[ebp]

; 2513 : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ ENDP	; ATL::CComObject<CSignature>::Release
_TEXT	ENDS
PUBLIC	?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z ; CSignature::_InternalQueryInterface
; Function compile flags: /Odt /RTCsu
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComObject<CSignature>::QueryInterface, COMDAT

; 2516 : 	{return _InternalQueryInterface(iid, ppvObject);}

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z ; CSignature::_InternalQueryInterface
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObject<CSignature>::QueryInterface
_TEXT	ENDS
PUBLIC	?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ ; CSignature::_GetEntries
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\signature.h
;	COMDAT ?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iid$ = 8						; size = 4
_ppvObject$ = 12					; size = 4
?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z PROC NEAR ; CSignature::_InternalQueryInterface, COMDAT
; _this$ = ecx

; 288  : BEGIN_COM_MAP(CSignature)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	call	?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ ; CSignature::_GetEntries
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?InternalQueryInterface@CComObjectRootBase@ATL@@SGJPAXPBU_ATL_INTMAP_ENTRY@2@ABU_GUID@@PAPAX@Z ; ATL::CComObjectRootBase::InternalQueryInterface
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z ENDP ; CSignature::_InternalQueryInterface
_TEXT	ENDS
PUBLIC	__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	__GUID_b722bccb_4e68_101b_a2bc_00aa00404770
PUBLIC	?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B ; `CSignature::_GetEntries'::`2'::_entries
PUBLIC	??_C@_0L@KEHCEMNB@CSignature?$AA@		; `string'
PUBLIC	__GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63
;	COMDAT ?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT
?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B DD 00H ; `CSignature::_GetEntries'::`2'::_entries
	DD	FLAT:??_C@_0L@KEHCEMNB@CSignature?$AA@
	DD	00H
	DD	FLAT:__GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63
	DD	00H
	DD	01H
	DD	FLAT:__GUID_00020400_0000_0000_c000_000000000046
	DD	00H
	DD	01H
	DD	FLAT:__GUID_b722bccb_4e68_101b_a2bc_00aa00404770
	DD	04H
	DD	01H
	DD	FLAT:__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
	DD	08H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_C@_0L@KEHCEMNB@CSignature?$AA@
CONST	SEGMENT
??_C@_0L@KEHCEMNB@CSignature?$AA@ DB 'CSignature', 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63
CONST	SEGMENT
__GUID_62ec64dc_b26d_46ce_9e33_24289bcf5f63 DD 062ec64dcH
	DW	0b26dH
	DW	046ceH
	DB	09eH
	DB	033H
	DB	024H
	DB	028H
	DB	09bH
	DB	0cfH
	DB	05fH
	DB	063H
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_b722bccb_4e68_101b_a2bc_00aa00404770
CONST	SEGMENT
__GUID_b722bccb_4e68_101b_a2bc_00aa00404770 DD 0b722bccbH
	DW	04e68H
	DW	0101bH
	DB	0a2H
	DB	0bcH
	DB	00H
	DB	0aaH
	DB	00H
	DB	040H
	DB	047H
	DB	070H
CONST	ENDS
;	COMDAT __GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352
CONST	SEGMENT
__GUID_fc4801a3_2ba9_11cf_a229_00aa003d7352 DD 0fc4801a3H
	DW	02ba9H
	DW	011cfH
	DB	0a2H
	DB	029H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03dH
	DB	073H
	DB	052H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ
_TEXT	SEGMENT
?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ PROC NEAR ; CSignature::_GetEntries, COMDAT

; 288  : BEGIN_COM_MAP(CSignature)

	push	ebp
	mov	ebp, esp

; 289  : 	COM_INTERFACE_ENTRY(ISignature)
; 290  : 	COM_INTERFACE_ENTRY(IDispatch)
; 291  : 	COM_INTERFACE_ENTRY(IOleCommandTarget)
; 292  : 	COM_INTERFACE_ENTRY(IObjectWithSite)
; 293  : END_COM_MAP()

	mov	eax, OFFSET FLAT:?_entries@?1??_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B+12
	pop	ebp
	ret	0
?_GetEntries@CSignature@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ ENDP ; CSignature::_GetEntries
_TEXT	ENDS
PUBLIC	??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>
PUBLIC	?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComAggObject<CSignature>::AddRef
PUBLIC	?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComAggObject<CSignature>::Release
PUBLIC	?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComAggObject<CSignature>::QueryInterface
PUBLIC	??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z ; ATL::CComContainedObject<CSignature>::CComContainedObject<CSignature>
PUBLIC	??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ ; ATL::CComContainedObject<CSignature>::~CComContainedObject<CSignature>
PUBLIC	??_7?$CComAggObject@VCSignature@@@ATL@@6B@	; ATL::CComAggObject<CSignature>::`vftable'
PUBLIC	??_G?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z ; ATL::CComAggObject<CSignature>::`scalar deleting destructor'
EXTRN	??_E?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z:NEAR ; ATL::CComAggObject<CSignature>::`vector deleting destructor'
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcom.h
xdata$x	SEGMENT
$T212796 DD	0ffffffffH
	DD	FLAT:$L212792
$T212794 DD	019930520H
	DD	01H
	DD	FLAT:$T212796
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7?$CComAggObject@VCSignature@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComAggObject@VCSignature@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComAggObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:??_E?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pv$ = 8						; size = 4
??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z PROC NEAR ; ATL::CComAggObject<CSignature>::CComAggObject<CSignature>, COMDAT
; _this$ = ecx

; 2848 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IUnknown@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComAggObject@VCSignature@@@ATL@@6B@
	mov	ecx, DWORD PTR _pv$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z ; ATL::CComContainedObject<CSignature>::CComContainedObject<CSignature>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2849 : 		_pAtlModule->Lock();

	mov	edx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [eax+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2850 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212792:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ
__ehhandler$??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z:
	mov	eax, OFFSET FLAT:$T212794
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$CComAggObject@VCSignature@@@ATL@@QAE@PAX@Z ENDP	; ATL::CComAggObject<CSignature>::CComAggObject<CSignature>
; Function compile flags: /Odt /RTCsu
;	COMDAT ?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ PROC NEAR ; ATL::CComAggObject<CSignature>::FinalConstruct, COMDAT
; _this$ = ecx

; 2854 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2855 : 		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::FinalConstruct

; 2856 : 		return m_contained.FinalConstruct();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?FinalConstruct@CComObjectRootBase@ATL@@QAEJXZ ; ATL::CComObjectRootBase::FinalConstruct

; 2857 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FinalConstruct@?$CComAggObject@VCSignature@@@ATL@@QAEJXZ ENDP ; ATL::CComAggObject<CSignature>::FinalConstruct
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComAggObject<CSignature>::AddRef, COMDAT

; 2875 : 	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InternalAddRef@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalAddRef
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?AddRef@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ ENDP	; ATL::CComAggObject<CSignature>::AddRef
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
tv74 = -16						; size = 4
$T212806 = -12						; size = 4
$T212805 = -8						; size = 4
_l$ = -4						; size = 4
_this$ = 8						; size = 4
?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComAggObject<CSignature>::Release, COMDAT

; 2877 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR [ebp-12], eax
	mov	DWORD PTR [ebp-8], eax
	mov	DWORD PTR [ebp-4], eax

; 2878 : 		ULONG l = InternalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?InternalRelease@?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAEKXZ ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::InternalRelease
	mov	DWORD PTR _l$[ebp], eax

; 2879 : 		if (l == 0)

	cmp	DWORD PTR _l$[ebp], 0
	jne	SHORT $L209252

; 2880 : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T212806[ebp], eax
	mov	ecx, DWORD PTR $T212806[ebp]
	mov	DWORD PTR $T212805[ebp], ecx
	cmp	DWORD PTR $T212805[ebp], 0
	je	SHORT $L212807
	mov	esi, esp
	push	1
	mov	edx, DWORD PTR $T212805[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T212805[ebp]
	call	DWORD PTR [eax+12]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $L209252
$L212807:
	mov	DWORD PTR tv74[ebp], 0
$L209252:

; 2881 : 		return l;

	mov	eax, DWORD PTR _l$[ebp]

; 2882 : 	}

	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Release@?$CComAggObject@VCSignature@@@ATL@@UAGKXZ ENDP	; ATL::CComAggObject<CSignature>::Release
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_hRes$ = -4						; size = 4
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComAggObject<CSignature>::QueryInterface, COMDAT

; 2884 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 2885 : 		ATLASSERT(ppvObject != NULL);

	cmp	DWORD PTR _ppvObject$[ebp], 0
	jne	SHORT $L212811
	push	OFFSET FLAT:??_C@_0P@BMHEGBAP@ppvObject?5?$CB?$DN?50?$AA@
	push	0
	push	2885					; 00000b45H
	push	OFFSET FLAT:??_C@_0EP@FBJOMLAB@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212811
	int	3
$L212811:

; 2886 : 		if (ppvObject == NULL)

	cmp	DWORD PTR _ppvObject$[ebp], 0
	jne	SHORT $L209258

; 2887 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	SHORT $L209256
$L209258:

; 2888 : 		*ppvObject = NULL;

	mov	ecx, DWORD PTR _ppvObject$[ebp]
	mov	DWORD PTR [ecx], 0

; 2889 : 
; 2890 : 		HRESULT hRes = S_OK;

	mov	DWORD PTR _hRes$[ebp], 0

; 2891 : 		if (InlineIsEqualUnknown(iid))

	mov	edx, DWORD PTR _iid$[ebp]
	push	edx
	call	?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
	test	eax, eax
	je	SHORT $L209262

; 2892 : 		{
; 2893 : 			*ppvObject = (void*)(IUnknown*)this;

	mov	eax, DWORD PTR _ppvObject$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 2894 : 			AddRef();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	DWORD PTR [eax+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2895 : #ifdef _ATL_DEBUG_INTERFACES
; 2896 : 			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
; 2897 : #endif // _ATL_DEBUG_INTERFACES
; 2898 : 		}
; 2899 : 		else

	jmp	SHORT $L209265
$L209262:

; 2900 : 			hRes = m_contained._InternalQueryInterface(iid, ppvObject);

	mov	edx, DWORD PTR _ppvObject$[ebp]
	push	edx
	mov	eax, DWORD PTR _iid$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?_InternalQueryInterface@CSignature@@QAEJABU_GUID@@PAPAX@Z ; CSignature::_InternalQueryInterface
	mov	DWORD PTR _hRes$[ebp], eax
$L209265:

; 2901 : 		return hRes;

	mov	eax, DWORD PTR _hRes$[ebp]
$L209256:

; 2902 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@?$CComAggObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComAggObject<CSignature>::QueryInterface
_TEXT	ENDS
PUBLIC	??1?$CComObject@VCSignature@@@ATL@@UAE@XZ	; ATL::CComObject<CSignature>::~CComObject<CSignature>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z PROC NEAR	; ATL::CComObject<CSignature>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComObject@VCSignature@@@ATL@@UAE@XZ ; ATL::CComObject<CSignature>::~CComObject<CSignature>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L209276
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L209276:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CComObject@VCSignature@@@ATL@@UAEPAXI@Z ENDP	; ATL::CComObject<CSignature>::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??1CSignature@@QAE@XZ:NEAR			; CSignature::~CSignature
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComObject@VCSignature@@@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComObject@VCSignature@@@ATL@@UAE@XZ PROC NEAR	; ATL::CComObject<CSignature>::~CComObject<CSignature>, COMDAT
; _this$ = ecx

; 2496 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], OFFSET FLAT:??_7?$CComObject@VCSignature@@@ATL@@6BIObjectWithSite@@@

; 2497 : 		m_dwRef = -(LONG_MAX/2);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -1073741823		; c0000001H

; 2498 : 		FinalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::FinalRelease

; 2499 : #ifdef _ATL_DEBUG_INTERFACES
; 2500 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2501 : #endif
; 2502 : 		_pAtlModule->Unlock();

	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	edx, DWORD PTR [ecx]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2503 : 	}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CSignature@@QAE@XZ			; CSignature::~CSignature
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComObject@VCSignature@@@ATL@@UAE@XZ ENDP		; ATL::CComObject<CSignature>::~CComObject<CSignature>
_TEXT	ENDS
PUBLIC	??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ	; ATL::CComAggObject<CSignature>::~CComAggObject<CSignature>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_G?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z PROC NEAR ; ATL::CComAggObject<CSignature>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ ; ATL::CComAggObject<CSignature>::~CComAggObject<CSignature>
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L209279
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L209279:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$CComAggObject@VCSignature@@@ATL@@UAEPAXI@Z ENDP	; ATL::CComAggObject<CSignature>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ ; ATL::CComAggObject<CSignature>::FinalRelease
;	COMDAT xdata$x
xdata$x	SEGMENT
$T212824 DD	0ffffffffH
	DD	FLAT:$L212820
$T212822 DD	019930520H
	DD	01H
	DD	FLAT:$T212824
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ PROC NEAR	; ATL::CComAggObject<CSignature>::~CComAggObject<CSignature>, COMDAT
; _this$ = ecx

; 2866 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComAggObject@VCSignature@@@ATL@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2867 : 		m_dwRef = -(LONG_MAX/2);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], -1073741823		; c0000001H

; 2868 : 		FinalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ ; ATL::CComAggObject<CSignature>::FinalRelease

; 2869 : #ifdef _ATL_DEBUG_INTERFACES
; 2870 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
; 2871 : #endif
; 2872 : 		_pAtlModule->Unlock();

	mov	edx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2873 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L212820:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ
__ehhandler$??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ:
	mov	eax, OFFSET FLAT:$T212822
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$CComAggObject@VCSignature@@@ATL@@UAE@XZ ENDP	; ATL::CComAggObject<CSignature>::~CComAggObject<CSignature>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComContainedObject<CSignature>::~CComContainedObject<CSignature>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CSignature@@QAE@XZ			; CSignature::~CSignature
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComContainedObject@VCSignature@@@ATL@@QAE@XZ ENDP	; ATL::CComContainedObject<CSignature>::~CComContainedObject<CSignature>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ PROC NEAR ; ATL::CComAggObject<CSignature>::FinalRelease, COMDAT
; _this$ = ecx

; 2859 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2860 : 		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::FinalRelease

; 2861 : 		m_contained.FinalRelease();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?FinalRelease@CComObjectRootBase@ATL@@QAEXXZ ; ATL::CComObjectRootBase::FinalRelease

; 2862 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FinalRelease@?$CComAggObject@VCSignature@@@ATL@@QAEXXZ ENDP ; ATL::CComAggObject<CSignature>::FinalRelease
_TEXT	ENDS
PUBLIC	?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::AddRef
PUBLIC	?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::Release
PUBLIC	?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::QueryInterface
PUBLIC	??_7?$CComContainedObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComContainedObject<CSignature>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@ ; ATL::CComContainedObject<CSignature>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCSignature@@@ATL@@6BIObjectWithSite@@@ ; ATL::CComContainedObject<CSignature>::`vftable'
PUBLIC	?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{4}'
PUBLIC	?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{4}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{8}'
PUBLIC	?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{8}'
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
	DD	FLAT:?GetTypeInfoCount@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
	DD	FLAT:?GetTypeInfo@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
	DD	FLAT:?GetIDsOfNames@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPAGIKPAJ@Z
	DD	FLAT:?Invoke@?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
	DD	FLAT:?get_EnvelopingFlag@CSignature@@UAGJPAF@Z
	DD	FLAT:?put_EnvelopingFlag@CSignature@@UAGJF@Z
	DD	FLAT:?get_RecipientCertificateStore@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_RecipientCertificateStore@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignerCertificate@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_SignerCertificate@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_SignatureID@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_SignatureID@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_Properties@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?put_Properties@CSignature@@UAGJJJPAG@Z
	DD	FLAT:?get_Base64EncodeXML@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_Base64EncodeXML@CSignature@@UAGJH@Z
	DD	FLAT:?get_Base64DecodeXML@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_Base64DecodeXML@CSignature@@UAGJH@Z
	DD	FLAT:?get_DocumentURI@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?get_DigestObjectStatus@CSignature@@UAGJJJPAH@Z
	DD	FLAT:?get_Language@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_Language@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignatureStatus@CSignature@@UAGJJPAH@Z
	DD	FLAT:?get_PhysicalSignatureUsage@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_PhysicalSignatureUsage@CSignature@@UAGJJ@Z
	DD	FLAT:?get_PhysicalSignatureFile@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_PhysicalSignatureFile@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CapturedSignatureFile@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?Sign@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_IncludeCamResponse@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_IncludeCamResponse@CSignature@@UAGJH@Z
	DD	FLAT:?SaveXMLSignature@CSignature@@UAGJPAG@Z
	DD	FLAT:?Verify@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?GetError@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OverwriteFile@CSignature@@UAGJH@Z
	DD	FLAT:?PFXExportCertificate@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?VerifyDetached@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?GetLastError@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetX509Certificate@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?ViewCertificate@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CertificateCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetCertificateInfo@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?SetActiveCertificate@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?get_SignedDocumentPath@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?get_SignerSubject@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertIssuer@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertExpiry@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_CertSerialNumber@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?FileExists@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?get_FailedUriCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_TotalUriCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_FailedUriFullPath@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_FailedUriFullPath@CSignature@@UAGJJPAG@Z
	DD	FLAT:?get_FailedUri@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?get_SignatureCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?SignXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?ReadAll@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SaveXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SignHTML@CSignature@@UAGJPAUIDispatch@@PAPAG@Z
	DD	FLAT:?SecureXMLVerify@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SetCSP@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetSignedHTML@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SignFile@CSignature@@UAGJPAG0@Z
	DD	FLAT:?GetSignedFileObject@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SetStoreName@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetStoreName@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?SignXMLEnveloped@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GetVersion@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?GetLicenseStatus@CSignature@@UAGJPAJ@Z
	DD	FLAT:?GetPropertyCount@CSignature@@UAGJJPAJ@Z
	DD	FLAT:?ViewAnyCertificate@CSignature@@UAGJPAG@Z
	DD	FLAT:?SelectActiveCertificate@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?VerifyXMLStr@CSignature@@UAGJPAGPAH@Z
	DD	FLAT:?SetActivePFXFileCert@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?PFXExportActiveCertificate@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?get_HostName@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_TimeStampURL@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_TimeStampURL@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_TimeStamping@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_TimeStamping@CSignature@@UAGJH@Z
	DD	FLAT:?get_HostOsType@CSignature@@UAGJPAJ@Z
	DD	FLAT:?get_CrlChecking@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CrlChecking@CSignature@@UAGJH@Z
	DD	FLAT:?get_SigCertStatus@CSignature@@UAGJJPAGJPAJ@Z
	DD	FLAT:?VerifyX509CertCRL@CSignature@@UAGJPAG0JPAH@Z
	DD	FLAT:?VerifyPFXCertCRL@CSignature@@UAGJPAG00JPAH@Z
	DD	FLAT:?get_AddWindowImage@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_AddWindowImage@CSignature@@UAGJH@Z
	DD	FLAT:?put_CRLLocation@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?VerifyActiveCertificate@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CertificatePolicy@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_AuthorityConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?get_UserConstrainedPolicy@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?put_CertificatePolicyChecking@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificateChainValidation@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificatePathLengthChecking@CSignature@@UAGJH@Z
	DD	FLAT:?put_ConfigFileName@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_DoDCompliance@CSignature@@UAGJH@Z
	DD	FLAT:?get_CertificatePolicyExplicit@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_CertificatePolicyExplicit@CSignature@@UAGJH@Z
	DD	FLAT:?put_CertificateTrustExplicit@CSignature@@UAGJH@Z
	DD	FLAT:?SignXMLXpathStr@CSignature@@UAGJPAG00PAPAG@Z
	DD	FLAT:?get_UseHMAC@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseHMAC@CSignature@@UAGJH@Z
	DD	FLAT:?get_HMACPassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_HMACPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?ChangeOrAddProperty@CSignature@@UAGJPAG0@Z
	DD	FLAT:?put_DetailedVerificationFlag@CSignature@@UAGJH@Z
	DD	FLAT:?CaptureLiveSignature@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?SignDataStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_ExcludeSignerCertificate@CSignature@@UAGJH@Z
	DD	FLAT:?CoSignXMLStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?CoSignFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?SignFiles@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?put_RecipientCertificates@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?EncryptStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?DecryptStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?EncryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DecryptFileA@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?put_TrustedRoots@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_RecipientCertificateFiles@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_DetachedObjects@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?put_AttachedObjects@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?ReadAllBase64@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_DecryptionPFXCertFile@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_DecryptUsingPFXFileCert@CSignature@@UAGJH@Z
	DD	FLAT:?put_DecryptionPFXPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_XpathNamespace@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_CamServerHost@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CamServerHost@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CamServerPort@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_CamServerPort@CSignature@@UAGJG@Z
	DD	FLAT:?get_UseCam@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseCam@CSignature@@UAGJH@Z
	DD	FLAT:?get_AgencyId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_AgencyId@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_CamValidationResponse@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?GetSigPropValueByName@CSignature@@UAGJJPAGPAPAG@Z
	DD	FLAT:?Base64DecodeBufferToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?Base64DecodeFileToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GunZipFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_CertSerialNumberFormat@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_CertSerialNumberFormat@CSignature@@UAGJJ@Z
	DD	FLAT:?SecureXMLVerifyFileToBuffer@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SecureXMLVerifyFileToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DeleteSignatureFromXMLStr@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?DeleteSignatureFromFile@CSignature@@UAGJPAG00PAPAG@Z
	DD	FLAT:?put_AllowedCertIssuerNames@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_CRLCacheDbConnectionString@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CRLCacheDbConnectionString@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_UseCRLCache@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseCRLCache@CSignature@@UAGJH@Z
	DD	FLAT:?put_CRLCacheTimeoutInMinutes@CSignature@@UAGJK@Z
	DD	FLAT:?put_CanonicalizationMethod@CSignature@@UAGJK@Z
	DD	FLAT:?get_NetscapeStorePassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_NetscapeStorePassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?SetActivePEMFileCert@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_SecureXMLPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_SignedDocumentCount@CSignature@@UAGJJPAJ@Z
	DD	FLAT:?SignXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	DD	FLAT:?SaveXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?ReadAllByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	DD	FLAT:?VerifyXMLByteArray@CSignature@@UAGJUtagVARIANT@@PAH@Z
	DD	FLAT:?SecureXMLVerifyByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?SignXMLXpathByteArray@CSignature@@UAGJUtagVARIANT@@PAG1PAU2@@Z
	DD	FLAT:?SignXMLEnvelopedByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAU2@@Z
	DD	FLAT:?Base64DecodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?Base64DecodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?Base64EncodeByteArrayToByteArray@CSignature@@UAGJUtagVARIANT@@PAU2@@Z
	DD	FLAT:?Base64EncodeByteArrayToFile@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?Base64EncodeStrToFile@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?Base64EncodeStrToStr@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?SetActivePFXB64Data@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?get_FloatingLicense@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_FloatingLicense@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_LicensedUserCount@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_IncludeCRLInSignature@CSignature@@UAGJH@Z
	DD	FLAT:?get_UsedCRLList@CSignature@@UAGJPAUtagVARIANT@@@Z
	DD	FLAT:?GetErrorDetail@CSignature@@UAGJJPAPAG@Z
	DD	FLAT:?put_PhysicalSignatureB64Str@CSignature@@UAGJPAG@Z
	DD	FLAT:?GetSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?GetX509CertificateChain@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?put_SignerCertificateChain@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_SignatureImageId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_SignatureImageId@CSignature@@UAGJPAG@Z
	DD	FLAT:?SignSignedInfoDigest@CSignature@@UAGJPAG0PAPAG@Z
	DD	FLAT:?ApplySignatureValue@CSignature@@UAGJPAGPAPAG@Z
	DD	FLAT:?GetSignedInfoDigestFromByteArray@CSignature@@UAGJUtagVARIANT@@PAGPAPAG@Z
	DD	FLAT:?ApplySignatureValueGetByteArray@CSignature@@UAGJPAGPAUtagVARIANT@@@Z
	DD	FLAT:?GetSignedDocumentB64Str@CSignature@@UAGJJJPAPAG@Z
	DD	FLAT:?GetSignedDocumentByteArray@CSignature@@UAGJJJPAUtagVARIANT@@@Z
	DD	FLAT:?get_CertValidationTransactionId@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_CertValidationTransactionId@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_IgnoreIncompleteSignature@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_IgnoreIncompleteSignature@CSignature@@UAGJH@Z
	DD	FLAT:?get_SignatureIndexToVerify@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_SignatureIndexToVerify@CSignature@@UAGJJ@Z
	DD	FLAT:?get_UseOcsp@CSignature@@UAGJPAH@Z
	DD	FLAT:?put_UseOcsp@CSignature@@UAGJH@Z
	DD	FLAT:?get_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspTrustedRespSignerCertPath@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspReqSignerPFXCertPath@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspReqSignerPFXCertPath@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspReqSignerPFXCertPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspResponderURL@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?put_OcspResponderURL@CSignature@@UAGJPAG@Z
	DD	FLAT:?get_OcspTextResponse@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_OcspB64Response@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_CertRevocationDate@CSignature@@UAGJPAPAG@Z
	DD	FLAT:?get_IncludeOcspResponse@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_IncludeOcspResponse@CSignature@@UAGJJ@Z
	DD	FLAT:?put_ProxyHost@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_ProxyPort@CSignature@@UAGJG@Z
	DD	FLAT:?put_ProxyUserName@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_ProxyPassword@CSignature@@UAGJPAG@Z
	DD	FLAT:?put_InclusiveNamespacePrefixList@CSignature@@UAGJUtagVARIANT@@@Z
	DD	FLAT:?get_TimeStampFormat@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_TimeStampFormat@CSignature@@UAGJJ@Z
	DD	FLAT:?get_TimeStampCritical@CSignature@@UAGJPAJ@Z
	DD	FLAT:?put_TimeStampCritical@CSignature@@UAGJJ@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
CONST	SEGMENT
??_7?$CComContainedObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
	DD	FLAT:?QueryStatus@CSignature@@UAGJPBU_GUID@@KQAU_tagOLECMD@@PAU_tagOLECMDTEXT@@@Z
	DD	FLAT:?Exec@CSignature@@UAGJPBU_GUID@@KKPAUtagVARIANT@@1@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCSignature@@@ATL@@6BIObjectWithSite@@@
CONST	SEGMENT
??_7?$CComContainedObject@VCSignature@@@ATL@@6BIObjectWithSite@@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
	DD	FLAT:?SetSite@CSignature@@UAGJPAUIUnknown@@@Z
	DD	FLAT:?GetSite@CSignature@@UAGJABU_GUID@@PAPAX@Z
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pv$ = 8						; size = 4
??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z PROC NEAR ; ATL::CComContainedObject<CSignature>::CComContainedObject<CSignature>, COMDAT
; _this$ = ecx

; 2804 : 	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CSignature@@QAE@XZ			; CSignature::CSignature
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7?$CComContainedObject@VCSignature@@@ATL@@6B?$IDispatchImpl@UISignature@@$1?IID_ISignature@@3U_GUID@@B$1?LIBID_XMLSIGNLib@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], OFFSET FLAT:??_7?$CComContainedObject@VCSignature@@@ATL@@6BIOleCommandTarget@@@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], OFFSET FLAT:??_7?$CComContainedObject@VCSignature@@@ATL@@6BIObjectWithSite@@@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CComContainedObject@VCSignature@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComContainedObject<CSignature>::CComContainedObject<CSignature>
_TEXT	ENDS
PUBLIC	?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ	; ATL::CComObjectRootBase::OuterAddRef
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComContainedObject<CSignature>::AddRef, COMDAT

; 2813 : 	STDMETHOD_(ULONG, AddRef)() throw() {return OuterAddRef();}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ ; ATL::CComObjectRootBase::OuterAddRef
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ENDP ; ATL::CComContainedObject<CSignature>::AddRef
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ PROC NEAR	; ATL::CComObjectRootBase::OuterAddRef, COMDAT
; _this$ = ecx

; 2180 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2181 : 		return m_pOuterUnknown->AddRef();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2182 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?OuterAddRef@CComObjectRootBase@ATL@@QAEKXZ ENDP	; ATL::CComObjectRootBase::OuterAddRef
_TEXT	ENDS
PUBLIC	?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ	; ATL::CComObjectRootBase::OuterRelease
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ PROC NEAR ; ATL::CComContainedObject<CSignature>::Release, COMDAT

; 2814 : 	STDMETHOD_(ULONG, Release)() throw() {return OuterRelease();}

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ ; ATL::CComObjectRootBase::OuterRelease
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	4
?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ENDP ; ATL::CComContainedObject<CSignature>::Release
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ PROC NEAR	; ATL::CComObjectRootBase::OuterRelease, COMDAT
; _this$ = ecx

; 2184 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2185 : 		return m_pOuterUnknown->Release();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2186 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?OuterRelease@CComObjectRootBase@ATL@@QAEKXZ ENDP	; ATL::CComObjectRootBase::OuterRelease
_TEXT	ENDS
PUBLIC	?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z ; ATL::CComObjectRootBase::OuterQueryInterface
; Function compile flags: /Odt /RTCsu
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComContainedObject<CSignature>::QueryInterface, COMDAT

; 2816 : 	{

	push	ebp
	mov	ebp, esp

; 2817 : 		return OuterQueryInterface(iid, ppvObject);

	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z ; ATL::CComObjectRootBase::OuterQueryInterface

; 2818 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	12					; 0000000cH
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComContainedObject<CSignature>::QueryInterface
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iid$ = 8						; size = 4
_ppvObject$ = 12					; size = 4
?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z PROC NEAR ; ATL::CComObjectRootBase::OuterQueryInterface, COMDAT
; _this$ = ecx

; 2188 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2189 : 		return m_pOuterUnknown->QueryInterface(iid, ppvObject);

	mov	esi, esp
	mov	eax, DWORD PTR _ppvObject$[ebp]
	push	eax
	mov	ecx, DWORD PTR _iid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	push	edx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2190 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?OuterQueryInterface@CComObjectRootBase@ATL@@QAEJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObjectRootBase::OuterQueryInterface
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::QueryInterface
?QueryInterface@?$CComObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComObject<CSignature>::AddRef
?AddRef@?$CComObject@VCSignature@@@ATL@@W3AGKXZ ENDP	; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComObject<CSignature>::Release
?Release@?$CComObject@VCSignature@@@ATL@@W3AGKXZ ENDP	; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?QueryInterface@?$CComObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<CSignature>::QueryInterface
?QueryInterface@?$CComObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<CSignature>::QueryInterface`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?AddRef@?$CComObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComObject<CSignature>::AddRef
?AddRef@?$CComObject@VCSignature@@@ATL@@W7AGKXZ ENDP	; [thunk]:ATL::CComObject<CSignature>::AddRef`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ PROC NEAR ; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?Release@?$CComObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComObject<CSignature>::Release
?Release@?$CComObject@VCSignature@@@ATL@@W7AGKXZ ENDP	; [thunk]:ATL::CComObject<CSignature>::Release`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::QueryInterface
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W3AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::AddRef
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{4}', COMDAT
	sub	DWORD PTR [esp+4], 4
	jmp	?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::Release
?Release@?$CComContainedObject@VCSignature@@@ATL@@W3AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{4}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<CSignature>::QueryInterface
?QueryInterface@?$CComContainedObject@VCSignature@@@ATL@@W7AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::QueryInterface`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?AddRef@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::AddRef
?AddRef@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::AddRef`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ PROC NEAR ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{8}', COMDAT
	sub	DWORD PTR [esp+4], 8
	jmp	?Release@?$CComContainedObject@VCSignature@@@ATL@@UAGKXZ ; ATL::CComContainedObject<CSignature>::Release
?Release@?$CComContainedObject@VCSignature@@@ATL@@W7AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<CSignature>::Release`adjustor{8}'
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CComObjectRootBase@ATL@@QAE@XZ	; ATL::CComObjectRootBase::CComObjectRootBase
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComObjectRootEx@VCComSingleThreadModel@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComObjectRootEx<ATL::CComSingleThreadModel>::CComObjectRootEx<ATL::CComSingleThreadModel>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 375  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

	mov	eax, DWORD PTR _nRequestedSize$[ebp]
	add	eax, 8
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 377  : 		if (p == NULL)

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L162795

; 378  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $L162782
$L162795:

; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 382  : 		m_pHead = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx

; 383  : 		
; 384  : 		return p->GetData();

	mov	ecx, DWORD PTR _p$[ebp]
	call	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
$L162782:

; 385  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 30   : 	{

	push	ebp
	mov	ebp, esp

; 31   : 		return malloc(nBytes);

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	_malloc
	add	esp, 4

; 32   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
_p$162801 = -8						; size = 4
_this$ = -4						; size = 4
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
$L162799:

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162797

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _p$162801[ebp], edx

; 392  : 			m_pHead = m_pHead->m_pNext;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 393  : 			Allocator::Free(p);

	mov	ecx, DWORD PTR _p$162801[ebp]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 394  : 		}

	jmp	SHORT $L162799
$L162797:

; 395  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp

; 36   : 		free(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 37   : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L162865

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L162865:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize, COMDAT
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::GetSize
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$162915 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 173  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 		if(m_aT != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162914

; 175  : 		{
; 176  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$162915[ebp], 0
	jmp	SHORT $L162916
$L162917:
	mov	ecx, DWORD PTR _i$162915[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$162915[ebp], ecx
$L162916:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$162915[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jge	SHORT $L162918

; 177  : 				m_aT[i].~T();

	jmp	SHORT $L162917
$L162918:

; 178  : 			free(m_aT);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 179  : 			m_aT = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L162914:

; 180  : 		}
; 181  : 		m_nSize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 182  : 		m_nAllocSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 183  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
PUBLIC	??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ ; `string'
;	COMDAT ??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
CONST	SEGMENT
??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@ DB 'n'
	DB	'Index >= 0 && nIndex < m_nSize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lsimpcoll.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 194  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 195  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L212897
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L212898
$L212897:
	push	OFFSET FLAT:??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
	push	0
	push	195					; 000000c3H
	push	OFFSET FLAT:??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212898
	int	3
$L212898:

; 196  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L162924
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jl	SHORT $L162923
$L162924:

; 197  : 		{
; 198  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);					

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$L162923:

; 199  : 		}
; 200  : 		return m_aT[nIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [eax+ecx*2]
$L212896:

; 201  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
EXTRN	__imp__RaiseException@16:NEAR
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC NEAR		; ATL::_AtlRaiseException, COMDAT

; 26   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 27   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _dwExceptionFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwExceptionCode$[ebp]
	push	ecx
	call	DWORD PTR __imp__RaiseException@16
	cmp	esi, esp
	call	__RTC_CheckEsp

; 28   : }

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
PUBLIC	?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlComModule::RegisterServer
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer, COMDAT
; _this$ = ecx

; 2873 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2874 : 		(pCLSID);
; 2875 : 		(bRegTypeLib);
; 2876 : 
; 2877 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 2878 : 
; 2879 : #ifndef _ATL_NO_COM_SUPPORT
; 2880 : 
; 2881 : 		hr = _AtlComModule.RegisterServer(bRegTypeLib, pCLSID);

	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegTypeLib$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_AtlComModule@ATL@@3VCAtlComModule@1@A
	call	?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlComModule::RegisterServer
	mov	DWORD PTR _hr$[ebp], eax

; 2882 : 
; 2883 : #endif	// _ATL_NO_COM_SUPPORT
; 2884 : 
; 2885 : 
; 2886 : #ifndef _ATL_NO_PERF_SUPPORT
; 2887 : 
; 2888 : 		if (SUCCEEDED(hr) && _pPerfRegFunc != NULL)

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L162933
	cmp	DWORD PTR ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA, 0 ; ATL::_pPerfRegFunc
	je	SHORT $L162933

; 2889 : 			hr = (*_pPerfRegFunc)(_AtlBaseModule.m_hInst);

	mov	esi, esp
	mov	edx, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
	push	edx
	call	DWORD PTR ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA ; ATL::_pPerfRegFunc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L162933:

; 2890 : 
; 2891 : #endif
; 2892 : 
; 2893 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 2894 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
_TEXT	ENDS
PUBLIC	?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleRegisterServer
; Function compile flags: /Odt /RTCsu
;	COMDAT ?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CAtlComModule::RegisterServer, COMDAT
; _this$ = ecx

; 2335 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2336 : 		return AtlComModuleRegisterServer(this, bRegTypeLib, pCLSID);

	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegTypeLib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleRegisterServer

; 2337 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?RegisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlComModule::RegisterServer
_TEXT	ENDS
PUBLIC	??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	??_C@_0CA@JANIBNGM@pComModule?9?$DOm_hInstTypeLib?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ; ATL::AtlRegisterTypeLib
;	COMDAT ??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@ DB 'pComModule != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@JANIBNGM@pComModule?9?$DOm_hInstTypeLib?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0CA@JANIBNGM@pComModule?9?$DOm_hInstTypeLib?5?$CB?$DN?50?$AA@ DB 'p'
	DB	'ComModule->m_hInstTypeLib != 0', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT
_pEntry$91353 = -12					; size = 4
_ppEntry$91348 = -8					; size = 4
_hr$ = -4						; size = 4
_pComModule$ = 8					; size = 4
_bRegTypeLib$ = 12					; size = 4
_pCLSID$ = 16						; size = 4
?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z PROC NEAR ; ATL::AtlComModuleRegisterServer, COMDAT

; 6028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6029 : 	ATLASSERT(pComModule != NULL);

	cmp	DWORD PTR _pComModule$[ebp], 0
	jne	SHORT $L212907
	push	OFFSET FLAT:??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@
	push	0
	push	6029					; 0000178dH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212907
	int	3
$L212907:

; 6030 : 	if (pComModule == NULL)

	cmp	DWORD PTR _pComModule$[ebp], 0
	jne	SHORT $L91342

; 6031 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L91339
$L91342:

; 6032 : 	ATLASSERT(pComModule->m_hInstTypeLib != NULL);

	mov	ecx, DWORD PTR _pComModule$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L212908
	push	OFFSET FLAT:??_C@_0CA@JANIBNGM@pComModule?9?$DOm_hInstTypeLib?5?$CB?$DN?50?$AA@
	push	0
	push	6032					; 00001790H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212908
	int	3
$L212908:

; 6033 : 
; 6034 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 6035 : 
; 6036 : 	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

	mov	eax, DWORD PTR _pComModule$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ppEntry$91348[ebp], ecx
	jmp	SHORT $L91349
$L91350:
	mov	edx, DWORD PTR _ppEntry$91348[ebp]
	add	edx, 4
	mov	DWORD PTR _ppEntry$91348[ebp], edx
$L91349:
	mov	eax, DWORD PTR _pComModule$[ebp]
	mov	ecx, DWORD PTR _ppEntry$91348[ebp]
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $L91351

; 6037 : 	{
; 6038 : 		if (*ppEntry != NULL)

	mov	edx, DWORD PTR _ppEntry$91348[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L91352

; 6039 : 		{
; 6040 : 			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;

	mov	eax, DWORD PTR _ppEntry$91348[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pEntry$91353[ebp], ecx

; 6041 : 			if (pCLSID != NULL)

	cmp	DWORD PTR _pCLSID$[ebp], 0
	je	SHORT $L91354

; 6042 : 			{
; 6043 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))

	mov	edx, DWORD PTR _pEntry$91353[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pCLSID$[ebp]
	push	ecx
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $L91354

; 6044 : 					continue;

	jmp	SHORT $L91350
$L91354:

; 6045 : 			}
; 6046 : 			hr = pEntry->pfnUpdateRegistry(TRUE);

	mov	esi, esp
	push	1
	mov	edx, DWORD PTR _pEntry$91353[ebp]
	call	DWORD PTR [edx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 6047 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91357

; 6048 : 				break;

	jmp	SHORT $L91351
$L91357:

; 6049 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
; 6050 : 				pEntry->pfnGetCategoryMap(), TRUE );

	push	1
	mov	eax, DWORD PTR _pEntry$91353[ebp]
	mov	esi, esp
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pEntry$91353[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
	mov	DWORD PTR _hr$[ebp], eax

; 6051 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91352

; 6052 : 				break;

	jmp	SHORT $L91351
$L91352:

; 6053 : 		}
; 6054 : 	}

	jmp	$L91350
$L91351:

; 6055 : 
; 6056 : 	if (SUCCEEDED(hr) && bRegTypeLib)

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91361
	cmp	DWORD PTR _bRegTypeLib$[ebp], 0
	je	SHORT $L91361

; 6057 : 		hr = AtlRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

	push	0
	mov	eax, DWORD PTR _pComModule$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ; ATL::AtlRegisterTypeLib
	mov	DWORD PTR _hr$[ebp], eax
$L91361:

; 6058 : 
; 6059 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L91339:

; 6060 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ENDP ; ATL::AtlComModuleRegisterServer
_TEXT	ENDS
PUBLIC	??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
PUBLIC	?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
EXTRN	__imp__RegisterTypeLib@12:NEAR
EXTRN	_wcsncpy:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT
$T212912 = -572						; size = 4
_nLenIndex$91332 = -568					; size = 4
_nLenPath$91331 = -564					; size = 4
_szDir$91329 = -556					; size = 520
_hr$ = -32						; size = 4
_pTypeLib$ = -24					; size = 4
_bstrPath$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hInstTypeLib$ = 8					; size = 4
_lpszIndex$ = 12					; size = 4
?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z PROC NEAR ; ATL::AtlRegisterTypeLib, COMDAT

; 5998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 572				; 0000023cH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-572]
	mov	ecx, 143				; 0000008fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5999 : 	CComBSTR bstrPath;

	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR

; 6000 : 	CComPtr<ITypeLib> pTypeLib;

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ	; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>

; 6001 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator&
	push	eax
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??ICComBSTR@ATL@@QAEPAPAGXZ		; ATL::CComBSTR::operator&
	push	eax
	mov	eax, DWORD PTR _lpszIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInstTypeLib$[ebp]
	push	ecx
	call	?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
	mov	DWORD PTR _hr$[ebp], eax

; 6002 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$L91328

; 6003 : 	{
; 6004 : 		OLECHAR szDir[MAX_PATH];
; 6005 : 		wcsncpy(szDir,bstrPath,MAX_PATH - 1);

	push	259					; 00000103H
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	lea	edx, DWORD PTR _szDir$91329[ebp]
	push	edx
	call	_wcsncpy
	add	esp, 12					; 0000000cH

; 6006 : 		szDir[MAX_PATH - 1] = 0;

	mov	WORD PTR _szDir$91329[ebp+518], 0

; 6007 : 		// If index is specified remove it from the path
; 6008 : 		if (lpszIndex != NULL)

	cmp	DWORD PTR _lpszIndex$[ebp], 0
	je	SHORT $L91330

; 6009 : 		{
; 6010 : 			size_t nLenPath = ocslen(szDir);

	lea	eax, DWORD PTR _szDir$91329[ebp]
	push	eax
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	mov	DWORD PTR _nLenPath$91331[ebp], eax

; 6011 : 			size_t nLenIndex = ocslen(lpszIndex);

	mov	ecx, DWORD PTR _lpszIndex$[ebp]
	push	ecx
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	mov	DWORD PTR _nLenIndex$91332[ebp], eax

; 6012 : 			if (memcmp(szDir + nLenPath - nLenIndex, lpszIndex, nLenIndex) == 0)

	mov	edx, DWORD PTR _nLenIndex$91332[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nLenPath$91331[ebp]
	lea	edx, DWORD PTR _szDir$91329[ebp+ecx*2]
	mov	eax, DWORD PTR _nLenIndex$91332[ebp]
	shl	eax, 1
	sub	edx, eax
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L91330

; 6013 : 				szDir[nLenPath - nLenIndex] = 0;

	mov	ecx, DWORD PTR _nLenPath$91331[ebp]
	sub	ecx, DWORD PTR _nLenIndex$91332[ebp]
	mov	WORD PTR _szDir$91329[ebp+ecx*2], 0
$L91330:

; 6014 : 		}
; 6015 : 		szDir[AtlGetDirLen(szDir)] = 0;

	lea	edx, DWORD PTR _szDir$91329[ebp]
	push	edx
	call	?AtlGetDirLen@ATL@@YGIPBG@Z		; ATL::AtlGetDirLen
	mov	WORD PTR _szDir$91329[ebp+eax*2], 0

; 6016 : 		hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);

	mov	esi, esp
	lea	eax, DWORD PTR _szDir$91329[ebp]
	push	eax
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??BCComBSTR@ATL@@QBEPAGXZ		; ATL::CComBSTR::operator unsigned short *
	push	eax
	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
	push	eax
	call	DWORD PTR __imp__RegisterTypeLib@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L91328:

; 6017 : 	}
; 6018 : 	return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212912[ebp], ecx
	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T212912[ebp]

; 6019 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212918
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	add	esp, 572				; 0000023cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L212918:
	DD	3
	DD	$L212917
$L212917:
	DD	-12					; fffffff4H
	DD	4
	DD	$L212913
	DD	-24					; ffffffe8H
	DD	4
	DD	$L212914
	DD	-556					; fffffdd4H
	DD	520					; 00000208H
	DD	$L212915
$L212915:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	68					; 00000044H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	0
$L212914:
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	0
$L212913:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ENDP	; ATL::AtlRegisterTypeLib
_TEXT	ENDS
PUBLIC	?CharNextO@@YAPAGPBG@Z				; CharNextO
; Function compile flags: /Odt /RTCsu
_TEXT	SEGMENT
_lp$91144 = -12						; size = 4
_lpsz$91140 = -8					; size = 4
_lpszTemp$ = -4						; size = 4
_lpszPathName$ = 8					; size = 4
?AtlGetDirLen@ATL@@YGIPBG@Z PROC NEAR			; ATL::AtlGetDirLen

; 5888 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 5889 : 	ATLASSERT(lpszPathName != NULL);

	cmp	DWORD PTR _lpszPathName$[ebp], 0
	jne	SHORT $L212921
	push	OFFSET FLAT:$SG91136
	push	0
	push	5889					; 00001701H
	push	OFFSET FLAT:$SG91137
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212921
	int	3
$L212921:

; 5890 : 	if(lpszPathName == NULL)

	cmp	DWORD PTR _lpszPathName$[ebp], 0
	jne	SHORT $L91138

; 5891 : 		return 0;

	xor	eax, eax
	jmp	SHORT $L91134
$L91138:

; 5892 : 
; 5893 : 	// always capture the complete file name including extension (if present)
; 5894 : 	LPCOLESTR lpszTemp = lpszPathName;

	mov	ecx, DWORD PTR _lpszPathName$[ebp]
	mov	DWORD PTR _lpszTemp$[ebp], ecx

; 5895 : 	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )

	mov	edx, DWORD PTR _lpszPathName$[ebp]
	mov	DWORD PTR _lpsz$91140[ebp], edx
$L91142:
	mov	eax, DWORD PTR _lpsz$91140[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $L91143

; 5896 : 	{
; 5897 : 		LPCOLESTR lp = CharNextO(lpsz);

	mov	edx, DWORD PTR _lpsz$91140[ebp]
	push	edx
	call	?CharNextO@@YAPAGPBG@Z			; CharNextO
	add	esp, 4
	mov	DWORD PTR _lp$91144[ebp], eax

; 5898 : 		// remember last directory/drive separator
; 5899 : 		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))

	mov	eax, DWORD PTR _lpsz$91140[ebp]
	movzx	ecx, WORD PTR [eax]
	cmp	ecx, 92					; 0000005cH
	je	SHORT $L91146
	mov	edx, DWORD PTR _lpsz$91140[ebp]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $L91146
	mov	ecx, DWORD PTR _lpsz$91140[ebp]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $L91145
$L91146:

; 5900 : 			lpszTemp = lp;

	mov	eax, DWORD PTR _lp$91144[ebp]
	mov	DWORD PTR _lpszTemp$[ebp], eax
$L91145:

; 5901 : 		lpsz = lp;

	mov	ecx, DWORD PTR _lp$91144[ebp]
	mov	DWORD PTR _lpsz$91140[ebp], ecx

; 5902 : 	}

	jmp	SHORT $L91142
$L91143:

; 5903 : 
; 5904 : 	return UINT( lpszTemp-lpszPathName );

	mov	eax, DWORD PTR _lpszTemp$[ebp]
	sub	eax, DWORD PTR _lpszPathName$[ebp]
	sar	eax, 1
$L91134:

; 5905 : }

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AtlGetDirLen@ATL@@YGIPBG@Z ENDP			; ATL::AtlGetDirLen
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_TEXT	ENDS
;	COMDAT ?CharNextO@@YAPAGPBG@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_lp$ = 8						; size = 4
?CharNextO@@YAPAGPBG@Z PROC NEAR			; CharNextO, COMDAT

; 700  : 	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	eax, DWORD PTR _lp$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $L212923
	mov	edx, DWORD PTR _lp$[ebp]
	add	edx, 2
	mov	DWORD PTR tv67[ebp], edx
	jmp	SHORT $L212924
$L212923:
	mov	eax, DWORD PTR _lp$[ebp]
	mov	DWORD PTR tv67[ebp], eax
$L212924:
	mov	eax, DWORD PTR tv67[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?CharNextO@@YAPAGPBG@Z ENDP				; CharNextO
_TEXT	ENDS
PUBLIC	??_C@_0CB@IHBDCFNI@pbstrPath?5?$CB?$DN?50?5?$CG?$CG?5ppTypeLib?5?$CB?$DN?50@ ; `string'
PUBLIC	??_C@_0BC@OFPPHOIH@hInstTypeLib?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_04LFHHJFCN@?4tlb?$AA@			; `string'
EXTRN	__imp__PathFindExtensionA@4:NEAR
EXTRN	__imp__SysAllocString@4:NEAR
;	COMDAT ??_C@_0CB@IHBDCFNI@pbstrPath?5?$CB?$DN?50?5?$CG?$CG?5ppTypeLib?5?$CB?$DN?50@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CONST	SEGMENT
??_C@_0CB@IHBDCFNI@pbstrPath?5?$CB?$DN?50?5?$CG?$CG?5ppTypeLib?5?$CB?$DN?50@ DB 'p'
	DB	'bstrPath != 0 && ppTypeLib != 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OFPPHOIH@hInstTypeLib?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BC@OFPPHOIH@hInstTypeLib?5?$CB?$DN?50?$AA@ DB 'hInstTypeLib != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFHHJFCN@?4tlb?$AA@
CONST	SEGMENT
??_C@_04LFHHJFCN@?4tlb?$AA@ DB '.tlb', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z
_TEXT	SEGMENT
tv226 = -420						; size = 4
tv219 = -416						; size = 4
tv228 = -412						; size = 4
tv185 = -408						; size = 4
tv178 = -404						; size = 4
tv187 = -400						; size = 4
tv151 = -396						; size = 4
tv146 = -392						; size = 4
tv153 = -388						; size = 4
$T212950 = -384						; size = 4
$T212949 = -380						; size = 4
$T212944 = -376						; size = 4
$T212943 = -372						; size = 4
$T212938 = -368						; size = 4
$T212937 = -364						; size = 4
$T212932 = -360						; size = 4
$T212931 = -356						; size = 4
_szExt$91201 = -348					; size = 5
_hr$ = -336						; size = 4
_lpszModule$ = -332					; size = 4
_nIndexLen$91185 = -328					; size = 4
_lpcszIndex$91178 = -324				; size = 4
_lpszExt$ = -320					; size = 4
_dwFLen$ = -316						; size = 4
_szModule$ = -308					; size = 270
__AtlSafeAllocaManager$ = -28				; size = 4
__lpa_ex$ = -20						; size = 4
__lpw_ex$ = -16						; size = 4
__acp_ex$ = -12						; size = 4
__convert_ex$ = -8					; size = 4
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_hInstTypeLib$ = 8					; size = 4
_lpszIndex$ = 12					; size = 4
_pbstrPath$ = 16					; size = 4
_ppTypeLib$ = 20					; size = 4
?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z PROC NEAR ; ATL::AtlLoadTypeLib, COMDAT

; 5913 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 420				; 000001a4H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-420]
	mov	ecx, 105				; 00000069H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5914 : 	ATLASSERT(pbstrPath != NULL && ppTypeLib != NULL);

	cmp	DWORD PTR _pbstrPath$[ebp], 0
	je	SHORT $L212928
	cmp	DWORD PTR _ppTypeLib$[ebp], 0
	jne	SHORT $L212929
$L212928:
	push	OFFSET FLAT:??_C@_0CB@IHBDCFNI@pbstrPath?5?$CB?$DN?50?5?$CG?$CG?5ppTypeLib?5?$CB?$DN?50@
	push	0
	push	5914					; 0000171aH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212929
	int	3
$L212929:

; 5915 : 	if (pbstrPath == NULL || ppTypeLib == NULL)

	cmp	DWORD PTR _pbstrPath$[ebp], 0
	je	SHORT $L91157
	cmp	DWORD PTR _ppTypeLib$[ebp], 0
	jne	SHORT $L91156
$L91157:

; 5916 : 		return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L91153
$L91156:

; 5917 : 
; 5918 : 	*pbstrPath = NULL;

	mov	ecx, DWORD PTR _pbstrPath$[ebp]
	mov	DWORD PTR [ecx], 0

; 5919 : 	*ppTypeLib = NULL;

	mov	edx, DWORD PTR _ppTypeLib$[ebp]
	mov	DWORD PTR [edx], 0

; 5920 : 
; 5921 : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>

; 5922 : 	ATLASSERT(hInstTypeLib != NULL);

	cmp	DWORD PTR _hInstTypeLib$[ebp], 0
	jne	SHORT $L212930
	push	OFFSET FLAT:??_C@_0BC@OFPPHOIH@hInstTypeLib?5?$CB?$DN?50?$AA@
	push	0
	push	5922					; 00001722H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212930
	int	3
$L212930:

; 5923 : 	TCHAR szModule[_ATL_MAX_PATH_PLUS_INDEX];
; 5924 : 
; 5925 : 	DWORD dwFLen = GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szModule$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstTypeLib$[ebp]
	push	edx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFLen$[ebp], eax

; 5926 : 	if( dwFLen == 0 )

	cmp	DWORD PTR _dwFLen$[ebp], 0
	jne	SHORT $L91168

; 5927 : 		return AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR $T212931[ebp], eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212931[ebp]
	jmp	$L91153
$L91168:

; 5928 : 	else if( dwFLen == MAX_PATH )

	cmp	DWORD PTR _dwFLen$[ebp], 260		; 00000104H
	jne	SHORT $L91170

; 5929 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	mov	DWORD PTR $T212932[ebp], -2147024774	; 8007007aH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212932[ebp]
	jmp	$L91153
$L91170:

; 5930 : 
; 5931 : 	// get the extension pointer in case of fail
; 5932 : 	LPTSTR lpszExt = NULL;

	mov	DWORD PTR _lpszExt$[ebp], 0

; 5933 : 
; 5934 : 	lpszExt = PathFindExtension(szModule);

	mov	esi, esp
	lea	eax, DWORD PTR _szModule$[ebp]
	push	eax
	call	DWORD PTR __imp__PathFindExtensionA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _lpszExt$[ebp], eax

; 5935 : 
; 5936 : 	if (lpszIndex != NULL)

	cmp	DWORD PTR _lpszIndex$[ebp], 0
	je	$L91177

; 5937 : 	{
; 5938 : 		LPCTSTR lpcszIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	ecx, DWORD PTR _lpszIndex$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], ecx
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L212935
	mov	DWORD PTR tv153[ebp], 0
	jmp	$L212936
$L212935:
	mov	esi, esp
	mov	edx, DWORD PTR __lpw_ex$[ebp]
	push	edx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	eax, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], eax
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L212933
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	push	ecx
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $L212933
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv146[ebp], esp
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $L212934
$L212933:
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv151[ebp], eax
$L212934:
	mov	edx, DWORD PTR __acp_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv151[ebp]
	push	edx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv153[ebp], eax
$L212936:
	mov	eax, DWORD PTR tv153[ebp]
	mov	DWORD PTR _lpcszIndex$91178[ebp], eax

; 5939 : #ifndef _UNICODE
; 5940 : 		if(lpcszIndex == NULL) 

	cmp	DWORD PTR _lpcszIndex$91178[ebp], 0
	jne	SHORT $L91182

; 5941 : 			return E_OUTOFMEMORY;

	mov	DWORD PTR $T212937[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212937[ebp]
	jmp	$L91153
$L91182:

; 5942 : #endif		
; 5943 : 		int nIndexLen = lstrlen(lpcszIndex);

	mov	esi, esp
	mov	ecx, DWORD PTR _lpcszIndex$91178[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _nIndexLen$91185[ebp], eax

; 5944 : 		
; 5945 : 		if( dwFLen + nIndexLen >= _ATL_MAX_PATH_PLUS_INDEX )

	mov	edx, DWORD PTR _dwFLen$[ebp]
	add	edx, DWORD PTR _nIndexLen$91185[ebp]
	cmp	edx, 270				; 0000010eH
	jb	SHORT $L91186

; 5946 : 			return E_FAIL;

	mov	DWORD PTR $T212938[ebp], -2147467259	; 80004005H
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212938[ebp]
	jmp	$L91153
$L91186:

; 5947 : 		lstrcpy(szModule + dwFLen,lpcszIndex);

	mov	esi, esp
	mov	eax, DWORD PTR _lpcszIndex$91178[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwFLen$[ebp]
	lea	edx, DWORD PTR _szModule$[ebp+ecx]
	push	edx
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91177:

; 5948 : 	}
; 5949 : 	LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szModule$[ebp]
	mov	DWORD PTR __lpa_ex$[ebp], eax
	cmp	DWORD PTR __lpa_ex$[ebp], 0
	jne	SHORT $L212941
	mov	DWORD PTR tv187[ebp], 0
	jmp	$L212942
$L212941:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$[ebp], eax
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L212939
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L212939
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv178[ebp], esp
	mov	edx, DWORD PTR tv178[ebp]
	mov	DWORD PTR tv185[ebp], edx
	jmp	SHORT $L212940
$L212939:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv185[ebp], eax
$L212940:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv185[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv187[ebp], eax
$L212942:
	mov	edx, DWORD PTR tv187[ebp]
	mov	DWORD PTR _lpszModule$[ebp], edx

; 5950 : #ifndef _UNICODE
; 5951 : 	if(lpszModule == NULL) 

	cmp	DWORD PTR _lpszModule$[ebp], 0
	jne	SHORT $L91195

; 5952 : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T212943[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212943[ebp]
	jmp	$L91153
$L91195:

; 5953 : #endif	
; 5954 : 	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);

	mov	esi, esp
	mov	eax, DWORD PTR _ppTypeLib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszModule$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadTypeLib@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 5955 : 	if (!SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$L91200

; 5956 : 	{
; 5957 : 		// typelib not in module, try <module>.tlb instead
; 5958 : 		TCHAR szExt[] = _T(".tlb");

	mov	edx, DWORD PTR ??_C@_04LFHHJFCN@?4tlb?$AA@
	mov	DWORD PTR _szExt$91201[ebp], edx
	mov	al, BYTE PTR ??_C@_04LFHHJFCN@?4tlb?$AA@+4
	mov	BYTE PTR _szExt$91201[ebp+4], al

; 5959 : 		if ((lpszExt - szModule + sizeof(szExt)/sizeof(TCHAR)) > _MAX_PATH)

	mov	ecx, DWORD PTR _lpszExt$[ebp]
	lea	edx, DWORD PTR _szModule$[ebp]
	sub	ecx, edx
	add	ecx, 5
	cmp	ecx, 260				; 00000104H
	jbe	SHORT $L91204

; 5960 : 			return E_FAIL;

	mov	DWORD PTR $T212944[ebp], -2147467259	; 80004005H
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212944[ebp]
	jmp	$L91153
$L91204:

; 5961 : 			
; 5962 : 		lstrcpy(lpszExt, szExt);

	mov	esi, esp
	lea	eax, DWORD PTR _szExt$91201[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszExt$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcpyA@8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 5963 : 		lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	edx, DWORD PTR _szModule$[ebp]
	mov	DWORD PTR __lpa_ex$[ebp], edx
	cmp	DWORD PTR __lpa_ex$[ebp], 0
	jne	SHORT $L212947
	mov	DWORD PTR tv228[ebp], 0
	jmp	$L212948
$L212947:
	mov	esi, esp
	mov	eax, DWORD PTR __lpa_ex$[ebp]
	push	eax
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$[ebp], eax
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	shl	ecx, 1
	cmp	ecx, 1024				; 00000400H
	ja	SHORT $L212945
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	push	edx
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	SHORT $L212945
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv219[ebp], esp
	mov	ecx, DWORD PTR tv219[ebp]
	mov	DWORD PTR tv226[ebp], ecx
	jmp	SHORT $L212946
$L212945:
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	push	edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv226[ebp], eax
$L212946:
	mov	eax, DWORD PTR __acp_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR __convert_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __lpa_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR tv226[ebp]
	push	eax
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv228[ebp], eax
$L212948:
	mov	ecx, DWORD PTR tv228[ebp]
	mov	DWORD PTR _lpszModule$[ebp], ecx

; 5964 : #ifndef _UNICODE
; 5965 : 		if(lpszModule == NULL) 

	cmp	DWORD PTR _lpszModule$[ebp], 0
	jne	SHORT $L91212

; 5966 : 			return E_OUTOFMEMORY;

	mov	DWORD PTR $T212949[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212949[ebp]
	jmp	SHORT $L91153
$L91212:

; 5967 : #endif		
; 5968 : 		hr = LoadTypeLib(lpszModule, ppTypeLib);

	mov	esi, esp
	mov	edx, DWORD PTR _ppTypeLib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpszModule$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadTypeLib@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L91200:

; 5969 : 	}
; 5970 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91216

; 5971 : 	{
; 5972 : 		*pbstrPath = ::SysAllocString(lpszModule);

	mov	esi, esp
	mov	ecx, DWORD PTR _lpszModule$[ebp]
	push	ecx
	call	DWORD PTR __imp__SysAllocString@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	edx, DWORD PTR _pbstrPath$[ebp]
	mov	DWORD PTR [edx], eax

; 5973 : 		if (*pbstrPath == NULL)

	mov	eax, DWORD PTR _pbstrPath$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L91216

; 5974 : 			hr = E_OUTOFMEMORY;

	mov	DWORD PTR _hr$[ebp], -2147024882	; 8007000eH
$L91216:

; 5975 : 	}
; 5976 : 	return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212950[ebp], ecx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T212950[ebp]
$L91153:

; 5977 : }

	lea	esp, DWORD PTR [ebp-428]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212956
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L212956:
	DD	3
	DD	$L212955
$L212955:
	DD	-28					; ffffffe4H
	DD	4
	DD	$L212951
	DD	-308					; fffffeccH
	DD	270					; 0000010eH
	DD	$L212952
	DD	-348					; fffffea4H
	DD	5
	DD	$L212953
$L212953:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	69					; 00000045H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	0
$L212952:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L212951:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z ENDP ; ATL::AtlLoadTypeLib
_TEXT	ENDS
PUBLIC	?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlComModule::UnregisterServer
; Function compile flags: /Odt /RTCsu
;	COMDAT ?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_bUnRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer, COMDAT
; _this$ = ecx

; 2897 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2898 : 		(bUnRegTypeLib);
; 2899 : 		(pCLSID);
; 2900 : 
; 2901 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 2902 : 
; 2903 : #ifndef _ATL_NO_PERF_SUPPORT
; 2904 : 
; 2905 : 		if (_pPerfUnRegFunc != NULL)

	cmp	DWORD PTR ?_pPerfUnRegFunc@ATL@@3P6AJXZA, 0 ; ATL::_pPerfUnRegFunc
	je	SHORT $L162938

; 2906 : 			hr = (*_pPerfUnRegFunc)();

	mov	esi, esp
	call	DWORD PTR ?_pPerfUnRegFunc@ATL@@3P6AJXZA ; ATL::_pPerfUnRegFunc
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L162938:

; 2907 : 
; 2908 : #endif
; 2909 : 
; 2910 : #ifndef _ATL_NO_COM_SUPPORT
; 2911 : 
; 2912 : 		if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L162940

; 2913 : 			hr = _AtlComModule.UnregisterServer(bUnRegTypeLib, pCLSID);

	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bUnRegTypeLib$[ebp]
	push	ecx
	mov	ecx, OFFSET FLAT:?_AtlComModule@ATL@@3VCAtlComModule@1@A
	call	?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlComModule::UnregisterServer
	mov	DWORD PTR _hr$[ebp], eax
$L162940:

; 2914 : 
; 2915 : #endif	// _ATL_NO_COM_SUPPORT
; 2916 : 
; 2917 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 2918 : 
; 2919 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
_TEXT	ENDS
PUBLIC	?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleUnregisterServer
; Function compile flags: /Odt /RTCsu
;	COMDAT ?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z PROC NEAR ; ATL::CAtlComModule::UnregisterServer, COMDAT
; _this$ = ecx

; 2343 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2344 : 		return AtlComModuleUnregisterServer(this, bRegTypeLib, pCLSID);

	mov	eax, DWORD PTR _pCLSID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegTypeLib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleUnregisterServer

; 2345 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?UnregisterServer@CAtlComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlComModule::UnregisterServer
_TEXT	ENDS
PUBLIC	?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ; ATL::AtlUnRegisterTypeLib
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT
_pEntry$91377 = -12					; size = 4
_ppEntry$91372 = -8					; size = 4
_hr$ = -4						; size = 4
_pComModule$ = 8					; size = 4
_bUnRegTypeLib$ = 12					; size = 4
_pCLSID$ = 16						; size = 4
?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z PROC NEAR ; ATL::AtlComModuleUnregisterServer, COMDAT

; 6066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 6067 : 	ATLASSERT(pComModule != NULL);

	cmp	DWORD PTR _pComModule$[ebp], 0
	jne	SHORT $L212963
	push	OFFSET FLAT:??_C@_0BA@MLGHOEGD@pComModule?5?$CB?$DN?50?$AA@
	push	0
	push	6067					; 000017b3H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212963
	int	3
$L212963:

; 6068 : 	if (pComModule == NULL)

	cmp	DWORD PTR _pComModule$[ebp], 0
	jne	SHORT $L91368

; 6069 : 		return E_INVALIDARG;

	mov	eax, -2147024809			; 80070057H
	jmp	$L91366
$L91368:

; 6070 : 
; 6071 : 	HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 6072 : 
; 6073 : 	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

	mov	ecx, DWORD PTR _pComModule$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _ppEntry$91372[ebp], edx
	jmp	SHORT $L91373
$L91374:
	mov	eax, DWORD PTR _ppEntry$91372[ebp]
	add	eax, 4
	mov	DWORD PTR _ppEntry$91372[ebp], eax
$L91373:
	mov	ecx, DWORD PTR _pComModule$[ebp]
	mov	edx, DWORD PTR _ppEntry$91372[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $L91375

; 6074 : 	{
; 6075 : 		if (*ppEntry != NULL)

	mov	eax, DWORD PTR _ppEntry$91372[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L91376

; 6076 : 		{
; 6077 : 			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;

	mov	ecx, DWORD PTR _ppEntry$91372[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pEntry$91377[ebp], edx

; 6078 : 			if (pCLSID != NULL)

	cmp	DWORD PTR _pCLSID$[ebp], 0
	je	SHORT $L91378

; 6079 : 			{
; 6080 : 				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))

	mov	eax, DWORD PTR _pEntry$91377[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pCLSID$[ebp]
	push	edx
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $L91378

; 6081 : 					continue;

	jmp	SHORT $L91374
$L91378:

; 6082 : 			}
; 6083 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, pEntry->pfnGetCategoryMap(), FALSE );

	push	0
	mov	eax, DWORD PTR _pEntry$91377[ebp]
	mov	esi, esp
	call	DWORD PTR [eax+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	mov	ecx, DWORD PTR _pEntry$91377[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
	mov	DWORD PTR _hr$[ebp], eax

; 6084 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91381

; 6085 : 				break;

	jmp	SHORT $L91375
$L91381:

; 6086 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister

	mov	esi, esp
	push	0
	mov	eax, DWORD PTR _pEntry$91377[ebp]
	call	DWORD PTR [eax+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 6087 : 			if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L91376

; 6088 : 				break;

	jmp	SHORT $L91375
$L91376:

; 6089 : 		}
; 6090 : 	}

	jmp	$L91374
$L91375:

; 6091 : 	if (SUCCEEDED(hr) && bUnRegTypeLib)

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91385
	cmp	DWORD PTR _bUnRegTypeLib$[ebp], 0
	je	SHORT $L91385

; 6092 : 		hr = AtlUnRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

	push	0
	mov	ecx, DWORD PTR _pComModule$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ; ATL::AtlUnRegisterTypeLib
	mov	DWORD PTR _hr$[ebp], eax
$L91385:

; 6093 : 
; 6094 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L91366:

; 6095 : }

	pop	esi
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ENDP ; ATL::AtlComModuleUnregisterServer
_TEXT	ENDS
EXTRN	__imp__UnRegisterTypeLib@20:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z
_TEXT	SEGMENT
tv134 = -52						; size = 4
tv83 = -48						; size = 4
$T212966 = -44						; size = 4
_ptla$91303 = -36					; size = 4
_hr$ = -28						; size = 4
_pTypeLib$ = -20					; size = 4
_bstrPath$ = -8						; size = 4
_hInstTypeLib$ = 8					; size = 4
_lpszIndex$ = 12					; size = 4
?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z PROC NEAR ; ATL::AtlUnRegisterTypeLib, COMDAT

; 5980 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-52]
	mov	ecx, 13					; 0000000dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5981 : 	CComBSTR bstrPath;

	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??0CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::CComBSTR

; 5982 : 	CComPtr<ITypeLib> pTypeLib;

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ	; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>

; 5983 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ; ATL::CComPtrBase<ITypeLib>::operator&
	push	eax
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??ICComBSTR@ATL@@QAEPAPAGXZ		; ATL::CComBSTR::operator&
	push	eax
	mov	eax, DWORD PTR _lpszIndex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hInstTypeLib$[ebp]
	push	ecx
	call	?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PBGPAPAGPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
	mov	DWORD PTR _hr$[ebp], eax

; 5984 : 	if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	$L91302

; 5985 : 	{
; 5986 : 		TLIBATTR* ptla;
; 5987 : 		hr = pTypeLib->GetLibAttr(&ptla);

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ; ATL::CComPtrBase<ITypeLib>::operator->
	mov	DWORD PTR tv83[ebp], eax
	mov	esi, esp
	lea	edx, DWORD PTR _ptla$91303[ebp]
	push	edx
	mov	eax, DWORD PTR tv83[ebp]
	push	eax
	mov	ecx, DWORD PTR tv83[ebp]
	mov	edx, DWORD PTR [ecx]
	call	DWORD PTR [edx+28]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 5988 : 		if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L91302

; 5989 : 		{
; 5990 : 			hr = UnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);

	mov	esi, esp
	mov	eax, DWORD PTR _ptla$91303[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _ptla$91303[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _ptla$91303[ebp]
	mov	dx, WORD PTR [ecx+26]
	push	edx
	mov	eax, DWORD PTR _ptla$91303[ebp]
	mov	cx, WORD PTR [eax+24]
	push	ecx
	mov	edx, DWORD PTR _ptla$91303[ebp]
	push	edx
	call	DWORD PTR __imp__UnRegisterTypeLib@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 5991 : 			pTypeLib->ReleaseTLibAttr(ptla);

	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ; ATL::CComPtrBase<ITypeLib>::operator->
	mov	DWORD PTR tv134[ebp], eax
	mov	esi, esp
	mov	eax, DWORD PTR _ptla$91303[ebp]
	push	eax
	mov	ecx, DWORD PTR tv134[ebp]
	push	ecx
	mov	edx, DWORD PTR tv134[ebp]
	mov	eax, DWORD PTR [edx]
	call	DWORD PTR [eax+48]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L91302:

; 5992 : 		}
; 5993 : 	}
; 5994 : 	return hr;

	mov	ecx, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T212966[ebp], ecx
	lea	ecx, DWORD PTR _pTypeLib$[ebp]
	call	??1?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
	lea	ecx, DWORD PTR _bstrPath$[ebp]
	call	??1CComBSTR@ATL@@QAE@XZ			; ATL::CComBSTR::~CComBSTR
	mov	eax, DWORD PTR $T212966[ebp]

; 5995 : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L212971
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	add	esp, 52					; 00000034H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$L212971:
	DD	3
	DD	$L212970
$L212970:
	DD	-8					; fffffff8H
	DD	4
	DD	$L212967
	DD	-20					; ffffffecH
	DD	4
	DD	$L212968
	DD	-36					; ffffffdcH
	DD	4
	DD	$L212969
$L212969:
	DB	112					; 00000070H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	97					; 00000061H
	DB	0
$L212968:
	DB	112					; 00000070H
	DB	84					; 00000054H
	DB	121					; 00000079H
	DB	112					; 00000070H
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	98					; 00000062H
	DB	0
$L212967:
	DB	98					; 00000062H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	114					; 00000072H
	DB	80					; 00000050H
	DB	97					; 00000061H
	DB	116					; 00000074H
	DB	104					; 00000068H
	DB	0
?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PBG@Z ENDP ; ATL::AtlUnRegisterTypeLib
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 273  : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::RemoveAll

; 278  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::~CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetSize, COMDAT
; _this$ = ecx

; 282  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 283  : 		return m_nSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 284  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetSize@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHXZ ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetSize
_TEXT	ENDS
PUBLIC	?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
EXTRN	_realloc:NEAR
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z
_TEXT	SEGMENT
_pVal$ = -12						; size = 4
_pKey$ = -8						; size = 4
_this$ = -4						; size = 4
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Add, COMDAT
; _this$ = ecx

; 286  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 		TKey* pKey;
; 288  : 		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ecx*4+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pKey$[ebp], eax

; 289  : 		if(pKey == NULL)

	cmp	DWORD PTR _pKey$[ebp], 0
	jne	SHORT $L162992

; 290  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L162988
$L162992:

; 291  : 		m_aKey = pKey;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pKey$[ebp]
	mov	DWORD PTR [edx], eax

; 292  : 		TVal* pVal;
; 293  : 		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx*4+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _pVal$[ebp], eax

; 294  : 		if(pVal == NULL)

	cmp	DWORD PTR _pVal$[ebp], 0
	jne	SHORT $L162996

; 295  : 			return FALSE;

	xor	eax, eax
	jmp	SHORT $L162988
$L162996:

; 296  : 		m_aVal = pVal;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pVal$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 297  : 		InternalSetAtIndex(m_nSize, key, val);

	mov	edx, DWORD PTR _val$[ebp]
	push	edx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex

; 298  : 		m_nSize++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 299  : 		return TRUE;

	mov	eax, 1
$L162988:

; 300  : 	}

	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?Add@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQADABQAG@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Add
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$163000 = -8						; size = 4
_this$ = -4						; size = 4
?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::RemoveAll, COMDAT
; _this$ = ecx

; 332  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 333  : 		if(m_aKey != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L162999

; 334  : 		{
; 335  : 			for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$163000[ebp], 0
	jmp	SHORT $L163001
$L163002:
	mov	ecx, DWORD PTR _i$163000[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$163000[ebp], ecx
$L163001:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _i$163000[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	SHORT $L163003

; 336  : 			{
; 337  : 				m_aKey[i].~TKey();
; 338  : 				m_aVal[i].~TVal();
; 339  : 			}

	jmp	SHORT $L163002
$L163003:

; 340  : 			free(m_aKey);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_free
	add	esp, 4

; 341  : 			m_aKey = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$L162999:

; 342  : 		}
; 343  : 		if(m_aVal != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $L163004

; 344  : 		{
; 345  : 			free(m_aVal);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_free
	add	esp, 4

; 346  : 			m_aVal = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
$L163004:

; 347  : 		}
; 348  : 
; 349  : 		m_nSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0

; 350  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?RemoveAll@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::RemoveAll
_TEXT	ENDS
PUBLIC	?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::FindKey
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z
_TEXT	SEGMENT
_nIndex$ = -8						; size = 4
_this$ = -4						; size = 4
_key$ = 8						; size = 4
?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Lookup, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		int nIndex = FindKey(key);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::FindKey
	mov	DWORD PTR _nIndex$[ebp], eax

; 365  : 		if(nIndex == -1)

	cmp	DWORD PTR _nIndex$[ebp], -1
	jne	SHORT $L163008

; 366  : 			return NULL;    // must be able to convert

	xor	eax, eax
	jmp	SHORT $L163006
$L163008:

; 367  : 		return GetValueAt(nIndex);

	mov	ecx, DWORD PTR _nIndex$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetValueAt
	mov	eax, DWORD PTR [eax]
$L163006:

; 368  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Lookup@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPAGABQAD@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Lookup
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetKeyAt, COMDAT
; _this$ = ecx

; 377  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L212986
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L212987
$L212986:
	push	OFFSET FLAT:??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
	push	0
	push	378					; 0000017aH
	push	OFFSET FLAT:??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212987
	int	3
$L212987:

; 379  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L163013
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L163012
$L163013:

; 380  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$L163012:

; 381  : 			
; 382  : 		return m_aKey[nIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$L212985:

; 383  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetKeyAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPADH@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nIndex$ = 8						; size = 4
?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetValueAt, COMDAT
; _this$ = ecx

; 385  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L212990
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L212991
$L212990:
	push	OFFSET FLAT:??_C@_0CA@CLKCNBMB@nIndex?5?$DO?$DN?50?5?$CG?$CG?5nIndex?5?$DM?5m_nSize?$AA@
	push	0
	push	386					; 00000182H
	push	OFFSET FLAT:??_C@_0FE@GCCFFNOH@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L212991
	int	3
$L212991:

; 387  : 		if(nIndex < 0 || nIndex >= m_nSize)

	cmp	DWORD PTR _nIndex$[ebp], 0
	jl	SHORT $L163019
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jl	SHORT $L163018
$L163019:

; 388  : 			_AtlRaiseException(EXCEPTION_ARRAY_BOUNDS_EXCEEDED);	

	push	1
	push	-1073741684				; c000008cH
	call	?_AtlRaiseException@ATL@@YAXKK@Z	; ATL::_AtlRaiseException
$L163018:

; 389  : 			
; 390  : 		return m_aVal[nIndex];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
$L212989:

; 391  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetValueAt@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPAGH@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::GetValueAt
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::CTempBuffer<char,1024,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L163024

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
$L163024:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::~CTempBuffer<char,1024,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::CTempBuffer<char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L163035

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
$L163035:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::~CTempBuffer<char,256,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 217  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 225  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $L163046

; 227  : 		{
; 228  : 			FreeHeap();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
$L163046:

; 229  : 		}
; 230  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::~CTempBuffer<unsigned char,256,ATL::CCRTAllocator>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 235  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QBEPAEXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::operator unsigned char *
_TEXT	ENDS
PUBLIC	?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

	mov	eax, DWORD PTR _nElements$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes

; 245  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ PROC NEAR		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>, COMDAT
; _this$ = ecx

; 248  : 	CComPtr() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>

; 249  : 	{
; 250  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtr@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeLib>::CComPtr<ITypeLib>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		if (p)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L163057

; 128  : 			p->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L163057:

; 129  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtrBase@UITypeLib@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::~CComPtrBase<ITypeLib>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *, COMDAT
; _this$ = ecx

; 131  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		return p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 133  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CComPtrBase@UITypeLib@@@ATL@@QBEPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator ITypeLib *
_TEXT	ENDS
PUBLIC	??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
PUBLIC	??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@		; `string'
;	COMDAT ??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
CONST	SEGMENT
??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@ DB 'p==0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lcomcli.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeLib>::operator&, COMDAT
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		ATLASSERT(p==NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213024
	push	OFFSET FLAT:??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
	push	0
	push	143					; 0000008fH
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213024
	int	3
$L213024:

; 144  : 		return &p;

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??I?$CComPtrBase@UITypeLib@@@ATL@@QAEPAPAUITypeLib@@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator&
_TEXT	ENDS
PUBLIC	??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@		; `string'
;	COMDAT ??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
CONST	SEGMENT
??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@ DB 'p!=0', 00H		; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ PROC NEAR ; ATL::CComPtrBase<ITypeLib>::operator->, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		ATLASSERT(p!=NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L213027
	push	OFFSET FLAT:??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
	push	0
	push	148					; 00000094H
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213027
	int	3
$L213027:

; 149  : 		return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 150  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$CComPtrBase@UITypeLib@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeLib@@@1@XZ ENDP ; ATL::CComPtrBase<ITypeLib>::operator->
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ICatRegister>::CComPtrBase<ICatRegister>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<ICatRegister>::CComPtr<ICatRegister>, COMDAT
; _this$ = ecx

; 248  : 	CComPtr() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ICatRegister>::CComPtrBase<ICatRegister>

; 249  : 	{
; 250  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtr@UICatRegister@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ICatRegister>::CComPtr<ICatRegister>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtrBase<ICatRegister>::~CComPtrBase<ICatRegister>, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		if (p)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L163071

; 128  : 			p->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L163071:

; 129  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtrBase@UICatRegister@@@ATL@@QAE@XZ ENDP	; ATL::CComPtrBase<ICatRegister>::~CComPtrBase<ICatRegister>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ PROC NEAR ; ATL::CComPtrBase<ICatRegister>::operator&, COMDAT
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		ATLASSERT(p==NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213034
	push	OFFSET FLAT:??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
	push	0
	push	143					; 0000008fH
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213034
	int	3
$L213034:

; 144  : 		return &p;

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??I?$CComPtrBase@UICatRegister@@@ATL@@QAEPAPAUICatRegister@@XZ ENDP ; ATL::CComPtrBase<ICatRegister>::operator&
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ PROC NEAR ; ATL::CComPtrBase<ICatRegister>::operator->, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		ATLASSERT(p!=NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L213037
	push	OFFSET FLAT:??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
	push	0
	push	148					; 00000094H
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213037
	int	3
$L213037:

; 149  : 		return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 150  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$CComPtrBase@UICatRegister@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UICatRegister@@@1@XZ ENDP ; ATL::CComPtrBase<ICatRegister>::operator->
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ PROC NEAR		; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>, COMDAT
; _this$ = ecx

; 248  : 	CComPtr() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>

; 249  : 	{
; 250  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtr@UITypeInfo@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z ; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z PROC NEAR	; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>, COMDAT
; _this$ = ecx

; 273  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _lp$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z ; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>

; 274  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CComPtr@UITypeInfo@@@ATL@@QAE@ABV01@@Z ENDP	; ATL::CComPtr<ITypeInfo>::CComPtr<ITypeInfo>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeInfo>::~CComPtrBase<ITypeInfo>, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		if (p)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L163087

; 128  : 			p->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L163087:

; 129  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtrBase@UITypeInfo@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<ITypeInfo>::~CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeInfo>::operator&, COMDAT
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		ATLASSERT(p==NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213046
	push	OFFSET FLAT:??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
	push	0
	push	143					; 0000008fH
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213046
	int	3
$L213046:

; 144  : 		return &p;

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??I?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAPAUITypeInfo@@XZ ENDP ; ATL::CComPtrBase<ITypeInfo>::operator&
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ PROC NEAR ; ATL::CComPtrBase<ITypeInfo>::operator->, COMDAT
; _this$ = ecx

; 147  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 		ATLASSERT(p!=NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L213049
	push	OFFSET FLAT:??_C@_04CLHEGAEG@p?$CB?$DN0?$AA@
	push	0
	push	148					; 00000094H
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213049
	int	3
$L213049:

; 149  : 		return (_NoAddRefReleaseOnCComPtr<T>*)p;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 150  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??C?$CComPtrBase@UITypeInfo@@@ATL@@QBEPAV?$_NoAddRefReleaseOnCComPtr@UITypeInfo@@@1@XZ ENDP ; ATL::CComPtrBase<ITypeInfo>::operator->
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ
_TEXT	SEGMENT
_pt$ = -8						; size = 4
_this$ = -4						; size = 4
?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeInfo>::Detach, COMDAT
; _this$ = ecx

; 198  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		T* pt = p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pt$[ebp], ecx

; 200  : 		p = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0

; 201  : 		return pt;

	mov	eax, DWORD PTR _pt$[ebp]

; 202  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Detach@?$CComPtrBase@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@XZ ENDP ; ATL::CComPtrBase<ITypeInfo>::Detach
_TEXT	ENDS
PUBLIC	??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ	; ATL::CComPtrBase<ITypeInfo2>::CComPtrBase<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtr<ITypeInfo2>::CComPtr<ITypeInfo2>, COMDAT
; _this$ = ecx

; 248  : 	CComPtr() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ ; ATL::CComPtrBase<ITypeInfo2>::CComPtrBase<ITypeInfo2>

; 249  : 	{
; 250  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtr@UITypeInfo2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtr<ITypeInfo2>::CComPtr<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeInfo2>::~CComPtrBase<ITypeInfo2>, COMDAT
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 127  : 		if (p)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L163108

; 128  : 			p->Release();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [edx]
	mov	esi, esp
	push	ecx
	call	DWORD PTR [edx+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L163108:

; 129  : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComPtrBase@UITypeInfo2@@@ATL@@QAE@XZ ENDP		; ATL::CComPtrBase<ITypeInfo2>::~CComPtrBase<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeInfo2>::operator&, COMDAT
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		ATLASSERT(p==NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213058
	push	OFFSET FLAT:??_C@_04DBLLIIGB@p?$DN?$DN0?$AA@
	push	0
	push	143					; 0000008fH
	push	OFFSET FLAT:??_C@_0FC@KBOEFHBO@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213058
	int	3
$L213058:

; 144  : 		return &p;

	mov	eax, DWORD PTR _this$[ebp]

; 145  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??I?$CComPtrBase@UITypeInfo2@@@ATL@@QAEPAPAUITypeInfo2@@XZ ENDP ; ATL::CComPtrBase<ITypeInfo2>::operator&
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@		; `string'
PUBLIC	??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ ; `string'
;	COMDAT ??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
CONST	SEGMENT
??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@ DB 'm_p == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
CONST	SEGMENT
??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@ DB 'C:\Program '
	DB	'Files\Microsoft Visual Studio .NET 2003\Vc7\atlmfc\include\at'
	DB	'lalloc.h', 00H				; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213061
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213061
	int	3
$L213061:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 128		; 00000080H
	jbe	SHORT $L163783

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L163784
$L163783:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L163784:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ; ATL::CExpansionVectorEqualHelper::IsEqualKey
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
;	COMDAT ?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z
_TEXT	SEGMENT
_i$163835 = -8						; size = 4
_this$ = -4						; size = 4
_key$ = 8						; size = 4
?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::FindKey, COMDAT
; _this$ = ecx

; 394  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 395  : 		for(int i = 0; i < m_nSize; i++)

	mov	DWORD PTR _i$163835[ebp], 0
	jmp	SHORT $L163836
$L163837:
	mov	eax, DWORD PTR _i$163835[ebp]
	add	eax, 1
	mov	DWORD PTR _i$163835[ebp], eax
$L163836:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$163835[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $L163838

; 396  : 		{
; 397  : 			if(TEqual::IsEqualKey(m_aKey[i], key))

	mov	eax, DWORD PTR _key$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$163835[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ; ATL::CExpansionVectorEqualHelper::IsEqualKey
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $L163839

; 398  : 				return i;

	mov	eax, DWORD PTR _i$163835[ebp]
	jmp	SHORT $L163834
$L163839:

; 399  : 		}

	jmp	SHORT $L163837
$L163838:

; 400  : 		return -1;  // not found

	or	eax, -1
$L163834:

; 401  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?FindKey@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQAD@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::FindKey
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
_TEXT	ENDS
;	COMDAT ?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z
_TEXT	SEGMENT
_k1$ = 8						; size = 4
_k2$ = 12						; size = 4
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z PROC NEAR ; ATL::CExpansionVectorEqualHelper::IsEqualKey, COMDAT

; 70   : 	{

	push	ebp
	mov	ebp, esp
	push	esi

; 71   : 		if (lstrcmpi(k1, k2) == 0)

	mov	esi, esp
	mov	eax, DWORD PTR _k2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k1$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrcmpiA@8
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	jne	SHORT $L89634

; 72   : 			return true;

	mov	al, 1
	jmp	SHORT $L89633
$L89634:

; 73   : 		return false;

	xor	al, al
$L89633:

; 74   : 	}

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
?IsEqualKey@CExpansionVectorEqualHelper@ATL@@SA_NQAD0@Z ENDP ; ATL::CExpansionVectorEqualHelper::IsEqualKey
_TEXT	ENDS
PUBLIC	??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
PUBLIC	??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
PUBLIC	??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
PUBLIC	??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::Wrapper<unsigned short *>
PUBLIC	??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator new<unsigned short *>
PUBLIC	??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator delete<unsigned short *>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
xdata$x	SEGMENT
$T213083 DD	0ffffffffH
	DD	FLAT:$L213078
	DD	0ffffffffH
	DD	FLAT:$L213079
$T213081 DD	019930520H
	DD	02H
	DD	FLAT:$T213083
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z
_TEXT	SEGMENT
tv94 = -40						; size = 4
tv78 = -36						; size = 4
$T213075 = -32						; size = 4
$T213074 = -28						; size = 4
$T213071 = -24						; size = 4
$T213070 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_nIndex$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 442  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	mov	eax, -858993460				; ccccccccH
	mov	DWORD PTR [ebp-40], eax
	mov	DWORD PTR [ebp-36], eax
	mov	DWORD PTR [ebp-32], eax
	mov	DWORD PTR [ebp-28], eax
	mov	DWORD PTR [ebp-24], eax
	mov	DWORD PTR [ebp-20], eax
	mov	DWORD PTR [ebp-16], eax
	mov	DWORD PTR _this$[ebp], ecx

; 443  : 		new(m_aKey + nIndex) Wrapper<TKey>(key);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
	add	esp, 8
	mov	DWORD PTR $T213071[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T213071[ebp], 0
	je	SHORT $L213072
	mov	ecx, DWORD PTR _key$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T213071[ebp]
	call	??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $L213073
$L213072:
	mov	DWORD PTR tv78[ebp], 0
$L213073:
	mov	edx, DWORD PTR tv78[ebp]
	mov	DWORD PTR $T213070[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 444  : 		new(m_aVal + nIndex) Wrapper<TVal>(val);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	push	4
	call	??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator new<unsigned short *>
	add	esp, 8
	mov	DWORD PTR $T213075[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T213075[ebp], 0
	je	SHORT $L213076
	mov	ecx, DWORD PTR _val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T213075[ebp]
	call	??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::Wrapper<unsigned short *>
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $L213077
$L213076:
	mov	DWORD PTR tv94[ebp], 0
$L213077:
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR $T213074[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 445  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L213078:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR $T213071[ebp]
	push	ecx
	call	??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
	add	esp, 8
	ret	0
$L213079:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _nIndex$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR $T213075[ebp]
	push	ecx
	call	??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator delete<unsigned short *>
	add	esp, 8
	ret	0
__ehhandler$?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z:
	mov	eax, OFFSET FLAT:$T213081
	jmp	___CxxFrameHandler
text$x	ENDS
?InternalSetAtIndex@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQADABQAG@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213088
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213088
	int	3
$L213088:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 1024		; 00000400H
	jbe	SHORT $L163911

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L163912
$L163911:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L163912:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213093
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213093
	int	3
$L213093:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 256		; 00000100H
	jbe	SHORT $L163919

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L163920
$L163919:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L163920:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
;	COMDAT ?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 276  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 		ATLASSERT( m_p == NULL );

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L213098
	push	OFFSET FLAT:??_C@_08GPODJFIN@m_p?5?$DN?$DN?50?$AA@
	push	0
	push	277					; 00000115H
	push	OFFSET FLAT:??_C@_0FB@IAFJMJBP@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213098
	int	3
$L213098:

; 278  : 		if( nBytes > t_nFixedBytes )

	cmp	DWORD PTR _nBytes$[ebp], 256		; 00000100H
	jbe	SHORT $L163927

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

	mov	edx, DWORD PTR _nBytes$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap

; 281  : 		}
; 282  : 		else

	jmp	SHORT $L163928
$L163927:

; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$L163928:

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]

; 288  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateBytes@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 312  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 		Allocator::Free( m_p );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?Free@CCRTAllocator@ATL@@SAXPAX@Z	; ATL::CCRTAllocator::Free
	add	esp, 4

; 314  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>, COMDAT
; _this$ = ecx

; 107  : 	CComPtrBase() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	{
; 109  : 		p = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtrBase@UITypeLib@@@ATL@@IAE@XZ ENDP		; ATL::CComPtrBase<ITypeLib>::CComPtrBase<ITypeLib>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ PROC NEAR	; ATL::CComPtrBase<ICatRegister>::CComPtrBase<ICatRegister>, COMDAT
; _this$ = ecx

; 107  : 	CComPtrBase() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	{
; 109  : 		p = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtrBase@UICatRegister@@@ATL@@IAE@XZ ENDP	; ATL::CComPtrBase<ICatRegister>::CComPtrBase<ICatRegister>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>, COMDAT
; _this$ = ecx

; 107  : 	CComPtrBase() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	{
; 109  : 		p = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@XZ ENDP		; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z PROC NEAR ; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>, COMDAT
; _this$ = ecx

; 117  : 	CComPtrBase(T* lp) throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 	{
; 119  : 		p = lp;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lp$[ebp]
	mov	DWORD PTR [eax], ecx

; 120  : 		if (p != NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $L163939

; 121  : 			p->AddRef();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, esp
	push	eax
	call	DWORD PTR [ecx+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L163939:

; 122  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$CComPtrBase@UITypeInfo@@@ATL@@IAE@PAUITypeInfo@@@Z ENDP ; ATL::CComPtrBase<ITypeInfo>::CComPtrBase<ITypeInfo>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ PROC NEAR	; ATL::CComPtrBase<ITypeInfo2>::CComPtrBase<ITypeInfo2>, COMDAT
; _this$ = ecx

; 107  : 	CComPtrBase() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 	{
; 109  : 		p = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 110  : 	}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CComPtrBase@UITypeInfo2@@@ATL@@IAE@XZ ENDP		; ATL::CComPtrBase<ITypeInfo2>::CComPtrBase<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 365  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 			return (this + 1);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 367  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L164148

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164148:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L213114:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L164160

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164160:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L213116:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,1024,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L164166

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164166:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L213118:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@D$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_p$ = -8						; size = 4
_this$ = -4						; size = 4
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

	mov	eax, DWORD PTR _nBytes$[ebp]
	push	eax
	call	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z	; ATL::CCRTAllocator::Allocate
	add	esp, 4
	mov	DWORD PTR _p$[ebp], eax

; 294  : 		if( p == NULL )

	cmp	DWORD PTR _p$[ebp], 0
	jne	SHORT $L164172

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

	push	-2147024882				; 8007000eH
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164172:

; 297  : 		}
; 298  : 		m_p = p;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [ecx], edx
$L213120:

; 299  : 	}

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__t$ = 8						; size = 4
??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>, COMDAT
; _this$ = ecx

; 428  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __t$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 429  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAD@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::Wrapper<char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__t$ = 8						; size = 4
??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::Wrapper<unsigned short *>, COMDAT
; _this$ = ecx

; 428  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __t$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 429  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@QAE@ABQAG@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::Wrapper<unsigned short *>
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
_TEXT	ENDS
;	COMDAT ??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z
_TEXT	SEGMENT
_hr$164246 = -8						; size = 4
_this$ = -4						; size = 4
_cs$ = 8						; size = 4
_bInitialLock$ = 12					; size = 1
??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z PROC NEAR ; ATL::CComCritSecLock<ATL::CComCriticalSection>::CComCritSecLock<ATL::CComCriticalSection>, COMDAT
; _this$ = ecx

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _cs$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+4], 0

; 289  : 	if( bInitialLock )

	movzx	eax, BYTE PTR _bInitialLock$[ebp]
	test	eax, eax
	je	SHORT $L164244

; 290  : 	{
; 291  : 		HRESULT hr;
; 292  : 
; 293  : 		hr = Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock
	mov	DWORD PTR _hr$164246[ebp], eax

; 294  : 		if( FAILED( hr ) )

	cmp	DWORD PTR _hr$164246[ebp], 0
	jge	SHORT $L164244

; 295  : 		{
; 296  : 			AtlThrow( hr );

	mov	ecx, DWORD PTR _hr$164246[ebp]
	push	ecx
	call	?AtlThrow@ATL@@YGXJ@Z			; ATL::AtlThrow
$L164244:

; 297  : 		}
; 298  : 	}
; 299  : }

	mov	eax, DWORD PTR _this$[ebp]
$L213126:
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@AAVCComCriticalSection@1@_N@Z ENDP ; ATL::CComCritSecLock<ATL::CComCriticalSection>::CComCritSecLock<ATL::CComCriticalSection>
_TEXT	ENDS
PUBLIC	?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Unlock
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>, COMDAT
; _this$ = ecx

; 303  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 304  : 	if( m_bLocked )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L164252

; 305  : 	{
; 306  : 		Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Unlock
$L164252:

; 307  : 	}
; 308  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComCritSecLock<ATL::CComCriticalSection>::~CComCritSecLock<ATL::CComCriticalSection>
_TEXT	ENDS
PUBLIC	??_C@_09HIEJFN@m_bLocked?$AA@			; `string'
;	COMDAT ??_C@_09HIEJFN@m_bLocked?$AA@
CONST	SEGMENT
??_C@_09HIEJFN@m_bLocked?$AA@ DB 'm_bLocked', 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ PROC NEAR ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Unlock, COMDAT
; _this$ = ecx

; 328  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 329  : 	ATLASSERT( m_bLocked );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $L213131
	push	OFFSET FLAT:??_C@_09HIEJFN@m_bLocked?$AA@
	push	0
	push	329					; 00000149H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213131
	int	3
$L213131:

; 330  : 	m_cs.Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Unlock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Unlock

; 331  : 	m_bLocked = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 332  : }

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Unlock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Unlock
_TEXT	ENDS
PUBLIC	??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@		; `string'
;	COMDAT ??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
CONST	SEGMENT
??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@ DB '!m_bLocked', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ PROC NEAR ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock, COMDAT
; _this$ = ecx

; 312  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 313  : 	HRESULT hr;
; 314  : 
; 315  : 	ATLASSERT( !m_bLocked );

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L213134
	push	OFFSET FLAT:??_C@_0L@MPGHMANA@?$CBm_bLocked?$AA@
	push	0
	push	315					; 0000013bH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213134
	int	3
$L213134:

; 316  : 	hr = m_cs.Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Lock
	mov	DWORD PTR _hr$[ebp], eax

; 317  : 	if( FAILED( hr ) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L164261

; 318  : 	{
; 319  : 		return( hr );

	mov	eax, DWORD PTR _hr$[ebp]
	jmp	SHORT $L164257
$L164261:

; 320  : 	}
; 321  : 	m_bLocked = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1

; 322  : 
; 323  : 	return( S_OK );

	xor	eax, eax
$L164257:

; 324  : }

	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Lock@?$CComCritSecLock@VCComCriticalSection@ATL@@@ATL@@QAEJXZ ENDP ; ATL::CComCritSecLock<ATL::CComCriticalSection>::Lock
_TEXT	ENDS
PUBLIC	__GUID_00020412_0000_0000_c000_000000000046
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
; File c:\program files\microsoft visual studio .net 2003\vc7\platformsdk\include\unknwn.h
CONST	SEGMENT
__GUID_00020412_0000_0000_c000_000000000046 DD 020412H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pp$ = 12						; size = 4
??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z PROC NEAR ; IUnknown::QueryInterface<ITypeInfo2>, COMDAT

; 123  :     	{

	push	ebp
	mov	ebp, esp
	push	esi

; 124  :     	    return QueryInterface(__uuidof(Q), (void **)pp);

	mov	esi, esp
	mov	eax, DWORD PTR _pp$[ebp]
	push	eax
	push	OFFSET FLAT:__GUID_00020412_0000_0000_c000_000000000046
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	DWORD PTR [edx]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 125  :     	}

	pop	esi
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	8
??$QueryInterface@UITypeInfo2@@@IUnknown@@QAGJPAPAUITypeInfo2@@@Z ENDP ; IUnknown::QueryInterface<ITypeInfo2>
_TEXT	ENDS
PUBLIC	?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z ; ATL::AtlComQIPtrAssign
PUBLIC	__GUID_00020401_0000_0000_c000_000000000046
PUBLIC	??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ ; ATL::CComPtrBase<ITypeInfo2>::operator ITypeInfo2 *
;	COMDAT __GUID_00020401_0000_0000_c000_000000000046
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlcomcli.h
CONST	SEGMENT
__GUID_00020401_0000_0000_c000_000000000046 DD 020401H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lp$ = 8						; size = 4
??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z PROC NEAR ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>, COMDAT
; _this$ = ecx

; 295  : 	T* operator=(const CComPtr<Q>& lp) throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 	{
; 297  : 		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T)));

	push	OFFSET FLAT:__GUID_00020401_0000_0000_c000_000000000046
	mov	ecx, DWORD PTR _lp$[ebp]
	call	??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ ; ATL::CComPtrBase<ITypeInfo2>::operator ITypeInfo2 *
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z ; ATL::AtlComQIPtrAssign

; 298  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ENDP ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z
_TEXT	SEGMENT
_pTemp$ = -4						; size = 4
_pp$ = 8						; size = 4
_lp$ = 12						; size = 4
_riid$ = 16						; size = 4
?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z PROC NEAR ; ATL::AtlComQIPtrAssign, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 59   : 	if (pp == NULL)

	cmp	DWORD PTR _pp$[ebp], 0
	jne	SHORT $L81067

; 60   : 		return NULL;

	xor	eax, eax
	jmp	SHORT $L81066
$L81067:

; 61   : 
; 62   : 	IUnknown* pTemp = *pp;

	mov	eax, DWORD PTR _pp$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pTemp$[ebp], ecx

; 63   : 	*pp = NULL;

	mov	edx, DWORD PTR _pp$[ebp]
	mov	DWORD PTR [edx], 0

; 64   : 	if (lp != NULL)

	cmp	DWORD PTR _lp$[ebp], 0
	je	SHORT $L81069

; 65   : 		lp->QueryInterface(riid, (void**)pp);

	mov	esi, esp
	mov	eax, DWORD PTR _pp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _riid$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _lp$[ebp]
	push	ecx
	call	DWORD PTR [eax]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L81069:

; 66   : 	if (pTemp)

	cmp	DWORD PTR _pTemp$[ebp], 0
	je	SHORT $L81071

; 67   : 		pTemp->Release();

	mov	edx, DWORD PTR _pTemp$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	esi, esp
	mov	ecx, DWORD PTR _pTemp$[ebp]
	push	ecx
	call	DWORD PTR [eax+8]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L81071:

; 68   : 	return *pp;

	mov	edx, DWORD PTR _pp$[ebp]
	mov	eax, DWORD PTR [edx]
$L81066:

; 69   : }

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?AtlComQIPtrAssign@ATL@@YGPAUIUnknown@@PAPAU2@PAU2@ABU_GUID@@@Z ENDP ; ATL::AtlComQIPtrAssign
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ PROC NEAR ; ATL::CComPtrBase<ITypeInfo2>::operator ITypeInfo2 *, COMDAT
; _this$ = ecx

; 131  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 		return p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 133  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??B?$CComPtrBase@UITypeInfo2@@@ATL@@QBEPAUITypeInfo2@@XZ ENDP ; ATL::CComPtrBase<ITypeInfo2>::operator ITypeInfo2 *
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>, COMDAT

; 431  : 		void *operator new(size_t, _Ty* p)

	push	ebp
	mov	ebp, esp

; 432  : 		{
; 433  : 			return p;

	mov	eax, DWORD PTR _p$[ebp]

; 434  : 		}

	pop	ebp
	ret	0
??$?2PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAD@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator new<char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>, COMDAT

; 436  : 		void operator delete(void* /* pv */, _Ty* /* p */)

	push	ebp
	mov	ebp, esp

; 437  : 		{
; 438  : 		}

	pop	ebp
	ret	0
??$?3PAD@?$Wrapper@PAD@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAD@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<char *>::operator delete<char *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator new<unsigned short *>, COMDAT

; 431  : 		void *operator new(size_t, _Ty* p)

	push	ebp
	mov	ebp, esp

; 432  : 		{
; 433  : 			return p;

	mov	eax, DWORD PTR _p$[ebp]

; 434  : 		}

	pop	ebp
	ret	0
??$?2PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAPAXIPAPAG@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator new<unsigned short *>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z PROC NEAR ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator delete<unsigned short *>, COMDAT

; 436  : 		void operator delete(void* /* pv */, _Ty* /* p */)

	push	ebp
	mov	ebp, esp

; 437  : 		{
; 438  : 		}

	pop	ebp
	ret	0
??$?3PAG@?$Wrapper@PAG@?$CSimpleMap@PADPAGVCExpansionVectorEqualHelper@ATL@@@ATL@@SAXPAXPAPAG@Z ENDP ; ATL::CSimpleMap<char *,unsigned short *,ATL::CExpansionVectorEqualHelper>::Wrapper<unsigned short *>::operator delete<unsigned short *>
_TEXT	ENDS
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
EXTRN	_atexit:NEAR
;	COMDAT CRT$XCU
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Odt /RTCsu
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 2602 : __declspec(selectany) CAtlWinModule _AtlWinModule;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??0CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::CAtlWinModule
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E1	ENDP
text$yc	ENDS
PUBLIC	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
EXTRN	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z:NEAR ; ATL::AtlWinModuleInit
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
??0CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2573 : 	CAtlWinModule()

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_ATL_WIN_MODULE70@ATL@@QAE@XZ

; 2574 : 	{
; 2575 : 		cbSize = sizeof(_ATL_WIN_MODULE);

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 44			; 0000002cH

; 2576 : 		HRESULT hr = AtlWinModuleInit(this);

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
	mov	DWORD PTR _hr$[ebp], eax

; 2577 : 		if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L88121

; 2578 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88121:

; 2579 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
PUBLIC	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??0_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 97   : 	{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
_TEXT	ENDS
PUBLIC	??0CComModule@ATL@@QAE@XZ			; ATL::CComModule::CComModule
CRT$XCU	SEGMENT
_$S7	DD	FLAT:_$E5
; Function compile flags: /Odt /RTCsu
; File c:\activex\xmlsign\xmlsign.cpp
CRT$XCU	ENDS
;	COMDAT _$E5
text$yc	SEGMENT
_$E5	PROC NEAR					; COMDAT

; 51   : CComModule _Module;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	??0CComModule@ATL@@QAE@XZ		; ATL::CComModule::CComModule
	push	OFFSET FLAT:_$E6
	call	_atexit
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E5	ENDP
text$yc	ENDS
PUBLIC	?Lock@CAtlModule@ATL@@UAEJXZ			; ATL::CAtlModule::Lock
PUBLIC	?Unlock@CAtlModule@ATL@@UAEJXZ			; ATL::CAtlModule::Unlock
PUBLIC	?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z ; ATL::CAtlModule::GetGITPtr
PUBLIC	??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ	; ATL::CAtlModuleT<ATL::CComModule>::CAtlModuleT<ATL::CComModule>
PUBLIC	?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements
PUBLIC	?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceD
PUBLIC	?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceD
PUBLIC	?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceS
PUBLIC	??_7CComModule@ATL@@6B@				; ATL::CComModule::`vftable'
PUBLIC	??_GCComModule@ATL@@UAEPAXI@Z			; ATL::CComModule::`scalar deleting destructor'
PUBLIC	??_C@_0O@PGKIMHP@_pModule?5?$DN?$DN?50?$AA@	; `string'
EXTRN	??_ECComModule@ATL@@UAEPAXI@Z:NEAR		; ATL::CComModule::`vector deleting destructor'
;	COMDAT ??_7CComModule@ATL@@6B@
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
CONST	SEGMENT
??_7CComModule@ATL@@6B@ DD FLAT:??_ECComModule@ATL@@UAEPAXI@Z ; ATL::CComModule::`vftable'
	DD	FLAT:?Lock@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?Unlock@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?GetLockCount@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
	DD	FLAT:?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
	DD	FLAT:?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0O@PGKIMHP@_pModule?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0O@PGKIMHP@_pModule?5?$DN?$DN?50?$AA@ DB '_pModule == 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0CComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CComModule@ATL@@QAE@XZ PROC NEAR			; ATL::CComModule::CComModule, COMDAT
; _this$ = ecx

; 3958 : 	CComModule()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ ; ATL::CAtlModuleT<ATL::CComModule>::CAtlModuleT<ATL::CComModule>
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET FLAT:??_7CComModule@ATL@@6B@

; 3959 : 	{
; 3960 : 		// Should have only one instance of a class 
; 3961 : 		// derived from CComModule in a project.
; 3962 : 		ATLASSERT(_pModule == NULL);

	cmp	DWORD PTR ?_pModule@ATL@@3PAVCComModule@1@A, 0 ; ATL::_pModule
	je	SHORT $L213165
	push	OFFSET FLAT:??_C@_0O@PGKIMHP@_pModule?5?$DN?$DN?50?$AA@
	push	0
	push	3962					; 00000f7aH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213165
	int	3
$L213165:

; 3963 : 		_pModule = this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?_pModule@ATL@@3PAVCComModule@1@A, edx ; ATL::_pModule

; 3964 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CComModule@ATL@@QAE@XZ ENDP				; ATL::CComModule::CComModule
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Lock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Lock@CAtlModule@ATL@@UAEJXZ PROC NEAR			; ATL::CAtlModule::Lock, COMDAT
; _this$ = ecx

; 2662 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2663 : 		return CComGlobalsThreadModel::Increment(&m_nLockCnt);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	?Increment@CComMultiThreadModel@ATL@@SGKPAJ@Z ; ATL::CComMultiThreadModel::Increment

; 2664 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Lock@CAtlModule@ATL@@UAEJXZ ENDP			; ATL::CAtlModule::Lock
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?Unlock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Unlock@CAtlModule@ATL@@UAEJXZ PROC NEAR		; ATL::CAtlModule::Unlock, COMDAT
; _this$ = ecx

; 2667 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2668 : 		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	?Decrement@CComMultiThreadModel@ATL@@SGKPAJ@Z ; ATL::CComMultiThreadModel::Decrement

; 2669 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?Unlock@CAtlModule@ATL@@UAEJXZ ENDP			; ATL::CAtlModule::Unlock
_TEXT	ENDS
PUBLIC	??_C@_0L@NJOPLADJ@ppGIT?5?$CB?$DN?50?$AA@	; `string'
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	??_C@_0M@GKCENBEN@m_pGIT?5?$CB?$DN?50?$AA@	; `string'
;	COMDAT ??_C@_0L@NJOPLADJ@ppGIT?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0L@NJOPLADJ@ppGIT?5?$CB?$DN?50?$AA@ DB 'ppGIT != 0', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_0M@GKCENBEN@m_pGIT?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0M@GKCENBEN@m_pGIT?5?$CB?$DN?50?$AA@ DB 'm_pGIT != 0', 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_ppGIT$ = 8						; size = 4
?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z PROC NEAR ; ATL::CAtlModule::GetGITPtr, COMDAT
; _this$ = ecx

; 2682 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2683 : 		ATLASSERT(ppGIT != NULL);

	cmp	DWORD PTR _ppGIT$[ebp], 0
	jne	SHORT $L213173
	push	OFFSET FLAT:??_C@_0L@NJOPLADJ@ppGIT?5?$CB?$DN?50?$AA@
	push	0
	push	2683					; 00000a7bH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213173
	int	3
$L213173:

; 2684 : 
; 2685 : 		if (ppGIT == NULL)

	cmp	DWORD PTR _ppGIT$[ebp], 0
	jne	SHORT $L88227

; 2686 : 			return E_POINTER;

	mov	eax, -2147467261			; 80004003H
	jmp	$L88224
$L88227:

; 2687 : 
; 2688 : 		HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 2689 : 		if (m_pGIT == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $L88231

; 2690 : 		{
; 2691 : 			hr = ::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
; 2692 : 				__uuidof(IGlobalInterfaceTable), (void**)&m_pGIT);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 40					; 00000028H
	mov	esi, esp
	push	edx
	push	OFFSET FLAT:__GUID_00000146_0000_0000_c000_000000000046
	push	1
	push	0
	push	OFFSET FLAT:_CLSID_StdGlobalInterfaceTable
	call	DWORD PTR __imp__CoCreateInstance@20
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax
$L88231:

; 2693 : 		}
; 2694 : 
; 2695 : 		if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $L88235

; 2696 : 		{
; 2697 : 			ATLASSERT(m_pGIT != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $L213174
	push	OFFSET FLAT:??_C@_0M@GKCENBEN@m_pGIT?5?$CB?$DN?50?$AA@
	push	0
	push	2697					; 00000a89H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213174
	int	3
$L213174:

; 2698 : 			*ppGIT = m_pGIT;

	mov	edx, DWORD PTR _ppGIT$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx], ecx

; 2699 : 			m_pGIT->AddRef();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	eax, DWORD PTR [eax]
	mov	esi, esp
	push	edx
	call	DWORD PTR [eax+4]
	cmp	esi, esp
	call	__RTC_CheckEsp
$L88235:

; 2700 : 		}
; 2701 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
$L88224:

; 2702 : 	}

	pop	esi
	add	esp, 8
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z ENDP ; ATL::CAtlModule::GetGITPtr
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CComModule::UpdateRegistryFromResourceD, COMDAT

; 4106 : 	{

	push	ebp
	mov	ebp, esp

; 4107 : #if defined(_ATL_STATIC_REGISTRY)
; 4108 : 		(lpszRes);
; 4109 : 		(bRegister);
; 4110 : 		(pMapEntries);
; 4111 : 		return E_FAIL;

	mov	eax, -2147467259			; 80004005H

; 4112 : #else
; 4113 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceD(lpszRes, bRegister, pMapEntries);		
; 4114 : #endif
; 4115 : 	}

	pop	ebp
	ret	16					; 00000010H
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceD
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CComModule::UpdateRegistryFromResourceD, COMDAT

; 4118 : 	{

	push	ebp
	mov	ebp, esp

; 4119 : #if defined(_ATL_STATIC_REGISTRY)
; 4120 : 		(nResID);
; 4121 : 		(bRegister);
; 4122 : 		(pMapEntries);
; 4123 : 		return E_FAIL;

	mov	eax, -2147467259			; 80004005H

; 4124 : #else
; 4125 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceD(nResID, bRegister, pMapEntries);
; 4126 : #endif
; 4127 : 	}

	pop	ebp
	ret	16					; 00000010H
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceD
_TEXT	ENDS
PUBLIC	?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResourceS
; Function compile flags: /Odt /RTCsu
;	COMDAT ?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CComModule::UpdateRegistryFromResourceS, COMDAT

; 4133 : 	{

	push	ebp
	mov	ebp, esp

; 4134 : #ifdef _ATL_STATIC_REGISTRY
; 4135 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(lpszRes, bRegister, pMapEntries);

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	push	eax
	mov	ecx, DWORD PTR _bRegister$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpszRes$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResourceS

; 4136 : #else
; 4137 : 		(lpszRes);
; 4138 : 		(bRegister);
; 4139 : 		(pMapEntries);
; 4140 : 		return E_FAIL;
; 4141 : #endif
; 4142 : 	}

	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	16					; 00000010H
?UpdateRegistryFromResourceS@CComModule@ATL@@UAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceS
_TEXT	ENDS
PUBLIC	??1CComModule@ATL@@UAE@XZ			; ATL::CComModule::~CComModule
; Function compile flags: /Odt /RTCsu
;	COMDAT ??_GCComModule@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCComModule@ATL@@UAEPAXI@Z PROC NEAR			; ATL::CComModule::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CComModule@ATL@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $L88660
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L88660:
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??_GCComModule@ATL@@UAEPAXI@Z ENDP			; ATL::CComModule::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ	; ATL::CAtlModuleT<ATL::CComModule>::~CAtlModuleT<ATL::CComModule>
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1CComModule@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CComModule@ATL@@UAE@XZ PROC NEAR			; ATL::CComModule::~CComModule, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CComModule@ATL@@UAE@XZ ENDP				; ATL::CComModule::~CComModule
_TEXT	ENDS
PUBLIC	??1CAtlModule@ATL@@UAE@XZ			; ATL::CAtlModule::~CAtlModule
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::~CAtlModuleT<ATL::CComModule>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CAtlModule@ATL@@UAE@XZ		; ATL::CAtlModule::~CAtlModule
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAE@XZ ENDP	; ATL::CAtlModuleT<ATL::CComModule>::~CAtlModuleT<ATL::CComModule>
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??1CAtlModule@ATL@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CAtlModule@ATL@@UAE@XZ PROC NEAR			; ATL::CAtlModule::~CAtlModule, COMDAT
; _this$ = ecx

; 2657 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2658 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlModule@ATL@@QAEXXZ		; ATL::CAtlModule::Term

; 2659 : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1CAtlModule@ATL@@UAE@XZ ENDP				; ATL::CAtlModule::~CAtlModule
_TEXT	ENDS
PUBLIC	?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z	; ATL::CRegObject::ResourceRegisterSz
PUBLIC	?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z ; ATL::CRegObject::ResourceUnregisterSz
; Function compile flags: /Odt /RTCsu
;	COMDAT ?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
tv230 = -2524						; size = 4
tv215 = -2520						; size = 4
tv208 = -2516						; size = 4
tv217 = -2512						; size = 4
tv158 = -2508						; size = 4
tv151 = -2504						; size = 4
tv160 = -2500						; size = 4
$T213210 = -2496					; size = 4
$T213207 = -2492					; size = 4
$T213202 = -2488					; size = 4
$T213201 = -2484					; size = 4
$T213200 = -2480					; size = 4
$T213195 = -2476					; size = 4
$T213194 = -2472					; size = 4
$T213193 = -2468					; size = 4
_pszRes$ = -2464					; size = 4
_szType$ = -2460					; size = 4
_nLen$90906 = -2456					; size = 4
_pszModuleQuote$90905 = -2448				; size = 1048
_hRes$ = -1396						; size = 4
_pszModuleUnquoted$ = -1388				; size = 1040
_pszModule$ = -344					; size = 4
_dwFLen$ = -340						; size = 4
_hInst$ = -336						; size = 4
_szModule$ = -328					; size = 260
__AtlSafeAllocaManager$ = -60				; size = 4
__lpa_ex$ = -52						; size = 4
__lpw_ex$ = -48						; size = 4
__acp_ex$ = -44						; size = 4
__convert_ex$ = -40					; size = 4
_hr$ = -36						; size = 4
_ro$ = -28						; size = 20
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z PROC NEAR ; ATL::CAtlModule::UpdateRegistryFromResourceS, COMDAT

; 5431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2524				; 000009dcH
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2524]
	mov	ecx, 631				; 00000277H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5432 : 	CRegObject ro;

	lea	ecx, DWORD PTR _ro$[ebp]
	call	??0CRegObject@ATL@@QAE@XZ

; 5433 : 
; 5434 : 	if (pMapEntries != NULL)

	cmp	DWORD PTR _pMapEntries$[ebp], 0
	je	SHORT $L90866
$L90868:

; 5435 : 	{
; 5436 : 		while (pMapEntries->szKey != NULL)

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $L90866

; 5437 : 		{
; 5438 : 			ATLASSERT(NULL != pMapEntries->szData);

	mov	ecx, DWORD PTR _pMapEntries$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $L213192
	push	OFFSET FLAT:??_C@_0BJ@MKNPNODP@0?5?$CB?$DN?5pMapEntries?9?$DOszData?$AA@
	push	0
	push	5438					; 0000153eH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213192
	int	3
$L213192:

; 5439 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);

	mov	eax, DWORD PTR _pMapEntries$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pMapEntries$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement

; 5440 : 			pMapEntries++;

	mov	edx, DWORD PTR _pMapEntries$[ebp]
	add	edx, 8
	mov	DWORD PTR _pMapEntries$[ebp], edx

; 5441 : 		}

	jmp	SHORT $L90868
$L90866:

; 5442 : 	}
; 5443 : 
; 5444 : 	HRESULT hr = AddCommonRGSReplacements(&ro);

	mov	esi, esp
	lea	eax, DWORD PTR _ro$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR [edx+20]
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _hr$[ebp], eax

; 5445 : 	if (FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $L90874

; 5446 : 		return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T213193[ebp], eax
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213193[ebp]
	jmp	$L90864
$L90874:

; 5447 : 
; 5448 : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>

; 5449 : 	TCHAR szModule[MAX_PATH];
; 5450 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();

	mov	ecx, OFFSET FLAT:?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A
	call	?GetModuleInstance@CAtlBaseModule@ATL@@QAEPAUHINSTANCE__@@XZ ; ATL::CAtlBaseModule::GetModuleInstance
	mov	DWORD PTR _hInst$[ebp], eax

; 5451 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);

	mov	esi, esp
	push	260					; 00000104H
	lea	ecx, DWORD PTR _szModule$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInst$[ebp]
	push	edx
	call	DWORD PTR __imp__GetModuleFileNameA@12
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _dwFLen$[ebp], eax

; 5452 : 	if( dwFLen == 0 )

	cmp	DWORD PTR _dwFLen$[ebp], 0
	jne	SHORT $L90884

; 5453 : 		return AtlHresultFromLastError();

	call	?AtlHresultFromLastError@ATL@@YAJXZ	; ATL::AtlHresultFromLastError
	mov	DWORD PTR $T213194[ebp], eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213194[ebp]
	jmp	$L90864
$L90884:

; 5454 : 	else if( dwFLen == MAX_PATH )

	cmp	DWORD PTR _dwFLen$[ebp], 260		; 00000104H
	jne	SHORT $L90886

; 5455 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	mov	DWORD PTR $T213195[ebp], -2147024774	; 8007007aH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213195[ebp]
	jmp	$L90864
$L90886:

; 5456 : 
; 5457 : 	LPOLESTR pszModule;
; 5458 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	lea	eax, DWORD PTR _szModule$[ebp]
	mov	DWORD PTR __lpa_ex$[ebp], eax
	cmp	DWORD PTR __lpa_ex$[ebp], 0
	jne	SHORT $L213198
	mov	DWORD PTR tv160[ebp], 0
	jmp	$L213199
$L213198:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$[ebp], eax
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L213196
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213196
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv151[ebp], esp
	mov	edx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv158[ebp], edx
	jmp	SHORT $L213197
$L213196:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv158[ebp], eax
$L213197:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv158[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv160[ebp], eax
$L213199:
	mov	edx, DWORD PTR tv160[ebp]
	mov	DWORD PTR _pszModule$[ebp], edx

; 5459 : #ifndef _UNICODE
; 5460 : 	if(pszModule == NULL) 

	cmp	DWORD PTR _pszModule$[ebp], 0
	jne	SHORT $L90898

; 5461 : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T213200[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213200[ebp]
	jmp	$L90864
$L90898:

; 5462 : #endif
; 5463 : 
; 5464 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 5465 : 	EscapeSingleQuote(pszModuleUnquoted, pszModule);

	mov	eax, DWORD PTR _pszModule$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszModuleUnquoted$[ebp]
	push	ecx
	call	?EscapeSingleQuote@CAtlModule@ATL@@SAXPAGPBG@Z ; ATL::CAtlModule::EscapeSingleQuote
	add	esp, 8

; 5466 : 	
; 5467 : 	HRESULT hRes;
; 5468 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE

	cmp	DWORD PTR _hInst$[ebp], 0
	je	SHORT $L90904
	mov	esi, esp
	push	0
	call	DWORD PTR __imp__GetModuleHandleA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	DWORD PTR _hInst$[ebp], eax
	jne	SHORT $L90903
$L90904:

; 5469 : 	{
; 5470 : 		// If Registering as an EXE, then we quote the resultant path.
; 5471 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 5472 : 		// quoted
; 5473 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2]; 		
; 5474 : 		pszModuleQuote[0] = OLESTR('\"');

	mov	WORD PTR _pszModuleQuote$90905[ebp], 34	; 00000022H

; 5475 : 		ocscpy(pszModuleQuote + 1, pszModuleUnquoted);

	lea	edx, DWORD PTR _pszModuleUnquoted$[ebp]
	push	edx
	lea	eax, DWORD PTR _pszModuleQuote$90905[ebp+2]
	push	eax
	call	?ocscpy@@YAPAGPAGPBG@Z			; ocscpy
	add	esp, 8

; 5476 : 		int nLen = ocslen(pszModuleQuote);

	lea	ecx, DWORD PTR _pszModuleQuote$90905[ebp]
	push	ecx
	call	?ocslen@@YAHPBG@Z			; ocslen
	add	esp, 4
	mov	DWORD PTR _nLen$90906[ebp], eax

; 5477 : 		pszModuleQuote[nLen] = OLESTR('\"');

	mov	edx, DWORD PTR _nLen$90906[ebp]
	mov	WORD PTR _pszModuleQuote$90905[ebp+edx*2], 34 ; 00000022H

; 5478 : 		pszModuleQuote[nLen + 1] = 0;

	mov	eax, DWORD PTR _nLen$90906[ebp]
	mov	WORD PTR _pszModuleQuote$90905[ebp+eax*2+2], 0

; 5479 : 
; 5480 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

	lea	ecx, DWORD PTR _pszModuleQuote$90905[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
	lea	edx, DWORD PTR _ro$[ebp]
	push	edx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax

; 5481 : 	}
; 5482 : 	else

	jmp	SHORT $L90908
$L90903:

; 5483 : 	{
; 5484 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);

	lea	eax, DWORD PTR _pszModuleUnquoted$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?$AA@
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax
$L90908:

; 5485 : 	}	
; 5486 : 	
; 5487 : 	if(FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L90910

; 5488 : 		return hRes;

	mov	edx, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T213201[ebp], edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213201[ebp]
	jmp	$L90864
$L90910:

; 5489 : 		
; 5490 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);

	lea	eax, DWORD PTR _pszModuleUnquoted$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw?$AA?$AA@
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?AddReplacement@CRegObject@ATL@@UAGJPBG0@Z ; ATL::CRegObject::AddReplacement
	mov	DWORD PTR _hRes$[ebp], eax

; 5491 : 	if(FAILED(hRes))

	cmp	DWORD PTR _hRes$[ebp], 0
	jge	SHORT $L90914

; 5492 : 		return hRes;

	mov	edx, DWORD PTR _hRes$[ebp]
	mov	DWORD PTR $T213202[ebp], edx
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213202[ebp]
	jmp	$L90864
$L90914:

; 5493 : 
; 5494 : 	LPCOLESTR szType = OLESTR("REGISTRY");

	mov	DWORD PTR _szType$[ebp], OFFSET FLAT:??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY?$AA?$AA@

; 5495 : 	LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _lpszRes$[ebp]
	mov	DWORD PTR __lpa_ex$[ebp], eax
	cmp	DWORD PTR __lpa_ex$[ebp], 0
	jne	SHORT $L213205
	mov	DWORD PTR tv217[ebp], 0
	jmp	$L213206
$L213205:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpa_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenA@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	add	eax, 1
	mov	DWORD PTR __convert_ex$[ebp], eax
	mov	edx, DWORD PTR __convert_ex$[ebp]
	shl	edx, 1
	cmp	edx, 1024				; 00000400H
	ja	SHORT $L213203
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213203
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv208[ebp], esp
	mov	edx, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv215[ebp], edx
	jmp	SHORT $L213204
$L213203:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv215[ebp], eax
$L213204:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpa_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv215[ebp]
	push	ecx
	call	?AtlA2WHelper@@YGPAGPAGPBDHI@Z		; AtlA2WHelper
	mov	DWORD PTR tv217[ebp], eax
$L213206:
	mov	edx, DWORD PTR tv217[ebp]
	mov	DWORD PTR _pszRes$[ebp], edx

; 5496 : #ifndef _UNICODE	
; 5497 : 	if(pszRes == NULL) 

	cmp	DWORD PTR _pszRes$[ebp], 0
	jne	SHORT $L90925

; 5498 : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T213207[ebp], -2147024882	; 8007000eH
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213207[ebp]
	jmp	SHORT $L90864
$L90925:

; 5499 : #endif	
; 5500 : 	hr = (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
; 5501 : 		ro.ResourceUnregisterSz(pszModule, pszRes, szType);

	cmp	DWORD PTR _bRegister$[ebp], 0
	je	SHORT $L213208
	mov	eax, DWORD PTR _szType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszRes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszModule$[ebp]
	push	edx
	lea	eax, DWORD PTR _ro$[ebp]
	push	eax
	call	?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z ; ATL::CRegObject::ResourceRegisterSz
	mov	DWORD PTR tv230[ebp], eax
	jmp	SHORT $L213209
$L213208:
	mov	ecx, DWORD PTR _szType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszRes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszModule$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ro$[ebp]
	push	ecx
	call	?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z ; ATL::CRegObject::ResourceUnregisterSz
	mov	DWORD PTR tv230[ebp], eax
$L213209:
	mov	edx, DWORD PTR tv230[ebp]
	mov	DWORD PTR _hr$[ebp], edx

; 5502 : 	return hr;

	mov	eax, DWORD PTR _hr$[ebp]
	mov	DWORD PTR $T213210[ebp], eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	lea	ecx, DWORD PTR _ro$[ebp]
	call	??1CRegObject@ATL@@UAE@XZ		; ATL::CRegObject::~CRegObject
	mov	eax, DWORD PTR $T213210[ebp]
$L90864:

; 5503 : }

	lea	esp, DWORD PTR [ebp-2532]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L213218
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L213218:
	DD	5
	DD	$L213217
$L213217:
	DD	-28					; ffffffe4H
	DD	20					; 00000014H
	DD	$L213211
	DD	-60					; ffffffc4H
	DD	4
	DD	$L213212
	DD	-328					; fffffeb8H
	DD	260					; 00000104H
	DD	$L213213
	DD	-1388					; fffffa94H
	DD	1040					; 00000410H
	DD	$L213214
	DD	-2448					; fffff670H
	DD	1048					; 00000418H
	DD	$L213215
$L213215:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	81					; 00000051H
	DB	117					; 00000075H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	0
$L213214:
	DB	112					; 00000070H
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	85					; 00000055H
	DB	110					; 0000006eH
	DB	113					; 00000071H
	DB	117					; 00000075H
	DB	111					; 0000006fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	100					; 00000064H
	DB	0
$L213213:
	DB	115					; 00000073H
	DB	122					; 0000007aH
	DB	77					; 0000004dH
	DB	111					; 0000006fH
	DB	100					; 00000064H
	DB	117					; 00000075H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	0
$L213212:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
$L213211:
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	0
?UpdateRegistryFromResourceS@CAtlModule@ATL@@QAGJPBDHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CAtlModule::UpdateRegistryFromResourceS
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\statreg.h
xdata$x	SEGMENT
$T213239 DD	0ffffffffH
	DD	FLAT:$L213232
$T213234 DD	019930520H
	DD	01H
	DD	FLAT:$T213239
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z
_TEXT	SEGMENT
tv145 = -84						; size = 4
tv140 = -80						; size = 4
tv147 = -76						; size = 4
tv90 = -72						; size = 4
tv85 = -68						; size = 4
tv92 = -64						; size = 4
$T213231 = -60						; size = 4
$T213230 = -56						; size = 4
$T213221 = -52						; size = 4
_lpszType$ = -48					; size = 4
_lpszID$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_szID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z PROC NEAR ; ATL::CRegObject::ResourceRegisterSz, COMDAT

; 443  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 444  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 445  : 	if (szID == NULL || szType == NULL)

	cmp	DWORD PTR _szID$[ebp], 0
	je	SHORT $L90123
	cmp	DWORD PTR _szType$[ebp], 0
	jne	SHORT $L90122
$L90123:

; 446  : 		return E_INVALIDARG;

	mov	DWORD PTR $T213221[ebp], -2147024809	; 80070057H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213221[ebp]
	jmp	$L90116
$L90122:

; 447  : 	
; 448  : 	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szID$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L213224
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $L213225
$L213224:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L213222
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213222
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv85[ebp], esp
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $L213223
$L213222:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv90[ebp], eax
$L213223:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv92[ebp], eax
$L213225:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _lpszID$[ebp], edx

; 449  : 	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szType$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L213228
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $L213229
$L213228:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L213226
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213226
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv140[ebp], esp
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv145[ebp], edx
	jmp	SHORT $L213227
$L213226:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv145[ebp], eax
$L213227:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv147[ebp], eax
$L213229:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR _lpszType$[ebp], edx

; 450  : #ifndef _UNICODE
; 451  : 	if (lpszID == NULL || lpszType)

	cmp	DWORD PTR _lpszID$[ebp], 0
	je	SHORT $L90135
	cmp	DWORD PTR _lpszType$[ebp], 0
	je	SHORT $L90134
$L90135:

; 452  : 	{
; 453  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T213230[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213230[ebp]
	jmp	SHORT $L90116
$L90134:

; 454  : 	}
; 455  : #endif // _UNICODE
; 456  : 	return RegisterFromResource(szFileName, lpszID, lpszType, TRUE);

	push	1
	mov	eax, DWORD PTR _lpszType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ; ATL::CRegObject::RegisterFromResource
	mov	DWORD PTR $T213231[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213231[ebp]
$L90116:

; 457  : }

	lea	esp, DWORD PTR [ebp-92]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L213238
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L213238:
	DD	1
	DD	$L213237
$L213237:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L213235
$L213235:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L213232:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z:
	mov	eax, OFFSET FLAT:$T213234
	jmp	___CxxFrameHandler
text$x	ENDS
?ResourceRegisterSz@CRegObject@ATL@@QAGJPBG00@Z ENDP	; ATL::CRegObject::ResourceRegisterSz
;	COMDAT xdata$x
xdata$x	SEGMENT
$T213262 DD	0ffffffffH
	DD	FLAT:$L213255
$T213257 DD	019930520H
	DD	01H
	DD	FLAT:$T213262
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z
_TEXT	SEGMENT
tv145 = -84						; size = 4
tv140 = -80						; size = 4
tv147 = -76						; size = 4
tv90 = -72						; size = 4
tv85 = -68						; size = 4
tv92 = -64						; size = 4
$T213254 = -60						; size = 4
$T213253 = -56						; size = 4
$T213244 = -52						; size = 4
_lpszType$ = -48					; size = 4
_lpszID$ = -44						; size = 4
__AtlSafeAllocaManager$ = -36				; size = 4
__lpa_ex$ = -28						; size = 4
__lpw_ex$ = -24						; size = 4
__acp_ex$ = -20						; size = 4
__convert_ex$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_szID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z PROC NEAR ; ATL::CRegObject::ResourceUnregisterSz, COMDAT

; 474  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-84]
	mov	ecx, 18					; 00000012H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 475  : 	USES_CONVERSION_EX;

	mov	DWORD PTR __convert_ex$[ebp], 0
	call	?_AtlGetConversionACP@ATL@@YGIXZ	; ATL::_AtlGetConversionACP
	mov	DWORD PTR __acp_ex$[ebp], eax
	mov	DWORD PTR __lpw_ex$[ebp], 0
	mov	DWORD PTR __lpa_ex$[ebp], 0
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 476  : 	if (szID == NULL || szType == NULL)

	cmp	DWORD PTR _szID$[ebp], 0
	je	SHORT $L90173
	cmp	DWORD PTR _szType$[ebp], 0
	jne	SHORT $L90172
$L90173:

; 477  : 		return E_INVALIDARG;

	mov	DWORD PTR $T213244[ebp], -2147024809	; 80070057H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213244[ebp]
	jmp	$L90166
$L90172:

; 478  : 
; 479  : 	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szID$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L213247
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $L213248
$L213247:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L213245
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213245
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv85[ebp], esp
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv90[ebp], edx
	jmp	SHORT $L213246
$L213245:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv90[ebp], eax
$L213246:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv90[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv92[ebp], eax
$L213248:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR _lpszID$[ebp], edx

; 480  : 	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

	mov	eax, DWORD PTR _szType$[ebp]
	mov	DWORD PTR __lpw_ex$[ebp], eax
	cmp	DWORD PTR __lpw_ex$[ebp], 0
	jne	SHORT $L213251
	mov	DWORD PTR tv147[ebp], 0
	jmp	SHORT $L213252
$L213251:
	mov	esi, esp
	mov	ecx, DWORD PTR __lpw_ex$[ebp]
	push	ecx
	call	DWORD PTR __imp__lstrlenW@4
	cmp	esi, esp
	call	__RTC_CheckEsp
	lea	edx, DWORD PTR [eax+eax+2]
	mov	DWORD PTR __convert_ex$[ebp], edx
	cmp	DWORD PTR __convert_ex$[ebp], 1024	; 00000400H
	jg	SHORT $L213249
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	call	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $L213249
	mov	eax, DWORD PTR __convert_ex$[ebp]
	add	eax, 3
	and	eax, -4					; fffffffcH
	call	__alloca_probe
	mov	DWORD PTR tv140[ebp], esp
	mov	edx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv145[ebp], edx
	jmp	SHORT $L213250
$L213249:
	mov	eax, DWORD PTR __convert_ex$[ebp]
	push	eax
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
	mov	DWORD PTR tv145[ebp], eax
$L213250:
	mov	ecx, DWORD PTR __acp_ex$[ebp]
	push	ecx
	mov	edx, DWORD PTR __convert_ex$[ebp]
	push	edx
	mov	eax, DWORD PTR __lpw_ex$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	call	?AtlW2AHelper@@YGPADPADPBGHI@Z		; AtlW2AHelper
	mov	DWORD PTR tv147[ebp], eax
$L213252:
	mov	edx, DWORD PTR tv147[ebp]
	mov	DWORD PTR _lpszType$[ebp], edx

; 481  : #ifndef _UNICODE
; 482  : 	if (lpszID == NULL || lpszType == NULL)

	cmp	DWORD PTR _lpszID$[ebp], 0
	je	SHORT $L90185
	cmp	DWORD PTR _lpszType$[ebp], 0
	jne	SHORT $L90184
$L90185:

; 483  : 	{
; 484  : 		return E_OUTOFMEMORY;

	mov	DWORD PTR $T213253[ebp], -2147024882	; 8007000eH
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213253[ebp]
	jmp	SHORT $L90166
$L90184:

; 485  : 	}
; 486  : #endif // _UNICODE
; 487  : 
; 488  : 	return RegisterFromResource(szFileName, lpszID, lpszType, FALSE);

	push	0
	mov	eax, DWORD PTR _lpszType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpszID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?RegisterFromResource@CRegObject@ATL@@IAEJPBGPBD1H@Z ; ATL::CRegObject::RegisterFromResource
	mov	DWORD PTR $T213254[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	call	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
	mov	eax, DWORD PTR $T213254[ebp]
$L90166:

; 489  : }

	lea	esp, DWORD PTR [ebp-92]
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $L213261
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L213261:
	DD	1
	DD	$L213260
$L213260:
	DD	-36					; ffffffdcH
	DD	4
	DD	$L213258
$L213258:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	116					; 00000074H
	DB	108					; 0000006cH
	DB	83					; 00000053H
	DB	97					; 00000061H
	DB	102					; 00000066H
	DB	101					; 00000065H
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	97					; 00000061H
	DB	77					; 0000004dH
	DB	97					; 00000061H
	DB	110					; 0000006eH
	DB	97					; 00000061H
	DB	103					; 00000067H
	DB	101					; 00000065H
	DB	114					; 00000072H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L213255:
	lea	ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
	jmp	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z:
	mov	eax, OFFSET FLAT:$T213257
	jmp	___CxxFrameHandler
text$x	ENDS
?ResourceUnregisterSz@CRegObject@ATL@@QAGJPBG00@Z ENDP	; ATL::CRegObject::ResourceUnregisterSz
PUBLIC	??0CAtlModule@ATL@@QAE@XZ			; ATL::CAtlModule::CAtlModule
PUBLIC	?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ ; ATL::CAtlModuleT<ATL::CComModule>::InitLibId
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlbase.h
;	COMDAT ??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::CAtlModuleT<ATL::CComModule>, COMDAT
; _this$ = ecx

; 2863 : 	CAtlModuleT() throw()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CAtlModule@ATL@@QAE@XZ		; ATL::CAtlModule::CAtlModule

; 2864 : 	{
; 2865 : 		T::InitLibId();

	call	?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ ; ATL::CAtlModuleT<ATL::CComModule>::InitLibId

; 2866 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CAtlModuleT<ATL::CComModule>::CAtlModuleT<ATL::CComModule>
_TEXT	ENDS
PUBLIC	??_C@_0BB@JLCMIEMB@_pAtlModule?5?$DN?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_0DN@JALIHHGH@ERROR?5?3?5Unable?5to?5initialize?5cri@ ; `string'
PUBLIC	??0_ATL_MODULE70@ATL@@QAE@XZ			; ATL::_ATL_MODULE70::_ATL_MODULE70
EXTRN	?atlTraceGeneral@ATL@@3VCTraceCategory@1@A:DWORD ; ATL::atlTraceGeneral
;	COMDAT ??_C@_0BB@JLCMIEMB@_pAtlModule?5?$DN?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BB@JLCMIEMB@_pAtlModule?5?$DN?$DN?50?$AA@ DB '_pAtlModule == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@JALIHHGH@ERROR?5?3?5Unable?5to?5initialize?5cri@
CONST	SEGMENT
??_C@_0DN@JALIHHGH@ERROR?5?3?5Unable?5to?5initialize?5cri@ DB 'ERROR : Un'
	DB	'able to initialize critical section in CAtlModule', 0aH, 00H ; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ??0CAtlModule@ATL@@QAE@XZ
_TEXT	SEGMENT
$T213270 = -12						; size = 8
_this$ = -4						; size = 4
??0CAtlModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlModule::CAtlModule, COMDAT
; _this$ = ecx

; 2615 : 	CAtlModule() throw()

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ebp-12], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-8], -858993460		; ccccccccH
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0_ATL_MODULE70@ATL@@QAE@XZ

; 2616 : 	{
; 2617 : 		// Should have only one instance of a class 
; 2618 : 		// derived from CAtlModule in a project.
; 2619 : 		ATLASSERT(_pAtlModule == NULL);

	cmp	DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A, 0 ; ATL::_pAtlModule
	je	SHORT $L213269
	push	OFFSET FLAT:??_C@_0BB@JLCMIEMB@_pAtlModule?5?$DN?$DN?50?$AA@
	push	0
	push	2619					; 00000a3bH
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213269
	int	3
$L213269:

; 2620 : 		cbSize = sizeof(_ATL_MODULE);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 36			; 00000024H

; 2621 : 		m_pTermFuncs = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 2622 : 
; 2623 : 		m_nLockCnt = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2624 : 		_pAtlModule = this;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A, ecx ; ATL::_pAtlModule

; 2625 : 		if (FAILED(m_csStaticDataInitAndTypeInfo.Init()))

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?Init@CComCriticalSection@ATL@@QAEJXZ	; ATL::CComCriticalSection::Init
	test	eax, eax
	jge	SHORT $L88204

; 2626 : 		{
; 2627 : 			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to initialize critical section in CAtlModule\n"));

	push	OFFSET FLAT:??_C@_0DN@JALIHHGH@ERROR?5?3?5Unable?5to?5initialize?5cri@
	push	0
	mov	ecx, OFFSET FLAT:?atlTraceGeneral@ATL@@3VCTraceCategory@1@A ; ATL::atlTraceGeneral
	call	??BCTraceCategory@ATL@@QBEKXZ		; ATL::CTraceCategory::operator unsigned long
	push	eax
	push	2627					; 00000a43H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	lea	ecx, DWORD PTR $T213270[ebp]
	call	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
	push	eax
	call	??RCTraceFileAndLineInfo@ATL@@QBAXKIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
	add	esp, 16					; 00000010H

; 2628 : 			ATLASSERT(0);

	xor	edx, edx
	jne	SHORT $L213271
	push	OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
	push	0
	push	2628					; 00000a44H
	push	OFFSET FLAT:??_C@_0FA@KBNNCCJL@C?3?2Program?5Files?2Microsoft?5Visua@
	push	2
	call	__CrtDbgReport
	add	esp, 20					; 00000014H
	cmp	eax, 1
	jne	SHORT $L213271
	int	3
$L213271:

; 2629 : 			CAtlBaseModule::m_bInitFailed = true;

	mov	BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed
$L88204:

; 2630 : 		}
; 2631 : 
; 2632 : 		m_pGIT = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+40], 0

; 2633 : 	}

	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 12					; 0000000cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0CAtlModule@ATL@@QAE@XZ ENDP				; ATL::CAtlModule::CAtlModule
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ??0_ATL_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_ATL_MODULE70@ATL@@QAE@XZ PROC NEAR			; ATL::_ATL_MODULE70::_ATL_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0CComCriticalSection@ATL@@QAE@XZ	; ATL::CComCriticalSection::CComCriticalSection
	mov	eax, DWORD PTR _this$[ebp]
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0_ATL_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_MODULE70::_ATL_MODULE70
_TEXT	ENDS
PUBLIC	??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@ ; `string'
PUBLIC	?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ ; ATL::CAtlModuleT<ATL::CComModule>::GetAppId
;	COMDAT ??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@ DB 'A', 00H, 'P', 00H
	DB	'P', 00H, 'I', 00H, 'D', 00H, 00H, 00H	; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pRegistrar$ = 8					; size = 4
?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements, COMDAT
; _this$ = ecx

; 2936 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 2937 : 		return pRegistrar->AddReplacement(L"APPID", T::GetAppId());

	call	?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ ; ATL::CAtlModuleT<ATL::CComModule>::GetAppId
	mov	esi, esp
	push	eax
	push	OFFSET FLAT:??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD?$AA?$AA@
	mov	eax, DWORD PTR _pRegistrar$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pRegistrar$[ebp]
	push	edx
	call	DWORD PTR [ecx+12]
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2938 : 	}

	pop	esi
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT ?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ
_TEXT	SEGMENT
?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::InitLibId, COMDAT

; 2869 : 	{

	push	ebp
	mov	ebp, esp

; 2870 : 	}

	pop	ebp
	ret	0
?InitLibId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAXXZ ENDP ; ATL::CAtlModuleT<ATL::CComModule>::InitLibId
_TEXT	ENDS
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Odt /RTCsu
CONST	ENDS
;	COMDAT ?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ
_TEXT	SEGMENT
?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ PROC NEAR ; ATL::CAtlModuleT<ATL::CComModule>::GetAppId, COMDAT

; 2940 : 	{

	push	ebp
	mov	ebp, esp

; 2941 : 		return OLESTR("");

	mov	eax, OFFSET FLAT:??_C@_11LOCGONAA@?$AA?$AA@

; 2942 : 	}

	pop	ebp
	ret	0
?GetAppId@?$CAtlModuleT@VCComModule@ATL@@@ATL@@SAPBGXZ ENDP ; ATL::CAtlModuleT<ATL::CComModule>::GetAppId
_TEXT	ENDS
PUBLIC	??1CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::~CAtlWinModule
; Function compile flags: /Odt /RTCsu
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
	call	??1CAtlWinModule@ATL@@QAE@XZ		; ATL::CAtlWinModule::~CAtlWinModule
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E2	ENDP
text$yd	ENDS
PUBLIC	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
;	COMDAT xdata$x
xdata$x	SEGMENT
$T213288 DD	0ffffffffH
	DD	FLAT:$L213284
$T213286 DD	019930520H
	DD	01H
	DD	FLAT:$T213288
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Odt /RTCsu
xdata$x	ENDS
;	COMDAT ??1CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAtlWinModule@ATL@@QAE@XZ PROC NEAR			; ATL::CAtlWinModule::~CAtlWinModule, COMDAT
; _this$ = ecx

; 2582 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	mov	DWORD PTR [ebp-16], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2583 : 		Term();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?Term@CAtlWinModule@ATL@@QAEXXZ		; ATL::CAtlWinModule::Term

; 2584 : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L213284:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
__ehhandler$??1CAtlWinModule@ATL@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T213286
	jmp	___CxxFrameHandler
text$x	ENDS
??1CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::~CAtlWinModule
PUBLIC	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
;	COMDAT ??1_ATL_WIN_MODULE70@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ PROC NEAR		; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1_ATL_WIN_MODULE70@ATL@@QAE@XZ ENDP			; ATL::_ATL_WIN_MODULE70::~_ATL_WIN_MODULE70
; Function compile flags: /Odt /RTCsu
; File c:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpcoll.h
_TEXT	ENDS
;	COMDAT ??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >, COMDAT
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 		RemoveAll();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll

; 102  : 	}

	add	esp, 4
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::~CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >
; Function compile flags: /Odt /RTCsu
_TEXT	ENDS
;	COMDAT _$E6
text$yd	SEGMENT
_$E6	PROC NEAR					; COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET FLAT:?_Module@@3VCComModule@ATL@@A
	call	??1CComModule@ATL@@UAE@XZ
	cmp	ebp, esp
	call	__RTC_CheckEsp
	pop	ebp
	ret	0
_$E6	ENDP
text$yd	ENDS
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?_Module@@3VCComModule@ATL@@A			; _Module
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
_BSS	SEGMENT
?_Module@@3VCComModule@ATL@@A DB 030H DUP (?)		; _Module
_BSS	ENDS
END
